{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2023",
    "semester": "Summer",
    "moed": "Moed A",
    "exam_date": "07.12.2023",
    "source_file": "os23SA.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "ב-VSFS, פעולת העתקה של קובץ בתוך אותה מערכת קבצים לרוב תהיה מהירה יותר מאותה פעולת העתקה בין מערכות קבצים שונות.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. מערכות קבצים שונות יכולות לשבת על התקנים שונים ואז ניתן לקרוא ולכתוב במקביל את הקובץ במהלך ההעתקה, בעוד שאותה מערכת קבצים לרוב נמצאת באותו כונן ונוכל לבצע רק פעולה אחת בכל פעם."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Semaphores"
      ],
      "content": {
        "text": "במשתני תנאי, שימוש ב-broadcast במקום signal פותר את בעיית ה-lost signal.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. בתרחיש הראשון שנלמד ל-lost signal, לא משנה אם יתבצע broadcast."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems"
      ],
      "content": {
        "text": "יש מקרים בהם עדיף להשתמש ב-4-RAID על פני 5-RAID.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. 5-RAID עדיף על 4-RAID בכל פרמטר."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Processes",
        "System Calls",
        "File Systems"
      ],
      "content": {
        "text": "בביצוע ()fork, הקבצים הפתוחים בתהליך האב נפתחים מחדש עבור תהליך הבן.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. בביצוע fork, טבלת הקבצים הפתוחים משתכפלת אך הקבצים לא נפתחים מחדש, ותהליך הבן יצביע לאותם קבצים שפתוחים אצל האב."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Scheduling",
        "Deadlocks",
        "Concurrency"
      ],
      "content": {
        "text": "בהרצת תהליכים וחוטים עם אלגוריתם התזמון FCFS לא יתכן שיתרחש קיפאון.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. תזמון FCFS חוט אחד יסיים לפני שהשני מתחיל ולכן לא מתקיים התנאי של hold and wait"
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Memory Management",
        "Virtual Memory",
        "Paging"
      ],
      "content": {
        "text": "נתונה מערכת בה רוחב כתובת וירטואלית הוא 32 ביט וגודל הזיכרון הפיזי הוא 1GB. כל כניסה בטבלת הדפים היא בגודל 3 בתים, כאשר 6 ביטים משמשים לסטטוס ואף ביט לא משמש לריפוד.\nתהליך הריץ את קטע הקוד הבא (M,N הם קבועים מספריים כלשהם שהוגדרו מראש):\nלאחר הרצת הקוד הנ\"ל, תוכן ה-TLB שהתווסף בעקבות הגישות למערך בשורה 4 הוא להלן (ניתן להניח שאף מיפוי של המערך לא היה ב-TLB לפני כן):\nמסגרת דף סטטוס\n2 11B ......\n3 2 ......\nהמספרים הנתונים הם בבסיס 16.\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": "1 int arr[N];\n2 int step = M;\n3 for (int i = 0; i < N; i += step)\n4    arr[i] = arr[i] + 1;"
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "מה גודל דף ומסגרת במערכת?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "ידוע שבגישה הראשונה למערך כאשר 0=i התהליך פנה לכתובת 2008 (בבסיס 16). מה הכתובת הפיזית בה מתחיל המערך arr?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "מה הגודל המינימלי והמקסימלי של N (גודל המערך arr) אם גודל int הוא 4 בתים?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "6.1: 1. כל כניסה בטבלת הדפים היא 24 ביט מתוכם 6 לסטטוס ואין ריפוד, כלומר 18 ביטים למספר מסגרת. הזיכרון הפיזי הוא 1GB = 2^30 כלומר 30 ביטים, ולפי 18 ביטים למסגרת יש 12 ביטים להיסט. גודל מסגרת = גודל דף ולפי ההיסט 2^12 בתים, כלומר גודל הדף/מסגרת הוא 4KB.\n6.2: 2. עבור הכתובת 2008 (בבסיס 16) ← לפי סעיף קודם ההיסט 12 ביטים כלומר 008, ומספר הדף 2. לפי ה-TLB דף 2 ממופה למסגרת 11B, נחבר חזרה עם אותו היסט ונקבל כתובת פיזית 11B008 (בבסיס 16).\n6.3: 3. לפי ה-TLB הגישה לתאי המערך גררה גישה ל-2 דפים בלבד. במקרה המינימלי, המערך מכיל איבר אחד בסוף הדף הראשון ואחד בתחילת הדף השני (אותו איבר לא יכול להתחלק בין 2 דפים בגלל שהזיכרון מיושר), כלומר המינימום הוא 2=N. עבור המקרה המקסימלי, קודם כל נשים לב שבכל דף בגודל 4KB נכנסים 1024 איברים של המערך (4 בתים כל אחד). המקרה המקסימלי הוא כאשר הפרמטר step/M הוא 2047. במקרה זה נבצע בדיוק 2 גישות למערך – תא 0 בתחילת הדף הראשון, ותא 2047 בסוף הדף האחרון. אנו יודעים שלא התבצעה גישה נוספת, כלומר שבגישה הבאה לתא 4094 חרגנו מגודל המערך N, כלומר המקסימום הוא 4093=N. אם נתעלם מהפרמטר של step/M (במקרה שהוא 1), אז במקרה המקסימלי המערך ממלא את 2 הדפים אליהם ניגשנו ולא יותר, כלומר 2048=N."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Mutexes",
        "Threads"
      ],
      "content": {
        "text": "להלן קוד למימוש מנעול עבור 2 חוטים, כאשר לכל חוט מזהה (0 או 1) המועבר בתור הפרמטר i:",
        "code_snippet": "1 int flag[2] = {0};\n2 int label[2] = {0};\n3 void lock(int i) {\n4    int j = 1-i;\n5    flag[i] = 1;\n6    label[i] = 1 + label[j];\n7    while ((flag[j]) && (label[i] > label[j]));\n8 }\n9 void unlock(int i) {\n10   flag[i] = 0;\n11 }"
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "הדגימו ריצה אפשרית המוכיחה כי המנעול אינו מקיים מניעה הדדית.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.2",
          "text": "שינו את הקוד כך שבשורה 7 האופרטור < הוחלף באופרטור =<. הדגימו ריצה אפשרית (לאחר השינוי) המוכיחה כי המנעול אינו מקיים חופש מקיפאון.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.3",
          "text": "האם המנעול הוגן? אם כן יש להוכיח, אחרת יש להראות דוגמה נגדית. רמז: התשובה זהה עם או בלי השינוי המתואר בסעיף הקודם.",
          "code_snippet": null,
          "options": [
            "המנעול הוגן",
            "המנעול לא הוגן"
          ]
        },
        {
          "id": "7.4",
          "text": "תקנו את המנעול כך שיקיים את 3 התכונות: מניעה הדדית, חופש מקיפאון, הוגנות. אין להוסיף משתנים גלובליים או מקומיים, וללא שימוש בפקודות אטומיות או אובייקטי סנכרון אחרים. יש לתאר בקצרה את השינוי ולכתוב קוד ברור.",
          "code_snippet": "void lock(int i)\n\nvoid unlock(int i)",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "7.1: 1. שני החוטים יגיעו במקביל לשורה 6 ויקבלו את אותו הערך עבור ה-label (כל אחד יקרא את הערך של החוט השני לפני שיכתוב את שלו). בריצה זו, שני החוטים יעברו את התנאי בשורה 7 ויכנסו לקטע הקריטי.\n7.2: 2. עבור אותה ריצה, כאשר שני החוטים יגיעו לשורה 7 עם השינוי – שניהם יהיו חסומים בלולאה ולכן יהיה קיפאון.\n7.3: 3. המנעול הוגן. נניח בשלילה שהמנעול לא הוגן, אז יתכן מצב שבו חוט כלשהו (ללא הגבלת הכלליות, חוט 0) חסום לצמיתות בזמן שחוט אחר (חוט 1) תופס ומשחרר את המנעול מספר לא מוגבל של פעמים. חוט 0 יכול להיות חסום רק בשורה 7, אך אם הגיע אליה הוא קיבל ערך כלשהו ל-label אותו כבר כתב לתא המתאים. בפעם הבאה שחוט 1 יריץ את שורה 6 הוא בהכרח יקרא את ערך זה ויכתוב ערך label עבור עצמו שגדול יותר מה-label של חוט 0, ולכן יהיה חסום בלולאה בשורה 7 (לפחות עד שחוט 0 יתפוס וישחרר את המנעול) – בסתירה לכך שחוט 1 תופס ומשחרר את המנעול בלי הגבלה בזמן שחוט 0 חסום.\n7.4: 4. ניתן לממש מנעול פטרסון (המנעול המשתמש ב-turn + flag) ע\"י שימוש במערך הדגלים באותו אופן כמו פטרסון, ושימוש בתא 0 מתוך מערך ה-label עבור המשתנה turn של פטרסון."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה מערכת קבצים LFS עם הנתונים הבאים:\nגודל בלוק הוא 2KB.\nגודל מצביע הוא 4 בתים.\nגודל סגמנט הוא 2000 בלוקים.\nבכל inode יש 6 מצביעים ישירים, 1 מצביע עקיף, 1 מצביע עקיף כפול, 1 מצביע עקיף משולש.\nבמערכת זו קיים קובץ בשם XYZ בגודל 2MB.\nידוע שביצירת הקובץ XYZ כל נתוניו נכתבו בבת אחת, ובתחילת הכתיבה הסגמנט של מערכת הקבצים היה ריק.\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "לכמה בלוקים בדיסק יש לכתוב כדי ליצור את הקובץ XYZ (כולל כתיבת הנתונים)? יש לפרט את סוגי הבלוקים ולציין כיצד התוכן שלהם קשור לקובץ XYZ. ניתן להניח שסגמנט חלקי נכתב לדיסק בסופו של דבר, אך יש להתייחס רק לבלוקים הרלוונטיים לקובץ XYZ (ולא לשאר הבלוקים בסגמנט שהתווספו ללא קשר ל-XYZ) - אין צורך להתייחס לכתיבות עבור הוספת הקובץ לתיקייה בה הוא נמצא.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "תהליך ניגש לבית האחרון בקובץ XYZ. כמה בלוקים יש לקרוא ולכתוב כדי לבצע את הפעולה בהנחה שה-inode של XYZ ידוע מראש, ואף נתון רלוונטי לא נמצא מראש ב-cache? יש לפרט את כל הבלוקים, הפעולה שמתבצעת עליהם, והסיבה שיש לגשת אליהם.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "תהליך פתח את הקובץ XYZ וביצע כתיבה של בית אחד במיקום 12,300 בקובץ. כמה בלוקים יש לקרוא ולכתוב כדי לבצע את הפעולה, בהנחה שה-inode של XYZ ידוע מראש, ואף נתון רלוונטי לא נמצא מראש ב-cache? יש לפרט את כל הבלוקים, הפעולה שמתבצעת עליהם, והסיבה שיש לגשת אליהם.",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "8.1: 1. 2MB הם 1024 בלוקים של נתונים. בכל בלוק נכנסים 512 מצביעים. ב-6 מצביעים ישירים + בלוק עקיף נכנסים 518 בלוקים של נתוני הקובץ (סה\"כ 519 בלוקים של DATA כולל העקיף). נשתמש בבלוק עקיף כפול עם מצביע אחד וזה יספיק לבלוקים הנוספים. סה\"כ 1024 לנתונים + 1 עקיף כפול + 2 עקיפים ישירים = 1027 בלוקים. בנוסף נצטרך לעדכן בלוק של inode + בלוק של imap. סה\"כ 1029 בלוקים. (צריך גם לעדכן את ה-CR אך זה לא נדרש בתשובה)\n8.2: 2. הבית האחרון בקובץ נמצא דרך גישה מהמצביע העקיף הכפול. לקרוא: inode ,imap CR, 2 בלוקים עקיפים, בלוק עם נתונים. סה\"כ 6 קריאות. לכתוב: צריך לעדכן זמן גישה ב-inode, בעקבותיו גם לעדכן imap. סה\"כ 2 כתיבות. (צריך לעדכן גם את ה-CR אך זה לא נדרש בתשובה)\n8.3: 3. בית 12,300 נמצא בבלוק השביעי בקובץ כלומר מהמצביע העקיף הראשון. לקרוא: inode,imap,CR, בלוק עקיף. סה\"כ 4 קריאות. לכתוב: בלוק נתונים שהתעדכן, בלוק עקיף מעודכן להצביע לנתונים החדשים, inode מעודכן, imap מעודכן. סה\"כ 4 כתיבות. (צריך גם לקרוא את בלוק הנתונים ולעדכן את ה-CR אך זה לא נדרש בתשובה)"
      },
      "difficulty_estimation": "Hard"
    }
  ]
}