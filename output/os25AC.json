{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2025",
    "semester": "Semester A",
    "moed": "Moed C",
    "exam_date": "26.03.2025",
    "source_file": "os25AC.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Deadlocks",
        "Concurrency"
      ],
      "content": {
        "text": "איזו טענה נכונה?",
        "code_snippet": null,
        "options": [
          "א. בכל מנעול בו מתאפשר קיפאון, בהכרח תיתכן גם הרעבה.",
          "ב. בכל מנעול בו מתאפשרת הרעבה, בהכרח יתכן גם קיפאון.",
          "ג. קיים מנעול בו מתאפשרים גם קיפאון וגם הרעבה, אך לא בכל מנעול בו מתאפשר אחד בהכרח יתכן גם השני.",
          "ד. לא קיים מנעול בו מתאפשרים גם קיפאון וגם הרעבה.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. ראינו מנעולים שלא מקיימים חופש מקיפאון וכן מקיימים הוגנות, וגם להיפך, אך לא כל המנעולים כאלו."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Virtual Memory",
        "Paging",
        "Memory Management"
      ],
      "content": {
        "text": "אם נגדיל את ה-TLB:",
        "code_snippet": null,
        "options": [
          "א. בהכרח נגדיל את ה-hit ratio.",
          "ב. לא יתכן שנקטין את ה-hit ratio.",
          "ג. נתפוס יותר מקום בזיכרון הפיזי (RAM) עבור הרשומות הנוספות.",
          "ד. נתפוס פחות מקום בזיכרון הפיזי (RAM) בגלל שהרשומות יעברו ל-TLB.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. הגדלת ה-TLB יכולה להקטין את ה-hit ratio (אך לא בהכרח תעשה זאת). אין קשר בין גודל ה-TLB לבין כמות הזיכרון שנתפוס ב-RAM, ה-TLB רק חוסך גישות לטבלאות הדפים."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O",
        "Disk Scheduling"
      ],
      "content": {
        "text": "נתון כונן SSD ובו קובץ שניגשים אליו פעמים רבות לקריאה בלבד. איזו טענה נכונה?",
        "code_snippet": null,
        "options": [
          "א. הגישות יגרמו לכך שיהיו יותר הפרעות בדיסק וסיכוי לשינוי הנתונים.",
          "ב. הגישות יגרמו לכך שיהיו פחות הפרעות בדיסק וסיכוי לשינוי הנתונים.",
          "ג. הגישות יאיצו את שחיקת הדיסק.",
          "ד. הגישות יאטו את שחיקת הדיסק.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "א",
        "explanation": "א'. בביצוע גישות רבות לאותם מיקומים בכונן SSD יש הפרעות קריאה, אשר עלולות לשנות ביטים סמוכים."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Deadlocks",
        "I/O",
        "Disk Scheduling"
      ],
      "content": {
        "text": "איזו טענה נכונה?",
        "code_snippet": null,
        "options": [
          "א. בשימוש במנעולים המקיימים חופש מקיפאון, לא ניתן להגיע לקיפאון.",
          "ב. בשימוש במנעולים המקיימים הוגנות, לא ניתן להגיע להרעבה.",
          "ג. שימוש ב-DMA חוסך את זמן העברת הנתונים מ/אל ההתקן בלבד.",
          "ד. בתזמון SCAN לעומת C-SCAN אין הבדל במרחק (הנמדד בסקטורים) שיעבור הראש הקורא-כותב, אלא רק בסדר הטיפול בבקשות.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. הקיפאון הקלאסי מתאפשר גם במנעולים המקיימים חופש מקיפאון, וראינו את אותו דבר גם עבור הרעבה (לדוגמה, במימוש מנעול קוראים-כותבים מתאפשרת הרעבה גם בשימוש במנעולים הוגנים). שימוש ב-DMA חוסך גם את זמן הטיפול בפסיקות של פעולה גדולה (אשר מחלקים לחלקים), ובתזמון SCAN ניתן לעבור מרחק קצר יותר בהתאם לסדר הטיפול (ראו מבחן 22BB)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Virtual Memory",
        "Paging",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה מערכת בה כל המסגרות בזיכרון תפוסות ושטח ההחלפה (swap) מלא לחלוטין. איזו טענה בהכרח נכונה לגבי מערכת זו?",
        "code_snippet": null,
        "options": [
          "א. לא ניתן לטפל באף page fault",
          "ב. לא ניתן להקצות זיכרון חדש לתהליכים.",
          "ג. אם מתקיים 1=Dirty עבור כל המסגרות בזיכרון, לא נוכל לבצע page out.",
          "ד. אם מתקיים 0=Dirty עבור מסגרת כלשהי בזיכרון, נוכל לבצע page in.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ד",
        "explanation": "ד'. נוכל לטפל ב-page fault מאחר ויתכן וניתן לפנות דף שנמצא כבר בדיסק (נכון גם אם 1=Dirty עבורו), ובהתאם נוכל להקצות זיכרון חדש ע\"י פינוי שדף שכזה. אם מתקיים 0=Dirty לדף במסגרת כלשהי אז בהכרח נוכל לפנות את מסגרת זו ולכן נוכל לבצע page in לדף חדש."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "CodeAnalysis",
      "topic": [
        "Processes",
        "System Calls",
        "Concurrency"
      ],
      "content": {
        "text": "נתונה התוכנית הבאה:\nתזכורת: באופרטורים &&, ||, אם התוצאה ידועה לפי האופרנד הראשון, לא נבדק/מבוצע האופרנד השני. ניתן להניח שכל הקריאות ל-fork הצליחו, והקובץ echo קיים במערכת.",
        "code_snippet": "int main() {\n  int r1 = !fork() || fork();\n  if (r1) {\n    char* args[3] = {\"echo\", \"r1: TRUE\", NULL};\n    execvp(args[0], args);\n    printf(\"r1: TRUE\\n\");\n  } else {\n    printf(\"r1: FALSE\\n\");\n  }\n  wait(NULL);\n\n  int r2 = !fork() && fork();\n  if (r2) {\n    char* args[3] = {\"echo\", \"r2: TRUE\", NULL};\n    execvp(args[0], args);\n  }\n  else {\n    printf(\"r2: FALSE\\n\");\n  }\n  if (r1 || r2)\n    printf(\"END\\n\");\n}"
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "כתבו פלט אפשרי של התוכנית הנתונה בהנחה שכל קריאות המערכת הצליחו, וציירו את עץ התהליכים שנוצר בעקבות הריצה שמובילה לפלט זה (יש לציין לכל תהליך בעץ את מזהה התהליך שלו). כמה תהליכים נוצרו במערכת, כולל התהליך הראשי?\nמספר תהליכים:\nפלט אפשרי ונימוק:\nעץ התהליכים:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "האם יתכנו זומבים בשלב כלשהו במהלך הריצה? אם כן, יש לציין את כל תהליכי הזומבים האפשריים בכל שלב, אחרת להסביר מדוע לא. יתכנו זומבים / לא יתכנו זומבים",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "נניח שלא נתונה ההנחה שהקובץ echo קיים במערכת, אלא נתון שלא קיים הקובץ echo במערכת. האם מספר התהליכים בתשובה לסעיף הראשון (שאלה 6.1) ישתנה? אם כן, יש לציין את התשובה לאחר השינוי, אחרת להסביר מדוע אין שינוי. התשובה תשתנה: / התשובה לא תשתנה",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. נניח שהתהליך המקורי הוא 100. בשורה 2 נוצרים 2 תהליכי בנים חדשים – 101, 102. עבור תהליך האב 100 ותהליך הבן הראשון שנוצר 101 מתקיים התנאי בשורה 3, הקריאה ל-execvp בשורה 5 לא חוזרת. תהליך הבן השני שנוצר 102 מגיע ל-wait בשורה 10 ואין לו בנים, לכן מיד ימשיך הלאה. בשורה 12 נוצרים 2 תהליכים חדשים תחת 102: תהליך הבן שלו 103 ותהליך נכד 104. התנאי בשורה 13 מתקיים עבור תהליך 103 בלבד, שמגיע ל-execvp בשורה 15 ולא ממשיך הלאה. אף אחד לא ידפיס את הפלט בשורה 20 (עבור 2 התהליכים שנותרו 102,104, מתקיים 0==r1==r2). סה\"כ נוצרו 5 תהליכים.\nפלט:\nr1: TRUE\nr1: TRUE\nr1: FALSE\nr2: TRUE\nr2: FALSE\nr2: FALSE\n\n2. כל תהליך יכול להיות זומבי מלבד התהליך הראשי (שלא ידוע לגביו). אין אף מנגנון שמכתיב סדר בין התהליכים. בכל נקודה בריצה, כל תהליך בן שמסתיים לפני תהליך האב שלו יהפוך לזומבי עד שתהליך האב יסתיים גם.\n\n3. אם echo לא קיים אז כל הקריאות ל-execvp יכשלו והתהליכים ימשיכו הלאה לפקודה הבאה במקום לא לחזור מהקריאה. 2 התהליכים 101, 100, שהגיעו לשורה 5 ימשיכו לשורה 12 (תהליך 100 ימתין עד שאחד מתהליכי הבנים שלו יסתיים), כך שכל אחד מהם מייצר 2 תהליכים נוספים שלא נוצרו קודם (בן ונכד לכל אחד). נוספו 4 תהליכים שלא היו קודם, סה\"כ 9 תהליכים."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 7,
      "type": "Open",
      "topic": [
        "Synchronization",
        "Threads",
        "Concurrency"
      ],
      "content": {
        "text": "Barrier הוא אובייקט סנכרון ל-N חוטים (N פרמטר אתחול) עם פעולה אחת: checkin, אשר נועדה לסנכרון שלב הביצוע של N החוטים. בקריאה לפעולה checkin, כל חוט הקורא לפעולה ממתין עד שכל N החוטים ביצעו קריאה לפעולה. רק כאשר כל N החוטים ביצעו קריאה ל-checkin, הקריאה חוזרת עבור כולם והם ממשיכים לפקודה הבאה. במילים אחרות, חוט שקורא ל-checkin חסום (הקריאה לא חוזרת) עד ש-N חוטים (כולל אותו) קוראים ל-checkin. החוט ה-N שמבצע קריאה ל-checkin (ה\"אחרון\") משחרר מחסימה את כל החוטים, שממשיכים לרוץ מהפקודה הבאה. שימו לב: הפעולה checkin אינה חד-פעמית. לאחר חזרה מקריאה ל-checkin ניתן לקרוא שוב לפעולה ולחכות שוב – עד אשר כל החוטים גם יקראו שוב ל-checkin, וכן הלאה. בשאלה זו ניתן להתעלם מגבולות int ולהניח שהייצוג אינסופי (אין overflow), וניתן להשתמש ב-spinning.",
        "code_snippet": "typedef struct {\n  int N;\n  int *arr;\n} Barrier;\n\nvoid init(Barrier *bar, int N) {\n  bar->N = N;\n  bar->arr = (int*) calloc(sizeof(int), N);\n}\n\nvoid destroy (Barrier *bar) {\n  free(bar->arr);\n}"
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "נתונה מערכת עם N חוטים בה לכל חוט יש מזהה i (בין 0 ל-N-1) אשר מועבר כפרמטר לפעולת checkin, ונתון מימוש Barrier המשתמש במערך בגודל N. השלימו את המימוש ע\"י כתיבת הקוד של הפעולה checkin, ללא שימוש בפעולות אטומיות או אובייקטי סנכרון אחרים. אין להוסיף שדות למבנה או לשנות את הקוד הנתון מלבד היכן שנדרש.\nvoid checkin (Barrier *bar, int i) {\n}",
          "code_snippet": "void checkin (Barrier *bar, int i) {\n}",
          "options": null
        },
        {
          "id": "7.2",
          "text": "נתונה אותה מערכת מהסעיף הקודם עם אותו מימוש חלקי ל-Barrier, אך עם מגבלה חדשה: כל תא במערך arr הוא טרינארי, כלומר שהוא יכול להכיל אחד משלושת הערכים 0, 1, 2 בלבד. תארו את השינוי הנדרש ל-Barrier בהשוואה לסעיף הקודם, והשלימו את המימוש המעודכן של checkin עם המגבלה הנתונה, ללא שימוש בפעולות אטומיות או אובייקטי סנכרון אחרים. אין להוסיף שדות למבנה או לשנות את הקוד הנתון מלבד היכן שנדרש. שימו לב: ערך טרינארי אומר שבמידה ונגדיל תא המכיל את הערך 2, התא יעודכן אל הערך 0. לא ניתן לעדכן ערכים גדולים מ-2 או קטנים מ-0 אל תוך אף תא במערך arr.\nvoid checkin (Barrier *bar, int i) {\n}",
          "code_snippet": "void checkin (Barrier *bar, int i) {\n}",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. התשובה זהה לשאלה 7 במבחן 22AB.\n\n2. למעשה אין צורך בשינוי בקוד מלבד תנאי ה-while, שצריך לעדכן כך שכל חוט מחכה לערך זהה לתא שלו או זה שאחריו (אם אחרי ההגדלה הערך הוא 0 - נחכה שאחרים יהיו 0 או 1, אם 1 – נחכה שאחרים יהיו 1 או 2, ואם 2 – נחכה שאחרים יהיו 2 או 0). במימוש מהסעיף הקודם, לא יתכן שאף חוט \"ישיג\" חוט אחר ביותר מ-1 ולכן ערך טרינארי הוא למעשה מספיק. במידה והערך של החוט הנוכחי הוא 0 לפני קידום התא, אז לפי התנאי בפסקה הקודמת כל חוט אחר שמשתמש ב-Barrier מכיל בתא שלו 0 (עוד לא קידם את המונה) או 1 (קידם את המונה וממתין לפחות לחוט הנוכחי). אם החוט הנוכחי קידם את הערך בתא שלו ל-1 אז לכל חוט אחר יתכן שיש בתא: 0 (אם עוד לא קרא ל-checkin) 1 (אם כבר קרא ל-checkin ואז נוכל להתקדם), 2 (אם כבר קרא ל-checkin והתקדם בעצמו וקרא ל-checkin שוב, ועכשיו בהכרח חסום עד שהחוט הנוכחי יקרא ל-checkin שוב)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems"
      ],
      "content": {
        "text": "נתונה מערכת עם workload אקראי של 512KB וסדרתי של 100MB. בנוסף נתונים שלושה דיסקים קשיחים עם הנתונים הבאים:\nRPM\nSEEK TIME\nTRANSFER RATE\nGHOST\n7200\n10ms\n200 MB/s\nFUSION\n15000\n10ms\n150 MB/s\nSENSOR\n5400\n5ms\n100 MB/s\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "איזה דיסק קשיח נעדיף עבור ה-workload האקראי, ואיזה נעדיף עבור הסדרתי?\nעבור האקראי:\nעבור הסדרתי:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "עבור ה-workload הסדרתי, מה אחוז הביצועים שנגיע אליו עבור כל אחד מהדיסקים הקשיחים? כלומר, מה היחס (באחוזים) בין המהירות בפועל לבין המהירות המקסימלית של כל דיסק.\n:GHOST\n:FUSION\n:SENSOR",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "לשיפור ביצועים ב-workload האקראי, הוחלט להשתמש במערך 4-RAID של דיסקים קשיחים מסוג FUSION. מה המספר המינימלי של דיסקים שנצטרך כדי לשפר את הביצועים על פני שימוש בדיסק אחד ללא RAID? יש לתת תשובה נפרדת לפעולות קריאה וכתיבה.\nקריאה: כמות דיסקים:\nכתיבה: כמות דיסקים:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. RPM 5400 הוא זמן סיבוב של 10ms ← זמן המתנה לסיבוב של 5.5ms. RPM של 7200 - זמן המתנה לסיבוב של 4.2ms. RPM של 15000 ← זמן המתנה לסיבוב של 2ms. זמן המיקום (seek+wait) לכל דיסק הוא: SENSOR 10.5ms FUSION 12ms GHOST 14.2ms זמן ההעברה ב-ms של 1MB לכל דיסק הוא 1000 חלקי קצב ההעברה המקסימלי של הדיסק: SENSOR 10ms FUSION 6.66ms GHOST 5ms בתרחיש האקראי של 512KB ייקח חצי מזה לזמן ההעברה, לכן סה\"כ הזמנים לפעולה לכל דיסק הם: SENSOR 15.5ms FUSION 15.33ms GHOST 16.7ms נעדיף את הקצר ביותר שהוא FUSION. בתרחיש הסדרתי של 100MB ייקח פי 100 מזמן ההעברה ל-1MB, לכן סה\"כ הזמנים לכל דיסק הם: SENSOR 1010.5ms FUSION 678ms GHOST 514.2ms נעדיף את הקצר ביותר שהוא GHOST.\n\n2. לפי הנתונים מעלה, זה הקצב שנגיע אליו בתרחיש הסדרתי עבור כל דיסק: GHOST 194.5 MB/s FUSION 147.5 MB/s SENSOR 99 MB/s באחוזים מהקצב המקסימלי נקבל: GHOST 97.25% FUSION 98.33% SENSOR 99%\n\n3. לפי הנתונים מעלה, זה הקצב שנגיע אליו בתרחיש האקראי עבור כל דיסק: GHOST 29.94 MB/s FUSION 32.6 MB/s SENSOR 32.2 MB/s כלומר עלינו להגיע לקצב גבוה יותר מ-MB/s 32.6 כדי שמערך ה-RAID ישפר. בתרחיש אקראי של קריאות הביצועים של 4-RAID עם N דיסקים הם N-1)*R) כאשר R קצב ההעברה בתרחיש האקראי, במקרה שלנו 32.6=R ולכן 3=N. בתרחיש אקראי של כתיבות הביצועים של 4-RAID הם 2/R ללא תלות בכמות הדיסקים, לכן לא נוכל לשפר את הביצועים על פני אף אחד מהדיסקים הקיימים."
      },
      "difficulty_estimation": "Medium"
    }
  ]
}