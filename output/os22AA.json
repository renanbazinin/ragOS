{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2022",
    "semester": "Semester A",
    "moed": "Moed A",
    "exam_date": "11.01.2022",
    "source_file": "os22AA.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Page Replacement",
        "Virtual Memory",
        "Memory Management"
      ],
      "content": {
        "text": "אלגוריתם השעון בוחר לפנות את הדף הכי ותיק (שניגשו אליו הכי בעבר).",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. אלגוריתם השעון (עם או בלי שדרוגים) מפנה את הדף הראשון שנמצא שלא ניגשו אליו מאז הסיבוב הקודם, לא בהכרח הדף הכי ותיק."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "System Calls",
        "Concurrency",
        "Atomic Operations"
      ],
      "content": {
        "text": "במקרים מסוימים, תהליכי משתמש יכולים לבטל פסיקות.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. רק לקרנל יש הרשאות לבטל פסיקות (לא מדובר בסיגנלים)."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Threads",
        "Processes",
        "Memory Management"
      ],
      "content": {
        "text": "חוטים של אותו תהליך יכולים לגשת למחסנית אחד של השני.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. לכל חוט יש מחסנית נפרדת משלו, אך חוטים של אותו תהליך חולקים את מרחב הכתובות כולו – ולכן יכולים לגשת למחסנית של חוט אחר באמצעות מצביע מתאים לזיכרון."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Paging",
        "Memory Management",
        "Virtual Memory"
      ],
      "content": {
        "text": "בדפדוף יש בעיה של פרגמנטציה חיצונית (external fragmentation).",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. דפדוף זו הקצאה בגודל קבוע, תמיד ניתן להשתמש בכל מסגרת ולכן אין פרגמנטציה חיצונית (אך כן יש פנימית)."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Deadlocks",
        "Concurrency",
        "Synchronization"
      ],
      "content": {
        "text": "אם יש קיפאון בהכרח יש גם הרעבה.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. יתכן קיפאון ללא הרעבה, לדוגמה מנעול הוגן אשר מגריל כל פעם אם להיכנס ללולאה אינסופית (קיימות גם דוגמאות מציאותיות יותר)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Virtual Memory",
        "Paging",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה מערכת עם זיכרון וירטואלי של 32GB וגודל דף של 4KB.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "נתון שטבלת דפים לינארית תופסת 24MB בזיכרון, וכל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת ועוד שלושה ביטים בלבד (ללא תוספות או ריפוד): ביט valid, ביט access, ביט dirty. מה גודל הזיכרון הפיזי המקסימלי במערכת זו? זיכרון פיזי מקסימלי:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "נתון שכל כניסה בטבלת הדפים (PTE) מכילה 32 ביטים בכל רמה, ונדרש שכל טבלה תאוחסן בדף אחד בדיוק. כמה רמות של טבלאות דרושות כדי למפות את מרחב הכתובות הוירטואלי? מספר רמות:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "מה מספר הגישות המקסימלי שעלול להתבצע לזיכרון הראשי, הזיכרון המשני (הדיסק), וה-TLB, בעקבות גישה של תהליך לכתובת וירטואלית כלשהי?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "6.1: 1. גודל הזיכרון הוירטואלי 2^35 בתים וגודל דף 2^12 בתים – ההיסט הוא 12 כלומר VPN הוא 23, ויש 2^23 דפים לתהליך – כלומר 8M (2^23) כניסות בטבלת הדפים. כל שורה בטבלת הדפים היא בגודל PTE, לפני נתוני השאלה 3+PTE=PFN ביטים. אם טבלת הדפים היא 24MB עבור 8M כניסות אז כל כניסה היא בגודל 24MB/8M בתים (24 ביטים). מאחר שנתון שכל PTE מכיל מסר מסגרת ועוד 3 ביטים, אז מספר המסגרת מיוצג ע\"י 21 ביטים, כלומר מקסימום 2^21 מסגרות בזיכרון הפיזי. גודל כל מסגרת הוא 4KB לכן הזיכרון הפיזי המקסימלי הוא 8GB.\n6.2: 2. 32 ביטים לכל PTE = 4 בתים. גודף דף הוא 4KB כלומר בכל דף נכנסות 1024 כניסות (2^10). לתהליך יש 2^23 דפים (כמו בסעיף א'), כלומר שמספר הדף מיוצג ע\"י 23 ביטים וכל רמה בטבלה מיוצגת ע\"י 10 ביטים סה\"כ 3 רמות לטבלת הדפים (3 ביטים עבור הרמה הראשונה, 10 עבור השניה, 10 עבור השלישית).\n6.3: 3. מספר גישות מקסימלי מתרחש ב-page fault ניגש ל-TLB (ונפספס), ניגש לטבלת הדפים (3 גישות לזיכרון, אחת לכל רמה) ונקבל page fault, ניגש לזיכרון ולדיסק כדי לפנות (page out) מסגרת, ואז שוב לזיכרון ולדיסק כדי לטעון את הדף המבוקש (page in), ניגש שוב לזיכרון כדי לעדכן את טבלת הדפים עם מיפוי הדף, נעדכן את ה-TLB, נחזור על הפקודה (גישה נוספת ל-TLB לא חובה לציין), וניגש שוב לזיכרון עבור הנתון עצמו."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Atomic Operations",
        "Mutexes"
      ],
      "content": {
        "text": "מנעול חד-פעמי הוא מנעול אשר ניתן לנעול פעם אחת בלבד: ברגע שחוט תופס את המנעול בהצלחה, אף חוט אחר לא יכול לתפוס יותר את המנעול לכל אורך התוכנית. פונקציית הנעילה של מנעול חד-פעמי מחזירה 0 לחוטים אשר נכשלו בתפיסת המנעול מבלי לחסום אותם (כלומר, ללא המתנה בדומה לקריאת trylock), ומחזירה 1 לחוט שהצליח. הבהרה: במנעול חד-פעמי, ברגע שחוט מסוים קיבל 1 מפונקציית הנעילה (תפס את המנעול בהצלחה), כל קריאה עתידית בכל חוט תחזיר 0, אפילו אם המנעול פנוי מאחר שהוא חד-פעמי. במנעול חד-פעמי ל-N חוטים מובטח שפונקציית הנעילה של כל מנעול לא נקראת יותר מ-N פעמים בכל ריצת התוכנית. נניח שלרשותנו עומדת פקודת חומרה אטומית ששמה Check&Add, אשר מקדמת מונה באחד ומחזירה האם ערכו החדש שווה לפרמטר C. את הפקודה ניתן לתאר כך: הבהרה: תיאור הפעולה הוא קוד C לצורך הסבר בלבד. פעולת המעבד מבצעת זאת באופן אטומי ולא בכמה פעולות. בכל שאלה זו אין להשתמש באובייקטי סנכרון או פעולות מעבד אטומיות מלבד Check&Add, ויש לדאוג למניעה הדדית וחופש מקיפאון.",
        "code_snippet": "int check_add(int *p, int C) {\n    assert(*p < C); // check invalid op (crashes if FALSE)\n    return (++*p == C);\n}",
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "ממשו מנעול חד-פעמי ל-2 חוטים המשתמש בתא זיכרון יחיד (משתנה אחד x המתקבל כפרמטר). יש לממש את הפונקציות הבאות:",
          "code_snippet": "void init2(int* x) {\n}\n\nint lock2(int* x) {\n}",
          "options": null
        },
        {
          "id": "7.2",
          "text": "מ ממשו מנעול חד-פעמי ל-3 חוטים המשתמש ב-2 תאי זיכרון (2 משתנים x,y המתקבלים כפרמטר). יש לממש את הפונקציות הבאות:",
          "code_snippet": "void init3(int* x, int* y) {\n}\n\nint lock3(int* x, int* y) {\n}",
          "options": null
        },
        {
          "id": "7.3",
          "text": "ממשו מנעול חד-פעמי ל-N חוטים (כאשר N פרמטר בפונקציית האתחול). יש להגדיר את מבנה המנעול (struct CALock) ולממש את הפונקציות הבאות:",
          "code_snippet": "typedef struct _calock {\n} CALock;\nvoid init(CALock *lock, int N) {\n}\nint lock(CALock *lock) {\n}\nvoid destroy(CALock *lock) {\n}",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "7.1: 1. נשתמש בפעולה עם 2=C כדי להבדיל בין החוט הראשון שקורא ל-lock2 לבין החוט השני: שימו לב: חשוב להחזיר הפוך מ-check_add. מובטחות עד 2 קריאות אך לא מובטח שיתבצעו 2 קריאות. יתכן שרק חוט אחד ינסה לתפוס את המנעול ואז יכשל – וקיבלנו קיפאון.\n```c\nvoid init2(int *x) {\n    *x = 0;\n}\n\nint lock2(int *x) {\n    return (!check_add(x, 2));\n}\n```\n7.2: 2. הפעולה נותנת לנו להבדיל בין החוט האחרון שביצע אותה לבין כל שאר החוטים, אך כאשר יש 3 חוטים זה לא מספיק - נדע רק להגיד מי החוט השלישי שביצע את הפעולה, וצריך להכריע בין ה-2 הראשונים. לכן נשתמש בפעולה כדי להפריד את החוט השלישי, ובין ה-2 הראשונים נפתור את הבעיה עם סעיף א':\n```c\nvoid init3(int *x, int *y) {\n    *x = *y = 0;\n}\n\nint lock3(int *x, int *y) {\n    if (check_add(x, 3))\n        return 0;\n    return (lock2(y));\n}\n```\n7.3: 3. נמשיך באותו רעיון כמו הסעיף הקודם – כל משתנה יאפשר לנו להפריד את החוט האחרון שביצע קריאה לפעולה החדשה בעזרתו, אז נשתמש ב-1-N משתנים כדי לייצר \"תחרויות\" בין החוטים. בכל תחרות האחרון יעזוב (יכשל בתפיסת המנעול), עד שנשאר רק חוט 1 שיתפוס אותו. שימו לב שהחוט שתפס את המנעול אינו בהכרח החוט הראשון שניסה, אלא החוט הראשון שביצע את הפעולה על המשתנה האחרון, ולא החוט האחרון שקרא לפעולה עבור אף אחד מהמשתנים.\n```c\ntypedef struct _calock {\n    int *carr;\n    int N;\n} CALock;\n\nvoid init(CALock *lock, int N) {\n    lock->carr = (int*) calloc(sizeof(int), N-1);\n    lock->N = N;\n}\n\nint lock(CALock *lock) {\n    for (int i = 0; i < lock->N - 1; ++i) {\n        if (check_add(lock->carr[i], N-i))\n            return 0;\n    }\n    return 1;\n}\n\nvoid destroy(CALock *lock) {\n    free(lock->carr);\n}\n```"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS עם גודל בלוק של 4KB. מספר הבלוקים של DATA במערכת הוא 20,000,000 ומספר ה-inodes הוא 40,000. הגודל של כל inode הוא 128 בתים. הסופר-בלוק מכיל את השדות הבאים: BSIZE – גודל הבלוק (4096 בתים) Nblocks – מספר הבלוקים הכולל Ninodes – מספר ה-inodes I_BMAP_Start – הבלוק הראשון של ה-inode bitmap D_BMAP_Start – הבלוק הראשון של ה-data bitmap כמו-כן בכל inode יש 10 מצביעים ישירים, מצביע אחד עקיף, ומצביע אחד עקיף כפול. בנוסף, מוגדרים בקרנל 2 מערכים שמתארים כמה ביטים פנויים (כמה אפסים) יש בכל בלוק של bitmap:",
        "code_snippet": "int inode_bmap_stat[ <value_1> ];\nint data_bmap_stat[ <value_2> ];",
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "האם ניתן לדעת מה הגדלים של המערכים הנתונים? אם כן, יש לפרט את הגדלים, אחרת יש לפרט איזה מידע חסר כדי לדעת את ערכם. ניתן לדעת – גודל 1_value: גודל 2_value: לא ניתן לדעת – מידע חסר:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "משתמש ביצע את הפעולה הבאה בטרמינל: 1 mkdir. הניחו שהפעולה מצליחה. כמה בלוקים צריך לקרוא ולכתוב לדיסק בכדי לבצע את הפעולה? קריאות: כתיבות:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "בתיקיית העבודה הנוכחית קיים קובץ רגיל שגודל הוא 45050 בתים. תוכנית משתמש פתחה את הקובץ בסופו (O_APPEND) וביצעה כתיבה של 10 בתים. כמה בלוקים צריך לקרוא מהדיסק בכדי לבצע את פעולת הכתיבה? בסעיף זה אין צורך להתייחס לכתיבות לדיסק. קריאות:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "8.1: 1. בכל אחד מהמערכים, כל תא מציין כמה ביטים פנויים יש בבלוק bitmap המתאים. כלומר לדוגמה, תא 0 של המערך הראשון מייצג כמה ביטים פנויים יש בבלוק הראשון של inode bitmap במערכת, תא 1 מייצג כמה ביטים פנויים יש בבלוק השני, וכן הלאה. כלומר שגודל כל מערך הוא פשוט ככמות הבלוקים ב-bitmap המתאים. גודל בלוק הוא 4KB שהם 32,678 ביטים. מספר ה-inodes הוא 40,000, דרושים 2 בלוקים של inode bitmap לכן הערך של 1_value הוא 2. באופן דומה, יש 2,000,000 בלוקים של DATA ולכך נדרש 611 בלוקים של data bitmap לכן הערך של 611 הוא value_2\n8.2: 2. יש להניח שתיקיית העבודה הנוכחית כבר נמצאת בזיכרון של הקרנל, כולל ה-DATA שלה, לכן ניגש אל הבלוקים הבאים: 1. בלוק inode bitmap בו יש ביט פנוי (נמצא ישר בזכות המערך בקרנל): קריאה וכתיבה כדי לעדכן את הביט המתאים. 2. בלוק Inode מתאים: קריאה וכתיבה כדי לעדכן את ה-inode (בלי לשנות את שאר הבלוק). 3. בלוק data bitmap בו יש ביט פנוי (נמצא ישר בזכות המערך בקרנל): קריאה וכתיבה כדי לעדכן את הביט המתאים. 4. בלוק DATA של התיקייה הנוכחית להוספת הרשומה של d1 (נניח שהפעולה לא מוסיפה בלוק חדש). 5. בלוק DATA שאיתרנו בשלב 3 ליצירת הכניסות שמופיעות בכל תיקייה (כמו ..). צעדים 1-3 דורשים קריאה וכתיבה, צעדים 4-5 דורשים כתיבה בלבד.\n8.3: 3. נתוני ה-inode כבר נמצאים בזיכרון לאחר פתיחת הקובץ (התקבלו גם תשובות שציינו קריאה של הבלוק inode). אם נחלק את גודל הקובץ בגודל בלוק נקבל שהכתיבה מתבצעת החל מבלוק 10 וגולשת אל בלוק 11 (אלו אינדקסים לפי הסדר של הקובץ, לא של הבלוקים עצמם בדיסק / מערכת הקבצים). כדי להגיע אליו נשתמש במצביע עקיף, לכן נצטרך לקרוא את בלוק המצביעים הרלוונטי ואח\"כ את הבלוק עצמו (כי לא משכתבים את כולו). בנוסף נצטרך לקרוא בלוק data bitmap כדי להקצות בלוק חדש (בלוק 11 של הקובץ), אין צורך לקרוא את הבלוק החדש אלא רק לכתוב אליו."
      },
      "difficulty_estimation": "Hard"
    }
  ]
}