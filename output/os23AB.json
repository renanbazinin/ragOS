{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2023",
    "semester": "Semester A",
    "moed": "Moed B",
    "exam_date": "20.02.2023",
    "source_file": "os23AB.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Memory Management",
        "Virtual Memory"
      ],
      "content": {
        "text": "אם הזיכרון המשני מלא לחלוטין, לא ניתן להקצות זיכרון נוסף לתהליכים קיימים או להריץ תהליכים חדשים.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. יתכן שעדיין יש מסגרות פנויות בזיכרון הראשי."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Mutexes"
      ],
      "content": {
        "text": "במערכת המשתמשת במנעולים הוגנים בלבד (ללא אובייקטי סנכרון אחרים), לא תיתכן הרעבה.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. בדומה לקיפאון, גם הרכבה של מנעולים הוגנים עלולה לגרום להרעבה. לדוגמה, מימוש מנעול קוראים-כותבים שנלמד בשיעור גורם להרעבת הכותב גם בשימוש במנעולים הוגנים."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "בכונן SSD נעדיף מערכת קבצים מבוססת לוג (כמו LFS) על-פני מערכת קבצים סטנדרטית (כמו VSFS), אחרת חלקים מהדיסק ישחקו משמעותית יותר מהר.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. כונן SSD דואג ברמת החומרה לפיזור הכתיבות כך שניתן להשתמש בו כרגיל, ללא תלות במערכת הקבצים שנבחר לשים בו."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Memory Management"
      ],
      "content": {
        "text": "בהקצאות זיכרון בגודל קבוע אין אף סוג של פרגמנטציה.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. יש פרגמנטציה פנימית אם נדרש למשתמש פחות זיכרון מהגודל הקבוע."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O",
        "Disk Scheduling"
      ],
      "content": {
        "text": "בדיסק קשיח עם מערכת קבצים VSFS, כתיבה סדרתית גדולה לקובץ תמיד תהיה מהירה או שווה במהירות למספר כתיבות אקראיות של אותה כמות מידע סך הכל לאותו קובץ.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. תלוי בהקצאה, יתכן שקובץ יתפזר על פני בלוקים בדיסק באופן שכתיבה סדרתית למעשה תתורגם לפעולות אקראיות בדיסק, בעוד שפעולה אקראית עלולה במקרה לפנות לבלוקים רציפים וכך להתבצע מהר יותר."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Virtual Memory",
        "Paging",
        "Page Replacement",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה מערכת המשתמשת באלגוריתם השעון (עם כל השדרוגים), בה רץ תהליך יחיד עם טבלת הדפים הלינארית המופיעה בהמשך. כל כניסה בטבלה מחולקת לעמודות אך כל שורה מייצגת רצף אחד של ביטים עבור PTE אחד. בטבלת הדפים הנתונה: P=Present, V=Valid, A=Accessed (Reference), D=Dirty. העמודה הימנית היא לתיאור בלבד ואינה חלק מנתוני ה-PTE. ידוע שגודל הטבלה קטן מדף אחד. בשאלה זו יש להתעלם מכל הזיכרון ומבני הנתונים של הקרנל מלבד טבלאות הדפים. יש לפרט ולנמק את כל החישובים.\n\nPFN     P V A D   ריפוד   סגמנט\n00100   1 1 1 0   0000000000   TEXT\n00000   0 1 0 0   000000000\n11101   1 1 0 0   0000000000\n00000   0 0 0 0   0000000000\n00010   1 1 1 0   0000000   DATA\n00000   0 0 0 0   0000000000\n10011   1 1 0 1   0000000   STACK\n00000   0 1 0 0   000000000\n10100   1 1 0 1   0000000000\n00000   0 0 0 0   0000000000\n00000   0 1 0 0   000000000\n01011   1 1 1 0   0000000   HEAP\n01101   1 1 1 0   0000000000\n00000   0 0 0 0   0000000000\n11010   1 1 1 0   0000000000\n00000   0 1 0 0   0000000",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "איזה נתון חסר כדי לחשב את גודל הזיכרון הוירטואלי וגודל הזיכרון הפיזי המקסימלי? מה יהיו גדלים אלו אם הערך של הנתון החסר הוא X?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "נניח שהתהליך הנתון הריץ את שורת הקוד הבאה: `int pid1 = fork();` נתון שהקריאה הצליחה, ותהליך הבן שנוצר עוד לא קיבל זמן מעבד. כמה מסגרות בזיכרון יהיו תפוסות מיד לאחר ביצוע כל שורת קוד זו (ביחס למצב בו שהיה בדיוק לפני הרצת שורה זו)?",
          "code_snippet": "int pid1 = fork();",
          "options": null
        },
        {
          "id": "6.3",
          "text": "נניח שכל שאר המסגרות בזיכרון (שאינן בשימוש ע\"י התהליך הנתון) שמורות לקרנל. התהליך ניגש לכתובת בדף מספר 10. איזה דף יפונה מהזיכרון? מה יהיה הערך החדש של ה-PTE של דף 10?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "6.1: הנתון החסר הוא גודל הדף. לכל תהליך יש 16 דפים (לפי מספר הכניסות בטבלה), לכן מרחב הכתובות הוא X*16 בתים. ה-PFN הוא 5 ביטים (לפי כמות הביטים בטבלה), סה\"כ 32 מסגרות וזיכרון פיזי X*32.\n\n6.2: התהליך הנוכחי תופס 9 מסגרות בזיכרון – 8 עבור זיכרון התהליך (כל דף עבורו 1=P) ועוד מסגרת אחת לטבלת הדפים (כפי שנתון, טבלת הדפים הלינארית קטנה מדף). בקריאה ל-fork לא תשוכפל אף מסגרת מהזיכרון בגלל copy-on-write, אלא אחרי ה-fork נתפוס רק מסגרת אחת נוספת עבור טבלת הדפים של התהליך החדש. מסגרת נוספת תידרש אחרי ההשמה למשתנה pid1. נצטרך לשכפל חלק מהמחסנית של תהליך האב בגלל -copy on-write. המחסנית היא דף אחד לכן זה ידרוש בדיוק מסגרת אחת נוספת. סה\"כ יהיו תפוסות עוד 2 מסגרות.\n\n6.3: אלגוריתם השעון מחפש בעדיפות דף שלא ניגשו אליו לאחרונה (0=A) וגם שלא בוצע בו שינוי (0=D). הדף היחיד שמקיים את 2 התנאים וגם נמצא בזיכרון (1=P) הוא דף מספר 2. נפנה את דף 2 מהזיכרון, ובתוך המסגרת שבה היה דף 2 נשים את דף 10, כלומר: PFN=11101, P=V=A=1, הביט D יכול להיות 0 או 1 בהתאם לפעולה שבוצעה."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Threads",
        "Concurrency",
        "Synchronization",
        "Race Conditions"
      ],
      "content": {
        "text": "נתונה התוכנית הבאה לקידום מונה משותף counter ע\"י חוטים מרובים, כאשר ערכי הקבועים T,N אינם ידועים (אך הם לכל הפחות 2). כל החוטים מריצים את אותה פונקציה foo או bar, כמפורט בהמשך. קמפלו והריצו את תוכנית זו פעמיים: פעם אחת כאשר כל החוטים שנוצרים (בשורה 23) מריצים את הפונקציה foo, ופעם נוספת כאשר כל החוטים שנוצרים מריצים את הפונקציה bar. ניתן להניח שכל קריאות המערכת הצליחו. יש לפרט בקצרה ובבירור את תזמוני הריצות שמובילים לכל אחת מהתשובות.",
        "code_snippet": "1 #define T ?? // 2 or more\n2 #define N ?? // 2 or more\n3 int counter = 0;\n4\n5 void* foo(void* arg)\n6{\n7   for (int i = 0; i < N; ++i) {\n8     ++counter;\n9   }\n10  return NULL;\n11}\n12\n13 void* bar (void* arg)\n14 {\n15   while (counter < N) {\n16     ++counter;\n17   }\n18  return NULL;\n19}\n20\n21 void main() {\n22   pthread_t threads [T];\n23   for (int i = 0; i < T; ++i)\n24     pthread_create(&threads [i], NULL, ??, NULL);\n25   for (int i = 0; i < T; ++i)\n26     pthread_join(threads[i], NULL);\n27   printf(\"counter = %d\\n\", counter);\n28 }",
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "מה הערך המינימלי של counter (כפונקציה של T,N) שיודפס בסוף התוכנית, כאשר החוטים מריצים את foo? רמז: הערך המקסימלי הוא T*N.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.2",
          "text": "מה הערך המקסימלי של counter (כפונקציה של T,N) שיודפס בסוף התוכנית, כאשר החוטים מריצים את bar? רמז: הערך המינימלי הוא N.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.3",
          "text": "נתון 2=T והחוטים שנוצרים מריצים את bar. מה המספר המקסימלי של פעמים (כפונקציה של N) שחוט כלשהו עלול להריץ את שורה 15? (רמז: המינימלי הוא 0)",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.4",
          "text": "נניח שלכל חוט שנוצר בשורה 23 יש מזהה ייחודי בין 0 ל-1-T. כמו-כן נתונה הפונקציה `int get_id()`, אשר מחזירה את מזהה החוט עבור החוט הקורא לה (שימו לב: המזהה אינו ה-TID, הפונקציה מחזירה ערך שונה בהתאם לחוט שקורא לה, ובטוחה לשימוש במקביל). ברצוננו לתקן את הפונקציה foo כך שבהרצת התוכנית עם foo, החוטים יקדמו את המונה לסירוגין (ובאופן נכון). כלומר, חוט 0 יקדם את המונה פעם אחת, ואז חוט 1 יקדם את המונה פעם אחת, אז חוט 2 יקדם פעם אחת, וכן הלאה עד חוט 1-T, אחריו חוט 0 יקדם את המונה פעם שניה, חוט 1 יקדם את המונה פעם שניה, וכו' לפי הסדר עד אשר כל חוט קידם את המונה N פעמים. ניתן להגדיר משתנים גלובליים ולהשתמש בסמפורים כרצונכם, אך אין להשתמש בפעולות אטומיות או אובייקטי סנכרון מלבד סמפורים. משתנים גלובליים (יש לציין ערכי אתחול בהערה):",
          "code_snippet": "void* foo(void* arg) {\n}",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "7.1: מינימום 2. ריצה לדוגמה: חוט 1 רוצה לקדם את המונה, קורא ערך 0 ונעצר לפני כתיבה של 1. חוט 2 מקדם את המונה 1-N פעמים, נעצר לפני הקידום האחרון (לפני כולו עוד לא קרא את המונה). שאר החוטים כולם מקדמים את המונה N פעמים ומסיימים. חוט 1 חוזר לרוץ וכותב 1 אל המונה (למעשה \"מאפס\" את שאר הקידומים שנעשו). חוט 2 רוצה לקדם את המונה, קורא ערך 1 ונעצר לפני כתיבה של 2. חוט 1 מקדם את המונה עוד 1-N פעמים שנשאר לו, ומסיים. חוט 2 חוזר לרוץ וכותב 2 אל המונה, קידם סה\"כ N פעמים ולכן מסיים.\n\n7.2: מקסימום 1-N+T. ריצה לדוגמה: חוט 1 נכנס ללולאה ומקדם את המונה עד שערכו 1-N. כל T החוטים במקביל בודקים את תנאי הלולאה ונכנסים ללולאה (המונה קטן מ-N). לפי הסדר, כל חוט מקדם את המונה בנפרד פעם אחת, סה\"כ T פעמים. כל החוטים מסיימים, ערך המונה הוא N-1+T.\n\n7.3: מקסימום N^2/2. ריצה לדוגמה: חוט 1 רוצה לקדם את המונה, קורא ערך 0 ונעצר לפני כתיבה של 1. חוט 2 מקדם את המונה עד N (סה\"כ N פעמים), נעצר לפני הכניסה ללולאה. חוט 1 חוזר לרוץ וכותב 1 אל המונה, רוצה לקדם שוב וקורא 1 ונעצר לפני כתיבה של 2. חוט 2 מקדם את המונה עד N (סה\"כ 1-N פעמים), נעצר לפני הכניסה ללולאה. חוט 1 חוזר לרוץ וכותב 2 אל המונה, רוצה לקדם שוב וקורא 2 ונעצר לפני כתיבה של 3. וכן הלאה. סה\"כ חוט 2 מקדם את המונה 1+(N-2)+...+1+(N-1) פעמים, כלומר N^2/2.\n\n7.4: גלובליים: sem_t sems[T]; // Initialized: sems[0] = 1, sems[1..T-1] = 0\n\nvoid* foo(void* arg)\n{\n  for (int i = 0; i < N; ++i) {\n    sem_wait(&sems[get_id()]);\n    ++counter;\n    sem_post(&sems[(get_id()+1)%T]);\n  }\n  return NULL;\n}"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "Memory Management",
        "Copy-on-Write"
      ],
      "content": {
        "text": "ב-VSFS קיים שדרוג של copy-on-write, אשר מאפשר להתייחס לאותו בלוק מידע (DATA) מכמה מקומות שונים (לדוגמה, להצביע אליו מכמה inodes שונים). לצורך השדרוג, נקצה אזור חדש בדיסק (סט בלוקים) שיכיל מספר עבור כל בלוק DATA, המייצג כמה הפניות יש אל אותו בלוק. נניח שכמות ההפניות המקסימלית לכל בלוק היא 255. בהעתקת קובץ בתוך מערכת הקבצים, לא נשכפל את המידע והמצביעים אלא רק ניצור inode חדש בו ערכי המצביעים זהים לקובץ המקור. במחיקה של קובץ (לחלוטין, כלומר לא נותרו hard links אל הקובץ) נחסיר 1 מכמות ההפניות של כל הבלוקים של הקובץ. בעדכון נתוני קובץ, נשכפל את הבלוקים ששונו ונעדכן את מספר ההפניות בהתאם (יחד עם עדכון המצביעים עבור ה-inode בו בוצע העדכון). יש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "נתונה מערכת קבצים עם גודל בלוק של 4KB. במערכת VSFS סטנדרטית (ללא השדרוג) נתון שיש מקום ל-10,000,000 בלוקים של DATA. לכמה בלוקים של DATA יהיה מקום עם השדרוג הנתון? כלומר, נתון דיסק קשיח ועליו מערכת קבצים VSFS סטנדרטית (ללא השדרוג) עם data region המכיל 10,000,000 בלוקים של DATA. ביצעו את השדרוג הנתון למערכת הקבצים, ללא שינוי שאר נתוני מערכת הקבצים מלבד שינוי גודל ה-data region לטובת הקצאת האזור החדש בדיסק (כלומר, ללא שינוי גודל בלוק, גודל inode, כמות inodes, וכו'). לכמה בלוקים של DATA יהיה מקום בדיסק לאחר השדרוג?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "במערכת הקבצים מהסעיף הקודם (לאחר השדרוג), נתון ש-inode מכיל 10 מצביעים ישירים, מצביע אחד עקיף, ומצביע אחד עקיף כפול. גודל מצביע הוא 4 בתים. משתמש ביצע העתקה של קובץ רגיל שגודל 45040 בתים, ואז ביצע כתיבה של 10 בתים אל סוף הקובץ המקורי. כמה בלוקים צריך לקרוא ולכתוב בדיסק בשביל לבצע כל אחת מהפעולות, במקרה המקסימלי? (בסעיף זה אין צורך להתייחס לגישה לתיקיות או לעדכון זמני גישה ב-inode, ניתן להניח שה-inode של קובץ המקורי כבר בזיכרון, ואף cache אינו מכיל מידע רלוונטי לביצוע הפעולה)",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "סטודנט טען כי עם השדרוג של copy-on-write, אין יותר צורך ב-data bitmap מדוע זה נכון, ומה היתרונות והחסרונות של ויתור על ה-data bitmap",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "8.1: ה-data region מכיל 10 מיליון בלוקים, כעת צריך באותה כמות בלוקים להכיל גם את האזור החדש של מספר ההפניות. כל הפניה לבלוק דורשת בית אחד (8 ביטים לייצוג מספר 0-255), לכן בכל בלוק 4KB נכנסות 4096 הפניות. כלומר, אם יש X בלוקים של DATA לאחר השינוי, נצטרך X/4096 בלוקים של הפניות (מעוגל מעלה). סה\"כ הבלוקים צריך להיות עדיין 10 מיליון, כלומר שאנו מחפשים X מקסימלי המקיים את המשוואה: X+X/4096 <= 10,000,000 התשובה היא X=9997559.\n\n8.2: קובץ המקור משתמש בכל 10 המצביעים הישירים ובמצביע עקיף אחד, עם בלוק מצביעים שמכיל מצביע יחיד. העתקה: נצטרך לקרוא ולכתוב inode bitmap עבור הקובץ החדש, לקרוא ולכתוב בלוק עם ה-inode החדש (נתוני המצביעים זהים ל-inode המקורי בגלל השימוש ב-copy-on-write), ובנוסף נקרא ונכתוב במקסימום 12 בלוקים של הפניות, להגדלה ב-1 של ההפניות לכל הבלוקים של DATA שמשתמש בהם הקובץ המקורי (כולל בלוק המצביעים העקיף גם אליו יש 2 הפניות כעת). סה\"כ 14 בלוקים לקריאה וכתיבה. כתיבה: הכתיבה לא גורמת להוספה של בלוק חדש אלא רק כתיבה לבלוק האחרון (ה-11) של הקובץ. הבלוק משותף (בגלל ההעתקה) ולכן צריך לשכפל אותו. בעקבות השכפול משתנה גם בלוק המצביעים, גם הוא משותף ולכן צריך לשכפל גם אותו. נצטרך לקרוא בלוק עקיף של מצביעים (כדי למצוא את בלוק ה-DATA), ואז לקרוא ולכתוב במקסימום 2 בלוקים של הפניות (אחד לכל בלוק), אח\"כ לקרוא בלוקים של data bitmap עד שנמצא מקום פנוי ואז לכתוב במקסימום 2 מהם (אם נמצא מקום פנוי אחד בכל בלוק), ולבסוף לכתוב את הנתונים המשוכפלים עצמם (2 בלוקים לכתיבה בלבד) ולעדכן את ה-inode של קובץ המקור עם המצביע המעודכן (קריאה וכתיבה). סה\"כ 6 קריאות ו-7 כתיבות. (יתכן שידרשו יותר קריאות של ה-data bitmap אך זה לא נדרש בשאלה)\n\n8.3: הטענה נכונה כי ניתן להשתמש באזור ההפניות כדי לדעת אם בלוק פנוי אם לבלוק DATA יש 0 הפניות, אז אף קובץ לא משתמש בו והבלוק פנוי. יתרונות: נוכל לחסוך מקום בדיסק שתפס ה-data bitmap. חסרונות: ידרשו יותר גישות כדי למצוא ו/או לפנות מקום פנוי, מאחר וכל בלוק של הפניות מכיל נתונים על פחות בלוקים מאשר ה-bitmap."
      },
      "difficulty_estimation": "Hard"
    }
  ]
}