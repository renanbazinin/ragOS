{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2024",
    "semester": "Semester B",
    "moed": "Moed A",
    "exam_date": "07.07.2024",
    "source_file": "os24BA.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Deadlocks",
        "Synchronization"
      ],
      "content": {
        "text": "כיצד ניתן למנוע קיפאון במערכת המשתמשת במנעולים להגנה על גישה למשאבים שונים?",
        "code_snippet": null,
        "options": [
          "תמיד לתפוס את המנעולים בסדר קבוע.",
          "כאשר נדרש לתפוס מספר מנעולים, נתפוס אותם \"בבת אחת\" (נוודא שחוט אחר לא מנסה לתפוס מנעולים במקביל אלינו).",
          "במידה ולא הצלחנו לתפוס מנעול, נשחרר את כל המנעולים שאנו מחזיקים וננסה מחדש.",
          "להימנע לחלוטין משימוש במנעולים ומניעה הדדית.",
          "כל התשובות נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. כל סעיף מייצג את אחת הטכניקות שנלמדו למניעת קיפאון ולכן כל התשובות נכונות."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Scheduling",
        "CPU Scheduling",
        "Processes"
      ],
      "content": {
        "text": "נתונה מערכת הפעלה ללא תמיכה בפסיקת שעון. איזו טענה בהכרח נכונה?",
        "code_snippet": null,
        "options": [
          "לא ניתן לטפל בפסיקות.",
          "לא ניתן לבצע context switch.",
          "תהליכים לעולם לא יהיו במצב READY",
          "תהליכים לא יכולים לבצע קריאות מערכת.",
          "כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. פסיקת שעון נועדה כדי לעצור תהליכים בכל פרק זמן קבוע ולהחזיר את השליטה לקרנל. ללא פסיקת שעון מערכת ההפעלה תמשיך לעבוד כרגיל מלבד מנגנון זה לא נוכל לוודא שהשליטה חוזרת בוודאות לקרנל (וההשלכות של כך)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Paging",
        "Virtual Memory",
        "Memory Management"
      ],
      "content": {
        "text": "במערכת עם טבלת דפים היררכית, תהליך ניגש לדף שהטבלה המכילה את המיפוי שלו לא הוקצתה (תת-הטבלה המתאימה ברמה התחתונה של טבלת הדפים לא קיימת). איזו טענה נכונה?",
        "code_snippet": null,
        "options": [
          "התרגום יתבצע באופן תקין אך יתרחש page fault",
          "התרגום יתבצע באופן תקין ולא יתרחש page fault.",
          "לא ניתן לבצע את התרגום הגישה תגרום לשגיאת זיכרון בתהליך.",
          "לא ניתן לבצע את התרגום הגישה תגרום לשגיאה בקרנל (תקיעת/קריסת המחשב).",
          "כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. אם לא הוקצתה הטבלה המתאימה, זה אומר שכל הרשומות בה הן 0=V, כלומר מייצגות זיכרון שאינו בשימוש ע\"י התהליך וכל גישה לכתובת כזו תגרום לשגיאה בתהליך."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "CodeAnalysis",
      "topic": [
        "Processes",
        "System Calls"
      ],
      "content": {
        "text": "נתון קטע הקוד הבא, של תוכנית בשם myexec:\n\nPID: 300\nהריצו את קטע הקוד, ושורת הפלט הראשונה שהתקבלה היא:\nניתן להניח שכל קריאות המערכת הצליחו, לא נוצרו תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.\nאיזו טענה נכונה?",
        "code_snippet": "int main()\n{\nchar* args[] = {\"myexec\", NULL};\nprintf(\"PID: %d\\n\", getpid());\nexecvp(args[0], args);\n}",
        "options": [
          "לא יהיה פלט נוסף לתוכנית.",
          "המשך הפלט יהיה \"300 :PID\" אינסוף פעמים (עד לעצירת התוכנית).",
          "המשך הפלט יהיה \"301 :PID\", לאחר מכן \"302 :PID\", וכן הלאה (עד לעצירת התוכנית).",
          "התוכנית תקרוס בשלב מסוים בגלל יצירה של יותר מדי תהליכים.",
          "כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ב",
        "explanation": "ב'. הקריאה ל-execvp מריצה שוב את ה-main באותו תהליך (קריאת execvp אינה יוצרת תהליך חדש), ולכן הקוד מייצג מעין לולאה אינסופית."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS המשתמשת ב-journaling. איזו טענה בהכרח נכונה?",
        "code_snippet": null,
        "options": [
          "קובץ לא יכול להכיל יותר נתונים מהמקום הפנוי ב-journal.",
          "קריאה מקובץ באופן סדרתי מתורגמת לגישה סדרתית לדיסק.",
          "שימוש ב-metadata journaling תמיד יהיה מהיר יותר מאשר journaling רגיל.",
          "אם מובטח שסדר הכתיבות בדיסק הוא לפי הסדר בו הן נשלחו, לא נצטרך fsync.",
          "כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ד",
        "explanation": "ד'. השימוש ב-fsync הוא כדי להבטיח שאנו לא מבצעים כתיבה כלשהי לפני שבוצעו הכתיבות שקדמו לה. אם מובטח שהכתיבות מתבצעות לפי הסדר, אין צורך ב-fsync."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Paging",
        "Virtual Memory",
        "Memory Management",
        "Page Replacement"
      ],
      "content": {
        "text": "נתונה מערכת עם גודל דף של 1KB, בה ידוע שהזיכרון הוירטואלי גדול פי 2 מהזיכרון הפיזי.\nכל תהליך במערכת משתמש בטבלת דפים לינארית, כאשר כל כניסה בטבלת הדפים היא בגודל 16 ביטים.\nנתון תהליך במערכת אשר אלו 10 הרשומות PTE הראשונות בטבלת הדפים שלו:\n\nכל שורה בטבלה מייצגת PTE, כאשר נתון: P=Present, V=Valid, A=Access (Reference), D=Dirty.\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": "PFN VPAD ריפוד\n00000 1 0 0 0 0000000\n00000 0 0 0 0 0000000\n11101 1 1 1 0000000\n00000 0 0 0 0 0000000\n00010 1 1 1 1 0000000\n00000 1 0 0 0 0000000\n01011 1 1 1 0000000\n00000 1 1 0 0 0000000\n11111 1 1 0 0 0000000\n00000 1 1 0 0 0000000\n... רשומות נוספות ...",
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "כמה כניסות יש בטבלת הדפים המלאה? מה גודל הטבלה המלאה בבתים?\nמספר כניסות:\nגודל הטבלה:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "התהליך הנתון ניגש לכתובת 0x1960 (הכתובת 1960 בבסיס 16.\nהאם תתרחש פסיקת דף? אם כן, יש להסביר מדוע, אחרת יש לפרט את הכתובת הפיזית אליה ניגש.\nכתובת פיזית:\nנימוק:\nתתרחש פסיקת דף",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "נתון שעבור כל הדפים שאינם מופיעים בטבלה מתקיים 0=V=1,P, והתהליך ניגש לדפים הבאים (משמאל לימין, כלומר קודם 2 ואז 7 וכן הלאלה):\n2, 7, 8, 4, 15, 16, 17, 2, 4\nכמה page faults יתרחשו במידה ואלגוריתם החלפת הדפים הוא LRU?\nיש להניח שכל page fault מפנה רק את המסגרות בשימוש ע\"י התהליך הנתון, וטוען רק אליהן.\npage faults מספר\nנימוק:\nלא ניתן לדעת",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "שאלה 6\n1. נתון גודל דף 1KB לכן ההיסט הוא 10 ביטים, לפי הטבלה ה-PFN הוא ביטים, כלומר שהזיכרון הפיזי מורכב מ-15 ביטים – 32KB. לפי הנתון שהזיכרון הוירטואלי כפול מהפיזי נקבל 64KB.\n2. ההיסט הוא 10 ביטים (מתוך 16) לכן נפריד למספר דף (6 ביטים) והיסט. מספר הדף שמתקבל הוא 110 בבינארי כלומר דף 6. לפי הטבלה דף 6 קיים בזיכרון במסגרת 11, לכן נתרגם מספר דף למספר מסגרת (ההיסט נשאר זהה) ונקבל את הכתובת הפיזית 0101100000 01011 כתובת פיזית 2D60.\n3. ב-4 הגישות הראשונות ניגשים לדפים עבורם 1=P לכן אין page fault\n3 הגישות הבאות הן לדפים 15,16,17, שלא בטבלה ולפי הנתון בשאלה 0=P עבורם לכן 3 הגישות יגרמו page fault. בהתחלה היו 6 מסגרות בשימוש, בעקבות 3 הגישות האלו יפונו 3 מהן שהן המסגרות המכילות את 2 הדפים שלא ניגשנו אליהם עדיין והמסגרת המכילה את דף 2 (אלו הגישות הכי רחוקות בעבר לפי LRU).\nבגישה הנוסף לדף 2 נקבל page fault נוסף ונפנה את המסגרת שתופס דף 7. הגישה האחרונה לדף 4 לא תגרום page fault כי הדף עדיין בזיכרון.\nסה\"כ page faults 4"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Semaphores",
        "Concurrency",
        "Atomic Operations",
        "Producer-Consumer"
      ],
      "content": {
        "text": "נתונה מערכת המשתמשת בפתרון של בעיית יצרן-צרכן. במערכת מוגדר טיפוס מיוחד Item ובנוסף מוגדרים 3 סמפורים:\nmutex, full, empty. הקבוע N מגדיר את כמות המדפים במחסן.\nכמו-כן נתונות הפונקציות הבאות:\nItem produce_item() – מייצרת מוצר חדש, ובטוחה לשימוש במקביל.\nvoid consume_item(Item) – צורכת מוצר קיים, ובטוחה לשימוש במקביל (על מוצרים שונים). אסור לקרוא לפונקציה זו יותר מפעם אחת לאותו מוצר.\nvoid add_item(Item) – מקבלת מוצר (שאינו קיים במחסן) ומוסיפה אותו אל המחסן. פונקציה זו אינה בטוחה לשימוש במקביל (כלומר, אסור לקרוא לה בו-זמנית מחוטים שונים או עם פונקציות אחרות הניגשות למחסן).\nItem del_item() – מוציאה מוצר אחד מהמחסן ומחזירה אותו. פונקציה זו אינה בטוחה לשימוש במקביל.\nשימו לב: פונקציות אלו נתונות ויש להשתמש בהן (אין צורך לממש אותן).\nיש לתאר בקצרה ובבירור כל פתרון ולכתוב קוד ברור.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "ממשו את הפתרון של בעיית יצרן-צרכן כפי שנלמד בכיתה, עם שימוש ב-3 הסמפורים שהוגדרו בלבד (ללא פעולות אטומיות או אובייקטי סנכרון אחרים):\nvoid produce()\nvoid consume()\nמייצרת מוצר יחיד ומוסיפה אותו אל המחסן.\nמוציאה מוצר יחיד מהמחסן וצורכת אותו.\nיש לציין גם את ערכי האתחול של 3 הסמפורים.\nערכי אתחול:\nempty=__\nfull=__\nmutex=__",
          "code_snippet": "void produce() {\n\n}\nvoid consume() {\n\n}",
          "options": null
        },
        {
          "id": "7.2",
          "text": "במערכת הנ\"ל עלתה דרישה למימוש פעולה חדשה אשר מייצרת ומוסיפה אל המחסן כמה מוצרים בבת אחת (באופן אטומי, כלומר כולם מתווספים בבת אחת). להלן הקוד שנכתב למימוש הפעולה:\n\nשימו לב: עבור הארגומנט א מובטח שמתקיים x >= N.\nהקוד המתואר לפעולה produce_several אינו תקין. תארו מה הבעיה וכיצד היא יכולה להתרחש.\nהבעיה:\nנימוק:",
          "code_snippet": "1 void produce_several(int x) {\n2 Item arr[x]; // assume this is allowed\n3 for (int i = 0; i < x; ++i)\n4 arr[i] = produce_item();\n5 for (int i = 0; i < x; ++i)\n6 sem_wait(&empty);\n7 sem_wait(&mutex);\n8 for (int i = 0; i < x; ++i)\n9 add_item(arr[i]);\n10 sem_post(&mutex);\n11 for (int i = 0; i < x; ++i)\n12 sem_post(&full);\n13 }",
          "options": null
        },
        {
          "id": "7.3",
          "text": "הקריאה sem_trywait מקבלת כארגומנט סמפור ומנסה להוריד את ערכו ב-1. אם ערך הסמפור גדול מ-0, הקריאה מורידה את ערכו ב-1 באופן אטומי ומחזירה 0, אחרת הקריאה חוזרת מיד ללא המתנה ומחזירה 1- (בניגוד ל-sem_wait אשר ממתינה עד אשר ניתן להוריד את ערך הסמפור).\nתקנו את הפעולה produce_several כך שתעבוד באופן תקין.\nיש לשנות את שורות 5-6 בלבד. ניתן להיעזר בקריאה sem_trywait, אך ללא פעולות אטומיות או אובייקטי סנכרון נוספים.\nתיאור הפתרון:\n(במקום שורות 5-6)",
          "code_snippet": "void produce_several(int x) {\n\n}",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "שאלה 7\n.1\nvoid produce() {\nItem item = produce_item();\nsem_wait(&empty);\nsem_wait(&mutex);\nadd_item(item);\nsem_post(&mutex);\nsem_post(&full);\n}\nvoid consume() {\nsem_wait(&full);\nsem_wait(&mutex);\nItem item = del_item();\nsem_post(&mutex);\nsem_post(&full);\nconsume_item(item);\n}\n(Initial values: empty = N, full = 0, mutex = 1)\n2. הבעיה: קיפאון.\nאם יש מקום אחד פנוי במחסן וקוראים לפעולה עם 2=x אז הפעולה חסומה, ופעולת produce אחרת גם תהיה חסומה מאחר ש-produce_several כבר הקצתה לעצמה את המקום הפנוי היחיד במחסן (בלי להשלים את הביצוע).\n.3\nvoid produce_several (int x) {\nItem arr[x]; // assume this is allowed\nfor (int i = 0; i < x; ++i)\narr[i] = produce_item();\n// for livelock: sem_wait(&mutex);\nfor (int i = 0; i < x; ++i)\nif (sem_trywait(&empty)) { // if failed\nfor (int k = 0; k < i; ++k)\nsem_post(&empty);\ni=-1;\n// for livelock: sem_post(&mutex);\n// for livelock: sem_wait(&mutex);\n}\n// for livelock: sem_post(&mutex);\nsem_wait(&mutex);\nfor (int i = 0; i < x; ++i)\nadd_item(arr[i]);\nsem_post(&mutex);\nfor (int i = 0; i < x; ++i)\nsem_post(&full);\n}"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems"
      ],
      "content": {
        "text": "נתון דיסק קשיח עם הנתונים הבאים:\nגודל סקטור: 512B.\nגודל בלוק: 8 סקטורים.\n8 משטחים (4 platters דו-צדדיים).\nצפיפות הסקטורים בכל רצועה היא בהתאם ל-2 אזורים: A, B. בכל אזור יש 200 רצועות.\nבאזור A יש 1024 בלוקים לרצועה, באזור B יש 256 בלוקים לרצועה.\nשימו לב: נתונים אלו רלוונטיים לכל סעיפי השאלה. הנתונים הכתובים בסעיפים עצמם מתווספים לנתונים אלו אך ספציפיים לאותו סעיף ואינם תקפים לשאר הסעיפים.\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "מה שטח האחסון הכולל בדיסק (כמה בתים של נתונים ניתן לאחסן בדיסק כולו)?\nשטח אחסון:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "משתמש הריץ מספר בדיקות על הדיסק לבדיקת קצב ההעברה של הדיסק:\nפעולות קריאה של 2MB רצופים מתבצעות בזמן ממוצע של 50ms.\nפעולות קריאה של 1MB רצופים מתבצעות בזמן ממוצע של 40ms.\nמה קצב ההעברה המקסימלי (transfer rate) של הדיסק?\nקצב העברה: MB/s\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "נניח שנוספו הנתונים הבאים על הדיסק הקשיח:\nמהירות סיבוב:6,000RPM\nזמן ה-seek הממוצע הוא 16ms, ובין שתי רצועות סמוכות הוא 1ms.\nנתון שיפור track skew: בקריאת סקטורים עוקבים ברצועות סמוכות אין המתנה לסיבוב.\nמהירות העברת המידע בדיסק (transfer rate) תוכננה כך שנוכל להעביר את המידע ברצועה אחת ב-A תוך כדי זמן סיבוב אחד בדיוק.\nמשתמש ביצע פעולה המתורגמת לקריאה של 50 רצועות שלמות ורצופות באזור B. מה קצב ההעברה בפועל?\nקצב בפועל: MB/s\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "שאלה 8\n1. באזור A – 1024 בלוקים כפול 200 רצועות כפול 8 משטחים כפול 4KB לבלוק.\nבאזורB – 256 בלוקים כפול 200 רצועות כפול 8 משטחים כפול 4KB לבלוק.\nסה\"כ נקבל: 8000MB = (1024+256)*200*8*4096 /1024/1024.\n2. נסתכל על ההפרש בין הפעולות, ונגלה כי קצב ההעברה המקסימלי של הדיסק הוא 1MB ב-10ms.\nנמיר לשניות ונקבל קצב העברה של 100MB/s\n3. זמן הסיבוב הוא 10ms כלומר שזמן ההמתנה לסיבוב הוא 5ms.\nלחישוב קצב ההעברה של הדיסק: ברצועה אחת של A יש 4MB = 1024*4KB של נתונים. כלומר שקצב ההעברה הוא 4MB בסיבוב (10ms), אחרי המרה לשניות נקבל קצב העברה מקסימלי של MB/s 400.\nברצועה אחת של B יש 1MB = 256*4KB של נתונים, כלומר שהפעולה הנדרשת היא 50MB, וזמן ההעברה שלה הוא שמינית שניה (בשנייה מעבירים 400MB), כלומר 125ms, לזה נדרש להוסיף את זמני המיקום השונים.\nזמן ה-seek הוא 16ms אבל צריך לעבור בין 49 רצועות נוספות עם 1ms לכל מעבר – סה\"כ 65ms.\nהזמן הכולל של הפעולה: seek 65ms + wait 5ms + transfer 125ms = 195ms.\nכלומר, לוקח 195ms להעביר 50MB, נעביר ליחידות המתאימות ונקבל קצב בפועל של 256.4MB/s\nיש 2 דרכים נוספות לחשב את הזמנים הנדרשים בשאלה:\nΟ אם הרצועות שקוראים באזור B מתפזרות בין המשטחים השונים, נצטרך לעבור בין רצועות רק 6 פעמים במקום 49 ולכן זמן ה-seek הכולל יהיה 22ms.\nΟ בשאלה נתון קצב ההעברה של הדיסק כולו לפי חישוב באזור A. מאחר שיש באזור B פחות נתונים ניתן לדייק יותר ולחשב קצב ההעברה לפי זמן הסיבוב באזור B (כלומר: העברה של 1MB ב-10ms, נקבל קצב העברה מקסימלי באזור B של 100MB/s במקום 400, ולכן זמן ההעברה יהיה 500ms במקום 125ms)."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 9,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Security"
      ],
      "content": {
        "text": "נתונה מערכת עם מנגנון 10-RAID עם 3 עותקים (כלומר – 1-RAID עם mirroring level של 3) בו זמינים 9 דיסקים קשיחים (ממוספרים 1-9), שלכל אחד מהם נפח (שטח אחסון) של 8TB.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "9.1",
          "text": "מה שטח האסון הכולל הזמין למשתמש?\nשטח אחסון:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "9.2",
          "text": "מה המספר המקסימלי של דיסקים שיכולים להתקלקל כך שלא נאבד שום מידע?\nמספר מקסימלי:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "9.3",
          "text": "מה המספר המינימלי של דיסקים שנדרש שיתקלקלו כך שנאבד שום מידע?\nמספר מינימלי:\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "שאלה 9\n1. זמינים 9 דיסקים של 8TB כל אחד, אך כל נתון משוכפל 3 פעמים –\n9*8TB/3 = 24TB\n2. במערך יש 3 קבוצות 0-RAID, בכל אחת יש 3 דיסקים משוכפלים (1-RAID).\nאם יתקלקלו 2 דיסקים מכל קבוצה לא נאבד מידע, אך בדיסק השביעי בהכרח נאבד מידע, כלומר מקסימום 6 דיסקים.\n3. רק כשנאבד את כל הדיסקים מאותה קבוצת מידע נאבד מידע, כלומר מינימום 3 דיסקים."
      },
      "difficulty_estimation": "Medium"
    }
  ]
}