{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2024",
    "semester": "Semester A",
    "moed": "Moed B",
    "exam_date": "22.03.2024",
    "source_file": "os24AB.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Virtual Memory",
        "Memory Management",
        "Paging"
      ],
      "content": {
        "text": "מה הוא ה-swap space?",
        "code_snippet": null,
        "options": [
          "א. מקום בדיסק המשמש לשמירת קבצים.",
          "ב. מקום בזיכרון הפיזי המשמש להחלפת תהליכים.",
          "ג. מקום במחסנית (stack) המשמש להחלפת משתנים.",
          "ד. מקום בקרנל המשמש כזיכרון מטמון לתרגום כתובות וירטואליות.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. כפי שנלמד, אזור ההחלפה (swap space) הוא אזור בדיסק המשמש לאחסון זיכרון של תהליכים."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Paging",
        "Virtual Memory",
        "Memory Management"
      ],
      "content": {
        "text": "אחת מהבעיות של טבלאות דפדוף לינאריות היא כמות הזיכרון בו משתמשות הטבלאות.\nמה יכול לעזור להתמודד עם בעיה זו?",
        "code_snippet": null,
        "options": [
          "א. TLB",
          "ב. הגדלת גודל הדף.",
          "ג. זיכרון משני (HDD).",
          "ד. זיכרון מטמון (cache).",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ב",
        "explanation": "ב'. אם נגדיל את גודל הדף יהיו פחות רשומות בטבלת הדפים, ולכן כל טבלה תשתמש בפחות זיכרון."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Mutexes",
        "Threads"
      ],
      "content": {
        "text": "נתונה הטענה: תמיד נעדיף מנעול שלא מבצע spinning.",
        "code_snippet": null,
        "options": [
          "א. הטענה נכונה.",
          "ב. הטענה נכונה רק במחשב עם מעבד יחיד.",
          "ג. הטענה נכונה רק כאשר במחשב יש מספר מעבדים.",
          "ד. הטענה לא נכונה: תמיד נעדיף מנעול שכן מבצע spinning.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ב",
        "explanation": "ב'. במחשב עם מעבד יחיד ה-spinning על מנעול תפוס הוא תמיד מיותר. הטענה לא תמיד נכונה עם יותר מעבדים, לדוגמה אם הקטע הקריטי קצר מאוד אז יתכן שעדיף להמתין."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Threads",
        "Concurrency",
        "Synchronization"
      ],
      "content": {
        "text": "להלן קוד עבור שני חוטי חישוב (threads) שירוצו בו זמנית (concurrently) במערכת עם מעבד יחיד, בה כל המשתנים משותפים לשני חוטי החישוב. נתון שהמשתנה x מאותחל ל-0.\nהקוד רלוונטי ל-2 השאלות הבאות (שאלות 4-5):\n\nמהו הערך המקסימלי עבור x בסיום ריצת שני חוטי החישוב?",
        "code_snippet": "Thread 1\nfor (j=1; j<=4; ++j)\nx = x + 1;\n\nThread 2\nfor (i=1; i<=6; ++i)\nx = x + 1;",
        "options": [
          "א. 5",
          "ב. 8",
          "ג. 9",
          "ד. 10",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ד",
        "explanation": "ד'. הערך המקסימלי מתקבל כאשר 2 החוטים מקדמים את המשתנה ללא הפרעות, מספר כולל של 10 פעמים."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Threads",
        "Concurrency",
        "Synchronization",
        "Atomic Operations"
      ],
      "content": {
        "text": "מהו הערך המינימלי עבור x בסיום ריצת שני חוטי החישוב?",
        "code_snippet": null,
        "options": [
          "א. 1",
          "ב. 2",
          "ג. 4",
          "ד. 6",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. הערך המינימלי בקוד מהסוג הזה הוא תמיד 2 (הסבר מלא במבחן os23AB)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Virtual Memory",
        "Paging",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה מערכת בה כתובת וירטואלית מכילה 32 ביטים, כתובת פיזית מכילה 40 ביטים, וגודל דף הוא 4KB. כל כניסה בטבלת הדפים תופסת 4 בתים.\nבמערכת זו נתון תהליך אשר משתמש ב-128KB של נתונים החל מכתובת 0, כך שכל גישה לכתובות גדולות או שוות ל-128K תגרום לשגיאה.\nשימו לב: נתונים אלו רלוונטיים לכל הסעיפים א'-ג'. הנתונים הכתובים בסעיפים עצמם מתווספים לנתונים אלו אך ספציפיים לאותו סעיף ואינם תקפים לשאר הסעיפים.\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "נתון שהתהליך משתמש בטבלת דפים לינארית. כמה זיכרון בבתים תתפוס טבלת הדפים של התהליך, ומהו מספר הכניסות בטבלה שהן valid?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "נתון שהתהליך משתמש בטבלת דפים היררכית, כאשר גודל כל חלק/טבלה בטבלת הדפים הוא דף. כמה רמות יהיו בטבלת הדפים, כמה זיכרון בבתים יתפסו טבלאות הדפים של התהליך (הסכום הכולל בכל רמות יחד), ומה מספר הכניסות בטבלאות שהן valid (הסכום הכולל בכל הרמות יחד?)",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "נתון תהליך אחר אשר משתמש בטבלת דפים היררכית כאשר גודל כל חלק/טבלה בטבלת הדפים הוא דף, ולהלן פירוט הכתובות בזיכרון בהן משתמש התהליך:\n- code segment בגודל 48KB המתחיל בכתובת 0x1000000.\n- data segment בגודל 600KB המתחיל בכתובת 0x8000000.\n- stack segment בגודל 64KB המתחיל בכתובת 0xF0000000 (וגדל לכתובות הגבוהות יותר).\nכל גישה לכתובת אחרת, שאינה בסגמנטים אלו, תגרום לשגיאה.\nתזכורת: התחילית 0x מציינת מספר בבסיס 16.\nכמה זיכרון בבתים יתפסו טבלאות הדפים של התהליך (הסכום הכולל בכל הרמות יחד), ומה מספר הכניסות בטבלאות שהן valid (הסכום הכולל בכל הרמות יחד)?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. גודל דף הוא 4KB כלומר שיש 12 ביטים להיסט, מה שמשאיר 20 ביטים ל-VPN בכתובת הוירטואלית. לכן לכל תהליך יש 2^20 דפים בזיכרון הוירטואלי.\nבטבלה הלינארית יש 2^20 רשומות שכל אחת בגודל 4 בתים, לכן סה\"כ 4MB=2^22.\nהתהליך משתמש ב-128KB זיכרון החל מכתובת 0, לכן אלו בדיוק 128/4=32 דפים, לכן 32 כניסות יהיו valid.\n\n2. כל דף בגודל 4KB וכל כניסה בטבלה היא 4 בתים, לכן יש 1024 כניסות בכל דף של הטבלה – נדרש לכך 10 ביטים. כמו בסעיף א' יש 20 ביטים ל-VPN כלומר 2 רמות לטבלת דפים היררכית (10+10).\nכמו בסעיף א' התהליך עדיין משתמש רק ב-32 דפים החל מדף 0, עם 1024 כניסות בכל דף כל 32 הכניסות עבור דפים אלו נכנסות בטבלה הראשונה, לכן גודל הטבלה הוא 2 דפים = 8KB.\nברמה העליונה משתמשים רק בכניסה אחת, ברמה התחתונה יש את המיפויים לדפים עצמם עם 32 כניסות – לכן סה\"כ 33 כניסות יהיו valid.\n\n3. כמו בסעיף הקודם טבלת הדפים ב-2 רמות.\nלכל 48K הכתובות בסגמנט ה-code יש את אותם 10 ביטים שמאליים, כלומר כולן נכנסות באותה טבלה ברמה התחתונה. בטבלה זו יהיו 48K/4K=12 רשומות valid.\nלכל 600K הכתובות בסגמנט ה-data יש את אותם 10 ביטים שמאליים ששונים מאלו של ה-code, לכן כולן באותה טבלה (נפרדת מהקודמת), יהיו בה 600K/4K=150 רשומות valid.\nלכל 64K הכתובות ב-stack גם אותם 10 ביטים שמאליים ששונים מה-code,data, לכן כולן באותה טבלה (נפרדת מ-2 הקודמות) ויהיו בה 64K/4K=16 רשומות valid.\nסה\"כ נתפוס דף אחד עבור הרמה העליונה ועוד 3 דפים עבור הרמה התחתונה – גודל הטבלה 4 דפים או 16KB.\nברמה העליונה יהיו 3 כניסות שהן valid לכל אחת מתת הטבלאות, ויחד עם הרמות התחתונות סה\"כ 181 כניסות valid."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Concurrency",
        "Synchronization",
        "Mutexes",
        "Condition Variables",
        "Atomic Operations"
      ],
      "content": {
        "text": "בסניף בנק מקומי הוחלט לפתח ארנק דיגיטלי לצורך מחשוב העברת הכספים בין חשבונות. הארנק הדיגיטלי מחזיק את סכום הכסף של כל לקוח בסניף, ומאפשר העברת כספים בין לקוח ללקוח.\nנתון כי יש N לקוחות (N קבוע וידוע מראש), והמערך הגלובלי balance המוגדר מטה מייצג את היתרה של כל הלקוחות, כך שתא 1 במערך מכיל את היתרה (סכום הכסף) של לקוח 1.\nלקוחות בארנק הדיגיטלי אינם יכולים להיכנס למינוס, כלומר שהארנק צריך לוודא שהמאזן של כל לקוח לעולם אינו שלילי.\nהארנק הדיגיטלי תומך בפעולות הבאות:\n- int getBalance(int c)\nמחזירה את היתרה הנוכחית של לקוח c.\n- int transfer (int c1, int c2, int amount)\nמעבירה את הסכום amount מהלקוח c1 אל הלקוח c2. פעולה זו היא blocking, כלומר במידה ואין ללקוח c1 מספיק כסף בחשבון הפעולה תחסום את החוט הקורא עד שיהיה ניתן לבצע את הפעולה בהצלחה. הפעולה מחזירה את היתרה של הלקוח c1 מיד לאחר ביצוע ההעברה.\nשימו לב: מובטח כי כל הפרמטרים תקינים (מזהי לקוחות בין 0 ל-1-N, סכומים גדולים מ-0). עליכם לממש את שתי הפעולות לעיל כאשר כל פעולה צריכה להתבצע באופן אטומי. בנוסף, חוטים שונים יכולים לקרוא לפעולות במקביל ובכל זמן וכמובן שעל הפתרון להיות יעיל ככל האפשר.\nמגבלות: לצורך הפתרון ניתן להשתמש במנעולים ומשתני תנאי בלבד (כלומר, לא ניתן להשתמש בסמפורים, פעולות מעבד אטומיות, או אובייקטי סנכרון אחרים מלבד מנעולים ומשתני תנאי).\nיש לתאר בקצרה ובבירור את הפתרון ולכתוב קוד ברור.\nתיאור הפתרון:\nמשתנים גלובליים (יש לכתוב ערכי אתחול בהערה):",
        "code_snippet": "#define N ??\nint balance[N]; // balance for all clients\n\nint getBalance(int c) {\n}\nint transfer (int c1, int c2, int amount) {\n}"
      },
      "sub_questions": null,
      "points": 25,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "#define N ??\nint balance[N]; // balance for all clients\npthread_mutex_t locks[N]; // lock for each client\n\nint getBalance(int c) {\n    return balance[c]; // no need to grab lock\n}\n\nint transfer (int c1, int c2, int amount) {\n    int res = -1;\n    // spinning, waiting for enough balance for c1\n    while (res == -1) {\n        // global ordering is needed to prevent deadlock\n        pthread_mutex_lock(&locks[MIN(c1,c2)]);\n        pthread_mutex_lock(&locks[MAX(c1,c2)]);\n\n        if (balance[c1] >= amount) {\n            balance[c1] -= amount;\n            balance[c2] += amount;\n            res = balance[c1];\n        }\n        pthread_mutex_unlock(&locks[c1]);\n        pthread_mutex_unlock(&locks[c2]);\n    }\n    return res;\n}"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Security"
      ],
      "content": {
        "text": "במערכת קבצים VSFS המשתמשת ב-journaling כפי שנלמד (כולל metadata journaling) יש בעיה: בעדכון נתונים של בלוק DATA קיים, קריסה בתרחישים מסוימים עדיין עלולה לגרום לשיבוש מערכת הקבצים.\nלהלן רצף הפעולות על הדיסק הנדרש למחיקת קובץ מתיקייה, כאשר לקובץ יש לפחות קישור אחד נוסף (hard-link), לתיקייה יש בלוק DATA יחיד, ומספרי ה-inode של התיקייה והקובץ ידועים מראש:\n1. קריאת בלוק ה-inode המכיל את ה-inode של התיקייה\n2. קריאת בלוק ה-inode המכיל את ה-inode של הקובץ\n3. קריאת בלוק ה-DATA הראשון (והיחיד) של התיקייה\n4. כתיבת טרנזקציה ללוג עם inode + TxB התיקייה + inode קובץ, ללא TxE\n5. כתיבה לבלוק ה-DATA של התיקייה (עדכון ללא הרשומה של הקובץ)\n6. fsync\n7. כתיבת TxE לטרנזקציה\n8. fsync\n9. עדכון ה-inode של התיקייה (כתיבה לבלוק המכיל את ה-inode של התיקייה)\n10. עדכון ה-inode של הקובץ (כתיבה לבלוק המכיל אותו)",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "באיזה שלב תיתכן קריסה שתגרום לבעיה במערכת הקבצים? יש לציין את השלב 1-10, ולאחר מכן לצרף הסבר ברור ותמציתי מדוע קריסה אחרי שלב זה היא בעייתית.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "הדגימו שני תרחישים של כתיבה לקובץ אשר לא גורמים להוספת בלוק DATA חדש אל הקובץ, כאשר באחד מהם תיתכן קריסה שתגרום לבעיה במערכת הקבצים ובשני לא תיתכן קריסה בשום שלב שתגרום לבעיה במערכת הקבצים.\nאין צורף לתאר את רצף הפעולות המלא לכל תרחיש, אלא רק לתאר את התרחיש והיכן המקרה הבעייתי או מדוע אף קריסה לא תגרום לבעיה.\nמבין הגישות בסעיף הקודם (שאלה 8.1), מה הגישה הראשונה אחריה נוכל להבטיח בוודאות שהפעולה תתבצע בהצלחה גם אם המערכת תקרוס? יש לנמק את התשובה.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "הציעו פתרון לבעיה. הפתרון עדיין צריך לבצע metadata journaling, כלומר שה-DATA אינו נכתב ללוג אלא נכתב פעם אחת בלבד לכל הפעולה (למיקומו הסופי בדיסק), אך קריסה בכל שלב של כל פעולה לא תביא לבעיה במערכת הקבצים.\nיש לתאר את הפתרון בקצרה ובבירור, להסביר מה הוא כולל ואיזה פעולות נוספות על הדיסק הוא גורר (או עלול לגרור), ולתת הסבר תמציתי מדוע הוא מטפל בבעיה.",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. אחרי שלב 5 או 6, אם נקרוס התיקייה לא תכיל את הקישור (hard-link) לקובץ אך זמן העדכון וגודל התיקייה לא השתנה ומס' הקישורים ב-inode של הקובץ לא עודכן.\n\n2. תרחיש בעייתי: שכתוב/עדכון נתונים קיימים בקובץ. אם נקרוס לאחר שכתוב הנתונים ולפני סגירת הטרנזקציה, נתוני הקובץ שונו אך ה-inode של הקובץ לא עודכן (עם זמן שינוי אחרון).\nתרחיש לא בעייתי: הוספת נתונים לקובץ (בין אם נדרש בלוק DATA חדש ובין שאינם גוררים בלוק DATA חדש). אם נקרוס לפני סגירת הטרנזקציה נתעלם מהנתונים שנוספו (כי ה-inode לא יעודכן ולכן גודל הקובץ ו/או המצביעים לא השתנו ונתעלם מהנתונים שנוספו), אם נקרוס אחרי סגירת הטרנזקציה אין בעיה.\n\n3. בכל פעם שמעדכנים נתונים בבלוק קיים לא נכתוב אל הבלוק הקיים אלא נקצה בלוק חדש ונכתוב אליו את הנתונים המעודכנים, וכחלק מהטרנזקציה נתפוס בלוק חדש ונשחרר את הקיים. עדכון כזה עלול לגרור עדכונים של בלוקים נוספים של DATA – בלוקים של מצביעים, אותם נעדכן באותו אופן."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 9,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems"
      ],
      "content": {
        "text": "נתונה מערכת עם מנגנון 4-RAID, גודל chunk של בלוק אחד ו-4 דיסקים קשיחים (ממוספרים 1-4), שכל אחד מהם בעל הנתונים הבאים:\n- מהירות סיבוב: 7500 RPM\n- זמן seek ממוצע: 10ms\n- בכל רצועה (track) בדיסק יש 8 בלוקים\n- מהירות העברת המידע תוכננה כך שנוכל להעביר את המידע ברצועה אחת תוך כדי זמן סיבוב אחד בדיוק.\nמשתמש ביצע פעולת כתיבה אחת לבלוקים הלוגיים 100-102 (הבלוקים הלוגיים ממוספרים החל מ-0), ונתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nמהו הזמן הקצר ביותר בו הפעולה יכולה להתבצע?\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": null,
      "points": 10,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "זמן הסיבוב הוא 8ms, עם 8 בלוקים ברצועה זמן הפעולה (קריאה/כתיבה) לבלוק הוא 1ms.\nנניח שדיסק ה-parity הוא דיסק 4 (זה לא משנה לתוצאה).\nבלוקים לוגיים 100-101 נמצאים באותו stripe בדיסקים פיזיים 2-3, ובלוק לוגי 102 נמצא ב-stripe הבא בדיסק פיזי 1.\nלביצוע הפעולה נדרש לקרוא בלוק אחד מכל דיסק 1-3 ואז לכתוב לאותו בלוק. בנוסף נדרש לקרוא 2 בלוקים מדיסק הזוגיות (אחד בכל stripe) ואז לכתוב לשניהם. דיסק הזוגיות הוא צוואר הבקבוק ולכן יכתיב את הביצועים.\nבמקרה האידיאלי הראש הקורא-כותב יהיה בדיוק במקום בתחילת הפעולה ולא יהיה בכלל זמן seek או המתנה לסיבוב.\nבדיסקים 1-3 לקרוא בלוק 1 לוקח 1ms, להמתין לסיבוב עד לאותו בלוק זה 7ms (דילוג על 7 הבלוקים הנותרים ברצועה שזה גם השלמת זמן הסיבוב שהוא כזכור 8ms), ואז כתיבה לאותו בלוק עוד 1ms – סה\"כ 9 מילישניות.\nבדיסק הזוגיות נדרש לקרוא 2 בלוקים רצופים ב-2ms, להמתין לסיבוב 6ms (דילוג על 6 הבלוקים הנותרים ברצועה), ואז כתיבה לאותם 2 בלוקים עוד 2ms – סה\"כ 10 מילישניות.\nמאחר שכל הדיסקים יכולים לפעול במקביל, הזמן הכולל המינימלי הוא 10ms."
      },
      "difficulty_estimation": "Hard"
    }
  ]
}