{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2023",
    "semester": "Semester A",
    "moed": "Moed A",
    "exam_date": "30.01.2023",
    "source_file": "os23AA.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Semaphores"
      ],
      "content": {
        "text": "כל שימוש במשתנה תנאי (condition variable) אפשר להחליף בשימוש בסמפור.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. כפי שנלמד, לא ניתן לממש משתנה תנאי באמצעות סמפור."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Memory Management",
        "Concurrency",
        "Atomic Operations"
      ],
      "content": {
        "text": "בגישה לזיכרון משותף במעבדים עם write-through cache, אין הבדל בביצועים בין פעולות קריאה לפעולות כתיבה.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. בכתיבה תמיד נשלח עדכון על גבי ה-bus, אך בקריאה יתכן שהפעולה תתבצע מקומית ב-cache של המעבד."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Virtual Memory",
        "Paging",
        "Memory Management"
      ],
      "content": {
        "text": "אם הזיכרון המשני מלא לחלוטין, יתכן שעדיין נוכל לטפל במקרה של page fault.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. אם יש מסגרת פנויה לא נדרש page out (ומקום בדיסק), וגם אם יש מסגרת לפינוי שכבר קיימת בדיסק (0=dirty)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Processes",
        "System Calls",
        "Signals"
      ],
      "content": {
        "text": "תהליך שהסתיים נמחק מעץ התהליכים רק כאשר תהליך האב שלו (לפי העץ) מבצע קריאה ל-wait.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. אם תהליך האב מתעלם מסיגנל SIGCHLD, תהליך הבן נמחק מיד כשמסתיים ללא מענה. (הסבר שגוי: אם תהליך האב מסתיים תהליך הבן נמחק מעץ התהליכים, אך זה קורה עקב wait של init – תהליך האב החדש)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "I/O",
        "File Systems",
        "Disk Scheduling"
      ],
      "content": {
        "text": "בכונן SSD, פעולות כתיבה מהירות יותר מפעולות קריאה.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. כתיבה אקראית מהירה יותר מקריאה סדרתית בגלל מבנה הלוג שהופך כתיבות אקראיות לסדרתיות, אך כתיבה סדרתית עדיין איטית יותר מקריאה סדרתית."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Scheduling",
        "CPU Scheduling"
      ],
      "content": {
        "text": "בתזמון תהליכים, הרעבה מוגדרת כמצב בו ייתכן שתהליך מסוים לעולם לא יסתיים, ואפקט השיירה מוגדר במצב בו ייתכן שתהליכים קצרים יתעכבו זמן רב עקב תהליך ארוך שתופס את המעבד.\nעבור תזמון Stride ניתן להניח שתהליך חדש מקבל ערך pass שהוא המינימלי מבין כל התהליכים במערכת.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "עבור כל אחד מאלגוריתמי התזמון הבאים, האם מתאפשרת הרעבה? יש לתת דוגמה קצרה היכן שכן, או הוכחה היכן שלא.",
          "code_snippet": null,
          "options": [
            "FCFS",
            "SJF",
            "SRTF",
            "RR",
            "MLFQ",
            "Lottery",
            "Stride"
          ]
        },
        {
          "id": "6.2",
          "text": "עבור כל אחד מאלגוריתמי התזמון הבאים, האם ייתכן אפקט השיירה? יש לתת דוגמה קצרה היכן שכן, או הוכחה היכן שלא. כמה תהליכים נוצרו במהלך ריצה תקינה של התוכנית, כולל התהליך הראשי?",
          "code_snippet": null,
          "options": [
            "FCFS",
            "SJF",
            "SRTF",
            "RR",
            "MLFQ",
            "Lottery",
            "Stride"
          ]
        },
        {
          "id": "6.3",
          "text": "סטודנט כתב תוכנית בה כתיבות לקבצים נאגרות בחוצץ (buffer) בזיכרון ונכתבות בבת אחת ובאופן רציף כאשר הסגמנט מתמלא. כשהריץ את התוכנית, בתחילה הקוד התנהג כצפוי והביצועים השתפרו ככל שגודל הסגמנט היה גדול יותר, עד גודל מסוים ממנו ביצועי התוכנית הדרדרו משמעותית (למרות שביצועי הכתיבה לדיסק המשיכו להשתפר).\nמה הסיבה לכך שביצועי התוכנית הדרדרו, למרות שפעולות הכתיבה לדיסק המשיכו להשתפר?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.4",
          "text": "הציעו דרך לטפל בבעיה בה נתקל הסטודנט בסעיף הקודם.",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "6.1:\nFCFS: לא. תהליכים מטופלים לפי הסדר, לכן בהכרח יגיע תורו של כל תהליך. (התייחסות לתהליכים בלולאה אינסופית לא נכונה, כי אין כזה דבר ב-FCFS)\nSJF: כן. תהליך ארוך יתעכב אחרי תהליכים קצרים שעלולים להגיע כל הזמן. כמו SJF\nSRTF: כן. כמו SJF\nRR: לא. תמיד יגיע תורו של כל תהליך לרוץ, בהתאם לסדר התור.\nMLFQ: לא. בזכות ה-priority boost, כל תהליך יקבל זמן ריצה בסופו של דבר.\nLottery: כן. אם תהליך מסוים לא יוגרל שוב ושוב.\nStride: כן. אם תהליכים חדשים מגיעים כל הזמן, ה-pass שלהם קטן מכל הקיימים.\n\n6.2:\nFCFS: כן. תהליכים מטופלים לפי הסדר, לכן תהליך ארוך שיגיע ראשון יגרום לתהליכים קצרים להתעכב אחריו.\nSJF: כן. אם תהליכים קצרים מגיעים רגע אחרי תהליך ארוך, הם מתעכבים אחריו.\nSRTF: לא. תהליכים קצרים תמיד יטופלו לפני ארוכים.\nRR: לא. כל תהליך יקבל קוונטה קבועה לפי סדר התור, בלי קשר לזמן הריצה שלו.\nMLFQ: לא. כמו RR, בנוסף לכך גם תהליך ארוך ירד בעדיפות ויקבל פחות זמן מעבד עם הזמן.\nLottery: כן. תהליך ארוך עם עדיפות גבוהה עלול להשתלט על המעבד כי אחרים לא יוגרלו.\nStride: כן. תהליך ארוך עם stride נמוך ישתלט על המעבד לזמן רב ואחרים יתעכבו אחריו.\n\n6.3: בגלל השימוש ב-LRU (או קירוב שלו), כאשר הגדלנו את החוצץ מעבר לסף מסוים נפגעו הביצועים של התוכנית (בדומה לדוגמה מהשיעור של loop.c).\n\n6.4: להגביל את גודל הסגמנט המקסימלי באופן תואם לגודל ה-cache, או להחליף את גודל ה-cache לאלגוריתם ללא הבעיה של LRU."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Semaphores",
        "Deadlocks",
        "Concurrency"
      ],
      "content": {
        "text": "נתונה מערכת בה נדרש לנהל N \"מחסנים\" שונים (בכל מחסן פעולות של יצרן-צרכן). לצורך כך הוגדר מערך של N מכל סמפור בפתרון שנלמד בשיעור.\nלהלן הקוד לניהול N המחסנים, כאשר הפרמטר t מייצג את אינדקס המחסן אליו פונים בפעולה (כדי לייצר או לצרוך מוצר) ושתי הפונקציה add_item/remove_item מוסיפות ומסירות מוצר ממחסן t בהתאמה (אך הן לא בטוחות לשימוש במקביל):\nבמערכת הנ\"ל עלתה דרישה לממש פעולה חדשה אשר צורכת מוצרים מכמה מחסנים בו-זמנית (באופן אטומי, אך לא יותר ממוצר אחד מכל מחסן). הפעולה מקבלת כארגומנט את המערך הבוליאני [items[N, כאשר התא 1 במערך מציין האם יש לצרוך מוצר ממחסן 1. להלן הקוד שנכתב למימוש הפעולה: סטודנט טען שבפעולה זו, כפי שניתן לראות בקוד, תפיסת המשאבים מתבצעת תמיד בסדר קבוע וכך מופר תנאי הקיפאון של המתנה מעגלית. למרות טענתו, בהרצת המערכת עם שימוש בפעולה זו ניתן להגיע למצב של קיפאון.",
        "code_snippet": "1 sem_t empty[N]; // init all to MAX\n2 sem_t full[N]; // init all to 0\n3 sem_t mutex(N); // init all to 1\n4 void produce(int t) {\n5     sem_wait(&empty[t]);\n6     sem_wait(&mutex[t]);\n7     add_item(t);\n8     sem_post(&mutex[t]);\n9     sem_post(&full[t]);\n10}\nvoid consume(int t) {\n    sem_wait(&full[t]);\n    sem_wait(&mutex[t]);\n    remove_item(t);\n    sem_post(&mutex[t]);\n    sem_post(&empty[t]);\n}\n\n1 void consume_several (int items [N]) {\n2     for (int i = 0; i < N; ++i) {\n3         if (items[i]) {\n4             sem_wait(&full[i]);\n5         }\n6     }\n7     for (int i = 0; i < N; ++i) {\n8         if (items[i]) {\n9             sem_wait(&mutex[i]);\n10            remove_item(i);\n11            sem_post(&mutex[i]);\n12            sem_post(&empty[i]);\n13        }\n14    }\n15}"
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "תארו ריצה המובילה לקיפאון.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.2",
          "text": "האם טענת הסטודנט נכונה? אם כן, יש להסביר כיצד יתכן קיפאון למרות שהופר תנאי הקיפאון של המתנה מעגלית, אחרת יש להסביר מדוע טענתו שגויה. (רמז: איזו הנחה נסתרת לגבי המשאבים הנחנו בלימוד 4 תנאי הקיפאון, שאינה מתקיימת פה?)\nהטענה נכונה / הטענה לא נכונה",
          "code_snippet": null,
          "options": [
            "הטענה נכונה",
            "הטענה לא נכונה"
          ]
        },
        {
          "id": "7.3",
          "text": "תקנו את הפעולה consume_several כך שתעבוד באופן תקין ללא קיפאון או livelock. יש לשנות את שורות 2-6 בלבד. ניתן להוסיף משתנים גלובליים ולהיעזר בקריאה sem_trywait, אובייקטי סנכרון ופעולות אטומיות כרצונכם (רמז: יש בשאלה 2 דרישות). יש לתאר בקצרה את הפתרון ולכתוב קוד ברור. משתנים גלובליים (יש לציין ערכי אתחול בהערה):",
          "code_snippet": "void consume_several (int items[N]) {\n    for (int i = 0; i < N; ++i) {\n        if (items[i]) {\n            sem_wait(&full[i]);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        if (items[i]) {\n            sem_wait(&mutex[i]);\n            remove_item(i);\n            sem_post(&mutex[i]);\n            sem_post(&empty[i]);\n        }\n    }\n}"
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "הטענה לא נכונה",
        "explanation": "7.1: 1. נניח 1=MAX והמחסנים ריקים. חוט 1 מייצר מוצר למחסן 0 (כלומר: [0]full הוא 1, כל השאר הם 0). חוט 2 מפעיל consume_several כדי לצרוך ממחסנים 0+1. הוא מקטין את [0]full ל-0 וחסום על [1]full. חוט 3 מפעיל consume כדי לצרוך ממחסן 0, חסום כי המחסן ריק ([0]full הוא 0). חוט 4 מפעיל produce כדי לייצר אל מחסן 0, חסום כי המחסן מלא ([0]empty הוא). לא יתכן שמחסן 0 גם ריק וגם מלא.\n\n7.2: הטענה לא נכונה. 2. הסטודנט צודק. בתנאי הקיפאון יש התייחסות למשאבים המתנהגים בדומה למנעול חוט מקצה את המשאבים הדרושים לו בתחילת הפעולה (כמו תפיסת מנעולים), ומשחרר אותם בסוף הפעולה (כמו שחרור מנעולים). בבעיית יצרן-צרכן אין הקצאה ושחרור, אלא להיפך – חוט קודם צריך \"לשחרר\" את המשאב (לייצר מוצר) לפני שחוט אחר יכול לתפוס אותו (לצרוך את המוצר).\n\n7.3: 3. כדי להימנע מקיפאון נפעל באופן דומה לפתרון של no preemption. בהקצאת המוצרים לפעולה נשתמש ב-trywait במקום wait. אם הגענו למחסן שבו אין מוצר לצרוך (ה-trywait נכשל) אז נחזיר את כל ההקצאות הקודמות (ע\"י post לכל המחסנים הקודמים) וננסה שוב מההתחלה. כך חוט לא יהיה חסום בהמתנה למשאב ולא יהיה קיפאון. כדי להימנע מ-livelock, נתפוס מנעול גלובלי הוגן master בתחילת כל ניסיון ונשחרר בסוף הניסיון (בין אם הצלחנו ובין אם לא). כך יגיע תורו של כל חוט לנסות להקצות מוצרים באופן בלעדי (בגלל ההוגנות). שימו לב: פתרון זה לא מונע הרעבה (כל פעם שמגיע תורו של חוט לא זמינים המוצרים שהוא צריך, אך מיוצרים כל פעם בתורם של חוטים אחרים). פתרון אפשרי נוסף ל-livelock הוא המתנה אקראית. פתרון שגוי שחזר על עצמו הוא עדכון מערך items ל-0 בכל תא בו נכשלנו בהקצאת המוצר. פתרון זה לא תקין מאחר שאנו לא יכולים לשנות את הפרמטר של המשתמש – יש לצרוך את כל המשאבים שהפעולה דורשת, ולהמתין עד שזה יתאפשר. משתנים גלובליים (יש לציין ערכי אתחול בהערה): sem_wait(&master); // fair global lock to avoid livelock int i = 0; while (i!= N) { if ((!items[i]) || (!sem_trywait(&full[i]))) { ++i; } else { // failed - give up and restart to avoid deadlock for (int k = 0; k < i; ++k) if (items[k]) sem_post(&full[k]); i = 0; sem_post(&master); // release & grab to allow other sem_wait(&master); // threads to try (avoid livelock) } } sem_post(&master);"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems"
      ],
      "content": {
        "text": "נתון דיסק קשיח עם הנתונים הבאים:\nמהירות סיבוב: RPM 12,000\nגודל מצביע: 4 בתים.\nגודל סקטור: 1024 בתים.\nגודל בלוק: 4KB.\n8 משטחים (4 platters דו-צדדיים).\nצפיפות הסקטורים בכל רצועה (track) היא בהתאם ל-4 אזורים: A,B,C,D. בכל אזור יש 1200 רצועות.\nבאזור A יש 4000 סקטורים לרצועה, באזור B יש 3000 סקטורים לרצועה,\nבאזור C יש 2000 סקטורים לרצועה, באזור D יש 1000 סקטורים לרצועה.\nזמן ה-seek הממוצע הוא 7ms, ובין שתי רצועות סמוכות הוא 1.5ms.\nנתון שיפור track skew: בקריאת סקטורים עוקבים ברצועות סמוכות אין המתנה לסיבוב.\nמהירות העברת המידע של הדיסק תואמת להעברת המידע ברצועה אחת ב-A תוך כדי זמן סיבוב אחד בדיוק.\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "מה הזמן המינימלי שתיקח פעולת קריאה של 1000 בלוקים רצופים בכל אזור, אם נעשה שימוש במשטח אחד בלבד? הניחו שמיקום הראש הקורא-כותב לפני כל פעולה אינו ידוע.\nמינימום A:\nמינימום B:\nמינימום C:\nמינימום D:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "נתונה גרסה חדשה של הדיסק, בה כל הנתונים זהים מלבד קצב העברת מידע של MB/s 100.\nהאם הגרסה החדשה זולה יותר (פחות טובה), יקרה יותר, או שאי אפשר לדעת?\nהגרסה החדשה: זולה יותר / יקרה יותר",
          "code_snippet": null,
          "options": [
            "זולה יותר",
            "יקרה יותר",
            "אי אפשר לדעת"
          ]
        },
        {
          "id": "8.3",
          "text": "הוחלט לנהל מערכת קבצים VSFS על גבי הדיסק הנתון בשאלה. לצורך כך, 99% מהבלוקים בדיסק הוגדרו להיות ה- data region של מערכת הקבצים.\nבכל inode יש 9 מצביעים ישירים ו-3 מצביעים עקיפים.\nכמה קבצים בגודל המקסימלי נוכל להחזיק בדיסק הנתון? ניתן להניח שאין מגבלה על כמות ה-inodes.\nקבצים בגודל המקסימלי:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "8.1:\nזמן הסיבוב הוא 5ms, לכן המתנה ממוצעת לסיבוב היא 2.5ms. כל פעולה מתחילה ב-seek ממוצע של 7ms והמתנה לסיבוב, כלומר זמן מיקום של 9.5ms. בנוסף, 1000 בלוקים הם 4000 סקטורים.\nאזור A: 4000 סקטורים זו רצועה אחת לכן הקריאה תיקח זמן סיבוב שלם (5ms), סה\"כ 14.5ms.\nאזור B: רצועה ושליש, לכן הקריאה תיקח זמן סיבוב ושליש (6.66ms) וזמן מעבר בין רצועות (1.5ms) כי הקריאה כולה באותו משטח (אחרת לא היה נדרש זמן המעבר), סה\"כ 17.66ms\nאזור C: בדיוק 2 רצועות ב-2 סיבובים (10ms) וזמן המעבר ביניהן (1.5ms), סה\"כ 21ms.\nאזור D: בדיוק 4 רצועות ב-4 סיבובים (20ms) ו-3 מעברים (4.5ms), סה\"כ 34ms.\n\n8.2: בדיסק המקורי מעבירים רצועה ב-A בזמן סיבוב בדיוק, כלומר שקצב העברת הנתונים הוא 4000 סקטורים לסיבוב, כלומר 4000KB / 5ms - כמעט 800MB/s. זה קצב משמעותית מהיר יותר מ-MB/s 100, לכן הדיסק החדש יהיה זול יותר.\n\n8.3: במשטח אחד בדיסק יש 120*(4000+3000+2000+1000) = 12 מיליון סקטורים, על 8 משטחים זה סה\"כ 96 מיליון סקטורים, או 24 מיליון בלוקים. 99% מהם זה 23,760,000 בלוקים של DATA. גודל בלוק 4KB גודל מצביע 4B כלומר 1024 מצביעים בבלוק. גודל הקובץ המקסימלי (בבלוקים) הוא 9 בלוקים בגישה ישירה ועוד 1024*3 בגישה עקיפה. המקום שהוא תופס בדיסק הוא כמות זו ועוד 3 בלוקים נוספים עבור הבלוקים העקיפים של המצביעים, סה\"כ 3084 בלוקים לקובץ. נחלק 23,760,000 ב-3084 ונקבל 7704 קבצים. תשובה שגויה היא חישוב כמות הבלוקים לפי גודל הקובץ בלבד (3081) במקום המקום שהוא תופס בדיסק, ואז מגיעים ל-7711 קבצים."
      },
      "difficulty_estimation": "Hard"
    }
  ]
}