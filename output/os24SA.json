{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2024",
    "semester": "Summer",
    "moed": "Moed A",
    "exam_date": "10.10.2024",
    "source_file": "os24SA.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Atomic Operations",
        "Synchronization",
        "Concurrency"
      ],
      "content": {
        "text": "נתון מעבד התומך בפעולה האטומית CAS, הניתנת להפעלה ע\"י קריאה לפונקציה:\nסטודנט כתב את הפונקציה הבאה לדימוי פעולת המעבד האטומית F&A באמצעות פעולת CAS:",
        "code_snippet": "BOOL compareAndSet (int* ptr, int expected, int new);\nint fetchAndAddWithCAS(int* val) {\nint tmp;\ndo {\ntmp = *val;\n} while (!compareAndSet(val, tmp, tmp+1));\nreturn tmp;\n}",
        "options": [
          "א. המימוש תקין, ושקול לשימוש ב-F&A.",
          "ב. המימוש תקין, אך יפגין ביצועים פחות טובים משימוש ב-F&A.",
          "ג. המימוש לא תקין, שימוש בו עלול לגרום לקיפאון.",
          "ד. המימוש לא תקין, שימוש בו עלול לגרום להרעבה.",
          "ה. המימוש לא תקין, הערך של val לא תמיד יקודם באופן נכון."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ד",
        "explanation": "ד'. חוט מסוים עלול להיכשל בקריאת ה-CAS שוב ושוב, ובכך להיות מורעב."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Threads",
        "Memory Management",
        "Processes"
      ],
      "content": {
        "text": "נתונים 2 חוטים A,B של אותו תהליך, ושניהם עוד לא הסתיימו. איזו טענה נכונה?",
        "code_snippet": null,
        "options": [
          "א. החוט A לעולם לא יכול לגשת למשתנים המקומיים של B.",
          "ב. החוט A יכול לגשת למשתנים המקומיים של B רק בתיווך מערכת ההפעלה (עם קריאת מערכת).",
          "ג. החוט A יכול לגשת למשתנים המקומיים של B רק אם B הגדיר אותם באופן מיוחד.",
          "ד. החוט A תמיד יכול לגשת למשתנים המקומיים של B.",
          "ה. החוט A תמיד יכול לגשת למשתנים המקומיים של B, גם אם החוטים לא היו באותו תהליך."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ד",
        "explanation": "ד'. כפי שנלמד, חוטים של אותו תהליך (בלבד) יכולים לגשת למחסנית אחד של השני ולכל הזיכרון של התהליך."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Signals",
        "IPC",
        "System Calls"
      ],
      "content": {
        "text": "מהו סיגנל (signal)?",
        "code_snippet": null,
        "options": [
          "א. מנגנון למניעת זומבים במערכת.",
          "ב. פסיקה שתהליך יכול לגרום במעבד.",
          "ג. מנגנון לשליחת הודעות מתהליך אל מערכת ההפעלה.",
          "ד. מנגנון לשליחת הודעות בין תהליכים ללא התערבות מערכת ההפעלה.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. סיגנל הוא מנגנון לשליחת הודעות בין תהליכים, או ממערכת ההפעלה אל תהליכים, בתיווך מערכת ההפעלה."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "File Systems"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS עם תיקייה d1 בה קיימת הרשומה הבאה: | 20 | a.txt | כלומר, בתיקייה d1 קיימת רשומה בה השם הוא a.txt ומספר ה-inode הוא 20. איזה מהתרחישים הבאים אינו אפשרי?",
        "code_snippet": null,
        "options": [
          "א. באותה תיקייה d1 קיימת גם הרשומה | 30 | a.txt |.",
          "ב. באותה תיקייה d1 קיימת גם הרשומה | 20 | b.txt |.",
          "ג. בתיקייה אחרת d2 קיימת הרשומה | 30 | a.txt |.",
          "ד. בתיקייה אחרת d2 קיימת הרשומה | 20 | a.txt |.",
          "ה. בתיקייה אחרת d2 קיימת הרשומה | 20 | b.txt |."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "א",
        "explanation": "א'. לא יתכנו 2 קבצים עם אותו שם באותה תיקייה. כל שאר האפשרויות תקינות."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "System Calls"
      ],
      "content": {
        "text": "במערכת קבצים VSFS, באיזו פעולה לא נדרש לגשת אל ה-inode של הקובץ?",
        "code_snippet": null,
        "options": [
          "א. פתיחת קובץ.",
          "ב. קריאת מקובץ.",
          "ג. כתיבה לקובץ.",
          "ד. סגירת קובץ.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ד",
        "explanation": "ד'. בסגירת קובץ נדרש רק למחוק את אובייקט ה-FD שנוצר עבורו, ואין בהכרח צורך בגישה ל-inode (או בכלל אל הדיסק)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "CodeAnalysis",
      "topic": [
        "Processes",
        "System Calls",
        "Concurrency",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה התוכנית הבאה בשם prog1:\nהריצו את התוכנית, והתהליך שנוצר קיבל את מזהה התהליך 42.\nידוע שהתוכנית prog2 אינה מדפיסה פלט או יוצרת תהליכים חדשים. ניתן להניח שכל קריאות המערכת הצליחו, לא נוצרים תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.",
        "code_snippet": "1 int main()\n2 {\n3 pid_t pid = getpid();\n4 \n5 if (fork() && !fork()) {\n6 if (!fork() || fork()) {\n7 fork();\n8 }\n9 }\n10 \n11 while (wait(NULL) != -1);\n12 if (pid != getpid()) {\n13 char* args[] = { \"prog2\", NULL };\n14 printf(\"%d [%d]\\n\", getpid(), getppid());\n15 execvp(args[0], args);\n16 }\n17 printf(\"Done: %d\\n\", getpid());\n18 }",
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "כתבו פלט אפשרי של התוכנית, וציירו את עץ התהליכים שנוצר בעקבות הריצה שמובילה לפלט זה (יש לציין לכל תהליך בעץ את מזהה התהליך שלו).\nכמה תהליכים נוצרו בתוכנית, כולל התהליך הראשי?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "נניח שהכניסו את שורה 11 להערה (לולאת ה-while). ידוע שהקוד של כל אחת מהתוכניות prog,prog2 נכנס בדף אחד, ושהמערכת משתמשת בטבלת דפים לינארי בגודל מקסימלי של 2 דפים.\nנתון כי מיד לאחר הרצת שורה 3, במערכת ההפעלה תפוסות 30 מסגרות עבור זיכרון של מרחב המשתמש (user space).\nכעת בדקו את מצב המערכת בנקודת זמן בריצה בה כל התהליכים אשר מריצים את שורה 15 (קריאת ה-execvp) כבר ביצעו אותה בהצלחה אך אף תהליך לא הריץ אף פקודה של התוכנית prog2, וכל שאר התהליכים (שאינם נכנסים לתנאי בשורה (12) עוד לא הסתיימו.\nכלומר: כל התהליכים כבר נוצרו, אף תהליך עוד לא הסתיים, וכל תהליך שקרא ל-execvp במהלך הריצה שלו כבר ביצע את הקריאה בהצלחה (אך עוד לא הריץ אף שורת קוד מתוך prog2).\nכמה מסגרות יהיו תפוסות במערכת עבור זיכרון המשתמש (user space) במקרה המינימלי והמקסימלי?\nיש להניח שלא נעשה שימוש ב-swapping, ואף תהליך אחר במערכת לא מבצע הקצאה, שחרור, או גישה לזיכרון.",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. נוצרים 7 תהליכים.\nבשורה 5 תהליך 42 יוצר את 43 ו-44. רק תהליך 44 נכנס אל התנאי.\nבשורה 6 תהליך 44 יוצר את 45 ו-46. תהליך 45 נכנס אל התנאי מיד ותהליך 44 נכנס גם, אחרי ביצוע ה-fork השני.\nתהליכים 44,45 יוצרים בשורה 7 את הבנים 47,48.\nכל תהליך מדפיס את הפלט רק לאחר שחיכה שהבנים שלו יסתיימו:\n48 [45]\n47 [44]\n46 [44]\n45 [44]\n44 [42]\n43 [42]\nDone: 42\n\n2. מינימום 30 מסגרות, אם התוכנית prog2 כבר רצה בתהליך אחר במערכת, והמחסנית של כל התהליכים החדשים ריקה או עוד לא נוצרה (טבלת הדפים היא חלק מהקרנל ולא זיכרון המשתמש). התקבלה גם תשובה של 36 מסגרות, עם נימוק שמחסנית ריקה תקבל דף.\nמקסימום 37 מסרות, מסגרת אחת עבור הקוד של התוכנית prog2 (לכל התהליכים יחד), ועוד מסגרת אחת לכל מחסנית עבור 6 התהליכים שקראו ל-execvp (מלבד הראשי)."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Mutexes",
        "Concurrency",
        "Threads"
      ],
      "content": {
        "text": "נתונה מערכת ללא תמיכה בפעולת המעבד האטומית F&A, בה המנעול המובנה אינו הוגן. כלומר, מימוש המנעול הזמין ע\"י מערכת ההפעלה מקיים מניעה הדדית וחופש מקיפאון אך עלול לגרום להרעבה.\nמתכנת כלשהו החליט לממש מנעול בהשראת Ticket Lock המשתמש בפקודת ++ במקום F&A החסרה.\nמאחר שפקודת ++ אינה אטומית וחוטים שונים עלולים לקבל את אותו מספר בתור, הקוד משתמש במנעול המובנה במערכת כדי להבטיח מניעה הדדית ביניהם. בנוסף, במידה וחוט הבחין שהתור התקדם מעבר למספר החוט שקיבל (כפי שעלול לקרות), החוט מחזיר את התור אחורה. להלן המימוש:\nשימו לב: השדה unfair הוא המנעול המובנה במערכת שאינו הוגן. הפרמטר myturn של unlock הוא ערך ההחזר של lock (המספר שקיבל החוט שתפס את המנעול).",
        "code_snippet": "typedef struct {\nint ticket; // init to 0\nint turn; // init to 0\nmutex_t unfair;\n} Lock1;\n\nint lock(Lock1* lock) {\nint myturn = lock->ticket++;\nwhile (lock->turn != myturn) {\nif (lock->turn > myturn)\nlock->turn = myturn;\nmutex_lock(&lock->unfair);\n}\nreturn myturn;\n}\n\nvoid unlock(Lock1* lock, int myturn) {\nlock->turn = myturn + 1;\nmutex_unlock(&lock->unfair);\n}",
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "האם המנעול שמתואר בקוד הנ\"ל מקיים מניעה הדדית? כן / לא הוכחה:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.2",
          "text": "האם המנעול שמתואר בקוד הנ\"ל מקיים חופש מקיפאון? כן / לא הוכחה:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.3",
          "text": "האם המנעול שמתואר בקוד הנ\"ל מקיים הוגנות (bounded waiting)? כן / לא הוכחה:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. המנעול מקיים מניעה הדדית.\nכל חוט תופס את המנעול unfair לפני הכניסה לקטע הקריטי ומשחרר אותו רק ביציאה מהקטע הקריטי, לכן אם יש 2 חוטים בקטע הקריטי בו-זמנית שניהם מחזיקים במנעול unfair בסתירה לכך שמנעול זה מקיים מניעה הדדית.\n\n2. המנעול לא מקיים חופש מקיפאון. דוגמה נגדית:\nחוט 1: מנסה לתפוס את המנעול, קורא 0=ticket ועוד לא מקדם ל-1.\nחוט 2: תופס את המנעול – קורא 0=ticket וגם מקדם ל-1. משחרר את המנעול ואז 1=turn.\nחוט 3: תופס את המנעול – קורא 1=ticket וגם מקדם ל-2. משחרר את המנעול ואז 2=turn.\nחוט 1: חוזר לרוץ, מעדכן 1=ticket, רואה שהתור התקדם ולכן מעדכן 0=turn, תופס את המנעול ואז משחרר אותו ומעדכן 1=turn.\nכל חוט שינסה לתפוס את המנעול חסום: יקבל מספר של 2 ומעלה אבל התור 1 ולא יקודם לערך הזה לעולם.\n\n3. המנעול לא מקיים הוגנות. דוגמה נגדית:\nחוט 1: מנסה לתפוס את המנעול, קורא 0=ticket ועוד לא מקדם ל-1.\nחוט 2: תופס את המנעול – קורא 0=ticket וגם מקדם ל-1, משחרר את המנעול ואז 1=turn.\nחוט 1: ממשיך לרוץ, מקדם את ticket ל-1 ורואה שה-turn התקדם לכן עומד לעדכן 0=turn אבל עוד לא עושה זאת.\nחוט 2: תופס את המנעול – קורא 1=ticket וגם מקדם ל-2, משחרר את המנעול ונעצר בדיוק לפני ההשמה של 2 turn אל\nחוט 1: מעדכן 0=turn.\nחוט 2: מעדכן 2=turn.\nחוט 1: חוזר בלולאה ורואה שה-turn התקדם לכן עומד לעדכן 0=turn אבל עוד לא עושה זאת.\nחוט 2: תופס שוב את המנעול – קורא 2=ticket וגם מקדם ל-3, משחרר את המנעול ונעצר בדיוק לפני ההשמה של turn 3 אל\nחוט 1: מעדכן 0=turn.\nחוט 2: מעדכן 3=turn.\nוחוזר חלילה."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "Memory Management",
        "Copy-on-Write"
      ],
      "content": {
        "text": "ב-VSFS קיים שדרוג של copy-on-write, אשר מאפשר להתייחס לאותו בלוק מידע (DATA) מכמה מקומות שונים (לדוגמה, להצביע אליו מכמה inodes שונים).\nלצורך השדרוג, נקצה אזור חדש בדיסק (סט בלוקים) שיכיל מספר עבור כל בלוק DATA, המייצג כמה הפניות יש אל אותו בלוק. נניח שכמות ההפניות המקסימלית לכל בלוק היא 65,535.\nבהעתקת קובץ בתוך מערכת הקבצים, לא נשכפל את המידע והמצביעים אלא רק ניצור inode חדש בו ערכי המצביעים זהים לקובץ המקור. במחיקה של קובץ (לחלוטין, כלומר לא נותרו hard links אל הקובץ) נחסיר 1 מכמות ההפניות של כל הבלוקים של הקובץ. בעדכון נתוני קובץ, נשכפל את הבלוקים ששונו ונעדכן את מספר ההפניות בהתאם (יחד עם עדכון המצביעים עבור ה-inode בו בוצע העדכון).\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "נתונה מערכת קבצים עם גודל בלוק של 4KB.\nבמערכת VSFS סטנדרטית (ללא השדרוג) נתון שיש מקום ל-2,000,000 בלוקים של DATA. לכמה בלוקים של DATA יהיה מקום עם השדרוג הנתון?\nכלומר, נתון דיסק קשיח ועליו מערכת קבצים VSFS סטנדרטית (ללא השדרוג) עם data region המכיל 2,000,000 בלוקים של DATA. ביצעו את השדרוג הנתון למערכת הקבצים, ללא שינוי שאר נתוני מערכת הקבצים מלבד שינוי גודל ה-data region לטובת הקצאת האזור החדש בדיסק (כלומר, ללא שינוי גודל בלוק, גודל inode, כמות inodes, וכו'). לכמה בלוקים של DATA יהיה מקום בדיסק לאחר השדרוג?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "נתונה מערכת קבצים VSFS עם שדרוג copy-on-write, בה כל inode מכיל 8 מצביעים ישירים, 2 מצביעים עקיפים, ו-2 מצביעים עקיפים כפולים. גודל מצביע הוא 4B.\nמשתמש ביצע פעולת כתיבה של בית בודד (1B) לקובץ כלשהו, כאשר הנתון היחיד שידוע מראש הוא מספר ה-inode אליו מבוצעת הכתיבה (אף cache אינו מכיל מידע רלוונטי לביצוע הפעולה).\nמה המספר המקסימלי של בלוקים של DATA שצריך לכתוב אליהם כדי להשלים את הפעולה?\nיש לתאר את הפעולה שמביאה למספר המקסימלי, ואת כל בלוקי ה-DATA אליהם נדרש לכתוב. ניתן להניח כל תרחיש שיוביל למספר המקסימלי, כל עוד הוא עומד בנתונים ובמגבלות שצוינו. אין לתאר פעולות קריאה.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "סטודנט טען כי עם השדרוג של copy-on-write, אין צורך ביותר מ-hard-link אחד לכל inode מאחר וניתן לשתף מידע בין קבצים עם השדרוג הנתון וזה יהיה שקול לשימוש ב-hard-links\nהאם טענת הסטודנט נכונה?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. ה-data region מכיל 2 מיליון בלוקים, כעת צריך באותה כמות בלוקים גם להכיל את האיזור החדש של מספר ההפניות.\nכל הפניה לבלוק דורשת 2 בתים (16 ביטים לייצוג מספר 0-65,535), לכן בכל בלוק 4KB נכנסות 2048 הפניות.\nכלומר, אם יש X בלוקים של DATA לאחר השינוי, נצטרך X/2048 בלוקים של הפניות (מעוגל מעלה). סה\"כ הבלוקים צריך להיות עדיין 2 מיליון, כלומר שאנחנו מחפשים X מקסימלי שמקיים את המשוואה:\nX+X/2048 <= 2,000,000\nהתשובה היא X=1999023\n\n2. מקסימום 3 בלוקים של DATA.\nהפעולה שמביאה למקסימום היא כתיבה לבלוק קיים אשר גורם לשכפול מקסימלי (שלו ושל המצביעים בדרך).\nלדוגמה, כתיבה לבית האחרון של קובץ בגודל המקסימלי אשר חולק את הבלוק הזה עם קובץ אחר, וגם את הבלוקים של המצביעים.\nבלוק ה-DATA האחרון נגיש מה-inode דרך מצביע עקיף כפול, לכן נדרש לכתוב אל:\n- בלוק חדש עבור שכפול ה-DATA אליו כתבנו (כי הוא משותף).\n- בלוק חדש עבור שכפול בלוק המצביעים המצביע אל בלוק ה-DATA.\n- בלוק חדש עבור שכפול בלוק המצביעים העקיפים המצביעים אל בלוק המצביעים.\nנדרש לעדכן גם את ה-inode, מספר הפניות ו-inode bitmap, אך אלו לא בלוקים של DATA ולכן לא נדרשו בשאלה.\n\n3. הסטודנט טועה.\nאמנם קבצים שונים יכולים לחלוק מידע, אך אם נשנה קובץ אחד זה לא ישפיע על האחרים, בניגוד ל-hard-link שמייצג שמות שונים לאותו קובץ (ולא רק אותו תוכן ברגע נתון)."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 9,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems",
        "RAID"
      ],
      "content": {
        "text": "נתונות 2 מערכות עם מנגנון RAID, בכל אחת מהן זמינים 4 דיסקים קשיחים (ממוספרים 1-4) בעלי מאפיינים זהים. כלומר, כל 8 הדיסקים בעלי מאפיינים זהים לחלוטין.\nהשתמשו ב-2 מערכות אלו באותו אופן בדיוק ביצעו את אותן פעולות (קריאה וכתיבה) לאותם בלוקים לוגיים ב-2 המערכות לאורך זמן.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "9.1",
          "text": "נתון שבמערכת הראשונה יש מנגנון 5-RAID ובמערכת השניה מנגנון 4-RAID.\nמשתמש ביצע פעולת כתיבה אחת זהה ב-2 המערכות: כתיבה לבלוקים של 2 שורות רצופות (stripes). בנוסף, המשתמש ביצע פעולת קריאה אחת זהה ב-2 המערכות: קריאת הבלוקים של 2 שורות רצופות.\nב-2 המקרים המשתמש הופתע לגלות שזמני הפעולות של המערכת השניה (4-RAID) היו קצרים יותר. כיצד זה יתכן?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "9.2",
          "text": "נתון שבמערכת הראשונה יש מנגנון 0-RAID ובמערכת השניה מנגנון 1-RAID עם mirroring level של 2.\nבו-זמנית, קרסו 2 הדיסקים הקשיחים הממוספרים 1-2 ב-2 המערכות יחד. המשתמש הופתע לגלות שרק במערכת השניה (1-RAID) אבדו נתונים, בעוד במערכת הראשונה (0-RAID) לא אבד אף נתון. כיצד זה יתכן?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. אמנם הפעולות זהות אך זה לא אומר שמיקום הראש הקורא-כותב או זמן הסיבוב זהים. הסבר אפשרי הוא שבמהלך הפעולה, זמן ההמתנה לסיבוב במערכת השניה היה קצר יותר ולכן הפעולה הסתיימה מהר יותר.\n\n2. אמנם 1-RAID מספק גיבוי אך אם נפלו 2 דיסקים אז נאבדו הנתונים.\nיתכן שהמשתמש אחסן נתונים רק באותם דיסקים שלא התקלקלו במערכת הראשונה (לדוגמה, בלוק לוגי 3 נמצא בדיסק 3 במערכת הראשונה אבל בדיסקים 1-2 במערכת השניה, ולכן אם אוחסנו בו נתונים הם יתאימו לתרחיש המתואר)."
      },
      "difficulty_estimation": "Medium"
    }
  ]
}