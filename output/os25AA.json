{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2025",
    "semester": "Semester A",
    "moed": "Moed A",
    "exam_date": "04.02.2025",
    "source_file": "os25AA.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "בקורס למדנו מספר רמות של RAID.\nחוו דעתכם על הטענה הבאה: ככל שרמת ה-RAID גבוהה יותר כך הוא טוב יותר.",
        "code_snippet": null,
        "options": [
          "א. הטענה נכונה.",
          "ב. הטענה לא נכונה.",
          "ג. לא למדנו מספיק רמות RAID כדי לענות על הטענה.",
          "ד. 0-RAID לא מספק אמינות ולכן לא ניתן להשוות אותו לרמות האחרות.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ב",
        "explanation": "ב'. לכל רמת RAID יתרונות וחסרונות, ואין רמה שטובה יותר מרמה אחרת אלא זה תלוי בדרישות (מלבד 5-RAID שטובה יותר מ-4-RAID). הטענה לא נכונה גם אם מסתכלים על ביצועים בנפרד או על אמינות בנפרד."
      }
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Scheduling",
        "CPU Scheduling"
      ],
      "content": {
        "text": "באלגוריתם התזמון MLFQ, זמן המחזור (turnaround time) הוא אופטימלי.",
        "code_snippet": null,
        "options": [
          "א. הטענה נכונה בתנאי שנקבע קוונטה קצרה מספיק.",
          "ב. הטענה נכונה בתנאי שנקבע קוונטה ארוכה מספיק.",
          "ג. הטענה לא נכונה.",
          "ד. MLFQ אינו אלגוריתם תזמון.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. זמן המחזור האופטימלי הוא באלגוריתם SRTF, באלגוריתם MLFQ יתכן זמן מחזור לא אופטימלי ללא קשר לקוונטה."
      }
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Memory Management",
        "Paging",
        "Page Replacement",
        "Virtual Memory"
      ],
      "content": {
        "text": "נתון תהליך שמערכת ההפעלה הקצתה לו שלוש מסגרות בלבד (לכל אורך הריצה שלו), אשר בהתחלה כולן פנויות (אף אחד מהדפים של התהליך אינו בזיכרון). התהליך פנה לדפים הבאים (משמאל לימין, כלומר קודם 0 ואז 1 וכן הלאה):\n0, 1, 3, 2, 4, 0, 4, 2, 1, 3, 3, 4\nכמה page faults יהיו אם אלגוריתם החלפת הדפים הוא האופטימלי (OPT)?",
        "code_snippet": null,
        "options": [
          "א. 6.",
          "ב. 7.",
          "ג. 8.",
          "ד. 9.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ב",
        "explanation": "ב'. 5 הגישות הראשונות הן החטאות (הגישה הראשונה לכל דף). לאחר מכן גישות 9 ו-10 יהיו החטאות (הגישות לדפים 1 .(3-1"
      }
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "נתון דיסק קשיח עם מערכת קבצים נפוצה כלשהי (שאינה VSFS) המחובר למחשב כלשהו. משתמש ניתק את הדיסק מהמחשב וחיבר אותו למחשב אחר בעל מערכת הפעלה שונה. במחשב האחר:",
        "code_snippet": null,
        "options": [
          "א. נוכל להשתמש בדיסק ולראות את הקבצים בו.",
          "ב. נוכל להשתמש בדיסק אך לא נראה את הקבצים שהיו בו לפני החלפת המחשב.",
          "ג. לא נוכל להשתמש בדיסק בלי למחוק קודם את כל הקבצים בתוכו.",
          "ד. לא נוכל להשתמש בדיסק בלי להחליף את מערכת הקבצים שלו למערכת קבצים אחרת (כמו VSFS).",
          "ה. לא נוכל להשתמש בדיסק כלל."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "א",
        "explanation": "א'. מערכת קבצים אינה ספציפית למערכת הפעלה וגם לא הקבצים בה, בכל מערכת הפעלה נוכל להשתמש בדיסק ולראות את הקבצים בו בתנאי שמערכת הקבצים הזו נתמכת באותה מערכת ההפעלה."
      }
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Concurrency",
        "Threads",
        "Processes"
      ],
      "content": {
        "text": "איזו מהטענות הבאות נכונה לגבי מקביליות:",
        "code_snippet": null,
        "options": [
          "א. הגדלת מספר החוטים בתוכנית תמיד תשפר את הביצועים.",
          "ב. מקביליות מייתרת את הצורך בשימוש באובייקטי סנכרון כמו מנעולים וסמפורים.",
          "ג. מקביליות משפרת את הביצועים ע\"י הרצת מספר חוטים במקביל על אותו מעבד/ליבה.",
          "ד. שימוש במקביליות לא רלוונטי במערכות עם מעבד יחיד (עם ליבה אחת).",
          "ה. ניתן לנצל מקביליות לשיפור ביצועים גם עם מעבד יחיד (עם ליבה אחת)."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. בעזרת מקביליות (concurrency) ניתן לשפר ביצועים גם עם מעבד יחיד לדוגמה ע\"י חפיפה. הבלבול עם מקביליות parallelism לא משנה את התשובה, כפי שנלמד לדוגמה עם ריבוי תהליכים לשיפור זמן המחזור."
      }
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Memory Management",
        "Paging",
        "Virtual Memory"
      ],
      "content": {
        "text": "נתונה מערכת עם גודל דף של 4KB וטבלת דפים היררכית. כל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת, 14 ביטים של סטטוס ו-20 ביטים של ריפוד. נתון שהגודל של PTE ו-PDE זהה, וכל טבלה/חלק מאוחסנים בדף אחד בדיוק (לא יותר ולא פחות).\nשימו לב: נתונים אלו רלוונטיים לכל סעיפי השאלה. הנתונים הכתובים בסעיפים עצמם מתווספים לנתונים אלו אך ספציפיים לאותו סעיף ואינם תקפים לשאר הסעיפים.\nיש לפרט ולנמק את כל החישובים בכל סעיף.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "נתון שטבלת הדפים של תהליך המשתמש בכל הדפים במרחב הכתובות שלו תופסת 1+512+5122 מסגרות בזיכרון הפיזי. כמה רמות יש בטבלת הדפים, מה מרחב הכתובות של תהליך, ומה גודל הזיכרון הפיזי המקסימלי?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "נתון תהליך אשר משתמש ב-30 דפים במרחב הכתובות שלו, המחולקים ל-4 סגמנטים נפרדים:\n- סגמנט קוד של 5 דפים רצופים.\n- סגמנט נתונים (data) של 5 דפים רצופים.\n- סגמנט ערימה (heap) של 10 דפים רצופים.\n- סגמנט מחסנית (stack) של 10 דפים רצופים.\nכל גישה לכתובת אחרת, שאינה בסגמנטים אלו, תגרום לשגיאה.\nכמו-כן נתון שהזיכרון שתופסת טבלת הדפים של תהליך זה הוא 100KB במקרה המקסימלי.\nכמה רמות יש בטבלת הדפים, ומהו מספר הכניסות בטבלה שהן valid (הסכום הכולל בכל הרמות יחד)?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "נתון שטבלת הדפים במערכת היא ב-3 רמות, ונתון תהליך זהה לתהליך בסעיף הקודם (שאלה 6.2).\nכמה זיכרון תתפוס טבלת הדפים של התהליך במקרה המינימלי, ומה מספר הכניסות בטבלה שהן valid (הסכום הכולל בכל הרמות יחד)?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. נניח שבכל טבלה נכנסות X רשומות PTE, בכל רמה של טבלה היררכית יש פי X יותר רשומות מאשר הרמה הקודמת. ברמה הראשונה תמיד יש טבלה אחת, ולכן לפי הנתון יש 512 רשומות בכל טבלה ו-3 רמות סה\"כ.\nברמה התחתונה ביותר יש 512^2 טבלאות שבכל אחת 512 רשומות, סה\"כ 512^3 דפים במרחב הכתובות, גודל כל דף 4KB כלומר שמרחב הכתובות הוא 2^39 בתים.\nגודל דף הוא 4KB ובכל טבלה 512 כניסות כלומר כל כניסה היא 8 בתים = 64 ביט. 34 ביט משמשים לסטטוס וריפוד כלומר מספר המסגרת PFN הוא 30 ביט, גודל מסגרת 4KB לכן הזיכרון הפיזי המקסימלי הוא 2^42 בתים.\n2. ברמה העליונה יש טבלה אחת. בכל סגמנט הדפים רצופים ולכן הרשומות המתאימות לדפים של כל סגמנט יתפזרו על פני 2 טבלאות במקסימום, סה\"כ 8 ברמה התחתונה. ל-2 טבלאות האלו יהיו במקרה המקסימלי 2 טבלאות (עם מצביע אחד כל אחת) ברמה מעל, וכן הלאה עד הרמה הראשונה שבה טבלה אחת. גודל הטבלה כולה 100KB שזה 25 דפים – ולכן יש 4 רמות (1 ברמה הראשונה, 8 ברמה 2 + 3 + 4.\nברמה התחתונה יש 30 כניסות valid (אחת לכל דף שהתהליך משתמש בו), ובכל רמה מעל יש 8 כניסות valid בהתאם לחלוקה שתוארה – סה\"כ 54 כניסות valid.\n3. במקרה המינימלי, כל הדפים ממופים לאותה טבלה ברמה התחתונה ולכן עבור 3 רמות יהיו בשימוש בדיוק 3 מסגרות - .12KB\nברמה התחתונה יהיו 30 כניסות valid (אחת לכל דף שהתהליך משתמש בו), ועוד כניסה אחת בכל רמה, סה\"כ 32 .valid כניסות"
      }
    },
    {
      "id": 7,
      "type": "Open",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Threads",
        "Semaphores",
        "Mutexes",
        "Deadlocks"
      ],
      "content": {
        "text": "נתונה מערכת מרובת חוטים עבורה נדרש לנהל מחסן המשתמש בפתרון של בעיית יצרן-צרכן עם התוספת הבאה: כל מוצר נדרש לעבור עיבוד לפני שניתן לצרוך אותו.\nכלומר, פעולת היצרן מייצרת ומוסיפה למחסן מוצר שהוא לפני עיבוד. פעולת הצרכן נדרשת להוציא מהמחסן ולצרוך מוצר שהוא אחרי עיבוד. פעולה נוספת, חדשה, מעבדת מוצר במחסן. על הפתרון לתמוך ב-3 הפעולות הבאות:\n- ()void produce – מייצרת מוצר לא מעובד ומוסיפה אותו אל המחסן.\n- ()void process – מוציאה מוצר לא מעובד מהמחסן, מעבדת אותו, ומחזירה את המוצר המעובד אל המחסן.\n- ()void consume - מוציאה מוצר מעובד מהמחסן וצורכת אותו.\nשימו לב: עיבוד מוצר עלול לקחת זמן רב, ולכן בזמן העיבוד יש לדאוג שפעולת process אינה תופסת מקום במחסן (כלומר, הפעולה מפנה את המדף שתפס המוצר במחסן, ולאחר העיבוד מקצה עבורו מדף מחדש).\nבמערכת מוגדר טיפוס מיוחד Item המייצג מוצר (מעובד או לא מעובד), ומוגדר הקבוע N המייצג את המקום במחסן (כמות המדפים). כלומר, במחסן יש מקום ל-N מוצרים סך הכל (מעובדים ולא מעובדים יחדיו).\nבנוסף נתונות הפונקציות הבאות:\n- Item produce_item() – מייצרת מוצר לא מעובד חדש, ובטוחה לשימוש במקביל.\n- void consume_item(Item) – צורכת מוצר מעובד קיים, ובטוחה לשימוש במקביל (על מוצרים שונים).\n- void add_item(Item) – מקבלת מוצר שאינו קיים במחסן (מעובד או לא מעובד) ומוסיפה אותו אל המחסן. פונקציה זו אינה בטוחה לשימוש במקביל, ואסור לקרוא לה אם כמות המוצרים במחסן היא N.\n- Item del_item() – מוציאה מוצר אחד מהמחסן (מעובד או לא מעובד) ומחזירה אותו. פונקציה זו אינה בטוחה לשימוש במקביל, ואסור לקרוא לה אם כמות המוצרים במחסן היא 0.\n- Item process_item(Item) – מקבלת מוצר לא מעובד, מעבדת אותו, ומחזירה את המוצר המעובד. פונקציה זו בטוחה לשימוש במקביל. אסור לקרוא לה עם מוצר מעובד כפרמטר, או להשתמש במוצר המקורי (הפרמטר שהועבר) לאחר העיבוד, אלא רק בערך ההחזר.\n- BOOL is_processed(Item) – מקבלת מוצר (מעובד או לא מעובד) ומחזירה TRUE אם המוצר מעובד, או FALSE אם המוצר לא מעובד.\nשימו לב: פונקציות אלו נתונות ויש להשתמש בהן (אין צורך לממש אותן). ניתן להניח שהמחסן מתנהג כמו תור FIFO (כלומר, המוצר שהתווסף ראשון ע\"י add_item הוא הראשון שיוחזר ע\"י del_item).",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "לפי הגדרת המחסן, בכל מימוש יתכן תרחיש דומה לקיפאון בו קיים חוט (אחד או יותר) אשר ביצע עיבוד למוצר וקיים חוט (אחד או יותר) אשר מעוניין לצרוך מוצר מעובד, אך לא ניתן לצרוך את המוצר.\nתארו תרחיש (שאינו תלוי במימוש) אשר מוביל לבעיה זו.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.2",
          "text": "ממשו את פעולות המחסן בהתאם לדרישות, תוך שימוש באובייקטי סנכרון בלבד (מנעולים, סמפורים, ומשתני תנאי). יש לדאוג לפתרון יעיל ככל האפשר ולהימנע מ-spinning. שימו לב: אין צורך לפתור את הבעיה המתוארת בסעיף הקודם, המימוש אינו תלוי במענה עליו (ניתן לממש באופן מלא גם ללא מציאת הבעיה). תיאור הפתרון: משתנים גלובליים (יש לציין ערכי אתחול בהערה, אין צורך לדאוג לפעולות אתחול והקצאות דינמיות/שחרור זיכרון):",
          "code_snippet": "void produce() {\n}\nvoid consume() {\n}\nvoid process() {\n}",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. חוט 1 יבצע ()produce עד שהמחסן מלא (N פעמים). חוט 2 יבצע ()process, יוציא מוצר לא מעובד מהמחסן ויתחיל לעבד אותו. חוט 1 יבצע ()produce נוסף לפני שחוט 2 מסיים לעבד, המחסן שוב מלא. חוט 2 יסיים את העיבוד, לא ניתן להוסיף חזרה כי המחסן מלא. חוט 3 יבצע ()consume, אין מוצרים מעובדים במחסן שניתן לצרוך.\n2. את הסמפור full (כמות המוצרים) נפריד ל-2 משאבים נפרדים: מוצרים מעובדים ולא מעובדים. בהוצאת מוצר נוסיף ונסיר מוצרים מהמחסן עד שנגיע למוצר מתאים:\n```c\nsem_t empty;   // # free spots, init to N\nsem_t unprocd; // # unprocessed items, init to 0\nsem_t procd;   // # processed items, init to 0\nsem_t mutex;   // protect access to warehouse, init to 1\n\nvoid produce() {\n    Item i = produce_item();\n    sem_wait(&empty);\n    sem_wait(&mutex);\n    add_item(i);\n    sem_post(&mutex);\n    sem_post(&unprocd);\n}\n\nvoid consume() {\n    sem_wait(&procd);\n    sem_wait(&mutex);\n    Item i = del_item();\n    while (!is_processed(i)) {\n        add_item(i);\n        i = del_item();\n    }\n    sem_post(&mutex);\n    sem_post(&empty);\n    consume_item(i);\n}\n\nvoid process() {\n    sem_wait(&unprocd);\n    sem_wait(&mutex);\n    Item i = del_item();\n    while (is_processed(i)) {\n        add_item(i);\n        i = del_item();\n    }\n    sem_post(&mutex);\n    sem_post(&empty);\n    i = process_item(i);\n    sem_wait(&empty);\n    sem_wait(&mutex);\n    add_item(i);\n    sem_post(&mutex);\n    sem_post(&procd);\n}\n```"
      }
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Memory Management"
      ],
      "content": {
        "text": "נתון כונן SSD בו גודל דף הוא 6KB וגודל בלוק הוא 6MB.\nעל הכונן קיימת מערכת קבצים VSFS בה גודל מצביע הוא 4 בתים, ובכל inode יש 10 מצביעים ישירים, מצביע אחד עקיף, מצביע אחד עקיף כפול, ומצביע אחד עקיף משולש.\nשימו לב: כל התייחסות של מערכת הקבצים אל בלוק בדיסק קשיח יש להחליף עם דף בכונן SSD (ולא בלוק SSD).\nלדוגמה, ה-inode מכיל מצביעים לדפים (ישירים, עקיפים, וכו').\nיש לפרט ולנמק את כל החישובים בכל סעיף.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה דפים של DATA הוא יתפוס בכונן?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "נניח שמעוניינים לקרוא מקובץ מסוים שמאוחסן במערכת הקבצים את הדף שמספרו 17,425 (דפי הקובץ ממוספרים החל מ-0), כאשר מספר ה-inode ידוע מראש, ואף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nהניחו שטבלאות המיפוי (log table + data table) זמינות בזיכרון של הכונן, וזמן הגישה אליהן זניח.\nיש לפרט בקיצור ובצורה מדויקת איך המערכת מאתרת את הדף המבוקש על הכונן, ואת כל פעולות הקריאה וכתיבה של דפים שיש לבצע כדי להשלים את הפעולה.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "סטודנט טען שכתיבה של קובץ גדול בבת אחת תהיה מהירה משמעותית מאשר כתיבה של הקובץ בחלקים, דף אחד שלם של נתונים (6KB) בכל פעם. האם טענת הסטודנט נכונה?",
          "code_snippet": null,
          "options": [
            "הסטודנט צודק",
            "הסטודנט טועה"
          ]
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. בכל דף עקיף נכנסים 6KB/4B = 1536 מצביעים.\nמצביעים ישירים 10 דפים.\nמצביע עקיף – 1536 דפים. עקיף כפול – 1536^2 דפים. עקיף משולש – 1536^3 דפים.\nסה\"כ: (10+1536+1536^2+1536^3)*6KB.\nבשביל דפים שיתפוס בכונן צריך להוסיף דפי מצביעים:\nמצביע עקיף – 1 דפים. עקיף כפול – 1+1536 דפים. עקיף משולש – 1+1536+1536^2.\nסה\"כ: 1+1536+1536^2+1536^3 + 1+1536+1+1536^2 + 10 דפים\n2. צריך לדלג על 10 הדפים הישירים, על 1536 הדפים שמוצבעים ע\"י המצביע העקיף מדרגה ראשונה ועל עוד 15360 דפים שמוצבעים ע\"י 10 מצביעים עקיפים מדרגה ראשונה שנמצאים בדף המצביעים מדרגה שניה. נותר לדלג על עוד 519 דפים – כלומר לגשת למצביע ה-11 מדרגה ראשונה שנמצא בדף המצביעים מדרגה שניה וממנו לגשת למצביע ה-520 בדף המצביעים הישירים.\nכלומר, יש להביא מהדיסק את: הדף שמכיל את ה-inode הרלוונטי, דף המצביעים מדרגה שניה הראשון, דף המצביעים מדרגה ראשונה שכתובתו היא ה-11 בדף המצביעים מדרגה שניה, דף הנתונים שכתובתו היא ה-520 בדף המצביעים מדרגה ראשונה.\nבכל גישה לדיסק יבוצע ראשית חיפוש בטבלת המיפוי log-table ואם הדף לא נמצא שם יבוצע חיפוש בטבלת המיפוי data-table.\nבנוסף יבוצע עדכון של זמן הגישה האחרון ב-inode הרלוונטי.\nטעויות נפוצות היו לא לפרט לאיזה מצביע ולאיזה דף יש לגשת, או לא לפרט כיצד מבוצע החיפוש של כל דף בכונן ה-SSD (באמצעות טבלאות המיפוי).\n3. הסטודנט טועה.\nכל עוד כותבים דף שלם בכל פעם, אין הבדל משמעותי אם נכתוב הכל בבת אחת או בחלקים בגלל שה-FTL הוא log .structured"
      }
    }
  ]
}