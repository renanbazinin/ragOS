{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2022",
    "semester": "Semester B",
    "moed": "Moed A",
    "exam_date": "13.06.2022",
    "source_file": "os22BA.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "בכונן SSD, קריאות מרובות מאותו קובץ אינן מאיצות את שחיקת הדיסק.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. קריאות אמנם מגבירות את הסיכוי להפרעות (disturbance) אבל לא שוחקות את הדיסק (זיכרון flash נשחק ממחזורי מחיקה + כתיבה)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Scheduling",
        "CPU Scheduling"
      ],
      "content": {
        "text": "זמן המחזור הממוצע של תזמון FIFO תמיד עדיף או שווה ל-RR.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. לדוגמה עבור תהליך ארוך שמידע אחריו מגיע תהליך קצר, זמן המחזור הממוצע של FIFO גרוע יותר."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Atomic Operations"
      ],
      "content": {
        "text": "במשתני תנאי (condition variable), אם נבטל את תפיסת המנעול המובנית ב-wait ובמקום זאת נבצעה באופן ידני מיד לאחר כל קריאה ל-wait, זה לא ישפיע על הנכונות ולא יוסיף בעיות חדשות.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. ב-wait שחרור המנעול והכניסה להמתנה מתבצעות באופן אטומי, אבל לאחר התעוררות (קבלת הסיגנל) מתבצעת תפיסת מנעול כרגיל, ואין הבדל אם תפיסת המנעול מחדשת מתבצעת בתוך ה-wait או באופן ידני מיד לאחר ה-wait, כל עוד היא מתבצעת."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Threads",
        "Processes",
        "Concurrency"
      ],
      "content": {
        "text": "חוטים במרחב המשתמש (user threads) יכולים לשפר את ביצועי התוכנית.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. בשימוש בחוטים במרחב המשתמש עדיין ניתן לשפר את ביצועי התוכנית ע\"י חפיפה (overlap) – הרצת קוד בחוט אחד בזמן שחוט אחר ממתין לקלט/פלט."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "I/O",
        "System Calls"
      ],
      "content": {
        "text": "שימוש ב-DMA חוסך את זמן העברת הנתונים מ/אל ההתקן בלבד.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. שימוש ב-DMA חוסך לא רק את העברת הנתונים, אלא גם את הטיפול בפסיקות ושליחת פקודות מחדש במקרה של פעולות קריאה/כתיבה גדולות."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Memory Management",
        "Virtual Memory",
        "Paging"
      ],
      "content": {
        "text": "נתונה מערכת עם גודל דף של 4KB וטבלת דפים היררכית. כל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת ועוד ביט present בלבד. נתון שהגודל של PTE ו-PDE זהה, וכל טבלה/חלק מאוחסנים בדף אחד בדיוק (לא יותר ולא פחות). יש לפרט ולנמק את החישובים בכל סעיף.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "נתון שעבור תהליך המשתמש בכל הדפים במרחב הכתובות שלו, טבלת דפים ב-3 רמות תופסת 1+2048+20482 מסגרות בזיכרון הפיזי. מה מרחב הכתובות של תהליך ומה גודל הזיכרון הפיזי המקסימלי? מרחב הכתובות: זיכרון פיזי מקסימלי: נימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "כיצד תשתנה התשובה לסעיף הקודם אם עבור תהליך שמשתמש בכל הדפים במרחב הכתובות שלו, טבלת דפים ב-2 רמות תופסת 1+1024 מסגרות בזיכרון הפיזי? מרחב הכתובות: זיכרון פיזי מקסימלי: נימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "נתון תהליך המשתמש ב-5 דפים של זיכרון, כאשר 2 מהדפים רצופים בזיכרון התהליך. מה הגודל המינימלי והמקסימלי של הזיכרון הפיזי שתתפוס טבלת הדפים של התהליך, לפי נתוני כל אחד מהסעיפים הקודמים? יש לספק 4 תשובות. גודל מינימלי 6.1: גודל מינימלי 6.2: גודל מקסימלי 6.1: גודל מקסימלי 6.2:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. עבור תהליך שמשתמש בכל הדפים בזיכרון שלו כל חלקי הטבלה יהיו מלאים. ברמה הראשונה תמיד יש מסגרת אחת, וברמה השלישית יש בריבוע לעומת הקודמת – כלומר שיש 2048 כניסות בכל חלק של הטבלה. לפי גודל הדף, כל כניסה היא 16 ביט (2 בתים). כל PTE מכיל מספר מסגרת ועוד ביט אחד כלומר 15 עבור ה-PFN. גודל מסגרת 4KB לכן הזיכרון הפיזי הוא 2^12*2^15 = 128MB. לפי גודל הטבלה יש 3 רמות ובכל אחת 2^11 כניסות, כלומר ה-VPN הוא 33 ביטים, מכאן שלתהליך יש 2^33 דפים. מרחב הכתובות הוא 32TB.\n2. כמו הסעיף הקודם רק עם 1024 כניסות בכל טבלה, לכן כל כניסה היא 32 ביט. לפיכך יש 31 ביט עבור PFN, זיכרון פיזי מקסימלי הוא 2^12*2^31 = 4TB. לפי גודל הטבלה יש 2^11 כניסות בכל רמה, כלומר ה-VPN הוא 22 ביטים, לתהליך יש 2^22 דפים. מרחב הכתובות הוא 4GB.\n3. במינימום ל-2 הסעיפים, המיפויים של כל הדפים נמצאים באותה טבלה ברמה האחרונה, ולכן הטבלה כולה תופסת דף אחד בכל רמה. מינימום 6.1 זה 3 מסגרות, מינימום 6.2 זה 2 מסגרות. במקסימום, נרצה שהמיפוי של כל דף יהיה בחלק אחר של הטבלה (תת-טבלה נפרדת ברמה התחתונה), גם עבור 2 הדפים הרצופים – המיפוי של אחד יהיה האחרון בחלק שלו והמיפוי של השני יהיה הראשון בחלק הבא. בכל מקרה יש מסגרת אחת ברמה העליונה. עבור 6.1 יהיו 5 מסגרות ברמה השניה ועוד 5 בשלישית, סה\"כ 11 מסגרות. עבור 6.2 יהיו 5 ברמה השניה, סה\"כ 6 מסגרות."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "Open",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Semaphores",
        "Mutexes"
      ],
      "content": {
        "text": "בשאלה זו יש לממש מנעול קוראים-כותבים (Reader-Writer Lock) אשר מקיים את שלוש התכונות: מניעה הדדית, חופש מקיפאון, והוגנות. ראשית, יש להגדיר מחדש את תכונות אלו באופן שתואם למנעול קוראים-כותבים, ולאחר מכן יש לספק מימוש מנעול אשר מקיים את התכונות.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "עבור מנעולים נלמדו שלוש תכונות שמימוש יכול לקיים: מניעה הדדית, חופש מקיפאון, והוגנות. תכונות אלו אפיינו את הפעולה הרצויה של מנעול רגיל. הגדירו מחדש את שלוש תכונות אלו, כך שיאפיינו במדויק את אופן הפעולה של מנעול קוראים-כותבים. כלומר, יש לנסח מחדש את ההגדרות כך שיהיו תואמות באופן ספציפי לתנאים הנדרשים במימוש מנעול קוראים-כותבים. שימו לב: ההגדרות אינן בהכרח זהות לאלו של מנעול רגיל (לדוגמה, כי מתאפשר יותר מחוט אחד בקטע הקריטי). מניעה הדדית: חופש מקיפאון: הוגנות:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.2",
          "text": "ממשו מנעול קוראים-כותבים אשר מקיים את שלוש התכונות, עם שימוש בסמפורים בלבד (ללא פעולות אטומיות או אובייקטי סנכרון אחרים)",
          "code_snippet": "typedef struct __rw_lock {\n} RWLock;\nvoid init(RWLock *lock) {\n}\nvoid destroy (RWLock *lock) {\n}\nvoid acquire_writelock(RWLock *bar) {\n}\nvoid release_writelock(RWlock *bar) {\n}\nvoid acquire_readlock(RWlock *bar) {\n}\nvoid release_readlock (RWlock *bar) {\n}\n",
          "options": null
        },
        {
          "id": "7.3",
          "text": "הוכיחו בקצרה שמימוש המנעול בסעיף הקודם אכן מקיים את שלוש התכונות. מניעה הדדית: חופש מקיפאון: הוגנות:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. מניעה הדדית: יש לכל היותר חוט כותב אחד בקטע הקריטי, או כל מספר של חוטים קוראים בקטע הקריטי. לא יתכן חוט כותב וקורא בו זמנית בקטע הקריטי.\nחופש מקיפאון: אם אף חוט לא נמצא בקטע הקריטי, חוט כלשהו יכנס לקטע הקריטי בסופו של דבר. אם יש רק חוטים קוראים בקטע הקריטי, חוט קורא כלשהו יכנס לקטע הקריטי בסופו של דבר.\nהוגנות: זהה להגדרה של מנעול רגיל (אם חוטים נכנסים ויוצאים מהקטע הקריטי, אז כל חוט נכנס לקטע הקריטי בסופו של דבר).\n2. המימוש מבוסס על הפתרון שנלמד בשיעור, עם שימוש בסמפורים בינאריים במקום מנעולים. כדי להתמודד עם הרעבת הכותבים, נוסיף מנעול הוגן נוסף (סמפור בינארי) ל-2 פעולות הנעילה, אשר יוודא שלא ניתן לעקוף אף חוט מספר לא מוגבל של פעמים. פעולות השחרור יהיו זהות.\n```c\ntypedef struct _rw_lock {\n    int numReaders;\n    sem_t writelock; // binary semaphore (init to 1)\n    sem_t readlock; // -\"-_\n    sem_t enterlock; // -\"-\n} RWLock;\nvoid acquire_writelock(RWLock *lock) {\n    sem_wait(&lock->enterlock); // don't allow any acquire\n    sem_wait(&lock->writelock);\n    sem_post(&lock->enterlock); // now others can acquire\n}\nvoid acquire_readlock(RWLock *lock) {\n    sem_wait(&lock->enterlock); // don't allow any acquire\n    sem_wait(&lock->readlock);\n    if (++lock->numReaders == 1)\n        sem_wait(&lock->writelock);\n    sem_post(&lock->readlock);\n    sem_post(&lock->enterlock); // now others can acquire\n}\n```"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS עם סופר-בלוק בבלוק 1, ושאר מערכת הקבצים מבלוק 2 והלאה. תוכן הסופר-בלוק מיוצג ע\"י המבנה הבא: כל inode מכיל 9 מצביעים ישירים, 2 מצביעים עקיפים, ו-1 מצביע עקיף כפול. גודל מצביע הוא 4 בתים, ונתונים הערכים הבאים: bsize = 4096 inode_size = 128 nblocks = 200 * 1000 * 1000 ninodes = 12 * 1000 * 1000 יש לפרט ולנמק את החישובים בכל סעיף.",
        "code_snippet": "struct superblock {\nint bsize; // block size\nint inode_size; // sizeof(struct inode)\nint nblocks; // number of data blocks on the disk\nint ninodes; // number of inodes\nint inode_start; // start of inodes area\nint data_start; // start of data block area\nint i_bmap_start; // start of inode bit map\nint d_bmap_start; // start of data bit map\nint max_file_size; // maximum size of file\n};",
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "לגבי כל אחד מהשדות הבאים, ציינו האם ניתן לדעת את ערכו. אם כן, יש לציין מה הערך, אחרת יש לציין מה הנתון החסר. inode_start: ניתן לדעת / לא ניתן לדעת data_start: ניתן לדעת / לא ניתן לדעת i_bmap_start: ניתן לדעת / לא ניתן לדעת d_bmap_start: ניתן לדעת / לא ניתן לדעת max_file_size: ניתן לדעת / לא ניתן לדעת",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "נתון קובץ בגודל המקסימלי האפשרי. המשתמש ביצע מחיקה של קובץ זה ממערכת הקבצים (לחלוטין, כלומר שלא נותרו עוד hard-links אל הקובץ), כאשר לפני הפעולה ידוע רק מספר ה-inode של הקובץ ושל התיקייה המכילה אותו, ואף cache אינו מכיל מידע רלוונטי. יש להניח שזה הקובץ היחיד בתיקייה. מה מספר הבלוקים המקסימלי שנצטרך לקרוא ולכתוב תוך כדי המחיקה, במקרה המקסימלי? יש לפרט את כל הבלוקים. בלוקים לקריאה: בלוקים לכתיבה:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "נתונה מערכת קבצים חדשה וריקה מלבד תיקייה אחת ובה קובץ יחיד בשם a.txt בגודל 40,000 בתים. בתיקייה זו, משתמש ביצע את הפקודות הבאות: מיד לאחר מכן, המשתמש ביצע את הפקודה הבאה: rm -r d1 # remove all files in d1, and d1 itself תארו את כל הפעולות במערכת הקבצים בעקבות הרצת הפקודה rm, לפי סדר הביצוע ובמקרה המינימלי. יש לפרט כמה בלוקים צריך לכתוב, לקרוא, ומאיזה סוג (DATA, inode, inode bitmap, וכו'). כמות בלוקים שנקראים: בלוקים לכתיבה:",
          "code_snippet": "mkdir d1\ncp a.txt d1/x.txt\nIn a.txt d1/y.txt\nln -s a.txt d1/z.txt\nrm -r d1 # remove all files in d1, and d1 itself",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. גודל בלוק הוא 4096B, כלומר 32,768 ביטים עבור כל bitmap. יש 12,000,000 inodes לכן נדרש 367 בלוקים עבור inode bitmap. גודל כל inode הוא 128 בתים לכן נדרש 375,000 בלוקים עבור inodes. יש 200,000,000 בלוקים של DATA לכן נדרש 6104 בלוקים עבור data bitmap לפי סדר ברירת המחדל של VSFS נקבל: אזור inode bitmap ראשון לכן i_bmap_start הוא 2 אזור data bitmap שני לכן יתחיל אחרי 367 בלוקים נוספים – d_map_start הוא 369 אזור inodes שלישי לכן יתחיל אחרי 6104 בלוקים נוספים – inode_start הוא 6473. אזור data רביעי לכן יתחיל אחרי 375,000 בלוקים נוספים – data_start הוא 381473 בכל בלוק נכנסים 1028 מצביעים, לכן גודל הקובץ המקסימלי max_file_size הוא: (9 + 2*1024 + 1024^2) * 4KB\n2. כדי למחוק קובץ אין צורך לגשת לכל הבלוקים שלו, אך כן נדרש לסמן את כל הביטים של כל הבלוקים שלו ב- data bitmap. הבלוקים האלו כוללים לא רק את אלו המייצגים את נתוני הקובץ אלא גם את הבלוקים של המצביעים. יש בלוק 1 של מצביעים במצביע העקיף, ועוד 1+1024 דרך המצביע העקיף הכפול. מאחר שמתואר המקרה המקסימלי, זה ידרוש גישה (קריאה + כתיבה) של כל 6104 הבלוקים ב-data bitmap. כדי לדעת באילו בלוקים נמצאים נתוני הקובץ נצטרך לקרוא את כל הבלוקים של המצביעים עצמם: 2 בלוקים של המצביעים הישירים ועוד 1+1024 של המצביע העקיף, וגם לקרוא את ה-inode של הקובץ: עוד 1028 קריאות. בנוסף, נדרש למחוק את הקובץ מהתיקייה המכילה אותו – קריאה וכתיבה של ה-inode של התיקייה וגם של ה-DATA של אותה תיקייה (זה הקובץ היחיד לכן יופיע בבלוק DATA הראשון של התיקייה): קריאה וכתיבה של 2 בלוקים. לסיום נצטרך לקרוא ולכתוב בלוק אחד של inode bitmap כדי לסמן שהקובץ מחוק. יש לשים לב שלא נדרש לכתוב אל ה-inode של הקובץ – כדי למחוק קובץ נעדכן ב-inode bitmap ואין צורך לשנות כלום ב-inode עצמו. קריאה של 7135 בלוקים (1 + 2 + 1028 + 6104) כתיבה של 6107 בלוקים (1 + 2 + 6104)\n3. לפי גודל הקובץ (40,000) הנתונים שלו תופסים 10 בלוקים של DATA. לפי מבנה ה-inode ל-9 הראשונים ניגש ממצביע ישיר, ואל העשירי דרך מצביע עקיף. אלו הפעולות שיש לבצע: 1. קריאת inode של התיקייה ואז DATA כדי לאתר את הכניסה של d1. 2. קריאת inode של d1 ואז ה-DATA כדי לאתר את הכניסות של x,y,z. 3. מחיקת x: קריאת ה-inode של x, קריאת בלוק מצביעים, לאחר מכן קריאה וכתיבה של ה-data bitmap לשחרור כל הנתונים של x (במקרה המינימלי הכל באותו בלוק), ובנוסף קריאה וכתיבה של בלוק אחד של inode bitmap לשחרור x. 4. מחיקת ע: קריאת ה-inode, זה hard-link לכן נדרש רק לעדכן את ה-inode לקישור אחד פחות. 5. מחיקת z: כמו מחיקת x אך מכיל רק בלוק DATA יחיד עם תוכן הקישור הסימבולי. 6. מחיקת הרשומות מהתיקייה לא נספרת כי התיקייה נמחקת כולה (אין צורך לעדכן נתונים). 7. מחיקת d1: עדכון (קריאה וכתיבה) של data bitmap וגם inode bitmap. 8. עדכון התיקייה הנוכחית (בה נמצא (d1): קריאת inode, קריאה ועדכון של DATA. במקרה המינימלי, כל ה-inodes באותו בלוק (ובהתאם ב-inode bitmap) וכל ה-DATA נמצאים באותו בלוק data bitmap, לכן יש רק קריאה וכתיבה אחת לכל אחד מאלו. נקבל סה\"כ: 7 קריאות ו-4 כתיבות."
      },
      "difficulty_estimation": "Hard"
    }
  ]
}