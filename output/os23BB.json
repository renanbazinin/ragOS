{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2023",
    "semester": "Semester B",
    "moed": "Moed B",
    "exam_date": "16.07.2023",
    "source_file": "os23BB.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Memory Management",
        "Virtual Memory",
        "Paging"
      ],
      "content": {
        "text": "אם הזיכרון הראשי (RAM) מלא, הקצאת זיכרון של דף חדש לתהליך בהכרח גוררת כתיבה לשטח ההחלפה ( swap space).\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. אם יש מסגרת לפינוי עבורה 0=Dirty, אין צורך לכתוב ל-swap."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Semaphores",
        "Concurrency"
      ],
      "content": {
        "text": "כל מימוש תקין של סמפור הוא הוגן.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. מימוש הסמפור המובנה בלינוקס הוא הוגן, אך בהגדרת אובייקט הסנכרון אין חובה לממש הוגנות. יש להבדיל מאובייקט כמו מנעול קוראים-כותבים שאינו הוגן – בגלל אופן השימוש בסמפורים/מנעולים הפנימיים. זה לא מפריך את הטענה שכן הסמפורים/מנעולים הפנימיים כן הוגנים, רק האובייקט שנוצר (שאינו הסמפור) אינו הוגן."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "Security"
      ],
      "content": {
        "text": "ב-LFS ניתן להוסיף מנגנון להתמודדות עם קריסות.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. ע\"י שימוש בטרנזקציות בדומה ל-journaling נוכל להבטיח התמודדות עם קריסות."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Processes",
        "Virtual Memory",
        "System Calls"
      ],
      "content": {
        "text": "בביצוע ()fork ללא copy-on-write, ישוכפל כל הזיכרון של תהליך האב.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. שטחי זיכרון שאינם ניתנים לכתיבה (כמו הקוד / TEXT) עדיין ישותפו ולא ישוכפלו."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Scheduling",
        "CPU Scheduling",
        "Processes"
      ],
      "content": {
        "text": "החלק של אלגוריתם התזמון שבוחר את התהליך הבא לביצוע ממומש כולו בתוכנה ולא בחומרה.\nנכון / לא נכון",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. תהליך הוא מבנה נתונים של הקרנל, לכן בחירת התהליך הבא לביצוע בהכרח מתבצעת ע\"י הקרנל בלבד – בקוד של מערכת ההפעלה."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "CodeAnalysis",
      "topic": [
        "Processes",
        "System Calls",
        "Concurrency",
        "Scheduling"
      ],
      "content": {
        "text": "נתונה התוכנית הבאה: \nנתון שיש מעבד יחיד ואלגוריתם התזמון הוא FIFO, וניתן להניח שכל קריאות המערכת הצליחו.\nתזכורת: יש לצרף הסבר ברור לכל סעיף.",
        "code_snippet": "1 int main()\n2 {\n3   int arr[N]={0}; // init all to 0\n4   char *e[] = {\"echo\", \"hello\",NULL};\n5   setbuf(stdout, NULL);\n6 \n7   for(int i = 0; i < N; ++i)\n8     arr[i] = (fork() > 0); // 0 or 1\n9 \n10  for(int i = 0; i < N; ++i)\n11    printf(\"%d \", arr[i]);\n12 \n13  if (arr[0])\n14    execvp(e[0], e);\n15  else\n16    printf(\"\\n\");\n17 }",
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "כתבו פלט אפשרי של התוכנית כאשר מתקיים 3=N.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "כמה תהליכים נוצרו במהלך ריצה תקינה של התוכנית, כולל התהליך הראשי, עבור ערך כלשהו של N? (כלומר, התשובה צריכה להיות פונקציה של N).",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "כיצד ישתנה פלט התוכנית אם אלגוריתם התזמון הוא MLFQ במקום FIFO?\nיש לענות לגבי המקרה הכללי ולא ביחס לסעיפים קודמים. אין צורך לכתוב את הפלט החדש, אלא לתאר בפירוט מה השינוי שיתרחש.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.4",
          "text": "כיצד ישתנה פלט התוכנית אם בתנאי בשורה 13 נבדוק את [1-arr[N במקום [0]arr?\nיש לענות לגבי המקרה הכללי ולא ביחס לסעיפים קודמים. אין צורך לכתוב את הפלט החדש, אלא לתאר בפירוט מה השינוי שיתרחש.",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. פלט התהליכים יהיה לפי סדר היצירה שלהם, כאשר בכל תהליך במערך arr יהיו ערכי ההחזר של כל קריאות ה-fork לפי נקודת מבטו (1 אם היה אב, 0 אם בן). כל תהליך שאינו שתת-עץ התהליך שנוצר קריאת ה-fork הראשונה מדפיס גם hello בגלל הקריאה ל-execvp.\n1 1 1 hello\n011\n10 1 hello\n1 1 0 hello\n001\n010\n100 hello\n000\n2. בכל קריאה ל-fork מוכפל מספר התהליכים, סה\"כ 2^N תהליכים.\n3. תוכן ההדפסות יישאר זהה (כל תהליך ידפיס את אותו דבר), אך סדר ההדפסות ישתנה – כל סדר הדפסות יהיה אפשרי עם הפלטים הנתונים, כולל ערבוב בין הדפסות התהליכים.\n4. אותו מספר תהליכים ידפיסו hello, אך אלו יהיו תהליכים שונים – כל התהליכים שהם לא עלה בעץ התהליכים ידפיסו hello (בעצם, כל התהליכים שהם תהליכי האב בקריאה האחרונה ל-fork בלולאה הראשונה)."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Threads",
        "Concurrency",
        "Atomic Operations",
        "Mutexes",
        "Semaphores"
      ],
      "content": {
        "text": "בסניף קופת חולים מקומי יש N חדרים אליהם מטופלים יכולים להיכנס.\nכל מטופל שמגיע מקבל מספר וממתין לתורו. כאשר מגיע תורו, המטופל נכנס לחדר המתאים עד לסיום הטיפול. אין הבדל בין החדרים וכל מטופל יכול לקבל טיפול בכל חדר, אך בכל חדר יש לטפל במטופל אחד בלבד בכל רגע נתון.\nלצורך מחשוב הסניף הוחלט לייצג כל מטופל ע\"י חוט ולהשתמש באובייקט סנכרון עם הפעולות הבאות:\nget_number – מטופל קורא לפעולה זו עם הגיעו לסניף ומקבל חזרה את המספר שלו בתור. יש להחזיר מספרים בסדר עולה (כלומר, החל מ-0 ללא דילוגים או כפילויות). אין צורך לטפל ב-overflow.\nwait_for_room – מטופל קורא לפעולה זו מיד לאחר קבלת המספר. הפעולה חוזרת רק כאשר הגיע תורו של המטופל, ומחזירה את מספר החדר (0 עד 1-N) אליו המטופל צריך להיכנס. לאחר שפעולה זו חוזרת, המטופל מיד נכנס לחדר המתאים.\nleave_room – מטופל קורא לפעולה זו לאחר סיום הטיפול, כאשר הוא עוזב את החדר. לאחר הקריאה לפעולה זו (ורק לאחריה), החדר המתאים פנוי לקבלת מטופל נוסף.\nבשאלה זו יש לממש את אובייקט הסנכרון עבור הסניף כך שחוטים שונים יוכלו לקרוא לפעולות אלו במקביל והמערכת תעבוד באופן תקין:\nבכל רגע נתון, בכל חדר יש לכל היותר מטופל אחד.\nאם יש חדר פנוי ויש מטופלים ממתינים, מטופל כלשהו יכנס לחדר.\nמטופלים יכנסו לחדרים לפי הסדר של מספרי התור שלהם. כלומר, לא יתכן מצב שבו מטופל עם תור 1+X נכנס לטיפול בחדר כלשהו בזמן שמטופל X חסום (ואין חדר פנוי עבורו).\nניתן להניח שימוש נכון באובייקט הסנכרון, כך שכל מטופל קורא לפעולות אלו לפי הסדר ומעביר את הארגומנטים הנכונים.\nלצורך הפתרון הוגדר הקבוע N והמשתנים הגלובליים הבאים:\nint r[N] = {0}; // init all to 0\nint next = 0, turn = N-1;\nאין להוסיף משתנים גלובליים או סטטיים.\nמותר להשתמש בפעולות מכונה אטומיות שנלמדו (רמז: fetch_and_add, test_and_set).\nיש לתאר בקצרה את הפתרון ולכתוב קוד ברור.\nתיאור הפתרון:",
        "code_snippet": "int get_number() {\n}\nint wait_for_room(int myNumber) {\n}\nvoid leave_room(int myRoom) {\n}",
        "options": null
      },
      "sub_questions": null,
      "points": 25,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "הפתרון נעזר ב-F&A כדי להגדיר תור לכל חוט ולעבור לתור הבא (בדומה למנעול ticket lock).\nכדי לתפוס חדר, כל חוט ממתין לתורו (יש N במקביל) ואז מנסה לתפוס חדר עם פעולת TAS אשר מבטיחה שלא יקרה מצב ש-2 חוטים נכנסים לאותו חדר. למעשה כל חדר הוא מעין מנעול TAS, וכל חוט מנסה לתפוס פעם אחת את המנעול של כל חדר (מובטח שיצליח מאחר שיש N חוטים ו-N חדרים).. המערך r הוא מערך בוליאני המציין לכל חדר אם הוא פנוי או תפוס. חובה להשתמש ב-TAS בגלל שיש N חוטים שעלולים לנסות לתפוס חדר במקביל.",
        "code_snippet": "int r[N] = {0};\nint next = 0, turn = N-1;\n\nint get_number() {\n    return fetch_and_add(&next);\n}\nint wait_for_room(int myturn) {\n    while (myturn > turn);\n    for (int i = 0; i < N; ++i) {\n        if (!test_and_set(r[i]))\n            return i;\n    }\n}\nvoid leave_room(int myRoom) {\n    r[myRoom] = 0;\n    fetch_and_add(&turn);\n}"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Memory Management"
      ],
      "content": {
        "text": "נתון דיסק קשיח ועליו מערכת קבצים VSFS עם שדרוג: בכל inode יש מקום ל-128 בתים של נתונים של הקובץ. בתים אלו נשמרים בשדה בתוך ה-inode עצמו, ולא בתוך בלוק DATA כמו שאר נתוני הקובץ. רק כאשר גודל הקובץ חורג מכמות זו, מערכת הקבצים תשתמש במצביעים עבור המשך נתוני הקובץ. כמו-כן נתון:\nגודל בלוק הוא 4KB וגודל מצביע הוא 4 בתים.\nגודל inode הוא 256 בתים (כולל 128 הבתים של הנתונים).\nבכל inode יש 5 מצביעים ישירים, 2 מצביעים עקיפים, 1 מצביע עקיף כפול, ו-1 מצביע עקיף משולש.\nבנתונים (DATA) של תיקייה קיימת טבלה עם 2 עמודות, גודל כל שורה בטבלה הוא מספר התווים בשם הקובץ (בית אחד לכל תו) + 8 בתים נוספים.\nגודל הנתונים של קישור סימבולי הוא בית אחד לכל תו.\nיש לפרט ולנמק את כל החישובים בכל סעיף.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה בלוקים של DATA הוא יתפוס?\nגודל מקסימלי:\nכמות בלוקים:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "משתמש פתח את הקובץ: /home/mta/a.txt\nידוע שקובץ זה הוא קישור סימבולי אל הקובץ: /usr/local/bin/ls\nנתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה. כמה בלוקים צריך לקרוא ולכתוב במקרה המינימלי בשביל לבצע את הפעולה?\nניתן להניח כל תרחיש שיוביל למספר הבלוקים המינימלי כל עוד הוא עומד בנתונים ובמגבלות שצוינו.\nמספר בלוקים מינימלי לקריאה:\nלכתיבה:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "סטודנט טען שהשדרוג הנתון (128 בתים של נתונים בתוך ה-inode עצמו) צפוי להביא להשפעה מועטה מאוד על הביצועים של מערכת הקבצים. הסבירו מדוע הוא צודק.",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. בכל בלוק עקיף נכנסים 4096/4 = 1024 מצביעים.\nלפי המצביעים ב-inode נקבל 1024^3 + 1024^2 + 1024*2 + 5 בלוקים עם נתוני הקובץ, לזה נוסיף את 128 הבתים בתוך ה-inode עצמו בשביל: (1024^3 + 1024^2 + 2048 + 5)*4KB + 128B.\nבשביל כמות הבלוקים נוסיף את הבלוקים של המצביעים – 2 עקיפים, אחד עקיף כפול שמוביל לעוד 1024 עקיפים, ואחד עקיף משולש שמוביל ל-1024 עקיפים כפולים ו-1024^2 עקיפים.\nסה\"כ נקבל: 5 + 2+2048 + 1+1024+1024^2 + 1+1024+1024^2+1024^3.\n2. במינימום, כל התיקיות לאורך הדרך מכילות את הרשומות שאנו נדרשים אליהן בתוך 128 הבתים של ה-inode, כך שיש רק לקרוא את ה-inode בדרך:\nשל השורש, אז home ואז mta ואז a.txt.\nמכאן נקרא את usr (השורש כבר נטען) ואז local ואז bin.\nבנוסף יש לעדכן את זמני הגישה אל a.txt ואל ls.\nבמקרה המינימלי, כל ה-inodes נמצאים באותו בלוק ולכן נבצע את כל הפעולה בקריאה אחת וכתיבה אחת.\n3. השיפור עוזר בקריאה של קבצים קטנים, אך כפי שלמדנו במערכות היום רוב הנתונים גם ככה ב-cache ונבצע מעט קריאות כאלו, לכן השיפור עלול להיות קטן מאוד."
      },
      "difficulty_estimation": "Hard"
    }
  ]
}