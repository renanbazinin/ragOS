{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2024",
    "semester": "Semester A",
    "moed": "Moed C",
    "exam_date": "30.04.2024",
    "source_file": "os24AC.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "CodeAnalysis",
      "topic": [
        "Processes",
        "System Calls",
        "Concurrency"
      ],
      "content": {
        "text": "נתונה התוכנית הבאה:",
        "code_snippet": "int main (int argc, char *argv[])\n{\nint N = 2;\nchar* args[] = {\"echo\", \"Done\", NULL};\npid_t pid;\n\nfor (int i = 0; i < N; ++i)\n{\nprintf (\"%d %d\\n\", getpid(), i);\nif (!fork())\nprintf (\"1: %d [%d]\\n\", getpid(), getppid());\nelse if (!fork())\nprintf (\"2: %d [%d]\\n\", getpid(), getppid());\nelse\nbreak; // exit for-loop\n}\nwait(NULL);\nwait(NULL);\nprintf (\"pid = %d\", getpid());\nexecvp(args[0], args);\nprintf(\"BYE BYE\\n\");\nreturn 0;\n}"
      },
      "sub_questions": [
        {
          "id": "1.1",
          "text": "כתבו פלט אפשרי של התוכנית בהנחה שכל הקריאות ל-fork הצליחו.\nהניחו שמזהה התהליך הראשי הוא 100, וכל תהליך שנוצר מקבל מזהה עוקב (101, 102, וכן הלאה).",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "1.2",
          "text": "כמה תהליכים נוצרו במהלך ריצת התוכנית, כולל התהליך הראשי?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "1.3",
          "text": "נניח שהערך של N אינו ידוע (אך לכל הפחות 0). כמה תהליכים נוצרו במהלך ריצת התוכנית כולל התהליך הראשי, כפונקציה של N?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1.1. 100 0\n1: 101 [100]\n101 1\n1: 102 [101]\npid = 102 Done\n2: 103 [101]\npid = 103 Done\npid = 101 Done\n2: 103 [100]\n103 1\n1: 104 [103]\npid = 104 Done\n2: 105 [103]\npid = 105 Done\npid = 103 Done\npid = 100 Done\n\n1.2. נוצרו 7 תהליכים.\nהתהליך הראשי יוצר 2 בנים, וכל אחד מהם יוצר 2 בנים.\n\n1.3. באיטרציה הראשונה התהליך הראשי יוצר 2 בנים.\nבכל איטרציה, כל התהליכים שנוצרו באיטרציה הקודמת (ורק הם) יוצרים 2 בנים כל אחד.\n1+2+4+.... = 2N+1-1"
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "Open",
      "topic": [
        "Scheduling",
        "Deadlocks",
        "Synchronization",
        "Semaphores"
      ],
      "content": {
        "text": "מצב של priority inversion מתרחש כאשר אלגוריתם התזמון גורם לקיפאון (deadlock) בגלל שתהליך ממתין המתנה פעילה למשאב (busy-wait) המוחזק ע\"י תהליך אחר שלעולם אינו מתוזמן.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "2.1",
          "text": "באילו מאלגוריתמי התזמון הבאים אפשרי להגיע למצב של priority inversion?",
          "code_snippet": null,
          "options": [
            "First Come First Served (FCFS)",
            "overlap עם SRTF",
            "Round-Robin (RR)",
            "עם כל השיפורים Multi-Level Feedback Queue (MLFQ)"
          ]
        },
        {
          "id": "2.2",
          "text": "נתונים קטעי הקוד הבאים ל-3 חוטים של אותו תהליך:\nThread 1\nwhile (1) {\nsem_wait(&U);\nprintf(\"3\");\nsem_post(&T);\n}\nThread 2\nwhile (1) {\nsem_wait(&S);\nprintf(\"2\");\nsem_post(&U);\n}\nThread 3\nwhile (1) {\nsem_wait(&T);\nprintf(\"1\");\nsem_post(&S);\n}\nאין חוטים נוספים בתהליך, ו-S,T,U סמפורים. נתון שהסמפור S אותחל לערך 1 (ערך האתחול של T,U לא ידוע). האם קיימת ריצה שתוביל לקיפאון?",
          "code_snippet": "Thread 1\nwhile (1) {\nsem_wait(&U);\nprintf(\"3\");\nsem_post(&T);\n}\nThread 2\nwhile (1) {\nsem_wait(&S);\nprintf(\"2\");\nsem_post(&U);\n}\nThread 3\nwhile (1) {\nsem_wait(&T);\nprintf(\"1\");\nsem_post(&S);\n}",
          "options": [
            "קיימת",
            "לא קיימת"
          ]
        },
        {
          "id": "2.3",
          "text": "האם קיימים 3 ערכי אתחול עבור הסמפורים S T U כך שהפלט שיודפס למסך יהיה תמיד לפי הסדר 1 ואז 2 ואז 3 שוב (123123123...)? אם כן, יש לציין את 3 הערכים ולהסביר, אחרת יש להסביר מדוע לא.",
          "code_snippet": null,
          "options": [
            "קיימים",
            "לא קיימים"
          ]
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "2.1. FCFS – לא אפשרי. תהליך רץ מהתחלה ועד הסוף, לא יתכן שתהליך ממתין למשאב של תהליך אחר (התהליך האחר עוד לא רץ ולכן לא מחזיק במשאב, או הסתיים ולכן שחרר את המשאב).\nSRTF – אפשרי. תהליך ארוך עלול להחזיק במשאב שתהליך קצר ממתין לו, בזמן שתהליכים קצרים אחרים כל הזמן מגיעים ולכן התהליך הארוך לא מתוזמן.\nRR – לא אפשרי. כל תהליך יקבל זמן ריצה בסופו של דבר.\nMLFQ – לא אפשרי. בגלל priority boost, כל תהליך יקבל זמן ריצה בסופו של דבר.\n\n2.2. לא. חוט 2 יכול לבצע לפחות איטרציה אחת של הלולאה, מה שמאפשר לחוט 1 לבצע לפחות איטרציה של הלולאה, מה שמאפשר לחוט 3 לבצע, וחזרה לחוט 1 וכו'.\n\n2.3. קיימים: S=0,T=1,U=0 יבטיח את הפלט הנדרש."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "Open",
      "topic": [
        "File Systems",
        "Memory Management",
        "I/O"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS עם הנתונים הבאים:\n- גודל בלוק הוא 512 בתים.\n- גודל מצביע הוא 8 בתים.\n- גודל inode הוא 512 בתים.\n- בכל inode יש 10 מצביעים ישירים, מצביע עקיף אחד, מצביע עקיף כפול אחד, ומצביע עקיף משולש אחד.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "3.1",
          "text": "משתמש יצר קובץ חדש בגודל 50KB. לכמה בלוקים בדיסק יש לכתוב כדי להשלים את הפעולה, במקרה המינימלי?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "3.2",
          "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה בלוקים של DATA הוא יתפוס?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "3.3",
          "text": "סטודנט טען שעבור קריאה של 4 קבצים שונים בגודל 25KB כל אחד נדרשות פחות קריאות של בלוקים בדיסק מאשר עבור קריאה של קובץ אחד בגודל 100KB. האם הוא צודק?",
          "code_snippet": null,
          "options": [
            "הסטודנט צודק",
            "הסטודנט טועה"
          ]
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "הסטודנט טועה",
        "explanation": "3.1. 107.\nבכל בלוק עקיף יש 64 מצביעים.\nכתיבה ל-inode bitmap, כתיבה ל-data bitmap (כל הביטים יהיו באותו בלוק), כתיבה ל-inode (אותו בלוק עם התיקייה המכילה את הקובץ), כתיבה ל-10 בלוקים בהצבעה ישירה, כתיבה לבלוק עקיף + 64 בלוקים של DATA שמצביע אליהם, כתיבה לבלוק עקיף כפול + בלוק עקיף יחיד שהכפול מצביע אליו + 26 בלוקים של DATA שמצביע אליהם, כתיבה לבלוק DATA של התיקייה לעדכון שלו עם רשומה נוספת עבור הקובץ החדש.\n\n3.2. (10 + 1+64 + 1+64+64^2 + 1+64+64^2+64^3)*512B.\n10 מצביעים ישירים – 10 בלוקים של DATA.\nמצביע עקיף – 1 בלוק מצביעים + 64 בלוקים של DATA.\nמצביע עקיף כפול – 1+64 בלוקים של מצביעים + 64^2 בלוקים של DATA.\nמצביע עקיף משולש – 1+64+64^2 בלוקים של מצביעים + 64^3 בלוקים של DATA.\n\n3.3. הסטודנט טועה.\nלכל קובץ קטן נדרש לגשת ל-52 בלוקים: קריאת inode + 10 בלוקים של DATA מהמצביעים הישירים + בלוק עקיף + 40 בלוקים של DATA מהמצביע העקיף. סה\"כ 208 בלוקים עבור 4 הקבצים.\nעבור הקובץ הגדול נדרשות 205 גישות: קריאת inode + 10 בלוקים של DATA מהמצביעים הישירים + בלוק עקיף + 64 בלוקים של DATA מהמצביע העקיף + בלוק עקיף כפול + 2 בלוקים של מצביעים עקיפים מהבלוק העקיף הכפול + 64 בלוקים של DATA מהבלוק הראשון + 62 בלוקים של DATA מהבלוק השני."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 4,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems",
        "Security"
      ],
      "content": {
        "text": "נתונה מערכת עם מנגנון 5-RAID, גודל chunk של בלוק אחד ו-5 דיסקים קשיחים (ממוספרים 1-5), כאשר בלוק ה-parity ב-stripe הראשון נמצא בדיסק 5, השני בדיסק 4, וכן הלאה באופן מעגלי.\nלכל אחד מהדיסקים הקשיחים יש את הנתונים הזהים הבאים:\nמהירות סיבוב: 6000 RPM\nזמן seek ממוצע: 15ms\nבכל רצועה (track) בדיסק יש 5 בלוקים.\nמהירות העברת המידע תוכננה כך שנוכל להעביר את המידע ברצועה אחת תוך כדי זמן סיבוב אחד בדיוק.\nהבלוקים ממוספרים החל מ-0, כלומר מספר הבלוק הלוגי הראשון במערך (RAID) הוא 0 ומספר הבלוק הפיזי הראשון בכל דיסק הוא 0. לפי כך, ה-stripe הראשון מכיל את הבלוקים הלוגיים 0-3.\nנתון שדיסק מספר 2 התקלקל ולאחר מכן משתמש ביצע פעולת קריאה לבלוקים הלוגיים 20-22, ונתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nהפעולה בוצעה בהצלחה ע\"י שימוש בשאר הדיסקים בהתאם לאופן הפעולה של 5-RAID.\nמהו הזמן הקצר ביותר בו הפעולה יכולה להתבצע? יש להזניח את זמן ביצוע החישובים במידה ונדרשים חישובים כלשהם.\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": null,
      "points": 10,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "זמן הסיבוב הוא 10ms.\nבכל רצועה יש 5 בלוקים לכן הזמן לקריאת בלוק בודד הוא 2ms.\nבלוקים לוגיים 20-22 נמצאים באותו stripe בדיסקים שונים. בלוק 22 נמצא בדיסק 2 שהתקלקל, כדי לקרוא אותו נצטרך לקרוא את כל שאר הנתונים ב-stripe ולבצע XOR – כלומר נצטרך את בלוקים 20,21,23 ואת ה-parity.\nבזמן הקצר ביותר, בכל הדיסקים הראש הקורא-כותב נמצא כבר במיקום ולא תהיה המתנה לסיבוב, נקרא את כל הבלוקים במקביל – זמן הפעולה יהיה זמן הקריאה של בלוק אחד: 2ms."
      },
      "difficulty_estimation": "Hard"
    }
  ]
}