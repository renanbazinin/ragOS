{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2024",
    "semester": "Semester B",
    "moed": "Moed B",
    "exam_date": "30.07.2024",
    "source_file": "os24BB.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "I/O",
        "Disk Scheduling"
      ],
      "content": {
        "text": "מה תפקידו של ה-servo burst?",
        "code_snippet": null,
        "options": [
          "א. לתקן שגיאות מיקום של הראש הקורא-כותב.",
          "ב. לקשר בין קובץ לבין מיקום ה-DATA שלו בדיסק.",
          "ג. לפרט את מיקומי האזורים השונים של מערכת הקבצים.",
          "ד. ליידע באיזה משטח (surface) נמצא כרגע הראש הקורא-כותב.",
          "ה. לאפשר לראש הקורא-כותב לדעת את כמות הסקטורים ברצועה."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "א",
        "explanation": "א' ה-servo burst הוא רצף נתונים מיוחד בדיסק שעוזר לראש הקורא-כותב לוודא את המיקום שלו ולתקן שגיאות מיקום שהצטברו כתוצאה מהתנועה."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "Memory Management"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS המשתמשת ב-free list למציאת שטח פנוי. איזו טענה נכונה לגבי מערכת קבצים זו, בהשוואה לשימוש ב-bitmap?",
        "code_snippet": null,
        "options": [
          "א. ניתן לנצל יותר שטח בדיסק.",
          "ב. מציאת שטח זיכרון פנוי רצוף תהיה קלה יותר.",
          "ג. נוכל להשתמש באותו בלוק DATA עבור קבצים שונים.",
          "ד. נוכל לנצל פחות זיכרון בכל בלוק DATA בשימוש, בגלל הצורך לשמור מצביע לבלוק הבא.",
          "ה. כל התשובות נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "א",
        "explanation": "א'. השימוש ב-free list אומר שלא נדרש שטח ייעודי בדיסק ולכן ניתן לנצל יותר שטח בדיסק במקום ה-bitmap. השימוש במצביעים בתוך הבלוקים מבוצע רק בבלוקים שאינם בשימוש – ולכן לא מבזבז נפח כלל."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Concurrency",
        "Synchronization",
        "Threads",
        "Processes"
      ],
      "content": {
        "text": "מה זה מרוץ / מצב מרוץ (race condition)?",
        "code_snippet": null,
        "options": [
          "א. קוד שרץ במקביל בחוטים שונים.",
          "ב. קוד שנכונות התוצאה שלו תלויה במתזמן.",
          "ג. קוד בו מספר חוטים ניגשים לאותו משאב משותף.",
          "ד. קוד קריטי שמחייב שימוש במנעול עבור מניעה הדדית.",
          "ה. כל התשובות נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ב",
        "explanation": "ב'. מרוץ הוא קטע קוד אשר נכונות התוצאה שלו תלויה בתזמון החוטים/תהליכים."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 4,
      "type": "CodeAnalysis",
      "topic": [
        "Processes",
        "System Calls",
        "IPC"
      ],
      "content": {
        "text": "נתון קטע הקוד הבא, של תוכנית בשם execme:\nהריצו את קטע הקוד, והתהליך שנוצר קיבל את מזהה התהליך 300.\nניתן להניח שכל קריאות המערכת הצליחו, לא נוצרו תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.\nאיזו טענה בהכרח נכונה?",
        "code_snippet": "int main()\n{\nchar* args[] = {\"execme\", NULL};\nif (!fork()) {\nexecvp(args[0], args);\nprintf(\"PID: %d\\n\", getpid());\n}\n}",
        "options": [
          "א. לא יהיה פלט לתוכנית.",
          "ב. הפלט יהיה \"300 :PID\" אינסוף פעמים (עד לעצירת התוכנית).",
          "ג. הפלט יהיה \"301 :PID\", לאחר מכן \"302 :PID\", וכן הלאה (עד לעצירת התוכנית).",
          "ד. התוכנית תקרוס בשלב מסוים בגלל יצירה של יותר מדי תהליכים.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "א",
        "explanation": "א'. תוכנית זו קוראת לעצמה במעין לולאה אינסופית, כך שבכל פעם נוצר תהליך בן שקורא לתוכנית מהתחלה ותהליך האב מסיים. קריאת execvp לא חוזרת ולכן התוכנית תמשיך לרוץ אך לא תדפיס אף פלט."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Threads",
        "Concurrency",
        "Memory Management",
        "Atomic Operations"
      ],
      "content": {
        "text": "נתון תהליך מרובה חוטים אשר משתמש במשתנה משותף. איזו טענה בהכרח נכונה?",
        "code_snippet": null,
        "options": [
          "א. כל כתיבה למשתנה תגרור הודעה לגביו ב-bus.",
          "ב. לכל מעבד תמיד יהיה עותק משלו של המשתנה (ב-cache של המעבד).",
          "ג. בכל רגע נתון יהיה רק עותק אחד של המשתנה (ב-cache של אחד המעבדים).",
          "ד. אם הגישה למשתנה היא לקריאה בלבד, לעולם לא תעבור הודעה לגביו ב-bus.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. כאשר ניגשים למשתנה משותף, תמיד יתכן שתעבור לגביו הודעה ב-bus (אפילו אם הגישה רק לקריאה – כדי לקבל את ערכו ולהכניס ל-cache). כתיבה למשתנה לא תמיד גוררת הודעה ב-bus, אלא רק אם נדרשת לנו גישה אקסקלוסיבית אל המשתנה (הודעת invalidate). משתנה משותף יכול להיות ב-cache של כל מעבד (או אף מעבד)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Memory Management",
        "Virtual Memory",
        "Paging"
      ],
      "content": {
        "text": "נתונה מערכת בה כל תהליך משתמש בטבלת דפים היררכית עם 3 רמות, כאשר לכל טבלה מוקצה מסגרת (גודל כל חלק/טבלה בטבלת הדפים הוא דף) וכל כניסה בטבלת הדפים היא בגודל 16 ביטים.\nנתון תהליך אשר זה החלק הראשון ברמה התחתונה של טבלת הדפים שלו (זו תת-הטבלה PT0 המלאה, המכילה את המיפויים עבור דפים 0 והלאה):\nPFN\nVPAD\nריפוד\n00000000 0\n000\n0000\n00100010 1\n000\n0000\n00011101 1\n1\n11\n0000\n000000000\n000\n0000\n00000010 1\n1\n11\n0000\n00000000 1 0\n00\n0000\n00001011 1\n1\n11\n0000\n00000000 1\n1\n00\n0000\n00011111 1\n1\n00\n0000\n00000000 1\n1\n00\n0000\n11010110 1 0\n00\n0000\n01100110 1\n1\n11\n0000\n01111111 1\n1\n1\n1\n0000\n11100000 1\n1\n11\n0000\n00000000 0\n000\n0000\n00001111 1\n1\n10 0000\n.P=Present, V=Valid, A=Access (Reference)D=Dirty :כאשר נתון ,PTE כל שורה בטבלה מייצגת\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "מה גודל הזיכרון הפיזי המקסימלי במערכת?\nזיכרון פיזי:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "מה גודל הזיכרון הוירטואלי של תהליך?\nזיכרון וירטואלי:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "מלבד הנתון בטבלה הנ\"ל, ידוע שהתהליך משתמש ב-15 דפים נוספים כאשר 3 מהם רצופים בזיכרון הוירטואלי של התהליך (עבור כולם: 0=P).\nכמה זיכרון פיזי תתפוס טבלת הדפים כולה של התהליך (הסכום הכולל בכל הרמות יחד) במקרה המינימלי ובמקרה המקסימלי, ומה מספר הכניסות שהן valid (הסכום הכולל בכל הרמות יחד) בכל אחד מהמקרים? יש לכלול בתשובות גם את החלק הטבלה הנתון בשאלה.\nגודל מינימלי:\nנימוק:\nמספר כניסות valid:\nגודל מקסימלי:\nנימוק:\nמספר כניסות valid:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. הטבלה היא בגודל דף – יש בה 16 רשומות של 16 ביטים, כלומר גודל דף הוא 32B.\nה-PFN הוא 8 ביטים לפי הטבלה כלומר שיש 256 מסגרות בזיכרון הפיזי, כל אחת בגודל 32B לכן גודל הזיכרון פיזי הוא 8KB.\n2. ידוע שיש 3 רמות ולפי הטבלה הנתונה יש 16 רשומות בכל טבלה (בכל רמה).\nטבלה אחת ברמה העליונה, 16 טבלאות ברמה האמצעית, 16^2 טבלאות ברמה התחתונה.\nבכל טבלה 16 רשומות לכן לתהליך יש סה\"כ 16^3 דפים בזיכרון הוירטואלי, גודל דף 32B ולכן גודל הזיכרון הוירטואלי הוא 128KB\n3. במקרה המינימלי כל 15 הדפים הנוספים נמצאים באותה טבלה ברמה התחתונה, כלומר חלק אחד של הטבלה עם 15 רשומות שהן valid.\nטבלה זו שונה מהטבלה הנתונה אבל ההצבעה אליה (ברמה האמצעית) יכולה להיות באותה טבלה.\nכלומר: טבלה אחת ברמה העליונה (עם רשומה אחת valid), טבלה אחת ברמה האמצעית (עם 2 רשומות valid),\n2 טבלאות ברמה התחתונה (עם 13 + 15 דפים בשימוש – רשומות valid).\nסה\"כ גודל הטבלה 4 מסגרות (128B) וכמות valid כוללת: 31 רשומות.\nבמקרה המקסימלי נרצה לשים כל דף נוסף בתת-טבלה נפרדת – ברמה התחתונה וגם האמצעית, אבל 3 הדפים הרצופים יכולים להיות רק ב-2 טבלאות נפרדות ולא 3: בסוף של טבלה אחת והתחלה של הבאה. כלומר 15 הדפים הנוספים יהיו ב-14 חלקים נפרדים.\nטבלה אחת ברמה העליונה (15 רשומות valid) + 15 טבלאות ברמה האמצעית (רשומה אחת valid בכל אחת) +\n15 טבלאות ברמה התחתונה (הנתונה עם 13 רשומות valid + 15 הדפים הנוספים).\nסה\"כ גודל הטבלה 31 מסגרות (992B) וכמות valid כוללת: 58 רשומות."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Semaphores",
        "Concurrency",
        "Deadlocks",
        "Atomic Operations"
      ],
      "content": {
        "text": "נתונה מערכת המשתמשת בפתרון של מנעול קוראים-כותבים.\n.numReaders, numWriters :int במערכת מוגדרים 2 משתנים משותפים מטיפוס\n.readlock, writelock :בנוסף מוגדרים 2 סמפורים\nהמשתנים המשותפים מאותחלים ל-0 והסמפורים מאותחלים ל-1.\nלהלן המימוש של מנעול קוראים-כותבים כפי שנלמד (עם שימוש בסמפורים בינאריים במקום מנעולים):\nיש לתאר בקצרה ובבירור כל פתרון ולכתוב קוד ברור.",
        "code_snippet": "void acquire_writelock() {\nsem_wait(&writelock);\n}\nvoid release_writelock() {\nsem_post(&writelock);\n}\nvoid acquire_readlock() {\nsem_wait(&readlock);\nif (++numReaders == 1)\nsem_wait(&writelock);\nsem_post(&readlock);\n}\nvoid release_readlock() {\nsem_wait(&readlock);\nif (--numReaders == 0)\nsem_post(&writelock);\nsem_post(&readlock);\n}",
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "במימוש הנלמד של מנעול קוראים-כותבים יש עדיפות לקוראים שגורמת לבעיה של הרעבת כותבים: חוט המנסה לתפוס את המנעול לכתיבה עלול להיות חסום לזמן לא מוגבל בזמן שחוטים אחרים תופסים ומשחררים את המנעול בהצלחה.\nתארו ריצה ברורה (עם מס' חוטים כרצונכם) המדגימה את הבעיה.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.2",
          "text": "במערכת הנ\"ל עלתה דרישה לתקן את המימוש כך שתינתן עדיפות לכותבים: אם חוט מעוניין לתפוס את המנעול לכתיבה, חוטים המעוניינים לתפוס את המנעול לקריאה לא יוכלו לעקוף אותו. כלומר, חוט המנסה לתפוס את המנעול לקריאה לא יצליח לתפוס אותו כל עוד קיים חוט המנסה לתפוס את המנעול לכתיבה.\nלהלן הקוד שנכתב למימוש מנעול קוראים-כותבים עם עדיפות לכותבים:\nהקוד המתואר אינו תקין. תארו מה הבעיה וכיצד היא יכולה להתרחש.\nהבעיה:\nנימוק:",
          "code_snippet": "void acquire_writelock() {\nsem_wait(&readlock);\n++numWriters;\nsem_post(&readlock);\nsem_wait(&writelock);\n}\nvoid release_writelock() {\nsem_post(&writelock);\nsem_wait(&readlock);\n--numWriters;\nsem_post(&readlock);\n}\nvoid acquire_readlock() {\nsem_wait(&readlock);\nwhile (numWriters > 0);\nif (++numReaders == 1)\nsem_wait(&writelock);\nsem_post(&readlock);\n}\nvoid release_readlock() {\nsem_wait(&readlock);\nif (--numReaders == 0)\nsem_post(&writelock);\nsem_post(&readlock);\n}",
          "options": null
        },
        {
          "id": "7.3",
          "text": "תקנו את מימוש המנעול כך שיעבוד באופן תקין ותינתן עדיפות לכותבים.\nניתן להיעזר בפעולה האטומית fetch_and_add, אך ללא פעולות אטומיות או אובייקטי סנכרון נוספים. אין להגדיר משתנים משותפים/גלובליים נוספים, מכל סוג.\nתיאור הפתרון:",
          "code_snippet": "void acquire_writelock() {\n\n}\nvoid release_writelock() {\n\n}\nvoid acquire_readlock() {\n\n}\nvoid release_readlock() {\n\n}",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. חוט 1: קורא ותופס את המנעול בהצלחה (מוריד את writelock ל-0).\nחוט 2: כותב וממתין על writelock שיגדל ל-1.\nחוט 3: קורא ותופס את המנעול בהצלחה (מדלג על writelock בגלל חוט 1).\nחוט 1: משחרר את המנעול (מדלג על writelock בגלל חוט 3).\nחוט 1: קורא ותופס את המנעול בהצלחה (מדלג על writelock בגלל חוט 3).\nחוט 3: משחרר את המנעול (מדלג על writelock בגלל חוט 1).\nכך ניתן להמשיך עד אינסוף וחוט 2 לעולם לא יצליח לתפוס את המנעול.\n2. הבעיה: קיפאון.\nחוט 1: כותב ומגדיל את numWriters, תופס את המנעול בהצלחה.\nחוט 2: קורא ותופס את readlock, חסום בלולאה.\nחוט 1: מנסה לשחרר את המנעול אך חסום בהמתנה ל-readlock.\nלא ניתן יותר להשתמש במנעול ע\"י אף חוט.\n3. שינוי 1: נגדיל ונקטין את numWriters באופן אטומי בלי להשתמש ב-readlock, וכך קורא שממתין בלולאה לא יחסום חוטים כותבים.\nשינוי 2: קוראים ימתינו בלולאה לפני תפיסת readlock, כך גם קורא שממתין בלולאה לא יחסום חוטים כותבים שמנסים לתפוס או לשחרר את המנעול.\nשינוי 2 מספיק גם בנפרד כדי לענות על הדרישות.\nvoid acquire_writelock() {\nfetch&add(&numWriters, 1);\nsem_wait(&writelock);\n}\nvoid release_writelock() {\nsem_post(&writelock);\nfetch&add(&numWriters, -1);\n}\nvoid acquire_readlock() {\nwhile (numWriters > 0);\nsem_wait(&readlock);\nif (++numReaders == 1)\nsem_wait(&writelock);\nsem_post(&readlock);\n}\nvoid release_readlock() {\nsem_wait(&readlock);\nif (--numReaders == 0)\nsem_post(&writelock);\nsem_post(&readlock);\n}"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS המשתמשת ב-journaling, עם הנתונים הבאים:\n- גודל בלוק הוא 2KB.\n- גודל inode הוא 256B.\n- גודל מצביע הוא 4B.\n- בכל inode יש: 10 מצביעים ישירים, 2 מצביעים עקיפים, מצביע אחד עקיף כפול.\n- המערכת משתמשת ב-metadata journaling, עם journal בגודל של 250 בלוקים.\nשימו לב: נתונים אלו רלוונטיים לכל סעיפי השאלה. הנתונים הכתובים בסעיפים עצמם מתווספים לנתונים אלו אך ספציפיים לאותו סעיף ואינם תקפים לשאר הסעיפים.\nיש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "נתון דיסק קשיח בגודל 100MB שעליו נמצאת מערכת הקבצים הנ\"ל, כאשר 99MB מהדיסק הוגדרו בתור ה-data region של מערכת הקבצים.\nמה המספר המקסימלי של קבצים שניתן להחזיק במערכת הקבצים בדיסק זה?\nמספר קבצים מקסימלי:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "משתמש יצר קובץ חדש (ריק) בתיקייה שמספר ה-inode שלה ידוע מראש. נתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה (מלבד מספר ה-inode של התיקייה).\nלכמה בלוקים נדרש לכתוב במקרה המינימלי כדי להשלים את הפעולה?\nיש לפרט את הכתיבות לפי הסדר בו הן מתבצעות, ובנוסף לציין היכן יש להמתין לכתיבות שיסתיימו (fsync) ומה השלב הראשון אחריו נוכל להבטיח בוודאות שהפעולה תתבצע בהצלחה גם אם המערכת תקרוס.\nמספר כתיבות מינימלי:\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. בדיסק כולו יש 100MB שהם 51,200 בלוקים (לפי גודל בלוק 2KB).\nמתוכם 99MB שמורים ל-DATA – 50688 בלוקים.\nבכל בלוק יש 8*2048 = 16,384 ביטים, כלומר ה-data bitmap הוא בגודל 4 בלוקים (50688/16384). בנוסף נדרש בלוק 1 עבור superblock, ועוד 250 בלוקים עבור ה-journal.\nסה\"כ עד כה ניצלנו 1+25+4+50688 = 50,943 בלוקים. נשארו 257 בלוקים עבור inode וגם inode bitmap.\nבכל בלוק נכנסים 2048/256 = 8 inodes. אפשר לנצל 256 בלוקים ל-inodes בהם יהיו 2048 inodes, ובלוק אחד מספיק ל-inode bitmap של כולם.\nכלומר, במערכת יש לכל היותר inodes 2048 ולכן מקסימום 2048 קבצים.\nתשובה שגויה הייתה להתייחס לכמות הקבצים בגודל המקסימלי שנכנסים ב-DATA הזמין, אך קובץ לא חייב להיות בגודל המקסימלי (ויכול גם להיות ריק).\n2. הפעולה דורשת לעדכן את הנתונים הבאים: inode של התיקייה, inode bitmap עבור הקובץ החדש, inode של הקובץ החדש, בלוק data של התיקייה.\nבמקרה המינימלי 2 ה-inodes באותו בלוק וניתן לעדכן אותם בכתיבה אחת, ובלוק ה-data של התיקייה מכיל מקום פנוי לרשומה נוספת.\nהפעולות לפי הסדר:\nΟ כתיבת TXE.\nΟ כתיבת inode bitmap אל ה-journal.\nΟ כתיבת inode מעודכנים (תיקייה + קובץ חדש) אל ה-journal.\nΟ עדכון בלוק ה-data של התיקייה, הוספת רשומה של הקובץ החדש (אין צורך לכתוב לבלוק חדש מאחר וזו הוספה של נתונים בלבד ולא שכתוב).\nΟ .fsync\nΟ כתיבת TXE.\nΟ fsync (אחרי שלב זה הפעולה תתבצע בוודאות).\nΟ עדכון inode bitmap במערכת הקבצים עצמה.\nΟ עדכון בלוק inode במערכת הקבצים עצמה.\nסה\"כ 7 פעולות כתיבה."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 9,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems"
      ],
      "content": {
        "text": "נתונה מערכת עם מנגנון 1-RAID עם 2 עותקים (כלומר – mirroring level של 2) בו זמינים 5 דיסקים קשיחים הממוספרים 1-9, שלכל אחד מהם נפח (שטח אחסון) של 2TB.\nכמו-כן ידוע שהזמן הקצר ביותר בו יכולה להתבצע פעולה על בלוק בודד בדיסק הוא 10ms.\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "9.1",
          "text": "מה הזמן הקצר ביותר שתיקח פעולת קריאה של 10 בלוקים לוגיים רצופים?\nהזמן הקצר ביותר: ms\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "9.2",
          "text": "מה הזמן הקצר ביותר שתיקח פעולת כתיבה אל 20 בלוקים לוגיים רצופים?\nהזמן הקצר ביותר: ms\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. בגלל ה-mirroring, תמיד נוכל לסדר 10 בלוקים לוגיים רצופים כך שנדרש לקרוא 2 בלוקים מכל דיסק, לכן הזמן הקצר ביותר הוא קריאה של 2 בלוקים מכל אחד מ-5 הדיסקים. לכל דיסק 20ms והקריאות יכולות להתבצע במקביל לכן סה\"כ 20ms.\nכל בלוק יש לכתוב ל-2 דיסקים שונים (בגלל ה-mirroring). מאחר שהבלוקים רצופים ובגלל החלוקה ב-striping נקבל כתיבה של 40 בלוקים סה\"כ שמתחלקת שווה בשווה בין הדיסקים. כלומר 8 בלוקים בכל דיסק (מינימום 80ms).\nהכתיבות רצופות בכל דיסק ומתבצעות במקביל בין הדיסקים לכן 80ms."
      },
      "difficulty_estimation": "Medium"
    }
  ]
}