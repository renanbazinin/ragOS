{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2023",
    "semester": "Semester B",
    "moed": "Moed A",
    "exam_date": "25.06.2023",
    "source_file": "os23BA.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Memory Management",
        "Virtual Memory",
        "I/O"
      ],
      "content": {
        "text": "אם הזיכרון הראשי (RAM) מספיק גדול, לא נצטרך לעולם לקרוא או לכתוב נתוני תהליך מ/אל הזיכרון המשני (דיסק).",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. עדיין נצטרך לקרוא נתוני תהליך מהדיסק, לדוגמה את קוד התהליך. בנוסף יש שימוש ב-swapping גם כשהזיכרון לא בהכרח מלא, בגלל high/low watermark."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Mutexes",
        "Concurrency",
        "Deadlocks"
      ],
      "content": {
        "text": "מנעול הוגן אינו מבטיח שכל חוט שמנסה לתפוס את המנעול בהכרח יצליח לתפוס אותו בשלב מסוים.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. במרה שאף חוט אינו מצליח לתפוס את המנעול (קיפאון), או שמתקיים במערכת קיפאון/הרעבה ללא קשור לתכונות המנעול (כמו הרעבת הכותבים במנעול קוראים-כותבים, גם בשימוש במנעול הוגן)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "File Systems"
      ],
      "content": {
        "text": "ב-LFS, נעדיף להשתמש בסגמנט גדול ככל הניתן.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. סגמנט גדול ייתן ביצועים טובים יותר אך סיכון גדול יותר לאיבוד נתונים."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Processes",
        "Scheduling",
        "System Calls"
      ],
      "content": {
        "text": "תהליך יכול לעבור באופן יזום (ע\"י התהליך) ממצב Running למצב Ready.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "נכון",
        "explanation": "נכון. ע\"י קריאת המערכת yield."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Scheduling",
        "CPU Scheduling"
      ],
      "content": {
        "text": "בתזמון RR, זמן התגובה הוא אופטימלי.",
        "code_snippet": null,
        "options": [
          "נכון",
          "לא נכון"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "לא נכון",
        "explanation": "לא נכון. זמן התגובה של RR טוב אך אינו אופטימלי (וגם לא אידיאלי) אפילו עם קוונטה מינימלית, כי תהליך חדש מתווסף לסוף התור וממתין לקוונטה של כל התהליכים לפניו."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Memory Management",
        "Virtual Memory",
        "Paging"
      ],
      "content": {
        "text": "נתונה מערכת עם זיכרון וירטואלי של 1GB וגודל דף של 4KB. נתון שבכל דף/חלק של טבלת הדפים נכנסות 1024 רשומות (PTE / PDE), וה-MMU משתמש ב-5 ביטים של סטטוס. יש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "מה גודל הזיכרון הפיזי המקסימלי האפשרי במערכת זו?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "כמה רמות דרושות לטבלת הדפים במערכת זו, וכמה ביטים בכתובת הווירטואלית משמשים לכל רמה?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "תהליך ביצע הקצאת זיכרון דינמית (malloc) של 5MB. כמה מסגרות יתפסו בזיכרון הראשי בעקבות ביצוע פקודה זו, במקרה המקסימלי?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": 25,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. בכל דף של 4KB יש 1024 רשומות PTE, כלומר גודל כל רשומה הוא 4 בתים = 32 ביטים. במקרה המקסימלי ה-PFN הוא כל הביטים מלבד 5 של סטטוס, לכן בזיכרון הפיזי יש 2^27 מסגרות. סה\"כ הזיכרון הפיזי הוא כפול גודל דף/מסגרת של 4KB, כלומר 512GB.\n2. לכל תהליך יש 1GB/4KB = 2^18 דפים. בכל דף של טבלת הדפים נכנסות 1024=2^10 רשומות כלומר צריך 2 רמות כדי למפות את כל הדפים. עבור הרמה התחתונה נשתמש ב-10 ביטים ועבור הרמה העליונה ב-8 ביטים.\n3. הקצאה של 5MB היא למעשה הקצאה של 5MB/4KB = 1280 דפים רצופים בזיכרון הוירטואלי של התהליך, או 1281 במקרה המקסימלי (אם ההקצאה לא מיושרת לתחילת הדף אלא מתחילה באמצע דף כלשהו). במקרה המקסימלי, 1281 דפים יכולים להתפרס על פני 3 חלקים שונים של טבלת הדפים ההיררכית. אם כל 3 חלקים אלו של טבלת הדפים לא הוקצו עד כה, נצטרך להקצות 1281 מסגרות חדשות עבור הזיכרון עצמו ועוד 3 מסגרות עבור החלקים של טבלת הדפים סה\"כ 1284 מסגרת במקרה המקסימלי. (יש לשים לב שהרמה הראשונה של טבלת הדפים בהכרח כבר קיימת, ולכן לא נכללת)"
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Semaphores",
        "Mutexes",
        "Concurrency",
        "Deadlocks"
      ],
      "content": {
        "text": "נתונה מערכת מרובת חוטים המנהלת N משאבים אקסקלוסיביים, כלומר שמותר לגשת רק לאחד מהמשאבים בכל רגע נתון (אך ניתן לגשת לאותו משאב ע\"י מספר חוטים במקביל). המשאבים ממוספרים 1-N...0. חוט אשר מעוניין לגשת למשאב i קורא לפעולה (enter(i לפני הגישה למשאב, ולפעולה (exit(i לאחר סיום השימוש במשאב. הקריאה (enter(i צריכה לחסום את החוט הקורא עד אשר הוא רשאי לגשת למשאב i (ואז הקריאה חוזרת). בשאלה זו יש לכתוב אובייקט סנכרון עבור מערכת זו (מימוש לפעולות enter, exit) כך שחוטים שונים יוכלו לקרוא לפעולות אלו במקביל והמערכת תעבוד באופן תקין: - מניעה הדדית: בכל רגע נתון, לא נעשית גישה ליותר ממשאב אחד. - חופש מקיפאון: אם חוט מנסה לגשת למשאב i ואין חוט הניגש למשאב שונה מ-i, החוט יצליח לגשת אל i. לצורך הפתרון הוגדרו המשתנים הגלובליים הבאים: int r=-1,c=0; sem_t mutex; // init to 1 אין להוסיף משתנים גלובליים, סטטיים, או להשתמש בפקודות מכונה אטומיות או אובייקטי סנכרון נוספים. void enter(int i) { } void exit(int i) { }",
        "code_snippet": "int r=-1,c=0;\nsem_t mutex; // init to 1\nvoid enter(int i) {\n}\nvoid exit(int i) {\n}"
      },
      "sub_questions": null,
      "points": 25,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "הפתרון נעזר במנעול ו-2 משתנים: המונה r מציין את אינדקס המשאב בשימוש כרגע, והמונה c מציין כמה חוטים משתמשים כרגע במשאב זה (כאשר 0==c אף משאב לא בשימוש). בניסיון גישה למשאב נתפוס את המנעול ונבדוק אם המשאב זמין (0==c כלומר אף משאב לא בשימוש, או r שווה למשאב שרוצים לגשת אליו). אם כן נוכל לקדם את c ולחזור, אחרת נשחרר את המנעול וננסה מחדש. המנעול הוגן, לכן נבטיח שלא יהיה קיפאון (אחרת יתכן שאותו חוט ינסה שוב ושוב לגשת למשאב לא זמין וימנע מאחרים לגשת או לשחרר את המשאב). שימו לב: למרות השימוש במנעול הוגן תיתכן הרעבה בפתרון, אך לא נדרשה הוגנות בשאלה.",
        "code_snippet": "void enter(int i) {\n    while (1) {\n        sem_wait(&mutex);\n        if ((r == i) || (c == 0)) {\n            r = i;\n            ++c;\n            sem_post(&mutex);\n            return;\n        }\n        sem_post(&mutex);\n    }\n}\nvoid exit(int i) {\n    sem_wait(&mutex);\n    --c;\n    sem_post(&mutex);\n}"
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems"
      ],
      "content": {
        "text": "נתון דיסק קשיח עם הנתונים הבאים: - מהירות סיבוב: 6,000 RPM - גודל סקטור: 1024 בתים. - גודל בלוק: 4KB. - 4 משטחים (2 platters דו-צדדיים). - צפיפות הסקטורים בכל רצועה היא בהתאם ל-4 אזורים: A, B, C, D. בכל אזור 50 רצועות, והאזורים מסודרים בדיסק מבחוץ פנימה – כאשר A הוא החיצוני ביותר ו-D הפנימי ביותר. - באזור A יש 2000 סקטורים לרצועה, באזור B יש 1500 סקטורים לרצועה, - באזור C יש 1000 סקטורים לרצועה, באזור D יש 500 סקטורים לרצועה. - זמן ה-seek הממוצע הוא 20ms, בין שתי רצועות סמוכות הוא 2ms, וזמן ה-seek המקסימלי הוא 40ms. - שיפור track skew: בקריאת סקטורים עוקבים ברצועות סמוכות אין המתנה לסיבוב. הבהרה: בקורס נהגנו לחשב זמנים ממוצעים. בשאלה זו נתונים זמנים בפועל שעלולים להיות גבוהים או נמוכים מהממוצע, עד כדי הנתונים שסופקו לגבי הדיסק. יש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "קוראים תוכן של קובץ בדיסק בגודל 100 בלוקים, אשר מפוצל על פני שתי רצועות באותו משטח (בתוך כל רצועה המידע יושב באופן רציף). מדדו וניטרו פעולה זו וגילו שמתבצעים, לפי הסדר: 1. השהיה מסוימת למשך זמן לא ידוע. 2. העברת 300KB של נתונים במשך 1.5ms. 3. השהיה של 50ms. 4. העברת שאר המידע של הקובץ (100KB) ברצף אחד, ללא השהיות נוספות. כמה זמן נמשכה העברת המידע בשלב 4?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "נתון קובץ בגודל 100MB. כיצד כדאי למקם את נתוני הקובץ בתוך הדיסק, כך שקריאה של כולו תתבצע באופן המהיר ביותר (במקרה הממוצע)? כמה זמן תיקח הפעולה במקרה זה?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "מה שטח האחסון הכולל בדיסק (כמה בתים של נתונים ניתן לאחסן בדיסק כולו)?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": 25,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. שלב 1 מתאים לזמן המיקום של הפעולה (seek + המתנה לסיבוב). לפי קצב העברה של 300KB ב-1.5ms, שלב 2 מתאים להעברה של נתונים מרצועה באזור A. שלב 3 תואם לזמן ה-seek והמתנה לסיבוב המקסימליים, כלומר שבהכרח עשינו את המרחק הכי רחוק בדיסק – מרצועה באזור A לרצועה באזור D. לכן בשלב 4 קוראים 100KB מרצועה באזור D. נחשב זמן העברה בפועל לפי זמן הסיבוב וכמות הנתונים – 100KB הם חמישית מהנתונים ברצועה ולכן ההעברה תיקח חמישית סיבוב – 2ms.\n2. הקובץ מכיל 102,400 סקטורים. נרצה לשים את כולם באופן רציף באזור A שם קוראים בקצב הכי מהיר. בכל רצועה ב-A יש 2000 סקטורים שניתן לקרוא ברצף, ובפיזור נכון על פני 4 המשטחים נוכל לקרוא 8000 סקטורים (2000 מכל משטח) ברצף ללא seek או המתנה לסיבוב ביניהם. מתוך הכמות הנדרשת, נוכל לחלק באופן הזה 96,000 סקטורים על פני 12 צילינדרים (48 רצועות על גבי 4 משטחים). כלומר שקריאה של 48 הרצועות האלו תתבצע עם זמן 11 מעברים בין רצועות בלבד (של 2ms לכל מעבר) וללא 22ms – seek למעברים ועוד 48 סיבובים לקריאה עצמה (480ms) – סה\"כ 502ms נותרו עוד 6400 סקטורים של הקובץ, אותם נשים בצילינדר נוסף (עדיין באזור A). בכל סיבוב ניתן לקרוא רצועה שלמה שהיא 2000 סקטורים, לכן נקרא 6400 סקטורים ב-3.2 סיבובים (32ms) ועוד זמן המעבר (seek) לרצועה זו של 2ms – סה\"כ תוספת של 34ms. לזה נוסיף זמן seek ממוצע 20ms + המתנה לסיבוב 5ms בתחילת הפעולה. נקבל סה\"כ 561ms. תשובה שגויה, המחלקת את הנתונים על-פני משטח אחד בלבד, תגיע לזמן מינימלי של 643ms.\n3. בכל אזור יש 50 רצועות, ובמשטח שלם יש 50*(2000+1500+1000+500) = 250,000 סקטורים. בדיסק יש 4 משטחים, כלומר מיליון סקטורים של 1KB."
      },
      "difficulty_estimation": "Medium"
    }
  ]
}