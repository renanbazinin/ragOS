{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2024",
    "semester": "Summer",
    "moed": "Moed B",
    "exam_date": "04.11.2024",
    "source_file": "os24SB.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Concurrency",
        "Atomic Operations",
        "Synchronization"
      ],
      "content": {
        "text": "נתון מעבד התומך בפעולה האטומית F&A, הניתנת להפעלה ע\"י קריאה לפונקציה:\nint fetchAndAdd(int* ptr);\nסטודנט כתב את הפונקציה הבאה לדימוי פעולת המעבד האטומית CAS באמצעות פעולת F&A:\nint compareAndSetWithFA(int* val, int expected, int new) {\nstatic int ticket = 0;\nstatic int turn = 0;\n// static vars are shared among threads (like global)\nint res = 0;\nint myturn = fetchAndAdd(&ticket);\nwhile (myturn != turn);\nif (*val == expected) {\n*val = new;\nres = 1;\n}\n++turn;\nreturn res;\n}",
        "code_snippet": "int fetchAndAdd(int* ptr);\nint compareAndSetWithFA(int* val, int expected, int new) {\nstatic int ticket = 0;\nstatic int turn = 0;\n// static vars are shared among threads (like global)\nint res = 0;\nint myturn = fetchAndAdd(&ticket);\nwhile (myturn != turn);\nif (*val == expected) {\n*val = new;\nres = 1;\n}\n++turn;\nreturn res;\n}",
        "options": [
          "א. המימוש תקין, ושקול לשימוש ב-CAS.",
          "ב. המימוש תקין, אך יפגין ביצועים פחות טובים משימוש ב-CAS.",
          "ג. המימוש לא תקין, שימוש בו עלול לגרום לקיפאון.",
          "ד. המימוש לא תקין, שימוש בו עלול לגרום להרעבה.",
          "ה. המימוש לא תקין, הערך של val לא תמיד יעודכן באופן נכון."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ב",
        "explanation": "ב'. המימוש מכיל מנעול ticket-lock מובנה כדי להבטיח נכונות ולכן יעבוד באופן תקין, אך המנעול יפגע בביצועים כי הפעולה לא מתבצעת במקביל (אפילו לא כשניגשים לערכים שונים בזיכרון), ולא באופן אטומי במעבד."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Threads",
        "Processes",
        "Context Switching"
      ],
      "content": {
        "text": "נתונים 2 חוטים A,B של 2 תהליכים שונים במערכת, ושניהם עוד לא הסתיימו. איזו טענה נכונה?",
        "code_snippet": null,
        "options": [
          "א. החוט A יכול למנוע החלפת הקשר ע\"י ביטול הפסיקות במערכת.",
          "ב. החלפת הקשר בין A ל-B יכולה להתבצע רק בעקבות קריאת מערכת.",
          "ג. החלפת הקשר בין A ל-B יכולה להתבצע רק בעקבות פסיקת שעון.",
          "ד. החלפת הקשר בין A ל-B לרוב תהיה איטית יותר מאשר אם היו באותו תהליך.",
          "ה. החלפת הקשר בין A ל-B לרוב תהיה מהירה יותר מאשר אם היו באותו תהליך."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ד",
        "explanation": "ד'. החלפת הקשר בין חוטים באותו תהליך היא מהירה יותר מאשר בין חוטים בתהליכים שונים."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "System Calls",
        "I/O",
        "Processes"
      ],
      "content": {
        "text": "מהי פסיקה(interrupt)",
        "code_snippet": null,
        "options": [
          "א. מנגנון לעצירת תהליכים כל פרק זמן קבוע.",
          "ב. קטע קוד שמריץ תהליך לטיפול באירוע כלשהו.",
          "ג. הודעה שנשלחת ממערכת ההפעלה אל תהליך.",
          "ד. הודעה שנשלחת בין תהליכים בתיווך מערכת ההפעלה.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. פסיקה היא הודעה שנשלחת אל המעבד/קרנל מרכיבי חומרה או תהליכים (באמצעות trap). פסיקת השעון משמשת לעצירת תהליכים כל פרק זמן קבוע, אך זה השימוש בסוג אחד של פסיקה ולא ההגדרה של פסיקה."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "File Systems"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS עם 2 קבצי משתמש A, B ששניהם hard links לאותו inode, ושני קבצי משתמש C,D ששניהם symbolic links – הקובץ C הוא קישור סימבולי אל A, והקובץ D הוא קישור סימבולי אל B.\nא. אם נמחק את A, משתמש יוכל עדיין לפתוח את C מכיוון שעדיין קיים B.\nב. לא יתכן ש-A,B באותה תיקייה מאחר שהם קישורים לאותו inode.\nג. לא יתכן ש-C,D באותה תיקייה מאחר שהם קישורים לאותו inode.\nד. ה-inode של C זהה ל-inode של D.\nה. כל התשובות האחרות אינן נכונות.",
        "code_snippet": null,
        "options": [
          "א. אם נמחק את A, משתמש יוכל עדיין לפתוח את C מכיוון שעדיין קיים B.",
          "ב. לא יתכן ש-A,B באותה תיקייה מאחר שהם קישורים לאותו inode.",
          "ג. לא יתכן ש-C,D באותה תיקייה מאחר שהם קישורים לאותו inode.",
          "ד. ה-inode של C זהה ל-inode של D.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. כל האפשרויות המתוארות אפשריות."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "System Calls",
        "Processes",
        "Security"
      ],
      "content": {
        "text": "נתונה הטענה: שינוי ערכי האוגרים במעבד מתבצע רק במצב קרנל (kernel mode).\nא. הטענה נכונה: ערכי האוגרים נשמרים ב-PCB וזה מבנה נתונים של הקרנל.\nב. הטענה נכונה: האוגרים נמצאים במעבד ורק לקרנל יש גישה לחומרה.\nג. הטענה לא נכונה: תהליך תמיד יכול לשנות את חלק מערכי האוגרים במעבד (ב-user mode)\nד. הטענה לא נכונה: תהליך יכול לקבל הרשאה זמנית לשנות ערכים של חלק מהאוגרים (ב-user mode).\nה. כל התשובות האחרות אינן נכונות.",
        "code_snippet": null,
        "options": [
          "א. הטענה נכונה: ערכי האוגרים נשמרים ב-PCB וזה מבנה נתונים של הקרנל.",
          "ב. הטענה נכונה: האוגרים נמצאים במעבד ורק לקרנל יש גישה לחומרה.",
          "ג. הטענה לא נכונה: תהליך תמיד יכול לשנות את חלק מערכי האוגרים במעבד (ב-user mode)",
          "ד. הטענה לא נכונה: תהליך יכול לקבל הרשאה זמנית לשנות ערכים של חלק מהאוגרים (ב-user mode).",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. הגישה לאוגרים מתבצעת באופן ישיר כחלק מפעולת המעבד הסטנדרטית גם ב-user mode (זו המשמעות של direct execution, גם עבור limited direct execution). תהליך ניגש לאוגרים במעבד בכל ריצה סטנדרטית."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Scheduling",
        "Synchronization",
        "Deadlocks"
      ],
      "content": {
        "text": "נתון אלגוריתם חדש בשם RMLFQ, המבוסס על MLFQ מלבד השינויים הבאים:\n- תהליך חדש מתווסף לתור בעדיפות הנמוכה ביותר במקום הגבוהה ביותר.\n- תהליך שלא ניצל את כל הקוונטה עולה תור אחד בעדיפות. תהליכים עדיין יורדים בעדיפות לפי אותה חוקיות.\n- priority boost, כל התהליכים יורדים לתור בעדיפות הנמוכה ביותר, במקום לעלות לגבוהה ביותר.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "היפוך עדיפויות (priority inversion) הוא מצב בו אלגוריתם התזמון גורם לקיפאון של תהליך כלשהו בגלל שהתהליך ממתין למשאב המוחזק ע\"י תהליך אחר שאינו מתוזמן עוד לעולם.\nבאילו מאלגוריתם התזמון הבאים אפשרי להגיע למצב של היפוך עדיפויות?\n:FCFS\nנימוק:\n:overlap ללא SRTF\nנימוק:\n:RMLFQ\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "בתזמון תהליכים, הרעבה מוגדרת כמצב בו יתכן שתהליך מסוים לעולם לא יסתיים.\nעבור כל אחד מהאלגוריתמים הבאים, האם מתאפשרת הרעבה? יש לתת דוגמה קצרה היכן שכן, או הוכחה היכן שלא.\n:FCFS\nנימוק:\noverlap ללא SRTF\nנימוק:\n:RMLFQ\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "בתזמון תהליכים, אפקט השיירה מוגדר כמצב בו יתכן שתהליכים קצרים יתעכבו זמן רב עקב תהליך ארוך.\nעבור כל אחד מהאלגוריתמים הבאים, האם יתכן אפקט השיירה? יש לתת דוגמה קצרה היכן שכן, או הוכחה היכן שלא.\n:FCFS\nנימוק:\noverlap ללא SRTF\nנימוק:\n:RMLFQ\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. FCFS – לא אפשרי. תהליך צריך להיות מתוזמן כדי להחזיק במשאב, ותהליך מתוזמן מתחילתו ועד סופו, אז לא יכול להיות שתהליך אחר ממתין למשאב.\nSRTF – אפשרי. תהליך ארוך שמחזיק במשאב עלול להיקטע עי תהליכים קצרים שמגיעים כל הזמן ולעולם לא לרוץ כדי לשחרר את המשאב.\nRMLFQ – לא אפשרי. לאחר priority boost כל התהליכים באותה עדיפות (נמוכה), כולם יתוזמנו כולל התהליך שמחזיק במשאב שבסופו של דבר ישחרר אותו. תהליכים חדשים מגיעים בעדיפות הכי נמוכה ולכן יקבלו קוונטה רק אחרי התהליך שמחזיק במשאב.\n2. FCFS – אין הרעבה. כל תהליך מתוזמן בתורו ולפני התהליכים שהגיעו אחריו.\nSRTF – יש הרעבה. תהליך ארוך עלול להיות מורעב ע\"י תהליכים קצרים שמגיעים כל הזמן.\nRMLFQ – אין הרעבה. כל תהליך ירוץ בסופו של דבר בגלל ה-priority boost, מאחר שתהליכים חדשים מגיעים בעדיפות נמוכה הם ירוצו רק אחרי קוונטה של כל שאר התהליכים.\n3. FCFS – יתכן אפקט השיירה. כל תהליך מחכה לתהליכים שהגיעו לפניו, גם תהליך קצר שלפניו תהליך ארוך מאוד.\nSRTF – לא יתכן אפקט השיירה. תהליך קצר תמיד יתוזמן לפני תהליך ארוך.\nRMLFQ – לא יתכן אפקט השיירה. אחרי priority boost כל התהליכים יקבלו קוונטה, תהליכים ארוכים יישארו בעדיפות נמוכה ולא ירוצו לפני תהליכים קצרים."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Mutexes",
        "Concurrency"
      ],
      "content": {
        "text": "נתונה מערכת בה המנעול המובנה אינו הוגן, כלומר, מימוש המנעול הזמין ע\"י מערכת ההפעלה מקיים מניעה הדדית וחופש מקיפאון אך עלול לגרום להרעבה.\nמתכנת כלשהו החליט לממש מנעול ל-N חוטים (כאשר N ידוע מראש) בהשראת מנעול הדגלים, בו לכל חוט יש דגל (תא במערך) ומזהה 1 (בין 0 עד 1-N).\nכאשר חוט מעוניין במנעול הוא מרים את הדגל ע\"י כתיבה של 1 או 2 לסירוגין בתא המתאים i במערך – פעם ראשונה 1, פעם שניה 2, פעם שלישית 1, וכן הלאה. כל ערך אחר מציין שהדגל למטה.\nכדי להימנע מקיפאון והרעבה, ננסה להבטיח שחוט לא יעקוף חוט אחר יותר מפעם אחת באופן הבא: אם הדגל 1 ניתנת עדיפות לחוטים עם מזהה נמוך יותר, ואם הדגל 2 ניתנת עדיפות לחוטים עם מזהה גבוה יותר. להלן מימוש חלקי:\n#define N ??\ntypedef struct {\nint flags[N]; // init to -2\nmutex_t unfair;\n} Lock2;\nvoid unlock(Lock2* lock, int i) {\nlock->flags[i] = -(lock->flags[i]);\nmutex_unlock(&lock->unfair);\n}\nvoid lock(Lock2* lock, int i) {\nlock->flags[i] = 3 + lock->flags[i];\nif (lock->flags[i] == 1) {\nfor (int k = 0; k < i; ++k)\nAAA;\n}\nelse {//lock->flags[i] == 2\nfor (int k = N-1; k > i; --k)\nBBB;\n}\nmutex_lock(&lock->unfair);\n}\nשימו לב: השדה unfair הוא המנעול המובנה במערכת שאינו הוגן. הפרמטר i הוא מזהה החוט שתופס/משחרר את המנעול. תוכן השורות המסומנות AAA,BBB מפורט בסעיפים הבאים, בנפרד לכל סעיף.",
        "code_snippet": "#define N ??\ntypedef struct {\nint flags[N]; // init to -2\nmutex_t unfair;\n} Lock2;\nvoid unlock(Lock2* lock, int i) {\nlock->flags[i] = -(lock->flags[i]);\nmutex_unlock(&lock->unfair);\n}\nvoid lock(Lock2* lock, int i) {\nlock->flags[i] = 3 + lock->flags[i];\nif (lock->flags[i] == 1) {\nfor (int k = 0; k < i; ++k)\nAAA;\n}\nelse {//lock->flags[i] == 2\nfor (int k = N-1; k > i; --k)\nBBB;\n}\nmutex_lock(&lock->unfair);\n}",
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "הוכיחו שהמנעול המתואר בקוד הנ\"ל מקיים מניעה הדדית ללא תלות בתוכן השורות AAA,BBB, אם ידוע שבשורות אלו לא מבוצעת פקודת return.\nהוכחה:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "7.2",
          "text": "נתון מימוש של המנעול המתואר בקוד הנ\"ל עם הערכים הבאים עבור השורות החסרות:\nAAA: while (lock->flags[k] == 1);\nAAA: while (lock->flags[k] == 2);\nידוע שהמימוש בסעיף זה מקיים רק אחת מהתכונות: חופש מקיפאון, הוגנות.\nאיזו תכונה לא מקיים מימוש המנעול בסעיף זה?\nחופש מקיפאון / הוגנות\nהוכחה:",
          "code_snippet": "AAA: while (lock->flags[k] == 1);\nAAA: while (lock->flags[k] == 2);",
          "options": null
        },
        {
          "id": "7.3",
          "text": "נתון מימוש של המנעול המתואר בקוד הנ\"ל עם הערכים הבאים עבור השורות החסרות:\nAAA: while (lock->flags[k] > 0);\nAAA: while (lock->flags[k] > 0);\n-ידוע שהמימוש בסעיף זה מקיים רק אחת מהתכונות: חופש מקיפאון, הוגנות.\nאיזו תכונה לא מקיים מימוש המנעול בסעיף זה?\nחופש מקיפאון / הוגנות\nהוכחה:",
          "code_snippet": "AAA: while (lock->flags[k] > 0);\nAAA: while (lock->flags[k] > 0);",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. ללא קשר לשורות AAA,BBB, כל חוט תופס את המנעול unfair לפני הכניסה לקטע הקריטי ומשחרר אותו רק ביציאה מהקטע הקריטי, לכן אם יש 2 חוטים בקטע הקריטי בו-זמנית שניהם מחזיקים במנעול unfair בסתירה לכך שמנעול זה מקיים מניעה הדדית.\n2. המנעול לא מקיים הוגנות. חוט 0 מנסה לתפוס את המנעול, מעדכן [0]flags ל-1 ומצליח ונכנס לקטע הקריטי. חוט 1 מנסה לתפוס את המנעול, מעדכן [1]flags ל-1 וממתין בלולאה על [0]flags. חוט 0 משחרר את המנעול ומנסה לתפוס שוב, מעדכן [0]flags ל-2 לכן לא ממתין ונכנס לקטע הקריטי, אז משחרר את המנעול ומנסה לתפוס שוב – ומעדכן [0]flags ל-1. חוט 1 חוזר לרוץ, עדיין חסום בלולאה וממתין לחוט 0 כי [0]flags כרגע 1. חוט 0 שוב משחרר את המנעול, תופס, משחרר, תופס. חוט 1 ממשיך בלולאה וחסום. חוזר חלילה עד אינסוף. המנעול כן מקיים חופש מקיפאון (לא נדרש להוכיח): נניח בשלילה שיש קיפאון, מאחר שהמנעול המובנה מקיים חופש מקיפאון אז החוטים בהכרח חסומים באחת מהלולאות (ולא בגישה למנעול המובנה). נניח בשלילה שיש חוט אחד או יותר שחסומים כאשר ערך הדגל שלהם הוא 1. נסתכל על החוט עם המזהה הכי קטן מביניהם – לא יתכן שהוא חסום כי אין חוט עם מזהה קטן ממנו עבורו הדגל הוא 1, לכן לא יתכן אף חוט חסום שהרים דגל עם 1. באותו אופן נניח בשלילה שיש חוטים חסומים עם דגל של 2. נסתכל על החוט עם המזהה הכי גדול מביניהם – לא יתכן שהוא חסום כי אין חוט עם מזהה גדול ממנו עבורו הדגל הוא 2, לכן לא יתכן חוט חסום שהרים דגל עם 2. אלו 2 הערכים היחידים שאפשריים לחוטים שמעוניינים במנעול, לכן הגענו לסתירה.\n3. המנעול לא מקיים חופש מקיפאון. חוט 0 מנסה לתפוס את המנעול, מעדכן [0]flags ל-1, תופס את המנעול ומשחרר אותו. חוט 0 שוב מנסה לתפוס את המנעול, מעדכן [0]flags ל-2 ומתעכב. חוט 1 מנסה לתפוס את המנעול, מעדכן [1]flags ל-1, חסום בהמתנה על [0]flags. חוט 0 חוזר לרוץ, עובר על מערך הדגלים וחסום בהמתנה על [1]flags. אף חוט לא יכול להתקדם – קיפאון. המנעול כן מקיים הוגנות (לא נדרש להוכיח): נניח בשלילה שיש הרעבה, אז קיים חוט שלא מצליח לתפוס את המנעול לעולם בזמן שחוטים אחרים מצליחים מספר לא מוגבל של פעמים. נניח חוט עם מזהה X לא מצליח, נסתכל על חוט כלשהו עם מזהה Y שמצליח לתפוס את המנעול פעמיים (בהכרח יש כזה), ללא הגבלת הכלליות נניח Y>X. בהכרח באחת הפעמים חוט Y מרים דגל עם הערך 1, ולכן חסום על התא של X עד ש-X יתפוס את המנעול בהצלחה, בסתירה לכך ש-Y הצליח לתפוס את המנעול פעמיים."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Disk Scheduling"
      ],
      "content": {
        "text": "נתונה מערכת קבצים VSFS בה גודל בלוק הוא 4KB, גודל מצביע הוא 4B, ובכל inode יש 4 מצביעים: 2 מצביעים ישירים, מצביע אחד עקיף, ומצביע אחד עקיף כפול. יש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "משתמש טוען כי בקובץ מסוים, הגישה לבית במיקום A בקובץ מהירה יותר מאשר הגישה לבית במיקום 1+A, והגישה לבית במיקום B בקובץ זהה למהירות הגישה לבית במיקום 1+A אבל מהירה יותר מהגישה לבית במיקום 1+B. האם הטענה של המשתמש נכונה? אם כן, יש לציין ערכים אפשריים עבור A,B, אחרת יש להוכיח מדוע הטענה לא אפשרית.\nהמשתמש צודק: / המשתמש טועה\nA= B=\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "משתמש החליט כי זמן הגישה הממוצע לבית אקראי אחד בקובץ בגודל 8MB הוא איטי מדי, ולכן רצה לחלק את המידע בקובץ לכמה קבצים נפרדים כך שזמן הגישה הממוצע לבית אקראי אחד יהיה המהיר ביותר. האם קיימת חלוקה כזו? אם כן, יש לפרט לכמה קבצים נדרש לחלק את הקובץ הגדול במינימום, אחרת יש להסביר מדוע לא.\nהחלוקה אפשרית: מינימום ____ קבצים / החלוקה לא אפשרית\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "נתון דיסק קשיח כלשהו בו ידוע שזמן המיקום (הסכום של seek + wait) הוא 20ms\nמשתמש הריץ מספר בדיקות על הדיסק וגילה את הנתונים הבאים:\n- פעולות קריאה/כתיבה של 48MB רצופים מתבצעות בזמן ממוצע של 820ms.\n- פעולות קריאה/כתיבה של X MB רצופים מתבצעות בזמן ממוצע של 320ms.\n- פעולות קריאה/כתיבה חוזרות של X MB באותו מיקום שוב ושוב (ללא אף פעולה אחרת בין לבין) מתבצעות בזמן ממוצע של 310ms\nמה הערך של X, ומהם נתוני הדיסק המלאים?\nהערך של X הוא: ____ MB\nקצב העברה מקסימלי: ____ MB/s\nזמן ה-seek הוא: ____ ms\nקצב RPM הוא: ____\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. הבית A הוא הבית האחרון בבלוק ה-DATA הנגיש מהמצביע הישיר האחרון, כך שהגישה לבית אחד אחריו (1+A) דורשת מעבר דרך בלוק עקיף. יש 2 מצביעים ישירים לכן 2-1*A=4KB\nהבית B הוא הבית האחרון בבלוק ה-DATA האחרון שנגיש דרך מצביע עקיף, כך שגישה אליו זהה ל-1+A בממוצע (שניהם עוברים דרך אותה כמות בלוקים/קריאות), אבל גישה לבית אחד אחריו (1+B) דורש גישה דרך בלוק עקיף כפול.\nאחרי 2 הבלוקים הישירים יש 1024 בלוקים הנגישים ממצביע עקיף לכן B=4KB*1026-1.\nA=8191\nB=4202495\n2. החלוקה אפשרית.\nבקובץ בגודל 8MB רוב הגישות לבית אחד אקראי יהיו דרך מצביע עקיף או מצביע עקיף כפול. הזמן הממוצע הטוב ביותר יהיה אם כל הגישות יהיו דרך מצביעים ישירים בלבד.\nלכן נרצה ליצור הרבה קבצים קטנים כאשר כל אחד מהם משתמש רק במצביעים ישירים. מספר הקבצים המינימלי יתקבל כאשר כל קובץ יהיה בגודל המקסימלי המשתמש במצביעים ישירים בלבד – כלומר 2 בלוקים.\nקובץ בגודל 8MB מכיל 2048 בלוקים של 8MB/4KB) DATA), בכל קובץ קטן נרצה 2 בלוקים לכן המינימום הוא 1024 קבצים.\n3. לפי הנתון הראשון, העברה של 48MB (ללא זמן מיקום) לוקחת 800ms.\nנחשב קצב העברה לפי 48MB ב-800ms ונקבל קצב העברה מקסימלי של MB/s 60.\nלפי הנתון השני, העברה של X MB (ללא זמן מיקום) לוקחת 300ms.\nנקבל שקצב ההעברה הוא XMB ב-300ms וזה זהה לקצב ההעברה המקסימלי שחישבנו (MB/s 60), מתוצאת השוויון נקבל X=18MB\nלפי הנתון השלישי, פעולות לאותו מקום שוב ושוב מתבצעות בזמן ממוצע הקצר יותר ב-10ms.\nכאשר מבצעים פעולה שוב ושוב חוסכים את זמן ה-seek מכיוון שמובטח שהראש הקורא-כותב כבר נמצא ברצועה הנכונה, כלומר שזמן ההמתנה לסיבוב הוא 10ms. סיבוב מלא הוא 20ms וזה מתאים לקצב סיבוב של 3000 RPM.\nזה מותיר אותנו עם זמן 10ms seek"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 9,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Networking"
      ],
      "content": {
        "text": "נתונות 2 מערכות עם מנגנון RAID, בכל אחת מהן זמינים 2 דיסקים קשיחים (ממוספרים 1-2) בעלי מאפיינים זהים. כלומר, כל 4 הדיסקים בעלי מאפיינים זהים לחלוטין. בשאלות על ביצועים יש להתייחס לממוצע הכללי (ולא לפעולה ספציפית).",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "9.1",
          "text": "נתון שבמערכת הראשונה יש מנגנון 4-RAID ובמערכת השניה מנגנון 5-RAID. סטודנט א' טען: אין הבדל בין המערכות. הדיסקים במערכת הראשונה יכילו את אותם נתונים כמו במערכת השניה, ולא יהיה הבדל ביצועים ביניהן. סטודנט ב' טען בתגובה: יתכן הבדל בין המערכות (בנתונים ו/או בביצועים), מאחר שבלוק ה-parity נמצא בדיסק קבוע במערכת הראשונה ומתחלף בין הדיסקים במערכת השניה. מי מהסטודנטים צודק?\nסטודנט א' / סטודנט ב'\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "9.2",
          "text": "נתון שבמערכת הראשונה יש מנגנון 4-RAID ובמערכת השניה מנגנון 0-RAID. סטודנט א' טען: במערכת השניה נקבל ביצועים טובים יותר גם בקריאה וגם בכתיבה. סטודנט ב' טען: במערכת השניה נקבל ביצועים טובים יותר בקריאה או בכתיבה אך לא בשניהם. סטודנט ג' טען: במערכת השניה לא נקבל ביצועים טובים יותר בקריאה ולא בכתיבה. מי מהסטודנטים צודק?\nסטודנט א' / סטודנט ב' / סטודנט ג'\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "1. סטודנט א'. עם 2 דיסקים, ה-parity הוא פשוט עותק של הנתונים כמו שהם, כלומר שהנתונים יהיו זהים לחלוטין בין 2 הדיסקים (כמו 1-RAID) ואין כל הבדל בין המערכות.\n2. סטודנט ב'. במערכת השניה נקבל ביצועים טובים יותר בכתיבה, כי נוכל לכתוב ל-2 הדיסקים במקביל ולקצר בחצי את זמן הכתיבה (ב-4-RAID נצטרך לכתוב כל נתון פעמיים בגלל ה-parity). בפעולות קריאה נקבל ביצועים זהים כי נוכל לנצל את 2 הדיסקים במקביל ב-2 המערכות."
      },
      "difficulty_estimation": "Medium"
    }
  ]
}