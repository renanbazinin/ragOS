{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2025",
    "semester": "Semester A",
    "moed": "Moed B",
    "exam_date": "25.02.2025",
    "source_file": "os25AB.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Memory Management",
        "I/O",
        "File Systems"
      ],
      "content": {
        "text": "נתונים שני כונני SSD ריקים בעלי נתונים טכניים זהים, וביצעו עליהם בדיוק את אותן פעולות. כלומר, ב-2 הכוננים בוצעו אותן פעולות קריאה/כתיבה עם אותם נתונים לאותם דפים לוגיים ובאותו סדר.\nאיזו טענה בהכרח נכונה?",
        "code_snippet": null,
        "options": [
          "א. מיפוי הדפים הלוגיים לפיזיים יהיה זהה בין הכוננים, ודפים אלו יכילו את אותם נתונים.",
          "ב. מיפוי הדפים הלוגיים לפיזיים עלול להיות שונה בין הכוננים, אך דפים אלו יכילו את אותם נתונים.",
          "ג. מיפוי הדפים הלוגיים לפיזיים יהיה זהה בין הכוננים, אך יתכן שחלק מדפים אלו (או כולם) יכילו נתונים שונים.",
          "ד. מיפוי הדפים הלוגיים לפיזיים עלול להיות שונה בין הכוננים, ויתכן שחלק מדפים אלו (או כולם) יכילו נתונים שונים.",
          "ה. לא ניתן לבצע את אותן פעולות על 2 הכוננים."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ד",
        "explanation": "ד'. בגלל שהשחיקה אקראית, יתכן שאותם דפים לוגיים יהיו ממופים לדפים פיזיים שונים בכונן (גם עם אותן גישות). בגלל הפרעות קריאה/כתיבה (read disturbs / program disturbs) יתכן שדפים אלו גם ישתבשו ויכילו נתונים שונים (בכונני SSD זה מטופל ע\"י מנגנונים לזיהוי ותיקון שגיאות)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Virtual Memory",
        "Paging",
        "Page Replacement"
      ],
      "content": {
        "text": "נתון תהליך שמערכת ההפעלה הקצתה לו שלוש מסגרות בלבד (לכל אורך הריצה שלו), אשר בהתחלה כולן פנויות (אף אחד מהדפים של התהליך אינו בזיכרון). התהליך פנה לדפים הבאים (משמאל לימין, כלומר קודם 0 ואז 1 וכן הלאה):\n0, 1, 3, 2, 4, 0, 4, 2, 1, 3, 3, 4\nכמה page faults יהיו אם אלגוריתם החלפת הדפים הוא MRU (Most Recently Used) (הפוך ל-LRU)?",
        "code_snippet": null,
        "options": [
          "א. 6",
          "ב. 7",
          "ג. 8",
          "ד. 9",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. 5 הגישות הראשונות הן החטאות (הגישה הראשונה לכל דף). לאחר מכן גישות 8,10,2 יהיו החטאות (הגישות לדפים 4-1,3,2)."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "I/O",
        "System Calls"
      ],
      "content": {
        "text": "מה תפקידו של ה-DMA?",
        "code_snippet": null,
        "options": [
          "א. סיוע בתרגום כתובות וירטואליות.",
          "ב. ביצוע החלפת הקשר (context switch)",
          "ג. העברת מידע בין התקני קלט-פלט והזיכרון.",
          "ד. סיוע למתזמן (scheduler) בקבלת החלטה.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. כפי שנלמד, ה-DMA משמש להעברת מידע בין התקני קלט-פלט והזיכרון במקום שהמעבד יעסוק בכך."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 4,
      "type": "CodeAnalysis",
      "topic": [
        "Processes",
        "System Calls"
      ],
      "content": {
        "text": "נתונה התוכנית הבאה:\nתזכורת: באופרטור &&, אם האופרנד הראשון הוא FALSE, לא נבדק/מבוצע האופרנד השני.\nכמה תהליכים נוצרו במהלך הרצת התוכנית, כולל התהליך הראשי?",
        "code_snippet": "int main()\n{\n    for (int i = 0; i < 3; ++i) {\n        if (!fork() && !fork()) {\n            break;\n        }\n    }\n}",
        "options": [
          "א. 7",
          "ב. 8",
          "ג. 15",
          "ד. 18",
          "ה. 31"
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. בכל איטרציה של הלולאה, התנאי גורם ליצירת 2 תהליכים חדשים. באיטרציה הראשונה התהליך הראשי יוצר 2 תהליכי בנים, אחד מסיים ואחד ממשיך הלאה. הראשי והבן שהמשיך הלאה יוצרים כל אחד 2 תהליכי בנים, מתוכם 2 ממשיכים הלאה בנוסף לתהליך הראשי והבן מהאיטרציה הראשונה, סה\"כ נוצרו 7. לאיטרציה השלישית מגיעים 4 תהליכים שכל אחד יוצר 2 תהליכי בנים ל-8 תהליכים נוספים, סה\"כ 15."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Threads",
        "Mutexes",
        "Atomic Operations"
      ],
      "content": {
        "text": "נתונה מערכת עם 1+N חוטים בה נעשה שימוש במנעול ALock) Anderson) עם מערך בגודל N.\nא. המנעול עובד באופן תקין.\nב. המנעול מקיים מניעה הדדית.\nג. המנעול מקיים חופש מקיפאון והוגנות.\nד. נקבל שגיאת קומפילציה או ריצה: לא ניתן לממש מנעול עם מערך בגודל N במערכת עם 1+N חוטים.\nה. כל התשובות האחרות אינן נכונות.",
        "code_snippet": null,
        "options": [
          "א. המנעול עובד באופן תקין.",
          "ב. המנעול מקיים מניעה הדדית.",
          "ג. המנעול מקיים חופש מקיפאון והוגנות.",
          "ד. נקבל שגיאת קומפילציה או ריצה: לא ניתן לממש מנעול עם מערך בגודל N במערכת עם 1+N חוטים.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. אם נשתמש במנעול אנדרסון עם מערך בגודל N במערכת בה יש 1+N חוטים, המנעול לא יקיים אף אחת מהתכונות."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Virtual Memory",
        "Paging",
        "Memory Management",
        "Page Replacement"
      ],
      "content": {
        "text": "נתבונן בקטע הקוד הבא שבו מוכפלות 2 מטריצות (המערך c מכיל בהתחלה רק אפסים):",
        "code_snippet": "int a[1024][1024], b[1024][1024], c[1024][1024];\n\nvoid multiply() {\n    for (int i = 0; i < 1024; i++)\n        for (int j = 0; j < 1024; j++)\n            for (int k = 0; k < 1024; k++)\n                c[i][j] += a[i][k] * b[k][j];\n}",
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "נתונות ההנחות הבאות:\n- גודל דף הוא 4KB.\n- הקוד של הפונקציה multiply מאוחסן בדף אחד.\n- במהלך הפעלת הפונקציה, המחסנית כולה מאוחסנת בדף אחד.\n- משתנה מטיפוס int תופס 4 בתים.\n- ב-TLB יש 8 כניסות, ואלגוריתם פינוי הדפים בו הוא LRU.\n- ה-TLB ריק בתחילת הפונקציה.\n- כל אחד מהמערכים a, b, c מתחיל בדיוק בתחילת הדף בו הוא נמצא.\nשימו לב: בשפת C, מערך דו-ממדי (כמו a) מאוחסן בזיכרון \"לפי שורות\", קודם איברי השורה הראשונה ואז איברי השורה השניה וכן הלאה. כלומר, קודם a[0][0] ואז a[0][1]...a[0][1023] ואז a[1][0]...a[1][1023] וכן הלאה עד השורה האחרונה a[1023][0]...a[1023][1023].\nכמה החטאות TLB (TLB misses) יהיו בזמן ביצוע הקוד?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "הציעו שינוי לקוד אשר יביא את מספר ההחטאות למינימום (כך שהמטריצה c עדיין תכיל בסוף הריצה את אותה תוצאה).\nאין צורך לממש את השינוי, אלא רק לפרט אותו באופן ברור.\nכמה החטאות TLB (TLB misses) יהיו בזמן ביצוע הקוד עם השינוי?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": 15,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "שאלה 6\n1. אחרי שהדפים בהם נמצאים הקוד והמחסנים יובאו ל-TLB הם יישארו שם באופן קבוע כי ניגשים אליהם לעיתים קרובות ופינוי הדפים מה-TLB נעשה לפי LRU. לכן עבור כל אחד משני הדפים (של הקוד ושל המחסנית) תהיה רק החטאה אחת – בפעם הראשונה שיגשו אליהם, בסה\"כ 2 החטאות.\nהקוד ניגש למערך a \"לפי שורות\" כלומר קודם לכל איברי השורה הראשונה של a, לאחר מכן לכל איברי השורה השניה של a וכן הלאה. בין כל 2 גישות לדף המכיל שורה של a תהיה גישה רק לארבעה דפים אחרים – דף המכיל איבר של b, דף המכיל איבר של c, הדף המכיל את הקוד והדף עם המחסנית.\nלכן, ברגע שדף המכיל שורה של a יובא ל-TLB הוא לא יפונה משם בזמן שהקוד משתמש בו כי הוא יישאר בין 5 הדפים שהם most recently used וב-TLB יש מקום ל-8 דפים. לכן יהיה צורך להביא כל דף של a (כל שורה של a נכנסת בדיוק בדף אחד) רק פעם אחת ל-TLB. איברי a מאוחסנים ב-1024 דפים כך שהגישות ל-a יגרמו ל-1024 החטאות.\nדבר דומה נכון גם עבור הגישות לדפים של c – 1024 החטאות נוספות.\nבכל איטרציה של הלולאה החיצונית, הקוד ניגש ל-b \"לפי עמודות\", כלומר קודם לכל איברי העמודה הראשונה, אחרי זה לאיברי העמודה השניה וכן הלאה. הבעיה היא שאיברים עוקבים באותה עמודה נמצאים בדפים שונים (עמודה אחת מתפרשת על פני כל הדפים של b).\nכתוצאה מכך כל הגישות ל-b יסבלו מהחטאות, ויש 1024^3 גישות כאלו.\nסה\"כ קיבלנו 2+1024+1024+1024^3 החטאות.\n\n2. נשמור את איברי המערך b בצורה הפוכה (מטריצה משוחלפת).\nכעת ניגש ל-b \"לפי שורות\", כלומר שעבור כל שורה של c נקבל 1024 החטאות בגישה ל-b, סה\"כ 1024^2 החטאות בגישה ל-b, ונקבל מספר החטאות כולל של: 2+1024+1024+1024^2\nהיפוך המטריצה b גורר 1024^2 החטאות נוספות, אך לא נדרש לפרט את זה בתשובה."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Semaphores",
        "Mutexes",
        "Concurrency",
        "Atomic Operations",
        "Threads"
      ],
      "content": {
        "text": "בשאלה זו יש לממש את אובייקט הסנכרון סמפור (Semaphore). כלומר, יש להגדיר את שדות האובייקט ולממש את הפעולות: sem_wait, sem_post. בכל סעיף יש לספק מימוש נפרד, בהתאם למגבלות המפורטות באותו סעיף.\nיש לדאוג למימוש יעיל ככל האפשר (ללא spinning) המקיים הוגנות וחופש מקיפאון.\nניתן להשתמש בקריאת המערכת ()yield.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "בסעיף זה יש לממש סמפור באמצעות מנעולים ומשתני תנאי בלבד: pthread_mutex_t, pthread_cond_t.\nתיאור הפתרון:\nהגדרת הסמפור (יש לציין ערכי אתחול בהערה, אין צורך לדאוג לפעולות אתחול והקצאות דינמיות/שחרור זיכרון):",
          "code_snippet": "typedef struct _sem_t1 {\n} sem_t1;\n\nvoid sem_wait(sem_t1 *sem) {\n}\n\nvoid sem_post(osem_t1 *sem) {\n}",
          "options": null
        },
        {
          "id": "7.2",
          "text": "בסעיף זה יש לממש סמפור באמצעות פעולות מעבד אטומיות בלבד: testAndSet, compareAndSet, fetchAndAdd, fetchAndSub.\nתיאור הפתרון:\nהגדרת הסמפור (יש לציין ערכי אתחול בהערה, אין צורך לדאוג לפעולות אתחול והקצאות דינמיות/שחרור זיכרון):",
          "code_snippet": "typedef struct _sem_t2 {\n} sem_t2;\n\nvoid sem_wait(sem_t2 *sem) {\n}\n\nvoid sem_post(sem_t2 *sem) {\n}",
          "options": null
        }
      ],
      "points": 10,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "שאלה 7\n1. עם מנעולים ומשתנאי תנאי, נגן על הסמפור באמצעות מנעול ונשתמש במשתנה תנאי להמתנה:\ntypedef struct _sem_t1 {\n    pthread_mutex_t lock;\n    pthread_cond_t cond;\n    int counter; // init to semaphore init value\n} sem_t1;\n\nvoid sem_wait(sem_t1 *sem) {\n    pthread_mutex_lock(&sem->lock);\n    while (sem->counter == 0) {\n        pthread_cond_wait(&sem->cond, &sem->lock);\n    }\n    --sem->counter;\n    pthread_mutex_unlock(&sem->lock);\n}\n\nvoid sem_post(sem_t1 *sem) {\n    pthread_mutex_lock(&sem->lock);\n    ++sem->counter;\n    pthread_cond_signal(&sem->cond);\n    pthread_mutex_unlock(&sem->lock);\n}\n\n2. עם פעולות מעבד אטומיות, נממש מעין ticket-lock לגישה לערך הסמפור:\ntypedef struct _sem_t2 {\n    int ticket; // init to 0\n    int turn; // init to 0\n    int counter; // init to semaphore init value\n} sem_t2;\n\nvoid sem_wait(sem_t2 *sem) {\n    int myticket = fetchAndAdd(&sem->ticket);\n    while (myticket != sem->turn)\n        yield();\n    while (sem->counter == 0)\n        yield();\n    fetchAndSub(&sem->counter);\n    fetchAndAdd(&sem->turn);\n}\n\nvoid sem_post(sem_t2 *sem) {\n    fetchAndAdd(&sem->counter);\n}\n\nמימוש אפשרי נוסף דומה למנעול-N (מתוך מבחן 22BC). קריאה ל-wait שקולה להמתנה לתור (כניסה לקטע הקריטי),\nוקריאה ל-post שקולה ליציאה מהקטע הקריטי (המאפשרת לחוט נוסף לבצע wait בהצלחה):\ntypedef struct _sem_t2 {\n    int ticket; // init to 0\n    int turn; // init to semaphore init value\n} sem_t2;\n\nvoid sem_wait(sem_t2 *sem) {\n    int myticket = fetchAndAdd(&sem->ticket);\n    while (myticket > sem->turn)\n        yield();\n}\n\nvoid sem_post(sem_t2 *sem) {\n    fetchAndAdd(&sem->turn);\n}"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "I/O",
        "Disk Scheduling"
      ],
      "content": {
        "text": "נתון דיסק קשיח ועליו מערכת קבצים VSFS עם שדרוג: בכל inode יש מקום ל-256 בתים של נתונים של הקובץ.\nבתים אלו נשמרים בשדה בתוך ה-inode עצמו, ולא בתוך בלוק DATA כמו שאר נתוני הקובץ. רק כאשר גודל הקובץ חורג מכמות זו, מערכת הקבצים תשתמש במצביעים עבור המשך נתוני הקובץ.\nכמו-כן נתון:\n- מהירות הסיבוב של הדיסק (RPM) היא 7500.\n- זמן ה-seek הממוצע של הדיסק הוא 15ms.\n- קצב ההעברה המקסימלי של הדיסק הוא MB/s 1.\n- גודל בלוק הוא 4KB וגודל מצביע הוא 8 בתים.\n- גודל inode הוא 512 בתים (כולל 256 הבתים של הנתונים).\n- בכל inode יש 9 מצביעים ישירים, 3 מצביעים עקיפים, ומצביע עקיף כפול אחד.\n- בנתונים (DATA) של תיקייה קיימת טבלה עם 2 עמודות, גודל כל שורה בטבלה הוא מספר התווים בשם הקובץ (בית אחד לכל תו) + בית אחד נוסף.\n- גודל הנתונים של קישור סימבולי הוא בית אחד לכל תו.\nיש לפרט ולנמק את כל החישובים בכל סעיף.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה בלוקים של DATA הוא יתפוס?",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "משתמש ביצע פעולת קריאה של 116KB מתוך הקובץ: home/mta/os/symlink/\n/usr/tmp/data/myfile :ידוע שקובץ זה הוא קישור סימבולי אל הקובץ\nפעולת הקריאה היא מתחילת הקובץ, ונתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nמה הזמן המינימלי שתיקח פעולה זו?\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "סטודנט טען כי מספר הקבצים המקסימלי שנוכל לגשת אליהם במערכת קבצים זו הוא חסום וקטן מאוד, למרות שאין מידע על טבלת ה-inodes (ואפילו אם הטבלה תהיה גדולה).\nהאם טענת הסטודנט נכונה? אם כן, יש לציין איזה נתון מגביל את מספר הקבצים הנגישים המקסימלי ומה המספר. אחרת, יש לציין איזה נתון חסר כדי שנוכל לחשב את מספר זה, ומהו המספר (כפונקציה של הנתון החסר).",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "שאלה 8\n1. בכל בלוק עקיף נכנסים 4096/8 = 512 מצביעים.\nלפי המצביעים ב-inode נקבל 512^2 + 512*3 + 9 בלוקים עם נתוני הקובץ, לזה נוסיף את 256 הבתים בתוך ה-inode עצמו.\nבשביל כמות הבלוקים נוסיף את הבלוקים של המצביעים – 3 עקיפים, ואחד עקיף כפול שמוביל לעוד 512 עקיפים,\nסה\"כ: 1+512+512^2 + 512*3+3 + 9 בלוקים\n\n2. כדי לבצע את הקריאה נצטרך לקרוא תחילה inode + DATA של 4 תיקיות ואז של הקובץ symlink עצמו ( + inode DATA). לאחר מכן נצטרך לקרוא עוד 3 תיקיות של הנתיב השני ואז את הקובץ myfile עצמו.\nסה\"כ 9 פעמים inode + DATA. בכל בלוק יש inodes 8, במקרה המינימלי ה-DATA הנדרש יהיה בתוך 256 הבתים של כל ה-inodes וכולם ישבו ב-2 בלוקים רציפים.\nלאחר מכן נצטרך לקרוא את נתוני הקובץ עצמם. 116KB זה 29 בלוקים (גם אחרי הפחתה של 256 בתים), כלומר שנצטרך להשתמש במצביע עקיף אחד – סה\"כ 30 בלוקים לקריאה. במקרה המינימלי כל הבלוקים האלו נמצאים באופן רציף ומיד אחרי 2 הבלוקים של ה-inodes שקראנו קודם. כלומר, ההעברה כולה היא קריאה רציפה של 32 בלוקים.\nבמקרה המינימלי לא יהיה זמן seek והמתנה לסיבוב, כלומר שזמן הפעולה הוא קריאת הבלוקים בלבד. בנוסף במקרה המינימלי כל הבלוקים יושבים ברצף (2 הבלוקים של inodes ומיד אחריהם כל ה-DATA), כך שזמן הפעולה הוא ההעברה של 32 בלוקים.\nלפי קצב העברה של 1MB/s, להעביר 32 בלוקים (128KB) זה בדיוק שמינית שניה, כלומר 125 מילישניות.\nהפעולה גם מעדכנת את זמן הגישה ב-inode (תוספת של 3.9ms), אך זה לא נדרש בבדיקה ובמקרה המינימלי.\nהתייחסות לכמות הנתונים שנקראו בפועל מכל בלוק היא לא נכונה, כי ההנחה שהפעולה רציפה אומרת שנקרא את כל הנתונים לאורך הדרך (אי אפשר \"לקפוץ\").\n\n3. הסטודנט צודק.\nמאחר שכל רשומה בתיקייה מכילה רק 8 ביטים בנוסף לשם הקובץ, ניתן לגשת רק למספרי inode הניתנים לייצוג ע\"י 8 ביטים, כלומר רק ל-256 קבצים."
      },
      "difficulty_estimation": "Hard"
    }
  ]
}