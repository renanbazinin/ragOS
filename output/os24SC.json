{
  "metadata": {
    "course_name": "Operating Systems",
    "year": "2024",
    "semester": "Summer",
    "moed": "Moed C",
    "exam_date": "02.12.2024",
    "source_file": "os24SC.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Atomic Operations",
        "Synchronization",
        "Concurrency"
      ],
      "content": {
        "text": "נתון מעבד התומך בפעולה האטומית TAS, הניתנת להפעלה ע\"י קריאה לפונקציה: סטודנט כתב את הפונקציה הבאה לקידום ב-1 באופן אטומי (ללא ערך החזר) באמצעות פעולת TAS:",
        "code_snippet": "int testAndSet(int* ptr, int val);\nint incrementWithTAS(int* val) {\n// repeat until old val is different than new val\n// i.e., until *this thread* increments val\nwhile (*val != testAndSet (val, *val+1));\n}",
        "options": [
          "א. המימוש תקין, הערך של val תמיד יקודם באופן נכון.",
          "ב. המימוש תקין, אך יפגין ביצועים פחות טובים משימוש ב-F&A.",
          "ג. המימוש לא תקין, שימוש בו עלול לגרום לקיפאון.",
          "ד. המימוש לא תקין, שימוש בו עלול לגרום להרעבה.",
          "ה. המימוש לא תקין, הערך של val לא תמיד יקודם באופן נכון."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. חוט כלשהו יכול לקרוא ערך של val (בקריאה של val*) ואז להתעכב זמן רב עד ביצוע הפעולה בזמן שחוטים אחרים קידמו את הערך, וכך להחזיר את הערך של val לערך קודם באופן לא נכון. פעולת TAS תמיד מבצעת את הכתיבה בהצלחה, והחלק האטומי בה הוא רק החלק שמחזיר לנו את הערך שהיה שם קודם."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "Threads",
        "Processes"
      ],
      "content": {
        "text": "נתון תהליך מרובה חוטים כלשהו. איזו טענה בהכרח נכונה לגבי החוטים של תהליך זה?",
        "code_snippet": null,
        "options": [
          "א. אם החוט הראשי מסתיים, כל שאר החוטים יעצרו מיד.",
          "ב. אם החוט הראשי מסתיים, שאר החוטים ימשיכו לרוץ עד שיסתיימו גם.",
          "ג. אם החוט הראשי מסתיים, חלק מהחוטים יעצרו מיד ואחרים ימשיכו לרוץ.",
          "ד. אם החוט הראשי מסתיים, התהליך יסתיים מיד אך יתכן ששאר החוטים ימשיכו לרוץ.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. כאשר החוט הראשי מסתיים, תלוי איך יסתיים יתכן שכל שאר החוטים יעצרו מיד ויתכן שכולם ימשיכו לרוץ עד שיסתיימו."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "Processes",
        "CPU Scheduling",
        "System Calls"
      ],
      "content": {
        "text": "מה זו החלפת הקשר (context switch)?",
        "code_snippet": null,
        "options": [
          "א. מנגנון לעצירת תהליכים כל פרק זמן קבוע.",
          "ב. מנגנון להחזרת השליטה למערכת ההפעלה.",
          "ג. מנגנון המאפשר לשנות את התהליך הנוכחי שמריץ המעבד.",
          "ד. פסיקה שמתרחשת כל זמן קבוע לצורך החלפה בין תהליכים.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. החלפת הקשר זה המנגנון המאפשר החלפה של התהליך הנוכחי שרץ על גבי המעבד."
      },
      "difficulty_estimation": "Easy"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "סטודנט טען כי ניתן לשפר את ביצועי VSFS באופן הבא: אם בכתיבה לקובץ אנו יודעים בוודאות שלא נעשה שינוי בקובץ (לדוגמה, כי יש לנו את ה-DATA העדכני ב-cache מפעולה קודמת), כלומר שתוכן הקובץ זהה לחלוטין לפני ואחרי פעולת הכתיבה, אז אין צורך לבצע כתיבות לדיסק עבור הפעולה.",
        "code_snippet": null,
        "options": [
          "א. הסטודנט צודק, וזה ישפר את ביצועי מערכת הקבצים.",
          "ב. הסטודנט צודק, אך לא תהיה לזה השפעה על ביצועי מערכת הקבצים (או השפעה זניחה).",
          "ג. הסטודנט טועה, יש מידע נוסף שנדרש לכתוב לדיסק מלבד ה-DATA.",
          "ד. הסטודנט טועה, נהיה חייבים לכתוב את ה-DATA אפילו אם הוא זהה ל-DATA הקיים.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ג",
        "explanation": "ג'. אם לא נעשה שינוי ב-DATA אין טעם לכתוב ערך זהה, אך נדרש לעדכן את ה-inode עם זמן השינוי האחרון של הקובץ."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Mutexes",
        "Concurrency"
      ],
      "content": {
        "text": "נתון מנעול Alock עם מערך בגודל N. איזו טענה בהכרח נכונה?",
        "code_snippet": null,
        "options": [
          "א. אם קיימים N חוטים בתהליך, חוט שתפס את המנעול יצליח לתפוס אותו שוב רק אחרי שכל 1-N החוטים האחרים תפסו ושחררו אותו.",
          "ב. אם יש 1+N חוטים המנסים לתפוס את המנעול, המנעול יקיים מניעה הדדית.",
          "ג. אם יש 1+N חוטים המנסים לתפוס את המנעול, המנעול יקיים חופש מקיפאון.",
          "ד. אם יש 1+N חוטים המנסים לתפוס את המנעול, המנעול יקיים הוגנות.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": true,
        "correct_option": "ה",
        "explanation": "ה'. אם יש 1+N חוטים ורק N תאים במערך, המנעול לא יקיים אף אחת מהתכונות."
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "Open",
      "topic": [
        "Memory Management",
        "Paging",
        "Virtual Memory"
      ],
      "content": {
        "text": "נתונה מערכת בה אין טבלאות דפים, ובמקום זאת יש ל-MMU (בזיכרון של הרכיב עצמו) טבלת תרגום כתובות אחת ויחידה לכל התהליכים והמסגרות. טבלת מיפוי זו היא טבלה הפוכה: האינדקס לטבלה הוא מספר מסגרת, ותוכן כל תא בטבלה הוא מזהה תהליך, מספר הדף של התהליך – אשר ממופה למסגרת המתאימה לאינדקס של התא, ביטים של סטטוס וריפוד (אם נדרש). יש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "נתונה מערכת עם טבלת דפים הפוכה בה גודל דף הוא 8KB, התומכת בזיכרון פיזי מקסימלי של 4GB. גודל הטבלה ההפוכה הוא 4MB, כאשר בכל רשומה בטבלה (PTE) חצי מהביטים משמשים למספר הדף והחצי השני משמשים למזהה התהליך, ביטים של סטטוס, וריפוד. מה גודל הזיכרון הוירטואלי של תהליך במערכת? זיכרון וירטואלי: נימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "נתונה מערכת עם טבלת דפים הפוכה בה גודל דף הוא 8KB והזיכרון הוירטואלי הוא 1GB. גודל הטבלה ההפוכה הוא 16MB, כאשר גודל כל רשומה בטבלה (PTE) הוא 4B. ידוע כי הזיכרון של הקרנל תופס 2 מסגרות במינימום. כמה תהליכים עם זיכרון מקסימלי ניתן להריץ במערכת זו? מספר תהליכים: נימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "6.1: 1. זיכרון פיזי 4GB וגודף דף 8KB אומר שיש 512K מסגרות בזיכרון הפיזי. הטבלה הפוכה לכן יש בה רשומה אחת לכל מסגרת, כלומר 512K רשומות בטבלה. גודל הטבלה הוא 4MB עם 512K רשומות, כלומר שגודל כל רשומה הוא 8B. לפי הנתון חצי מהרשומה משמש למספר הדף, כלומר שמספר הדף הוא 4B = 32 ביטים, לכן לכל תהליך יש 2^32 = 4G דפים. גודל דף הוא 8KB, לכן גודל הזיכרון הוירטואלי הוא 32TB = 4G*8KB.\n6.2: 2. גודל הטבלה ההפוכה 16MB וגודל רשומה 4B כלומר שיש 4M רשומות בטבלה, ולכן 4M מסגרות בזיכרון הפיזי. גודל דף 8KB עם זיכרון וירטואלי 1GB, כלומר לכל תהליך יש 128K דפים (בזיכרון מקסימלי משתמש בכולם). ב-4M רשומות/מסגרות ניתן להכניס 32 תהליכים, אך צריך זיכרון גם לקרנל – לפי הנתון הקרנל תופס מינימום 2 מסגרות כלומר במקסימום נוכל להריץ 31 תהליכים."
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 7,
      "type": "CodeAnalysis",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Atomic Operations",
        "Mutexes"
      ],
      "content": {
        "text": "מנעול חד-פעמי הוא מנעול אשר ניתן לנעול פעם אחת בלבד: ברגע שחוט תופס את המנעול בהצלחה, אף חוט אחר לא יכול לתפוס יותר את המנעול לכל אורך התוכנית. פונקציית הנעילה של מנעול חד-פעמי מחזירה 0 לחוטים אשר נכשלו בתפיסת המנעול מבלי לחסום אותם (כלומר, ללא המתנה בדומה לקריאת trylock), ומחזירה 1 לחוט שהצליח. הבהרה: במנעול חד-פעמי, ברגע שחוט מסוים קיבל 1 מפונקציית הנעילה (תפס את המנעול בהצלחה), כל קריאה עתידית בכל חוט תחזיר 0, אפילו אם המנעול פנוי מאחר שהוא חד-פעמי. במנעול חד-פעמי ל-N חוטים מובטח שפונקציית הנעילה של כל מנעול לא נקראת יותר מ-N פעמים בכל ריצת התוכנית. נניח שלרשותנו עומדת פקודת חומרה אטומית ששמה Flip, אשר מבצעת היפוך לוגי לערך כלשהו (כמו אופרטור NOT בוליאני) ומחזירה את ערכו לפני ההיפוך. את הפקודה ניתן לתאר כך: הבהרה: תיאור הפעולה הוא קוד C לצורך הסבר בלבד. פעולת המעבד מבצעת זאת באופן אטומי ולא בכמה פעולות. בכל שאלה זו אין להשתמש באובייקטי סנכרון או פעולות מעבד אטומיות מלבד Flip, ויש לדאוג למניעה הדדית וחופש מקיפאון.",
        "code_snippet": "int flip(int* val) {\n*val = !*val;\nreturn !*val;\n}",
        "options": null
      },
      "sub_questions": [
        {
          "id": "7.1",
          "text": "ממשו מנעול חד-פעמי ל-2 חוטים המשתמש בתא זיכרון יחיד (משתנה אחד x המתקבל כפרמטר). יש לממש את הפונקציות הבאות:",
          "code_snippet": "void init2(int* x) {\n}\nint lock2(int* x) {\n}",
          "options": null
        },
        {
          "id": "7.2",
          "text": "ממשו מנעול חד-פעמי ל-3 חוטים המשתמש ב-2 תאי זיכרון (2 משתנים x,y המתקבלים כפרמטר). יש לממש את הפונקציות הבאות:",
          "code_snippet": "void init3(int* x, int* y) {\n}\nint lock3(int* x, int y) {\n}",
          "options": null
        },
        {
          "id": "7.3",
          "text": "ממשו מנעול חד-פעמי ל-N חוטים (כאשר N פרמטר בפונקציית האתחול). יש להגדיר את מבנה המנעול (struct CALock) ולממש את הפונקציות הבאות:",
          "code_snippet": "typedef struct _fliplock {\n} FlipLock;\nvoid init(FlipLock *lock, int N) {\n}\nint lock(FlipLock *lock) {\n}\nvoid destroy (FlipLock *lock) {\n}",
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "7.1: 1. נשתמש ב-flip כדי להבדיל בין החוט הראשון שמנסה לתפוס את המנעול לחוט השני. עבור הראשון נחזיר ערך כך שיתפוס בהצלחה את המנעול, ועבור השני לא (ולא להיפך – אחרת יהיה קיפאון אם השני לא ינסה לתפוס את המנעול).\nCode:\nvoid init2(int* x) {\n*x = 1;\n}\nint lock2(int* x) {\nreturn flip(x);\n}\n\n7.2: 2. אם נשתמש באותה שיטה מהסעיף הקודם, החוט הראשון והחוט השלישי יקבלו את אותו ערך. לא ניתן להכריע לטובת החוט השני זה יגרום לקיפאון כי לא מובטח ש-2 חוטים ינסו לתפוס את המנעול. לכן נצטרך להיעזר במשתנה הנוסף. נשתמש ב-ע כדי \"לפסול\" את החוט השני (רק הראשון והשלישי שיבצעו עליו flip יקבלו חזרה 1), ואז נשתמש ב-א כמו בסעיף הקודם כדי להכריע בין 2 החוטים שנשארו.\nCode:\nvoid init3(int* x, int *y) {\n*x = *y = 1;\n}\nint lock3(int* x, int *y) {\nif (flip(y))\nreturn flip(x);\nelse\nreturn 0;\n}\n\n7.3: 3. בדומה לסעיף הקודם, נשתמש בסדרה של משתנים כדי לפסול חלק מהחוטים כל פעם. כל חוט שיקבל 1 מ-flip ימשיך \"להתחרות\" באמצעות המשתנה הבא, ולכל חוט שיקבל 0 (בשלב כלשהו) נחזיר 0 כך שנכשל בתפיסת המנעול. כל פעם ימשיכו חצי מהחוטים (מעוגל מעלה) עד שלבסוף רק חוט אחד \"יזכה\" במנעול.\nCode:\ntypedef struct _fliplock {\nint *arr;\nint size;\n} FlipLock;\nvoid init(FlipLock *lock, int N) {\nlock->size = log2(N)+1; // rounded up\nlock->arr = (int*) calloc(lock->size, sizeof(int));\n}\nint lock(FlipLock *lock) {\nfor (int i = 0; i < lock->size; ++i) {\nif (flip(lock->arr[i]))\nreturn 0;\n}\nreturn 1;\n}\nvoid destroy (FlipLock *lock) {\nfree(lock->arr);\n}"
      },
      "difficulty_estimation": "Hard"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "I/O",
        "Disk Scheduling",
        "File Systems"
      ],
      "content": {
        "text": "נתונה מערכת עם workload אקראי של 1MB וסדרתי של 50MB. יש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "פרטו נתונים של 3 דיסקים קשיחים לבחירתכם כך שיתקיימו התנאים הבאים:\n- דיסק קשיח א' הוא המהיר ביותר בתרחיש הסדרתי.\n- דיסק קשיח ב' הוא המהיר ביותר בתרחיש האקראי.\n- דיסק קשיח ג' אינו האיטי ביותר באף אחד מהתרחישים.\nלכל דיסק יש לפרט קצב העברה מקסימלי, זמן seek, ו-RPM.",
          "code_snippet": null,
          "options": [
            "קצב העברה א': MB/s",
            "קצב העברה ב': MB/s",
            "קצב העברה ג': MB/s",
            "זמן seek א': ms",
            "זמן seek ב': ms",
            "זמן seek ג': ms",
            "קצב RPM א':",
            "קצב RPM ב':",
            "קצב RPM ג':",
            "נימוק:"
          ]
        },
        {
          "id": "8.2",
          "text": "משתמש ביצע ניסוי על דיסק כלשהו, והופתע לגלות שהקצב הממוצע בתרחיש הסדרתי (של 50MB) זהה לקצב הממוצע בתרחיש האקראי (של 1MB), עבור אותו דיסק. מה יכולים להיות מאפייני הדיסק כדי להסביר את תוצאה זו?",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": true,
        "correct_option": null,
        "explanation": "8.1: 1. נבחר לכל הדיסקים את אותו RPM כך שלא ישפיע על הביצועים. נרצה: דיסק א' עם קצב העברה מהיר ו-seek איטי, דיסק ב' עם קצב העברה איטי ו-seek מהיר, ודיסק ג' שהוא ממוצע. להלן בחירה אפשרית: דיסק א': 25MB/s, seek 1s דיסק ב': 1MB/s, seek 0.01s דיסק ג': 10MB/s, seek 0.55s כאמור, לא משנה ה-RPM שנבחר כל עוד הוא זהה לשלושתם, ואז זמן ההמתנה לסיבוב לא משפיע על ההבדל ביניהם. בתרחיש הסדרתי: דיסק א' 2 שניות, דיסק ב' 25.01 שניות, דיסק ג' 3 שניות. בתרחיש האקראי: דיסק א' 1.02 שניות, דיסק ב' 0.51 שניות, דיסק ג' 0.55 שניות.\n8.2: 2. יש כמה סיבות אפשריות לתופעה, אחת מהן היא שבדיסק אין track skew וכמות הנתונים הרצופים (בצילינדר) היא 512KB, לכן הגענו למהירות האופטימלית וקריאה של יותר נתונים ברצף גורמת לזמן המתנה ארוך לסיבוב (ועוד זמן seek קצר בין רצועות סמוכות)."
      },
      "difficulty_estimation": "Medium"
    }
  ]
}