{
  "metadata": {
    "course_name": "מערכות הפעלה",
    "year": "2025",
    "semester": "סמסטר ב'",
    "moed": "מועד ב'",
    "exam_date": "04.08.2025",
    "source_file": "os25BB.pdf"
  },
  "questions": [
    {
      "id": 1,
      "type": "MultipleChoice",
      "topic": [
        "Scheduling",
        "CPU Scheduling",
        "Processes"
      ],
      "content": {
        "text": "נתונה מערכת עם אלגוריתם תזמון מבוסס RR מלבד ההבדל הבא: משימה חדשה מתווספת לתחילת התור במקום לסופו, ומתחילה לרוץ לאחר סיום הקוונטה הנוכחית. משימה שסיימה את הקוונטה שלה עדיין חוזרת לסוף התור, ויש להניח שלא נוצרות 2 משימות חדשות בו-זמנית.\nאיזו טענה בהכרח נכונה?",
        "code_snippet": null,
        "options": [
          "א. זמן התגובה של האלגוריתם הוא אופטימלי.",
          "ב. זמן המחזור של האלגוריתם תמיד עדיף או שווה לזה של RR סטנדרטי.",
          "ג. לכל 1<N, אם מספר המשימות בתור בכל רגע נתון הוא בדיוק N, בהכרח תתרחש הרעבה.",
          "ד. לכל 1<N, אם מספר המשימות בתור בכל רגע נתון הוא בדיוק N, לא תיתכן הרעבה.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": false,
        "correct_option": null,
        "explanation": null
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 2,
      "type": "MultipleChoice",
      "topic": [
        "File Systems",
        "I/O"
      ],
      "content": {
        "text": "נתון שרת עם 6 דיסקים קשיחים בעלי נתונים זהים, בגודל 2TB כל אחד.\nאיזה מהמנגנונים הבאים יאפשר להתמודד עם קלקול של יותר מדיסק אחד? מבין אלו, יש לבחור את המנגנון המספק את שטח האחסון המקסימלי.",
        "code_snippet": null,
        "options": [
          "א. RAID-0",
          "ב. RAID-1 עם mirroring level של 2",
          "ג. RAID-1 עם mirroring level של 3",
          "ד. RAID-5.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": false,
        "correct_option": null,
        "explanation": null
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 3,
      "type": "MultipleChoice",
      "topic": [
        "I/O",
        "System Calls",
        "File Systems"
      ],
      "content": {
        "text": "ברצוננו לפתח מנהל התקן (דרייבר) שבו נשמר ערך פרטי לכל גישה להתקן, שאינו משותף עם שאר הגישות לאותו התקן.\nמה הדרך הנכונה ביותר לעשות זאת?",
        "code_snippet": null,
        "options": [
          "א. נגדיר פרמטר למודול, כך שיהיה ניתן להתקין אותו עם ערך שונה לפי הנדרש.",
          "ב. נגדיר מערך גלובלי וניגש אליו לפי ה-MINOR של ההתקן עליו מבוצעת הפעולה.",
          "ג. ארגומנט הקובץ (struct file) מאפשר לשמור ערך פרטי לכל גישה שונה להתקן.",
          "ד. ארגומנט ההיסט (offset) בפעולות קריאה/כתיבה מאפשר לנו לשמור ערך פרטי הנפרד מגישות אחרות להתקן.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": false,
        "correct_option": null,
        "explanation": null
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 4,
      "type": "MultipleChoice",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Atomic Operations",
        "Mutexes"
      ],
      "content": {
        "text": "נתונה מערכת עם N חוטים המשתמשת במנעול מסוג ticket lock, וידוע שבנקודת זמן מסוימת בריצה הערך הנוכחי של ticket הוא X.\nמה הערך המקסימלי האפשרי של turn באותה נקודת זמן?",
        "code_snippet": null,
        "options": [
          "א. X",
          "ב. X-1",
          "ג. X-N",
          "ד. X-N+1",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": false,
        "correct_option": null,
        "explanation": null
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 5,
      "type": "MultipleChoice",
      "topic": [
        "Memory Management",
        "Virtual Memory",
        "Paging"
      ],
      "content": {
        "text": "נתונה מערכת עם טבלת דפים לינארית בה כל רשומה (PTE) מכילה 3 ביטים של סטטוס. כתובת פיזית מורכבת מהיסט של 13 ביטים ומספר מסגרת של 23 ביטים.\nבמערכת זו רצים 2 תהליכים A,B, וידוע שטבלת הדפים של תהליך A היא בגודל 4 מסגרות בדיוק.\nמהו מרחב הכתובות של תהליך B?",
        "code_snippet": null,
        "options": [
          "א. 8KB",
          "ב. 8MB",
          "ג. 64MB",
          "ד. אין מספיק נתונים כדי לחשב את התשובה.",
          "ה. כל התשובות האחרות אינן נכונות."
        ]
      },
      "sub_questions": null,
      "points": 5,
      "solution": {
        "is_present_in_file": false,
        "correct_option": null,
        "explanation": null
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 6,
      "type": "CodeAnalysis",
      "topic": [
        "Processes",
        "IPC",
        "System Calls",
        "Memory Management",
        "Paging"
      ],
      "content": {
        "text": "נתונה התוכנית הבאה:\nהריצו את התוכנית, והתהליך שנוצר קיבל את מזהה התהליך 42.\nבמערכת זו נתון גם:\n- גודל דף הוא 1KB.\n- טבלת הדפים של כל תהליך תמיד תופסת דף אחד בדיוק.\n- תהליך 42 משתמש ב:\n  Ο 2 דפים של TEXT.\n  Ο 2 דפים של DATA.\n  Ο דף אחד של מחסנית.\n  Ο דף אחד של ערימה.\n- כל pipe משתמש בחוצץ (buffer) בגודל דף אחד.\nיש להניח שכל קריאות המערכת שיכולות להצליח הצליחו, לא נוצרים תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.\nתזכורת: כל הדפסה לפלט הסטנדרטי מתבצעת מיד, ללא חוצץ (buffer) הדפסה או המתנה לירידת שורה.",
        "code_snippet": "1 char buf[1024]; // 1024 bytes\n2 \n3 int main() {\n4   int rc;\n5   int pipefd[2]; // 0-read end, 1-write end\n6   pipe (pipefd);\n7 \n8   if (fork() > 0) {\n9     close(pipefd[0]);\n10 \n11    for (int i = 0; i < 3; ++i) {\n12      buf[0] = 'A'+i; // i=0->'A', i=1->'B', etc.\n13 \n14      // write 1024 bytes into pipe\n15      write(pipefd [1], buf, 1024);\n16      printf(\"%c\", buf[0]);\n17    }\n18    close(pipefd[1]);\n19    wait(NULL);\n20  }\n21  else {\n22    close(pipefd[1]);\n23 \n24    // read 1024 bytes from pipe\n25    while ((rc = read(pipefd[0], buf, 1024)) != 0)\n26      printf(\"%c\", buf[0]);\n27  }\n28}"
      },
      "sub_questions": [
        {
          "id": "6.1",
          "text": "כתבו את כל הפלטים האפשריים של התוכנית.\nיש להסביר כל פלט באופן מפורט.\nמספר פלטים אפשריים:\nפירוט הפלטים ונימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.2",
          "text": "איזו תופעה תתרחש אם נמחק (או נכניס להערה) את שורה 18 של התוכנית?\nיש לפרט את התופעה במלואה ולהסביר מדוע השינוי גורם לה.\nהתופעה:\nנימוק:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "6.3",
          "text": "מה המספר המקסימלי של מסגרות של מרחב המשתמש (user space) שיכולות להיות בשימוש ע\"י תהליכים 42 ו-43 במהלך ריצת התוכנית הנתונה?\nיש לפרט את הריצה והנקודה בריצה שמובילה למקסימום זה, ולפרט את כל המסגרות הרלוונטיות שיהיו בשימוש.\nניתן להניח כל תרחיש שיוביל למספר המקסימלי, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.\nמספר מסגרות מקסימלי:\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": false,
        "correct_option": null,
        "explanation": null
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 7,
      "type": "Open",
      "topic": [
        "Synchronization",
        "Concurrency",
        "Threads",
        "Atomic Operations",
        "Semaphores"
      ],
      "content": {
        "text": "בסניף קופת חולים מקומי יש N חדרים אליהם מטופלים יכולים להיכנס.\nכל מטופל שמגיע ממתין לתורו. כאשר מגיע תורו, המטופל נכנס לחדר המתאים עד לסיום הטיפול. אין הבדל בין החדרים וכל מטופל יכול לקבל טיפול בכל חדר, אך בכל חדר יש לטפל במטופל אחד בלבד בכל רגע נתון.\nלצורך מחשוב הסניף הוחלט לייצג כל מטופל ע\"י חוט. מטופל המגיע לסניף קורא לפעולה ()enter על-מנת להמתין לתורו, ולפעולה (leave(i לאחר שסיים את הטיפול בחדר בֿ, ואז החדר i פנוי. הקריאה ()enter צריכה לחסום את המטופל עד שהגיע תורו, ולהחזיר את מספר החדר אליו על המטופל להיכנס (0 עד 1-N).\nבשאלה זו יש לכתוב אובייקט סנכרון עבור מערכת זו (מימוש לפעולות enter, leave) כך שלקוחות שונים יוכלו לקרוא לפעולות אלו במקביל וקופת החולים תעבוד באופן תקין:\n- בכל רגע נתון, בכל חדר יש לכל היותר מטופל אחד.\n- אם יש חדר פנוי ויש מטופלים ממתינים, מטופל כלשהו יכנס לחדר הפנוי.\n- מטופלים יכנסו לחדרים באופן הוגן. כלומר, לא יתכן מצב שבו מטופל ממתין לצמיתות בזמן שמטופלים אחרים נכנסים ויוצאים מחדרי הטיפול ללא הגבלה.\nניתן להניח שימוש נכון באובייקט הסנכרון, כך שכל מטופל קורא לפעולות אלו לפי הסדר ומעביר את הארגומנט הנכון.\nלצורך המימוש ניתן להשתמש בפעולות האטומיות F&A, CAS בלבד. אין להשתמש באובייקטי סנכרון או פקודות מכונה אטומיות אחרות. יש להימנע מ-spinning ע\"י שימוש נכון בקריאה ()pthread_yield.\nעבור הפתרון הוגדר הקבוע N והמשתנים הגלובליים הבאים:\nאין להוסיף משתנים גלובליים או סטטיים, או לשנות את הגדרות וערכי אתחול אלו.\nשימו לב: פתרון המאפשר רק למטופל אחד לקבל טיפול בכל רגע נתון אינו עומד בדרישות, ולא יקבל ניקוד.\nתיאור הפתרון:",
        "code_snippet": "int r[N] = {0}; // init all to 0\nint next = 0, turn = 0;\n\nint enter() {\n}\nvoid leave(int i) {\n}"
      },
      "sub_questions": null,
      "points": 25,
      "solution": {
        "is_present_in_file": false,
        "correct_option": null,
        "explanation": null
      },
      "difficulty_estimation": "Medium"
    },
    {
      "id": 8,
      "type": "Open",
      "topic": [
        "File Systems",
        "Security",
        "Atomic Operations"
      ],
      "content": {
        "text": "שאלה זו מתייחסת למערכת קבצים VSFS עם journaling (ללא metadata journaling).\nמספר סטודנטים התווכחו לגבי הצורך להשתמש בטרנזקציות עבור פעולות מסוימות במערכת זו:\n- סטודנט א' טוען: עבור כל פעולה במערכת הקבצים הדורשת כתיבה אל בלוק אחד בלבד, אין צורך ליצור טרנזקציה ואפשר לבצע את הכתיבה ישירות במערכת הקבצים ועדיין להתמודד בהצלחה עם קריסה.\n- סטודנט ב' טוען: סטודנט א' צודק, אך גם עבור פעולות הדורשות כתיבה אל 2 בלוקים אין צורך ליצור טרנזקציה, בתנאי שלפחות אחד הבלוקים הוא בלוק שנמצא ב-DATA region.\n- סטודנט ג' טוען: סטודנט ב' צודק, אך הטענה נכונה עבור כל פעולה הדורשת כתיבה אל 2 בלוקים לכל היותר, גם אם כל הבלוקים הנכתבים אינם נמצאים ב-DATA region.\n- סטודנט ד' טוען: הסטודנטים האחרים טועים, כדי להתמודד עם קריסות יש ליצור טרנזקציה עבור כל פעולה הדורשת כתיבה אל בלוק כלשהו.\nשימו לב: בבלוקים של כל פעולה הכוונה היא לבלוקים הנדרשים עבור הפעולה עצמה ב-VSFS ללא כתיבת הטרנזקציה הנדרשת עבור אותה פעולה. בכל הפעולות אין מגבלה על כמות הבלוקים אותם נדרש לקרוא עבור הפעולה.",
        "code_snippet": null,
        "options": null
      },
      "sub_questions": [
        {
          "id": "8.1",
          "text": "תארו פעולה במערכת קבצים VSFS (ללא journaling) אשר דורשת כתיבה אל בלוק אחד בלבד.\nיש לפרט את כל הבלוקים אליהם נדרש לגשת עבור הפעולה, לקריאה ולכתיבה, לפי סדר הגישה הנדרש.\nניתן להניח כל תרחיש שיביא לפעולה זו, אך נתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nהפעולה:\nפירוט הפעולה:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.2",
          "text": "תארו פעולה במערכת קבצים VSFS (ללא journaling) אשר דורשת כתיבה אל 2 בלוקים בדיוק, כאשר לפחות אחד מהם הוא בלוק שנמצא ב-DATA region.\nיש לפרט את כל הבלוקים אליהם נדרש לגשת עבור הפעולה, לקריאה ולכתיבה, לפי סדר הגישה הנדרש.\nניתן להניח כל תרחיש שיביא לפעולה זו, אך נתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nהפעולה:\nפירוט הפעולה:",
          "code_snippet": null,
          "options": null
        },
        {
          "id": "8.3",
          "text": "מי מהסטודנטים צודק? יש לבחור בטענה הנכונה ביותר, ולהסביר בבירור מדוע הטענה נכונה והאחרות שגויות.\nסטודנט א' / סטודנט ב' / סטודנט ג' / סטודנט ד'\nנימוק:",
          "code_snippet": null,
          "options": null
        }
      ],
      "points": null,
      "solution": {
        "is_present_in_file": false,
        "correct_option": null,
        "explanation": null
      },
      "difficulty_estimation": "Medium"
    }
  ]
}