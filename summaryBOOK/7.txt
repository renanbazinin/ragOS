# מערכות הפעלה – שיעור 7

בשיעור הקודם התחלנו לדבר על דפדוף. אמרנו שטבלת הדפים עוזרת לנו לעשות את המיפוי מדף וירטואלי למסגרת.
הרכיב שעוזר לנו בתהליך התרגום הוא ה-**mmu** שמתבצע המרה מכתובת וירטואלית לכתובת פיזית שבה הנתונים הרצויים נמצאים. לכל תהליך יש טבלת דפים משלו.
טבלת הדפים היא כמו סוג של מערך שכל רשומה (pte) בו יש מיפוי.
**כאשר יהיה ניגש לכתובת וירטואלית אנחנו מתרגמים את זה לשני חלקים:**
1. לאיזה מספר דף הוא ניגש.
2. לאיזה היסט מתחילת הדף הזה.
את החלקים הללו אנחנו מסיקים מהכתובת הוירטואלית (לפי הביטים).
כמות הביטים שיש בכתובת הוירטואלית תלויה במרחב הכתובות של התהליך (מה גודל הזיכרון הוירטואלי שלו), למשל אם הכתובת הוירטואלית היא 16 ביטים אז גודל הזיכרון הוירטואלי של התהליך הוא 2^16 בתים.
**ההיסט תלוי בגודל הדף** – מספר הביטים לייצוג ההיסט הוא לוג 2 של גודל הדף. למשל אם גודל הדף הוא 2^14 אז ההיסט יהיה 14 ביטים (כלומר נדרשים 14 ביטים כדי לייצג כתובת כלשהי בתוך הדף).
מספר הביטים לייצוג ה-**vpn** הוא לוג 2 של כמות הדפים שיש לתהליך. למשל אם לתהליך יש 4 דפים בזיכרון הוירטואלי שלו, כמות הביטים לייצוג ה-**vpn** יהיה 2.

החלוקה של הכתובת הפיזית דומה לחלוקה של הכתובת הוירטואלית – ההיסט הוא בגודל זהה לגודל ההיסט של הדף הוירטואלי, ומספר המסגרת (**pfn**) יהיה הביטים שנותרו.
טבלת הדפים תשמש לתרגום בין מספר הדף הוירטואלי לבין מספר המסגרת הפיזית.
ה-**mmu** יודע איפה טבלת הדפים של כל תהליך, הוא מזין לטבלת הדפים את מספר הדף המבוקש ומקבל ממנה את מספר המסגרת אליה מספר הדף הזה ממופה. וכך אנחנו מקבלים את הכתובת הפיזית.

### טבלת הדפים:
לכל תהליך יש את הזיכרון שלו, זה הדפים שהוא תופס. אבל חוץ מזה, מערכת ההפעלה שומרת לנו את טבלת הדפים שלו. טבלת הדפים שומרת את המיפויים של אותו תהליך. כלומר, יש בה סט של רשומות, כאשר קיימת רשומה עבור כל דף של התהליך וכל רשומה כזאת מכילה את המיפוי (מספר המסגרת ועוד כמה עניינים) ובאמצעותה ה-**mmu** יכול לבצע את התרגום שלו.

### (pte (page table entry – רשומה בטבלת הדפים.
בכל **pte (page table entry)** שהיא רשומה בטבלה, יש מספר ביטים שנועדו לטור מספר עניינים:
יש את מספר המסגרת (**pfn**). בנוסף יש מספר ביטים ריקים, כי גודל הרשומה בדרך כלל מסוגל להחזקה הכי גבוהה של 2 שקרובה (אם נניח כל הנתונים תופסים 17 ביטים, גודל הרשומה יהיה 32 ביטים ולשם כך יהיו כמה ביטים ריקים חסרי משמעות).
בנוסף, יש עוד כל מיני ביטים של מידע על המיפוי (דפים), שנותנים לנו מידע נוסף לגבי המיפוי:
- **valid bit:** אומר האם המיפוי הזה בכלל תקף. תהליך לא משתמש בכל הדפים שלו. ייתכנו דפים שלא בשימוש והם לא צריכים לתפוס מקום. אם ביט זה הוא 0 אז המיפוי הזה לא תקף (זה דף שהתהליך לא משתמש בו). אם תהליך מנסה לגשת לדף כזה, כשה-**mmu** רואה שהביט הוא 0 הוא מוציא שגיאה למערכת ההפעלה (**trap**) שאומר שהתהליך ניגש לזיכרון לא תקין.

---

| Page Table |
| :--- |
| • Simplest form: **linear page table** |
| • Indexed by **VPN**, lookup **PTE** to find **PFN** |
| |
| |
| PFN | D | A | R/W | P | ... |
| | Bits |
| |
| • **Valid**: whether translation is valid |
| • Unused space is **invalid**, access will trap into OS |
| • **Protection (R/W)**: read / write / execute |
| • **Present (P)**: in physical memory or disk (discussed later) |
| • **Dirty (D)**: whether page has been modified |
| • **Reference (A)**: indicating page has been accessed (recently) |

- **Protection (R/W) bit:** ביט הרשאות (פעולות שניתן לעשות על הזיכרון הזה) – האם המיפוי ניתן לקריאה/כתיבה/הרצה. למשל, כל הדפים שמכילים את קטע הקוד (איזור הקוד) של התהליך, יוגדרו לקריאה בלבד, אי אפשר לשנות כלום ויש את הקוד של התהליך. האחסון והערימה יוגדרו לכתיבה. לכל דף ניתן לתת הרשאות שונות. אם ננסה לבצע פעולת כתיבה למקום שאסור לנו, ה-**mmu** ימצא את המיפוי המתאים ויראה שביט ה-**protection** לא תואם, ויוציא שגיאה.

- **Present (P) bit:** נדבר עליו בשיעור הבא.

שני הביטים הבאים מייצגים את הפעולות שבוצעו לאחרונה על הזיכרון (נדבר עליהם עוד בשיעור הבא):
- **Dirty (D) bit:** ביט שאומר האם הדף הזה שונה (לאחרונה).
- **Reference (A) bit:** ביט שאומר האם מישהו ניגש לדף הזה (לאחרונה).

אז רשומה בטבלת דפים (**pte**) היא רצף ביטים שמייצג את הנתונים הרלוונטיים של התהליך ואת מספר המסגרת.

כשה-**mmu** מבצע תרגום: ברגע שחילקנו את הכתובת הוירטואלית להיסט ולמספר דף, ההיסט מתורגם כמו שהוא, אבל מספר הדף נכנס לטבלת הדפים ומקבל מתוכה מספר המסגרת המתאים.

זו נקראת **טבלת דפים ליניארית**.
יש בה את כל הרשומות ששייכות לתהליך כלשהו והן יושבות ברצף.
ברגע שאנחנו ניגשים לכתובת מסוימת, ה-**mmu** יודע איפה כתובת תחילת טבלת הדפים ששייכת לתהליך הספציפי (יש רגיסטר במעבד עבור זה) ואז הוא יודע לפי זה לגשת לאינדקס המתאים.

טבלת דפים ליניארית היא הגרסה הבסיסית והנוחה של טבלת דפים, אבל היא לא בשימוש.
אם נחשב כמה זיכרון תופסת טבלת דפים ליניארית כזו (גם טבלת הדפים צריכה מקום בו היא תאוחסן).
אם ניקח עניינים של מערכת סטנדרטית: מחשב 32 ביט- זה אומר שמרחב הכתובות שלו הוא 32 ביטים כלומר כל כתובת וירטואלית היא 32 ביטים, כלומר **4GB**.

גודל דף סטנדרטי הוא **4KB**.
אם נחלק זאת- נקבל שההיסט הוא 12 ביטים (כי לוג 2 של 4KB זה 12) וה-**vpn** (מה שנשאר מגודל הכתובת הוירטואלית בביטים פחות גודל ההיסט) זה 20 ביטים.
20 ביטים של **vpn** זה אומר שלכל תהליך יש 1MB דפים שגודל כל דף הוא 4KB ולכן סך הכל זה יוצא 4GB.
נניח שכל **pte** תופס 4 בתים (מספר מסגרת + עוד כמה ביטים) סה"כ 32 ביטים.
אז 4 בתים (גודל רשומה לכל דף) כפול 1MB (מספר הדפים במערכת) זה **4MB**, שזהו גודלה של טבלת דפים המשויכת לתהליך כלשהו. זה לא חלק מהזיכרון של תהליך, זה שמור ב-**kernel** עבור כל תהליך.
גם זה צריך לשבת באופן פיזי בזיכרון כדי שה-**mmu** יוכל לגשת אליו ולבצע מיפויים.
בהנחה שיש 100 תהליכים במחשב, נצטרך **400MB** זיכרון לשם שמירת המיפויים.
בשיעור הקודם ראינו שיש יותר מ-300 תהליכים שרצים על המחשב, כלומר מדובר על בערך **1.5GB** לצורך הזיכרון ול-RAM שראינו במחשב הקודם יש **8GB**.

### אז יש לנו 2 בעיות:
1. זה תופס המון זיכרון. כמו כן, כל טבלה צריכה לשבת באופן רציף בזיכרון (**4MB** רצופים) מאחר וה-**mmu** מקבל את כתובת תחילת הטבלה ושם הוא מחפש. זה מאוד איטי.
2. כל פעם שהתהליך ניגש לזיכרון, ה-**mmu** ניגש לטבלת הדפים, מקבל את המיפוי ורק אז להעביר את זה למעבד שייגש לזיכרון. כלומר על כל גישה של תהליך לזיכרון וירטואלי, יש שתי גישות פיזיות לזיכרון.

### בתור התחלה, נטפל בבעיה הראשונה.
1. **פתרון אחד שיכול לעבוד:** נעשה דפים יותר גדולים. כל דף יותר גדול, אז יהיו פחות דפים ולכן גודל טבלת הדפים קטן. אבל אז הגדלנו את הבעיה של פרגמנטציה פנימית: כל פעם שתהליך רוצה זיכרון, הוא מקבל יותר זיכרון ממה שהוא צריך.
לפי בדיקה נמצא ש-16KB זה המספר הכי יעיל לגודל דף, אבל זה עדיין לא מספיק גדול.
זה עדיין יותר זיכרון ממה שהיינו רוצים.
אי אפשר לשנות את גודל הדף, זה ישפר במקצת אבל לא באופן דרסטי.

2. **פתרון שני שיכול לעבוד:** אם נסתכל על טבלת הדפים של תהליך (כתבנו לצד כל דף למה הוא משמש).
כל התאים האפורים הם דפים שלא בשימוש.
רוב התהליכים לא משתמשים בכל הזיכרון של מרחב הכתובות שלהם.
רעיון: נציא את כל השטח האפור, נצמצם אותו לפחות רשומות.

---

| Most of the page table is **unused** | Page-sized Table 0 | P1 Code |
| :--- | :--- | :--- |
| • Turn the page table into a **tree** | Table 1 | Heap |
| • Split page table into page-sized units | Table 2 | |
| • Track in a **page directory** | Table 3 | Stack |
| • One Page Directory Entry (PDE) per part | | |
| • Entire page of entries invalid? | | |
| • Don't allocate it | No need to allocate! | |

---

| Multi-Level Page Table |
| :--- |
| RAM |
| P1 Page Directory |

בהתחלה, טבלת הדפים של תהליך ישבה במקום כלשהו בתוך ה-RAM וענינו ל-**mmu** את כתובת תחילת הטבלה ולפי זה הוא חיפש את הרשומות וביצע את המיפוי.
**הרעיון:** נחלק את טבלת הדפים לחלקים שווים ונסדר אותם בזיכרון. ה-**mmu** לא יודע איפה נמצא כל חלק, לכן נחזיק מן "מילון" – **טבלת מיפויים (page directory)** שבו נחזיק איפה נמצא כל חלק שאפשר בזיכרון (כלומר בתוכה יהיה המיקום של כל חלק). גם את הטבלה הזו נשים בזיכרון.
נצא שכל חלק כזה ייכנס בגודל דף, וכל חלק נשים במקום אחר בזיכרון.

כעת, אם יש חלק שכלו רשום דבר לא משתנה בו, אז לא צריך בכלל להחזיק אותן בזיכרון.

הפעולה החדשה של ה-**mmu**: הוא ייגש ל-**page directory** כשנרצה למצוא את החלק הרלוונטי, ואז ייגש לזיכרון כדי למצוא את הדף הספציפי.
ה-**page directory** מכיל מצביעים לכל החלקים של ה-**page table** וזה נראה כמו עץ.
הטבלה הזו נקראת **Multi-Level Page table** – טבלת דפים היררכית.

### דוגמא לחלוקה ואיך זה נראה עבור ה-**mmu**:
יש לנו מרחב כתובות של **16KB** כלומר גודל הכתובת הוירטואלית הוא 14 ביטים.
גודל כל דף: **32B** (32 בתים), כלומר 5 ביטים להיסט.
כמות הביטים שנשארה היא 9 ולכן מספר הדפים הוירטואליים הוא 512 (2 בחזקת 9).
- אז ההיסט נשאר כמו שהוא וה-**mmu** לוקח את המספר של ה-**vpn**, פונה איתו לטבלת הדפים לרשומה מספר 198 ומשיג ממנה את ה-**pte** וממנה את ה-**pfn**.

אז יש לנו את טבלת הדפים של תהליך מסוים, נרצה לחלק אותה לחלקים כך שכל חלק יהיה בגודל של דף (32 בתים במקרה זה). נעשה זאת בדרך הבאה:
1. נבדוק מהי כמות המיפויים שנכנסת בדף: אם גודל דף הוא 32 בתים וגודל כל רשומה בטבלה היא 2 בתים, אז נכנסים בדף 16 רשומות (גודל דף חלקי גודל רשומה).
סך הכל בטבלת הדפים יש 512 רשומות (כי יש 512 דפים ויש רשומה-מיפוי עבור כל דף).

אם בכל דף נכנסים 16 רשומות, נשתמש במספר הדף כדי לחלק שוב את הכתובת וההיסט נשאר כמו שהוא, אבל הפעם אין לנו **vpn** (לדף טבלת דפים ליניארית). נחלק ל-**page table index**.
מאחר ובכל דף יש 16 רשומות, זה אומר שכדי לייצג כתובת של רשומה בדף, נדרשים 4 ביטים. 4 הביטים הללו יהיו הביטים הראשונים משמאל להיסט שלנו, הם נקראים **page table index**.

---

| | |
| :--- | :--- |
| • Virtual address space: | 16KB (2¹⁴) |
| • Virtual address: | 6362 |
| • Page size: | 32B (2⁵) |
| • PTE size: | 2B |
| • # of virtual pages: | 512 (2⁹) |

Virtual address:
| 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 1 | 0 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Page Directory index | Page Table index | Offset |
| 12 | 6 | 26 |

כשנבנה את תת הטבלה האחרונה, נרצה להסתכל על אינדקס 6 (לפי הדוגמא למטה) בתוכה.
**איך נדע על איזה תת טבלה להסתכל?** הביטים שנשארו הם ה-**page directory index**.
אמרנו שכל רשומה בדף אינדקס היא 2 בתים. ב-**page directory** יש 32 רשומות (2 בחזקת 5) וגודל רשומה הוא 2 בתים לכן סך הכל גודל ה-**page directory** הוא 64 בתים (64 ביט).

- אז ה-**pte** איך נחשב את גודלו?
גודל של כל רשומה (גודל ה-**pte**) תלוי בגודל הזיכרון הפיזי הכולל (ה-RAM).
נניח שיש **1M** מסגרות (2 בחזקת 20) אז ה-**pfn** הוא 20 ביט. ה-**pte** הוא 20-מ ביט, נניח 32 ביטים (מעגלים לחזקה הגבוהה ביותר של 2).
**אז ניתן לחשב את ה-pte רק אם נתון לנו משהו לגבי הזיכרון הפיזי ומשם נוכל להסיק את גודל ה-pte.**

**אז איך התרגום מתבצע עכשיו מבחינת ה-mmu:**
לקחנו את הכתובת הוירטואלית וחילקנו ל-
**page directory index**
**page table index**
**offset**
את ההיסט מעתיקים כמו שהוא.
לאחר מכן ה-**mmu** לוקח את ה-**PDI (page directory index)** וניגש אליו ב-**PD (page directory)**.
ה-PD הביא לנו את ה-**page table** כלומר חלק אחד מהטבלה (החלק הרלוונטי אלינו), ובעזרת ה-**PTI (page table index)** אנחנו ניגשים לאינדקס המתאים ב-**PT) page table)** ומקבלים את ה-**pfn**.

---

| | |
| :--- | :--- |
| • Physical memory (RAM) size: | 64KB (2¹⁶) |
| • Frame size = page size: | 32B (2⁵) |
| • # of physical frames: | 2048 (2¹¹) |

Virtual address:
| 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 1 | 0 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Page Directory index (12) | Page Table index (6) | Offset (26) |

---

אל הסוף עוד רמה. חסכנו הרבה מקום. כל חלק בטבלת הדפים שלא היה בשימוש, לא נמצא אצלנו.
מצד שני נוספה לנו עוד גישה לזיכרון. כל פעם שהתהליך ניגש לזיכרון הוירטואלי שלו, מאחורי הקלעים נעשות 3 גישות לזיכרון הפיזי.

**דוגמא:**
בהינתן הנתונים הבאים (מהתמונה):
גודל ההיסט הוא 9 ביטים.
מספר הרשומות בכל דף: 128.
לכן ה-**page table index** הוא 7 ביטים.
ה-**page directory index** מה שנשאר, כלומר 14 ביטים.

| • Let’s assume (for example): | |
| :--- | :--- |
| • Virtual address space: | 1GB (2³⁰) |
| • Page size: | 512B (2⁹) |
| • PTE: | 4B |
| • # of virtual pages: | 2MB (2²¹) |
| • PTEs per page: | 128 (2⁷) |

| VPN | Offset |
| :--- | :--- |
| Page Directory index | Page Table index | |
| 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 | 12 11 10 9 8 7 | 6 5 4 3 2 1 0 |

---

אם נסתכל עכשיו על הזיכרון, נראה שה-**page directory table** שלנו הוא עצום. נדרשים 14 ביטים כדי לייצג כתובת בו, כלומר יש בו 16,384 רשומות (2 בחזקת 14 רשומות).
אנחנו חסכנו זיכרון, אבל לא מספיק.
נשים לב שה-**page directory** תופס יותר מדי, הוא תופס 128 דפים.

אל נשליך ונחלק אותה. אל נחלק את ה-**page directory** בעצמו לחלקים.
כמות הגישות לזיכרון תעלה, אבל מבחינת זיכרון אנחנו הרבה יותר יעילים.
המטרה היא שכל דבר ייכנס בגודל דף. הדרך הקלה לעשות זאת: ברגע שחישבנו פעם אחת שה-**page table index** הוא 7 ביטים, כל רמה נוספת גם תמיד תהיה בעלת אותו מספר ביטים לייצוג ה-**vpn** מאחר וכל רמה תהיה 7 ביטים (חוץ מהאחרונה שיכולה להיות פחות) ולא יותר מכך, כי 7 ביטים לוקחים לדף של 2^7 רשומות (חישבנו בהתחלה שבכל דף נכנסים 2 בחזקת 7 רשומות).
- עכשיו ה-**mmu** שלנו נהיה היררכי: לוקח מספר מסוים לרמה הראשונה, מספר אחר לרמה השנייה וכן הלאה.

---

| | |
| :--- | :--- |
| • Page size: | 512B (2⁹) |
| • PTEs per page: | 128 (2⁷) |
| • Page Directory entries: | 16384 (2¹⁴) |
| • Spans **128** pages | |
| • Can add a directory to the directory! | |

| Page Directory index | Page Table index | Offset |
| :--- | :--- | :--- |
| PD index 0 | PD index 1 | |

---

# TLB
כל גישה לזיכרון היא יקרה. אל יהיה לנו רכיב חומרה מיוחד שיושב במעבד ותפקידו להיות מטמון של מיפויים.
ה-**tlb** יחזיק את המיפויים האחרונים של הדפים. ברגע שניגשים לדף, נלך לבדוק האם הוא ב-**tlb**.
ל-**tlb** יש זיכרון קטן אך מאוד מהיר, גישה אליו היא כמו 0 שניות מבחינתנו.
**פעולת ה-mmu:** בכל פעם שיש גישה לזיכרון, הוא קודם יבדוק את ה-**tlb**.
אם המיפוי קיים ב-**tlb** אז הכל נהדר. אם המיפוי לא קיים, נעשה את התהליך הארוך (נלך לחפש בטבלת הדפים) אבל אחרי שנמצא את המיפוי, נחזור ונעדכן את ה-**tlb** עם המיפוי הזה.

---

| TLB | |
| :--- | :--- |
| • Example: | `for (int i = 0; i < 10; i++; ++i) {` |
| | `  ++a[i];` |
| | `}` |
| | |
| With cache (TLB) | P1 Virtual Memory |
| 13 memory accesses | 10 array elements | |
| | 20 memory accesses | a[0] a[1] a[2] |
| | for just **3** pages | a[3] a[4] a[5] a[6] |
| | | a[7] a[8] a[9] |
| | | |
| **miss**, hit, hit, **miss**, hit, hit, | |
| hit, **miss**, hit, hit | |
| | | |
| **TLB hit rate** is 70% | |

הקוד הזה ניגש למערך ובצד ימין של התמונה ניתן לראות כיצד המערך יושב בזיכרון (כל שורה היא דף בזיכרון הוירטואלי).
אם ניגשים עם טבלת דפים ליניארית, יהיו 20 גישות לזיכרון הפיזי.
אם ניגשים עם טבלת דפים היררכית אז תלוי כמה רמות יש בה (אם יש 2 רמות אז 30, אם 3 רמות אז 40.. כל רמה מוסיפה לנו עוד גישה לזיכרון הפיזי עבור כל גישה לזיכרון הוירטואלי).

מה ש-**tlb** נותן לנו זה קיצור בגישות לזיכרון.
כל פעם שניגש ל-**tlb** והתרגום לא יהיה שם, נקרא לזה **miss**, אבל כשהיה קיים נקרא לזה **hit**.

**יש ל-tlb עקרונות רגילים של cache:**
אם ניגשנו לאיזשהו מקום בזיכרון, כנראה שנגש אליו עוד פעם או לדברים סמוכים אליו אז כדאי לשמור את המיפוי הזה. ה-**tlb** הוא מעין רשימה גדולה של המון מיפויים, הוא שומר בתוכו הנתונים הרלוונטיים לתהליך ההמרה בין כתובת וירטואלית לפיזית.
אם תהליך ניגש לדף מסוים, אז ה-**mmu** ימצא אותו מהר.

אם נעשה עכשיו **context switch**, הבעיה תהיה ש-**tlb** לא יהיה מעודכן עבור התהליך הנוכחי.
הפתרון לכך: נוסיף לכל רשומה ב-**tlb** מזהה נוסף שנקרא **ASID (address space id)** שיציין לאיזה תהליך הרשומה הזו שייכת וכך ניתן להבדיל בין רשומות של תהליכים שונים.

