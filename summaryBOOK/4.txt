מערכות הפעלה – שיעור 4

API (Application programming interface) – ממשק שמערכת ההפעלה מציגה עבור התוכנית
משתמש שלנו. קריאות מערכת הן סוג של API של מערכת ההפעלה.
אם לכל מערכת הפעלה יהיה ממשק משונה (סט של פקודות מערכת משלה), זה אומר שנצטרך לשכפל קוד בכל
תוכנית. במקום זה, נקבע סטנדרט שנקרא POSIX API שהוא סט קריאות המערכת שמערכת ההפעלה
חייבת לתמוך בו. כל מערכת הפעלה רשאית לתמוך בסט פקודות רחב יותר כרצונה אבל אז אנחנו יכולים לכתוב
תוכנית שתשתמש בשינויים וסטנדרט הזה ולא צריך לשכפל אותה כל פעם מחדש.
זה גם מאפשר לנו לכתוב ספריות קוד פעם אחת.

על התהליכים:
הזכרנו שבמערכת ההפעלה (ב-Kernel) יש
טבלת תהליכים ורשומה לכל תהליך שנקראת
PCB, אבל התהליכים גם מייצרים עץ. כשאנחנו
מדליקים את המחשב, הוא מחליט על תהליך קבוע
יחיד שנקרא init והמזהה שלו (ה-pid שלו)
הוא תמיד 1. תהליך זה הוא השורש של עץ
התהליכים. במהלך הריצה של המחשב, התהליך
הזה יכול ליצור תהליכים בנים. לכל תהליך בן
שהוא יוצר, יש pid שונה. אותו תהליך בן יכול
ליצור תהליכים נוספים בנים, וגם תהליך מספר 1 יכול ליצור תהליכים בנים נוספים וכך בעצם נוצר עץ תהליכים.
תהליך יכול להיווצר רק ע"י תהליך אחר שהוא האבא שלו (חוץ מתהליך 1 שהוא השורש).

[תרשים עץ תהליכים: init (1) הוא השורש, בנים: Parent (2) ו-Parent (4). ל-2 יש בן Child (3), ל-4 יש בנים Child (5) ו-Child (6)]

• Process ID (PID): (mostly) increasing identifier
• Get PID: getpid()
• Get parent PID: getppid()

קריאת מערכת לקבלת המספר המזהה של תהליך:
קריאת מערכת לקבלת המספר המזהה של ההורה
של התהליך:

* לתהליך אין דרך לשנות תהליך מעבר לתהליך ההורה שלו.

היום נדבר על 3 קריאות מערכת עיקריות:
1. () Fork – קריאת המערכת הזו יוצרת תהליך חדש בן לתהליך שהפעיל את קריאת המערכת הזו.
Fork היא מעטפת לקריאת מערכת שנקראת clone.
Fork עובדת בצורה קצת שונה: ברגע שהיא מייצרת תהליך חדש, היא יוצרת עותק של התהליך הקיים.
ז"א אם למשל תהליך האב הריץ קוד מסוים, בתהליך הבן יהיה שכפול של אותו הקוד.
מהרגע שקראנו ל-Fork, שכפלנו את תהליך האב וכעת יש שני עותקים של אותו תהליך, אבל כל אחד מהם עצמאי,
כל אחד מהם ממשיך לרוץ מאותה נקודה והלאה באופן עצמאי.

copy on write- לכל תהליך יש זיכרון. בעת יצירת תהליך חדש שהוא שכפול של אותו תהליך, גם הזיכרון
משוכפל. אחד הדברים שמערכת ההפעלה עושה בשביל לשפר ביצועים: אם זה עותק, לא צריך לשכפל בפועל את
הזיכרון, זו פעולה יקרה. במקום זה ניתן לחסוך את ההעתקה הזו, ולהגדיר שהזיכרון הזה משותף לשני
התהליכים (האב והבן), עד שאחד התהליכים יעשה פעולת write. אם אחד התהליכים יבוא וישנה משהו
בזיכרון, ייווצר בעיה. רק בנקודה הזו, מערכת ההפעלה מוצאת מקום חדש בזיכרון, יוצרת עותק של מה שהיה
בו ומשנה את מה שהתהליך רצה לשנות.

דוגמא לתוכנית המשתמשת ב-fork. הטיפוס pid_t הוא הטיפוס שמוגדר עבור ערך ההחזרה של fork ושל getpid, זה משתנה long שמייצג טיפוס של תהליך.

```c
// pid1=555 pid2=1617
int main()
{
  pid_t pid1 = getpid();
  pid_t pid2 = fork();

  printf("%d\n", getpid());
  printf("%d\n", pid1);
  printf("%d\n", pid2);
}
/* פלט (אב):
555
555
1617
*/

// pid2=0
int main()
{
  pid_t pid1 = getpid();
  pid_t pid2 = fork();

  printf("%d\n", getpid());
  printf("%d\n", pid1);
  printf("%d\n", pid2);
}
/* פלט (בן):
1617
555
0
*/
```

נניח והתחלנו להריץ את הקוד השמאלי (שהוא תהליך בפני עצמו) והתהליך הזה קיבל מזהה תהליך מספר 555.
הקוד הזה רץ ובשורה הזו: `pid_t pid1 = getpid();` אנחנו מבקשים לקבל את מספר
מזהה התהליך של התהליך הנוכחי ולכן ב-pid1 יהיה לנו המספר 555 (זה ה-process id) של התהליך
הנוכחי. אנחנו מגיעים לפקודה הבאה וקוראים ל-fork. מה שקורה עכשיו: כל התהליך שלנו משוכפל וקיבלנו תהליך
חדש שהוא שכפול של התהליך הקודם. המשתנה pid1 של התהליך המשוכפל, יכיל את אותו הערך – 555.
הקוד שהתהליך החדש הזה הולך להריץ, הוא אותו קוד כמו של תהליך האב. נקודת הריצה (איפה שהתהליך
החדש נמצא כעת בקוד) היא אותה נקודה מהרגע שהתהליך שוכפל. התהליך החדש יתחיל לרוץ מאותה נקודה
שתהליך האב יצר אותו. (כלומר ירוץ מהפקודה אחת לאחר הקריאה ל-fork) במקביל לתהליך האב.
יש שני הבדלים בין העותקים הללו של התהליכים:
1. לתהליך החדש שנוצר יש pid שונה. מזהה התהליך במקרה זה הוא 1617.
2. ברגע שקראנו ל-fork, שכפלנו הכל, כולל המשתנים והערך שהיה בהם (pid1) נשאר כמו שהוא.
ועכשיו fork צריכה להחזיר ערך. את ערך ההחזר של fork אנחנו שומרים במשתנה pid2 שנוצר גם בקוד
של תהליך האב וגם בקוד של תהליך הבן. יש שווי בין הערך המוחזר מפונקציה זו בתהליך האב לבין הערך
המוחזר בתהליך הבן. בתהליך האב, fork מחזירה את ה-pid של תהליך הבן שנוצר (במקרה שלנו 1617)
ובתהליך הבן, fork מחזירה תמיד את הערך 0. זהו לא process id ולא מזהה מיוחד, זה רק סימן שזהו
תהליך הבן ולא התהליך המקורי.
* חשוב לציין שכל קריאת מערכת יכולה להיכשל. אם fork נכשלת היא מחזירה את הערך -1.
אם לא קראנו ל-fork וחזר לנו -1, זה אומר שלא נוצר תהליך חדש. זה יכול לקרות בגלל שאין לנו הרשאות לייצר
תהליכים או כי יש יותר מדי תהליכים במערכת ולא ניתן ליצור אחד חדש.
כמעט כל קריאות המערכת מחזירות -1 אם הן נכשלות.

דוגמא לשימוש נפוץ ב-fork:

```c
// Typical usage example (fork.c)
printf("hello world (pid:%d)\n", getpid());
int rc = fork();
if (rc < 0) {
    fprintf(stderr, "fork failed\n");
    exit(1);
}
else if (rc == 0) {
    // child (new process)
    printf("I am child of %d (pid:%d)\n", getppid(), getpid());
}
else {
    // parent
    printf("I am parent of %d (pid:%d)\n", rc, getpid());
}
```

ברגע הקריאה ל-fork, נוצר לנו עוד תהליך. דבר ראשון שעושים לאחר קריאת מערכת זה זיהוי ההצלחה. אם הערך המוחזר קטן מ-0 אז הייתה שגיאה. עכשיו נרצה להבדיל בין התהליכים שנוצרו. אז נשתמש ב-if כדי לבצע פקודות בהתאם לערך ההחזר של fork (ערך ההחזר של תהליך בן הוא 0 או ערך החזר שונה מ-0).

זהו הפלט של התוכנית לעיל:
הפלט של שני התהליכים ייצא לאותו מסך טרמינל. הסדר של ההדפסה לא מובטח (בין התהליכים), לא מובטח מי מהם ידפיס ראשון ומי שני.

```bash
prompt$ gcc fork.c -Wall -o fork
prompt$ ./fork
hello world (pid:56)
I am parent of 57 (pid:56)
I am child of 1 (pid:57)
prompt$
```

ניתוח לשורה "I am child of 1":
למה על התהליכים. תהליך עם מזהה תהליך 1 הוא ה-init כפי שכבר אמרנו (התהליך הראשון של המערכת).
כשישיהו יוצר תהליך, הוא יוצר לעצמו בן בעל עץ התהליכים. בתוכנית שלנו – ההורה (מזהה 56) יצר את תהליך הבן (מזהה 57) והמשיך לרוץ. כשתהליך האב סיים לרוץ, הוא נמחק מעץ התהליכים ומחוקים את התהליך. אבל אם הוא הסתיים, אז יש בעיה כי תהליך הבן נשאר מנותק מהעץ. זה לא דבר תקין כי אנחנו רוצים שכל התהליכים בעץ יהיו בנים של init. ברגע שתהליך האב מסתיים, כל הבנים שלו הופכים באופן אוטומטי להיות הבנים של init.

[תרשים: עץ עם init (1) בראש. לתהליך 2 יש בן 3. תהליך (מסומן בסמל אדום) הסתיים, וקריאת ה-fork() שלו יצרה את תהליך 7 שמשויך כעת ל-init]

1. דוגמא: כמה פעמים יודפס "hello there"?

```c
// peculiar1.c
fork();
fork();
printf("hello there\n");
```

מריצים את התהליך השמאלי העליון. זהו תהליך האב. הוא מבצע קריאת fork ויוצר תהליך בן, שזהו התהליך הימני העליון. שני התהליכים שכרגע קיימים, ירוצו מפונקצית ה-fork השנייה. התהליך השמאלי העליון מבצע עוד פעולת fork ויוצר את התהליך השמאלי התחתון. כך גם התהליך הימני העליון יוצר את התהליך הימני התחתון.
יש 4 תהליכים שהתחלנו וממשיכים מפונקצית ה-printf וכן גם העליונים. מכאן שיודפס 4 פעמים "hello there".

2. דוגמא: כמה פעמים יודפס "hello there"?

```c
// peculiar2.c
int pid = fork();
if (pid)
    fork();
fork();
printf("hello there\n");
```

התהליך השמאלי העליון מבצע קריאה ל-fork ויוצר את התהליך הימני העליון. בשניהם מתבצעת בדיקה האם pid שונה מ-0. רק בהורה האב התשובה תהיה כן ולכן הוא יבצע עוד fork ויוצר תהליך חדש (הימני התחתון). התהליך הימני העליון לא נכנס ל-if אבל ממשיך לפקודת ה-fork הבאה ויוצר תהליך נוסף. במקביל גם התהליך השמאלי העליון מבצע עוד fork ולכן נוצר עוד תהליך, וגם הימני התחתון יצר עוד תהליך. לכן בסה"כ יש 6 תהליכים ולכן בסה"כ יודפס 6 פעמים "hello there".

* What is the output?
[תרשים עץ: P בראש, בנים 2, 5, 3. ל-2 יש בן 4. ל-3 יש בן 6]

3. דוגמא: האם יכול להיות יודפס "hehellollo"?

```c
// peculiar3.c
int main(int argc, char *argv[])
{
    fork();
    printf("hello\n");
}
```

בדרך כלל זה לא יקרה. בגלל המימוש של printf. כאשר קוראים לה, היא שומרת buffer של תווים וברגע שהוא מתמלא או שיש ירידת שורה, הוא כותב למסך את מה שהצטבר עד עכשיו.
חשוב לשים לב לדברים האלו. כשאנחנו כותבים קוד, צריכים להתחשב במקביליות כי לא ניתן לדעת באיזה סדר דברים יתקבלו.

4. דוגמא: מה יודפס?

```c
// peculiar4.c
int x = 0;
if (fork()) {
    sleep(5); // BLOCKED state for 5 seconds
    printf("%d\n", x);
}
else {
    x += 3;
}
```

ב-if נוצר לנו תהליך חדש. בתהליך האב ה-if יתקיים, ואז הוא ידפיס 0. בתהליך הבן, הוא לא ייכנס ל-if אלא ל-else ויוסיף 3 ל-x. כמו כן, הזיכרון של תהליך הבן הוא עותק.

5. דוגמא: כמה תהליכים ייווצרו?

```c
// peculiar5.c
fork();
if (fork()) {
    fork();
}
fork();
```

בתהליך האב – נסמן אותו תהליך מספר 1 (זה לא מזהה התהליך, זה רק מספר) – מתבצעת הקריאה הראשונה של fork לכן נוצר תהליך נוסף נסמן אותו 2 (סך הכל עד כה 2). בתהליך האב ב-if יש יצירה של תהליך נוסף (נסמן אותו 3) ובו כן הוא נכנס ל-if ולכן נוצר עוד תהליך (נסמן אותו 5, עד כה 4). בסוף תהליך האב יוצר תהליך נוסף (נסמן אותו 7, עד כה 5). בתהליך הבן הראשון שנוצר (נסמן אותו 2) יתבצע יצירת תהליך נוסף ב-if (נסמן אותו 4). בבן הזה לא מתקיים ה-if ולכן נוצר עוד תהליך (נסמן אותו 8). בתהליך הבן שנוצר ב-if (נסמן אותו 3) ובן הבן (5) שנוצרו מהאב הראשון, גם בהם לא מתקיים ה-if, וייצר תהליך נוסף לכל אחד (נסמן 9 ו-10). התהליכים 4,6 מייצרים תהליך אחד כל אחד מהם וכן גם התהליכים 3,5.
סך הכל נוצרו 12 תהליכים.

6. דוגמא: מה יודפס?

```c
// peculiar6.c
int x = 0;
if (fork()) {
    sleep(5); // BLOCKED state for 5 seconds
}
else {
    x += 3;
}
printf("%d\n", x);
```

אנחנו לא יכולים להניח שום דבר על סדר התהליכים. בדרך כלל יודפס 3 ואז 0 אבל ייתכן שגם יודפס 0 ואז 3.

אם נרצה להפוך את זה לדטרמיניסטי? כלומר שידפיס פלט אחד תמיד – נשתמש בקריאת המערכת wait.
קריאת המערכת הזו אומרת לתהליך האב לחכות לתהליך בן שיסיים (כל תהליך שנוצר על ידו, לא תהליך ספציפי במקרה הזה) ורק אז ימשיך את הקוד שלו (כלומר הוא נכנס למצב blocked והוא לא running, ורק כשאחד התהליכים שלו מסתיים הוא חוזר לפעול). Wait מחזירה -1 אם אין לו בנים. תמיד נעדיף ב-wait כפרמטר null.

גרסה נוספת של wait: גרסה שמקבלת pid של תהליך בן מסוים ואז תהליך האב יחכה שהוא יסיים ולא לסתם תהליך בן שלו שיסיים. הקריאה נקראת waitpid ונתנו לה כפרמטר את המספר המזהה של תהליך הבן הרצוי. בשני הווריאציות של הקריאה, ניתן לחכות רק לתהליכים בנים.

• To wait for all child processes to end:
• while (wait(NULL) != -1);

```c
// wait.c
int x = 0;
int rc = fork();
if (rc) {
    wait(NULL); // BLOCKED until child terminates
    // equivalent here: waitpid(rc, NULL, 0);
}
else {
    x += 3;
}
printf("%d\n", x);
```
• Output is always 30 (הערה: ייתכן וזו טעות סופר והכוונה ל-3 ו-0 בסדר מסוים תלוי במימוש)

קריאת מערכת exec:
אחרי ביצוע קריאת fork, ההורה והילד מפעילים את אותו הקוד (שכפול של תהליך האב). אם רוצים שתהיה תוכנית אחרת כשהם פועלים בתהליך בן: נשתמש בקריאת המערכת exec.
- קריאת המערכת הזו מקבלת שם תוכנית (שכבר בנינו) שתהליך הבן יריץ וארגומנטים שנשלחים לתוכנית (argv).
- קריאת המערכת הזו לוקחת את תהליך האב ומשנה את כל התוכן שלו, היא מוחקת את כל הזיכרון הקיים ושמה במקומו זיכרון של תוכנית אחרת.
- כשקוראים ל-exec והיא מצליחה, היא לא חוזרת לעולם (הפקודה הבאה לא תתבצע).

```c
// myprog1
main()
{
    ...
    char* argv[] = {"myprog2", "some", "arg", "here", NULL};
    execvp(argv[0], argv);
    printf("hello");
}
```

יש כמה סוגים של exec, אנחנו נלמד על execvp שמקבלת שם של תוכנית וארגומנטים לתוכנית. בארגומנטים תמיד נשים כארגומנט הראשון את שם התוכנית, לאחר מכן את הארגומנטים לתוכנית ובסוף תמיד NULL.
הכוונה בכך שלאחר שקוראים ל-exec כל בריוניה שהיא לא חוזרת (אם היא הצליחה) זה למשל את שורת ה-printf לאחר הקריאה – לא נקבל לעולם. זה יודפס רק אם הייתה שגיאה והקריאה ל-exec לא הצליחה.

```c
// exec.c
int rc = fork();
if (rc < 0) {
    fprintf(stderr, "fork failed\n");
    exit(1);
}
else if (rc == 0) {
    char* args[5] = { "wc", "-l", "exec.c", NULL };
    execvp(args[0], args);
    printf("this shouldn't print out\n");
}
else {
    int rc_wait = wait(NULL); // or waitpid(rc, NULL, 0)
    printf("I am parent of %d (rc_wait:%d) (pid:%d)\n", 
           rc, rc_wait, getpid());
}
```

מה קורה כשתהליך בן מסתיים ותהליך האב נזכר לעשות wait רק אחרי שהוא הסתיים? זה ילכוד.
כשתהליך מסתיים, הוא לא נמחק (מה שהראינו קודם שהוא כן נמחק זה לא מדויק). משוחרר כל מה שהוא תפס לצורך הריצה שלו, אבל הרשומה שלו בטבלת התהליכים לא נמחקת, היא נשארת איפשהו וזאת בכדי שנוכל לעשות wait גם אחרי שהתהליך הסתיים. אם לא עושים wait לתהליכים שהסתיימו - נוצרת בעיה כי נוצרת רשימה של תהליכים שאף אחד לא ישתמש בהם יותר. תהליך שהסתיים אבל לא נמחק לחלוטין נקרא תהליך זומבי. כשאנחנו משתמשים בקריאות המערכת שלמדנו היום, אנחנו צריכים לדאוג לא ליצור תהליך זומבי. אחת מהדרכים לעשות זאת היא לקרוא ל-wait. אם קראנו ל-wait ויש תהליכים שהסתיימו, הקריאה תודיע לנו שהם הסתיימו ותמחק אותם. כלומר wait לא רק ממתינה שתהליך הבן יסיים, אלא היא גם מסירה אותו מעל התהליכים ואז התהליך הזה באמת נמחק.

דרך נוספת לטפל בתהליכים זומבים – אם תהליך האב מסתיים: כל הבנים שלו הופכים להיות הבנים של init. התהליך init תמיד מפנה תהליכים שהסתיימו.

