מערכות הפעלה – שיעור 16

נכון / לא נכון:

1. טענה: אם יש הרעבה, בהכרח יש קיפאון.
הטענה לא נכונה. תהליך מורעב (כפי שלמדנו בקורס) הוא תהליך (חוט) שחסום בזמן שחוטים אחרים מתקדמים. אם יש הרעבה וחוט מסוים חסום, זה לא אומר שכולם חסומים (שזה קיפאון), זה אומר למעשה בדיוק את ההפך כי כל שאר החוטים מתקדמים.

2. טענה: אם יש קיפאון, בהכרח יש הרעבה.
הטענה לא נכונה. כפי שהזכרנו לעיל, הרעבה פירושה - חוט אחד חסום בזמן שחוטים אחרים מתקדמים. אם יש קיפאון, אף חוט לא מתקדם, לכן לא מתקיימת הרעבה, כי בקיפאון כולם חסומים (ולא רק חוט אחד בזמן שכל השאר מתקדמים).

3. טענה: בבעיית הפילוסופים הסועדים ניתן למנוע הרעבה.
הטענה נכונה. אם נשתמש במנעולים הוגנים הכל יהיה סדר. הפתרונות שראינו כשדיברנו על הפילוסופים הסועדים - מנעו קיפאון אך לא דיברנו על מניעת הרעבה. אבל אפשר למנוע הרעבה. נקבע סדר מסוים ביניהם. אפילו מנעול אחד גלובאלי הוגן ימנע הרעבה.

4. טענה: במערכת עם מעבד יחיד, שימוש בחוטים יכול לשפר ביצועים.
הטענה נכונה. דיברנו על שני יתרונות לשימוש בחוטים: 1. מקביליות (יותר דברים שקורים בו-זמנית) 2. חפיפה, ניתן לעשות פעולות בזמן שאולצנו אחרים (למשל קוראים קלט מהמשתמש ובזמן הזה מריצים קוד אחר שמריץ חישובים וכך לנצל טוב יותר את המעבד שלנו ולגרום לביצועים של התוכנית שלנו להיות יותר טובים).

5. טענה: אם נשתמש רק בסמפורים שאינם בינאריים, ייתכן קיפאון.
הטענה נכונה. סמפור שאינו בינארי הוא אינו מנעול, כלומר יש יותר מאחד מנשאים. לדוגמא ניקח סמפור s1 שאותחל ל-2 (אינו בינארי, כי סמפור בינארי הוא 0 או 1 תמיד). בנוסף ניקח סמפור s2 שאותחל גם הוא ל-2. ניקח חוט 1 שבכדי להיכנס לקטע הקריטי הוא צריך שני משאבים מ-s1 ומשאב אחד מ-s2 (2 נדפים ומקום ברשימה). ניקח חוט 2 שבכדי להיכנס לקטע הקריטי הוא צריך שני משאבים מ-s2 ומשאב אחד מ-s1. לו דוגמא דדלוק פוטנציאלי – כי אם נריץ את שני החוטים בצורה הזו, ייתכן שהחוט הראשון יצליח ויתפוס, וירז את שני הפקודות הראשונות והסמפור הראשון ירד ל-0 והחוט השני במקביל יריץ את שתי הפקודות הראשונות שלו ועדכן את הסמפור השני ל-0. עכשיו כל חוט ממשיך לשורה הבאה תקוע בדדלוק. הראשון מחכה ל-s2 שיהפוך רק כאשר השני יסיים אבל השני מחכה ל-s1 שיסיים רק כאשר הראשון יסיים ומתקיימים כל התנאים לדדלוק, יש פה תלות מעגלית.

חוט 1:
3. wait (s1)
4. wait (s1)
6. wait (s2)

חוט 2:
1. wait (s2)
2. wait (s2)
5. wait (s1)

מערכת תקועה אם הסבר לפי שמיים.

6. טענה: מנעול מונע החלפה (context switch) בקטע הקריטי.
הטענה לא נכונה. מנעול לא מונע החלפות, הוא רק מוודא שאף אחד לא יוכל להריץ את קטע הקוד הספציפי במקביל אלינו. גם אם המנעול אצלי, עדיין ייתכן שיהיה context switch בין החוט הנוכחי לבין חוט אחר.

7. טענה: במחשב עם מעבד יחיד, עדיף מנעול שלא מבצע spinning.
הטענה נכונה. אם יש לנו מעבד יחיד, אז יכול לרוץ עליו רק תהליך אחד (חוט יחיד) בכל רגע נתון. אם חוט כלשהו רץ ומנסה לתפוס מנעול תפוס ורואה שהמנעול תפוס, אין לו סיבה לבצע spinning, כי המנעול יפונה ע"י חוט אחר וכל עוד אנחנו רצים על המעבד, מי שמחזיק את המנעול לא רץ ולכן לא ישחרר את המנעול. הדבר הנכון לעשות במקרה כזה הוא שהחוט שראה שהמנעול תפוס - יוותר על זמן המעבד שיש לו, כי המנעול לא הולך להשתחרר עד שמי ירוץ החוט שמחזיק במנעול וישחרר אותו.

- אם יש לנו יותר ממעבד אחד, אז המצב קצת שונה וזה תלוי. כי עכשיו בזמן שאנחנו מנסים לתפוס (spinning) חוט אחר על מעבד אחר יכול לרוץ חוט אחר שמחזיק במנעול ולשחרר אותו. אז במחשב עם יותר ממעבד אחד, זה תלוי במצב:
- אם המנעול הוא TAS LOCK או TTAS LOCK למשל, לא שווה לעשות spinning כי תהיה פגיעה בביצועים.
- אם המנעול הוא CLA למשל אז כן שווה לעשות spinning.

מנעולים:

1. יש לנו פה מימוש של מנעול עבור שני חוטים. כל חוט שרוצה לתפוס את המנעול (עד שני חוטים) קורא ל-lock עם המספר שלו (כלומר i=0/1). בסיום הקטע הקריטי החוט קורא ל-unlock.

```c
int turn;
void lock(int i) {
    turn = i;
    while (turn != i);
}
void unlock(int i) {
    turn = 1-i;
}
```

השאלה: האם המנעול מקיים את שלושת הזכויות של מנעול (מניעה הדדית, deadlock freedom ומהוגנות)?

* אם אנחנו רוצים להראות שתכונה לא מתקיימת, אנחנו צריכים להראות ריצה כלשהי שלא מקיימת את התכונה.
* אם אנחנו רוצים להראות שתכונה כן מתקיימת, נניח בשלילה ונגיע לסתירה.

1. המנעול לא מקיים מניעה הדדית. מניעה הדדית פירושה: שני חוטים לא יכולים להיות בקטע הקריטי במקביל. אם זה לא מתקיים, זה אומר שייתכן ושני חוטים מחזיקים במנעול בו זמנית, כלומר שני חוטים נמצאים בקטע הקריטי במקביל. רוצה שנדגים את אי הקיום של מניעה הדדית: חוט 0 קורא ל-lock. אצלנו turn=0. יצא מיד מלולאת ה-while כי התנאי לא מתקיים וברגע שקריאת ה-lock הסתיימה הוא נכנס לקטע הקריטי. חוט 1 במקביל, קורא ל-lock בדיוק באותה צורה. turn=1, התנאי לא מתקיים אז יצא מיד מלולאה. קריאת ה-lock הסתיימה ולכן הוא נכנס לקטע הקריטי גם כן. שני החוטים בו זמנית בקטע הקריטי ובו זמנית מחזיקים במנעול ולכן אין מניעה הדדית במנעול הזה.

2. המנעול מקיים deadlock freedom – הכוונה ב-deadlock freedom היא שלא יכול לקרות דדלוק בשימוש בקוד של המנעול לבד. נניח בשלילה שיכול להיות דדלוק, כלומר יכול להיות מצב בו כל המערכת שלנו תקועה. אם אנחנו במצב של דדלוק, המשמעות היא שכל החוטים במערכת תקועים, או יכולים להתקדם, חסומים. השורה היחידה בה חוטים יכולים להיתקע בקוד עד אינסוף היא לולאת ה-while בקריאה ל-lock. אז זה אומר שיש לנו שני חוטים: חוט מספר 0 וחוט מספר 1 ושניהם תקועים בלולאה. אם חוט מספר 0 נמצא בלולאה ולא יכול לצאת ממנה, אז לפי הקוד זה אומר ש-turn != 0 ולכן הוא חוזר על הלולאה שוב ושוב. אם חוט מספר 1 נמצא בלולאה ולא יכול לצאת ממנה, אז לפי הקוד זה אומר ש-turn != 1. אבל לפי הקוד, turn חייב להיות 0 או 1 כי הערך היחידי שנכתב אליו הוא 0/1. הגענו לסתירה ולכן לא ייתכן דדלוק במערכת ומכאן שהמנעול מקיים deadlock freedom.

3. המנעול לא מקיים הוגנות. ייתכן הרעבה. נראה ריצה בה זה קורה:
- חוט 0 רץ וכותב ל-turn את הערך 0.
- חוט 1 רץ וכותב ל-turn את הערך 1 (עוד לפני שחוט 0 הספיק להגיע ללולאת ה-while).
- חוט 1 יוצא מלולאת ה-while ונכנס לקטע הקריטי.
- חוט 0 חסום, הוא ב-while כי turn=1 כרגע והוא לא יכול להתקדם.
- חוט 1 יוצא מהקטע הקריטי וקורא ל-unlock. הוא מעדכן turn = 0.
- לכאורה זה אמור להיות כדי שחוט 0 יתקדם, אבל מאחר ואנחנו שולטים בתזמון, נקבע שמיד לאחר שחוט 1 יוצא מהקטע הקריטי, הוא קורא ל-lock שוב ומעדכן turn=1 לפני שחוט 0 הספיק לצאת מהלולאה.
- על כל התזמון הנ"ל ניתן לחזור עד אינסוף וכך נקבל שחוט 0 יהיה מורעב לעומת חוט 1 שתמיד יתקדם ויבצע פעולות.

** אם חוט תפס את המשאב ומחזיק בו לנצח, זו לא הרעבה, זה באג בקוד. בשביל הרעבה צריך שיהיה מישהו שתמיד תופס ומשחרר את המשאב.

2. מימוש נוסף של מנעול, דומה מלבד השורה השנייה ב-lock.

```c
int turn;
void lock(int i) {
    turn = 1-i;
    while (turn != i);
}
void unlock(int i) {
    turn = 1-i;
}
```

1. המנעול מקיים מניעה הדדית. בקוד הזה, שני חוטים לא יכולים להיות בקטע הקריטי במקביל. נניח בשלילה שייתכן מצב בו שני חוטים ביחד בקטע הקריטי (שניהם מחזיקים במנעול). כדי להגיע למצב כזה, מה שהיה צריך לקרות:
- אם חוט 0 בקטע הקריטי, זה אומר שמישהו הוא ראה ש-turn = 0 (כלומר היה בלולאה וראה ששינו).
- כנ"ל לגבי חוט 1, אם הוא בקטע הקריטי אז מישהו הוא ראה ש-turn = 1 (ללא הגבלת הכלליות).
- לפני שכל חוט ראה שינוי, הוא כתב את התור. חוט מספר 0 או מישהו לפניו, כתב turn=1 ואז נכנס ללולאה עד שראה turn=0. ואילו לגבי חוט מספר 1, גם הוא או מישהו כתב turn=0. חוט מספר 1 היה חייב לכתוב את זה אחרי turn=1 כי חוט 0 ראה turn=0 וזה לא יכול להיות שזה קרה לפני. אבל יש סתירה, כיוון ש-turn=1 כתבנו turn=0.

ויוֹתך אף אחד לא כתב ל-turn ומישהו חוט מספר 1 קרא turn=1. זו הסתירה. אז לא יכול להיות ששני חוטים יהיו ביחד בקטע הקריטי, ולכן יש מניעה הדדית.

(תרשים: 0: turn <- 1, 1: turn <- 0, 0: turn == 0, 1: turn == 1)

2. המנעול לא מקיים deadlock freedom – המנעול הזה אמנם לפני חוטים אבל זה אומר ששני חוטים יכולים להשתמש בו. זה לא מחייב ששני חוטים משתמשים בו, אולי יש רק חוט אחד במערכת, ואז חוט אחד מנסה לתפוס את המנעול וחוט אחר שלא. אם יבוא חוט 0 ויקרא ל-lock, נכנסים לדדלוק- כי חוט 0 מעדכן את turn = 1 ועכשיו הוא חסום בלולאת ה-while לנצח. אף אחד לא מבטיח לנו שיגיע חוט מספר 1 ויזל אותו. ברגע שעשינו את זה שמישהו אחר יכניס לדדלוק. - אם שני החוטים כל הזמן ינסו לתפוס את המנעול, לא יהיה דדלוק. רק אם יש חוט יחיד.

3. המנעול מקיים הוגנות. לא ייתכן הרעבה. נניח בשלילה שיש חוט שמישהו מנסה לתפוס את המנעול ויש חוט אחר שכל הזמן תופס אותו, כך שהחוט השני לא מצליח לתפוס את המנעול בכלל. נניח שחוט מספר 1 תקוע בלולאה ולא מצליח לתפוס את המנעול. לכן, לפי הקוד הוא תקוע בהכרח בלולאת ה-while ורואה ש-turn=0 תמיד. בזמן שהוא רואה את זה, חוט 0 יצא ונכנס לקטע הקריטי כלומר תופס את המנעול, משחרר וכו'. נסתכל על הפעם הבאה שחוט מספר 0 משחרר את המנעול: לאחר השחרור הוא מעדכן את turn=1 ואז תופס מחדש את המנעול אולם כותב ב-lock: turn=1, זאת הוא לא מצליח לתפוס את המנעול כי הוא נכנס ללולאת ה-while ויוצא ממנה ולכן זה אומר שהוא רואה ש-turn=0 . אבל הוא כתב turn=1 פעמיים ובמקביל אליו, חוט מספר 1 לא יצא מהלולאה ולכן לא יתכן שכתב turn=0. זו סתירה כי לא יתכן ש-turn השתנה מ-1 ל-0 סתם ככה. מישהו היה חייב לשנות אותו. המקום היחידי בו משנים את turn הוא חוט 0-ו חוט 1 ויכול לקטע הקריטי יצא ממנו. מכאן נובע ולא מורעב.

אובייקטי סנכרון:
אנחנו מקבלים הגדרה של אובייקט וצריכים לממש אותו בצורה נכונה.

1. מנעול חד-פעמי – ניתן לנעול פעם אחת בלבד (unlock אין)
- lock מחזירה 1 לחוט שהצליח, 0 לכל השאר
- מנעול חד-פעמי ל-N חוטים – lock נקראת עד N פעמים

נתונה פקודת חומרה אטומית חדשה:
- מקדמת מונה באחד, מחזירה אם ערכו החדש שווה ל-C, נכשלת אם ערך המונה גדול מ-C

```c
bool check_add(int *p, int C) {
    assert(*p < C); // check invalid op
    return (++*p == C);
}
```

* במנעול חד פעמי – אם חוט ניגש אליו ורואה שהוא תפוס, הוא לא עושה spinning וממשיך לנסות כי אין טעם לכך. ברגע שראינו שהמנעול תפוס, אף אחד אף פעם לא יכול לשחרר אותו. זה אובייקט שמשתמש לכך שרק חוט אחד יבצע פעולה מסוימת. ניתן לקרוא ל-lock כמה פעמים שרוצים, אבל לא יקרה כלום אחרי הקריאה הראשונה.

* הפקודה האטומית מקבלת מצביע ומגדילה אותו ב-1. דומה ל-fetch_and_add רק שבמקום להחזיר את הערך, היא מגדילה ב-1 באופן אטומי ומחזירה האם ערכו לאחר ההגדלה שווה ל-C. אם ערך המונה לא קטן מ-C, הפעולה נכשלת ומקריסה את התוכנית.

ממשו מנעול חד-פעמי ל-2 חוטים עם תא זיכרון (משתנה) יחיד

```c
void init2(int *lock) { }
void lock2(int *lock) { }
```

אנחנו מקבלים משתנה lock (משתנה פדר שמועבר בין פונקציה לפונקציה). נניח שהוא ל-0 (פחות משנה לאיזה ערך אנחנו מאתחלים אותו, 0 זה לצורך הנוחות).

- בחינת מימושים לא תקינים ל-lock2:

1. וקרא ל-check_add(lock,1): המימוש הזה בתכנית נקרוס. החוט הראשון שיקרא ל-lock2 יגדיל את המנעול ב-1 ויתפוס אותו. החוט השני שיקרא ל-lock2 יגרום לתוכנית לקרוס כי ערך המנעול לא קטן מ-C.

2. וקרא ל-check_add(lock,2): החוט הראשון יקרא לזה ויקבל false ותצא, וכן גם החוט השני והתוכנית לא תקרוס. המימוש הזה עדיין לא טוב כי: החוט הראשון שקורא למנעול מעלה את lock מ-0 ל-1 ומקבל החזרה 0. החוט השני קורא גם ומגדיל את lock מ-1 ל-2 ומקבל בחזרה 1, ולכן הוא זה שתופס את המנעול. אבל נרצה שהחוט הראשון שמבקש את המנעול יתפוס אותו, מאחר ולא מובטח לנו שיגיע חוט שני (אבטלה לחוט ללן שיהיו עד שני חוטים אך לא מובטח אחרים, אנחנו לא יכולים להניח בקריאה הראשונה בה חוט נכשל – שיגיע חוט נוסף בעתיד ויתפוס את המנעול). זה סוג של דדלוק כי החוט ינסה לתפוס את המנעול, המנעול פנוי אף עדיין לא קיבלנו אותו.

- המימוש הנכון ל-lock2:
וקרא ל-!check_add(lock,2): כלומר נהפוך את הערך שחוזר מ-check_add. החוט הראשון שיקרא ל-lock2 יעלה את המנעול מ-0 ל-1, check_add יחזיר 0 ולכן נהפוך זאת ונחזיר 1. כל חוט אחר שיבוא לאחר מכן, יעלה את המנעול מ-1 ל-2 ויקבל בחזרה 0.
* זה יעבוד למימוש של עד שני חוטים.

```c
init(...) { *lock = 0; }
lock(...) {
    return !check_add(lock, 2);
}
```

ממשו מנעול חד-פעמי ל-3 חוטים עם 2 תאי זיכרון

```c
void init3(int *l1, int *l2) { }
void lock3(int *l1, int *l2) { }
```

אנחנו מקבלים שני משתני פדר: l1, l2 (הפקודה הזו טעות שיש פעמיים l1).

- בחינת מימושים לא תקינים ל-lock3:

1. וקרא ל-check_add(lock,3): כאן תהיה אותה בעיה כמו מקודם- רק החוט השלישי יצליח לתפוס את המנעול, וזה לא תקין, כי אולי השלישי לא יגיע בכלל ולא ינסה לתפוס את המנעול.

2. וקרא ל-!check_add(lock,3): תהיה כאן בעיה כי החוט הראשון יקבל 1 וכן גם החוט השני יקבל 1.

- המימוש הנכון ל-lock3:
נניח שאנחנו מעבירים ל-check_add את הערך 3 עבור l. נניח שאנחנו קוראים לפעולה הזו הרבה פעמים על חוט משתנה. בפעם הראשונה שנקרא לה, המונה יעלה מ-0 ל-1 ויחזיר לנו 0. בפעם השנייה מ-1 ל-2 ויחזיר 0, כך עד הפעם החמישית שבה ההגדלה תהיה מ-4 ל-5 ויחזיר לנו 1. עכשיו אנחנו לא יכולים לקרוא יותר לפעולה הזו מבלי לשנות משהו, כי אז התוכנית תקרוס (N-5 מ-6). אז האובייקט הזה צריך להבדיל בין כל החוטים שקראו לפעולה מלבד האחרון.

אבל בשביל המימוש שלנו אנחנו רוצים מצב הפוך: שהראשון יקבל מכל השאר, כך שהוא יהיה זה שיצליח לתפוס את המנעול וכל השאר ייכשלו. מה שנעשה: רק החוט השלישי שיבצע את הקריאה, יקבל 1 ולכן ייכנס ל-if. הוא יחזיר 0 מה-lock וזה לא מה שרצינו. שני החוטים הראשונים - ייכנסו ל-else ובו נשתמש ב-lock2 שכתבנו בסעיף הקודם, הפעם עם המשתנה השני שלנו שמאותחל ל-0.

```c
init(...) { *l1 = 0; *l2 = 0; }
lock(...) {
    if (check_add(l1, 3)) return 0;
    else return lock2(l2);
}
```
(המנעול שמימשנו בסעיף הקודם)

ממשו מנעול חד-פעמי ל-N חוטים

```c
struct CALock { ... };
void init(struct CALock *lock, int N) { }
void lock(struct CALock *lock) { }
void destroy(struct CALock *lock) { }
```

הפעם אנחנו יכולים להגדיר כמה משתנים שבא לנו- יש לנו סטראקט שאנחנו מגדירים אותו. דבר ראשון שנעשה: אם N=2, וקרא למנעול שכבר קיים לנו (lock2). אם N!=2, נשתמש ברקורסיה. נפעיל ברקורסיה את הרעיון של המנעול של ה-3 חוטים: אנחנו יודעים להבדיל בין החוט האחרון לבין כל השאר. האחרון שיבצע את הקריאה מבין החוטים, יפסיד. כל השאר יתקדמו שיבצעו את הקריאה יפסיד וכן הלאה עד שנותאר עם 2 חוטים ונקרא ל-lock2.

מימוש 1 אפשרי:
```c
lock(...) {
    if (N == 2) return lock2(...);
    if (check_add(_, N)) return 0;
    else return lock_N-1();
}
```

מימוש 2 אפשרי:
```c
for (int i=0; i < N-2; ++i) {
    if (check_add(arr[i], N-i)) return 0;
}
return lock2(arr, N-2);
```

במימוש השני שהוא לא רקורסיה: יהיה לנו בסטראקט מערך שאותחל את כולו באפסים. נקדם את התא הראשון במערך עד שיגיע ל-N והתא השני יתקדם עד שיגיע ל-1-N וכן הלאה..

מנעולים:
זהו מנעול לכל מספר של חוטים. המזהה me הינו ייחודי לכל חוט.

```c
typedef struct { int turn; int busy; } FlakyLock;
void init(FlakyLock *lock) {
    lock->busy = 0;
}
void lock(FlakyLock *lock, int me) {
    do {
        do {
            lock->turn = me;
        } while (lock->busy);
        lock->busy = 1;
    } while (lock->turn != me);
}
void unlock(FlakyLock *lock) {
    lock->busy = 0;
}
```

השאלה: האם המנעול מקיים מניעה הדדית, deadlock freedom ומהוגנות?

- דיברנו על כך שלא ניתן לממש מנעול לכל מספר של חוטים עם רק שני משתנים בלבד. בשביל לממש מנעול ל-100 חוטים, נדרשים 100 משתנים. אלא אם כן משתמשים בפקודות חומרה מיוחדות מה שלא קורה כאן. אז לא יכול להיות שהמנעול הזה תקין. לא ייתכן שהוא גם מקיים מניעה הדדית וגם deadlock freedom, במצב הזה אחד מהם לא יכול להתקיים בוודאות.

1. המנעול לא מקיים deadlock freedom - נניח שיש לנו 2 חוטים.
- חוט מספר 0 רץ ומעדכן turn = 0. המנעול פנוי והוא מתקדם ומעדכן busy = 1.
- לפני שחוט מספר 0 מספיק להיכנס ללולאה, חוט מספר 2 קורא ל-lock ומעדכן turn=2.
- עכשיו חוט מספר 0 יינקה בלולאה כי זה לא תורו, וחוט מספר 2 יינקה בלולאה כיוון שהמנעול תפוס (busy=1).
במקרה זה שני החוטים תקועים ואין להם לאן להתקדם. בנוסף אף אחד לא יכול לתפוס את המנעול יותר אף פעם.

2. המנעול מקיים מניעה הדדית - נניח בשלילה שאין מניעה הדדית כלומר שני חוטים יתפסו שניהם את המנעול ויהיו בקטע הקריטי בו זמנית. אם חוט מספר 1 נמצא בקטע הקריטי, הפעולות שביצע לפני הכניסה לקטע הקריטי: הוא ראה שפנוי (turn=1) אחרת הוא לא היה יוצא מהלולאה השנייה), לפני כן הוא קבע את busy=1, לפני כן הוא כאמור ראה busy=0 לפני זה הוא שינה את התור להיות שלו.
- עכשיו בעת בחוט מספר 2: יבצע את אותן הפקודות כמו של חוט מספר 1 ורק ש-turn יהיה 2.
- נסתכל על הפעם האחרונה שהוא עדכן turn=2, זה חייב להיות באחד משני המקומות שמתמידים מצביעים עליהם בציור.
- אם זה היה בחלק התחתון, אז לא ייתכן שהוא יצא מהלולאה הראשונה כי busy=1.
- אז אנחנו יודעים בוודאות שזה היה בחלק העליון. נזכור שהוא ראה מישהו בהמשך ש-turn=2 וזה יכול לקרות רק לאחר העדכון שלו של turn. אבל כשהוא עדכן את turn הוא ראה busy=1 והוא גם שינה את busy ל-1 ולכן לא יתכן שחוט מספר 1 ראה busy=0. סתירה גם במקרה הזה. לכן לא יכול להיות שלא מתקיימת מניעה הדדית.

(תרשים: 1: turn <- 1, 1: busy == 0, 1: busy <- 1, 1: turn == 1, 1: CS, 2: CS)

אובייקטי סנכרון:

- Barrier – אובייקט ל-N חוטים עם פעולה אחת: checkin
- בקריאה ל-checkin, החוט הקורא ממתין (חסום) עד אשר N חוטים ביצעו קריאה ל-checkin.
- ברגע שהחוט ה-N מבצע קריאה ל-checkin, כל החוטים משוחררים מחסימה וממשיכים לרוץ מהפקודה הבאה.
- הפעולה checkin אינה חד-פעמית. ניתן לקרוא לה שוב ולהמתין עד שכל שאר החוטים גם יקראו ל-checkin פעם שנייה, וכן הלאה.

זהו אובייקט סנכרון שבאמת קיים. הרעיון שלו: אנחנו רוצים ליצור נקודת סנכרון בין החוטים (דומה ל-join). חוט רוצה לחכות שחוט אחר יסיים, אבל לא יסיים לגמרי אלא רק חלק מסוים מהקוד שלו. יכול להיות שיש לנו חוט a שצריך קטע קוד ובנקודה כלשהי הוא קורא ל-checkin ושם הוא נעצר.

היחידה של barrier. הפעולה הזו אומרת שהחוט רוצה להיחסם ולהמתין. עכשיו חוט a יהיה חסום עד שכל החוטים יקראו ל-checkin. כלומר אם יש b חוטים אלינו, אנחנו נחכה שהם גם יקראו ל-checkin. רק כששניהם יקראו ל-checkin, אז שניהם יכולים להמשיך (מעין נקודת סנכרון).

נתונה מערכת עם N חוטים ומימוש חלקי ל-Barrier
- לכל חוט מזהה ייחודי i (בין 0 ל-1-N) שמועבר כפרמטר ל-checkin
- ממשו את checkin ללא שימוש בפעולות אטומיות או אובייקטי סנכרון

```c
typedef struct {
    int N;
    int *arr;
} Barrier;

void init(Barrier *bar, int N) {
    bar->N = N;
    bar->arr = (int*) calloc(sizeof(int), N);
}

void destroy(Barrier *bar) {
    free(bar->arr);
}

void checkin(Barrier *bar, int i) { ... }
```

כדי לממש את הפעולה, אנחנו נלמד כמה חוטים שהולכים לקרוא ל-checkin. ברגע שחוט מסוים קורא ל-checkin אנחנו צריכים שהוא ימתין עד שכל N החוטים קראו ל-checkin.
- דרישה נוספת מהמימוש: שלא יהיה חד פעמי. כלומר לאחר שנעשינו a ,checkin יוכל לקרוא לעוד פעולה ולבצע checkin שוב. כלומר הוא יחכה עד שכל החוטים יקראו ל-checkin שוב.
כמו כן, הוקצה לנו מערך בגודל N שכל תאיו מאותחלים ל-0. i הוא מזהה של החוט בין 0 ל-1.

נממש את checkin:

```c
checking (...) {
    arr[i]++;
    for (int x=0; x<N; ++x)
        while (arr[x] < arr[i]);
}
```

במערך יש תא לכל חוט. בכל פעם שחוט קורא ל-checkin, הוא יבצע הגדלה ב-1 של התא שלו באינדקס שלו במערך. חוט מסוים צריך לחכות שכל התאים במערך יהיו לפחות 1, ורק אז בעצם הוא יכול להתקדם. בהפעלה שנייה, חוט יחכה שכולם יהפכו ל-2 וכן הלאה.. פעולת ה-checkin היא חסומה, עד שכל החוטים לא יסיימו את הפעולה לא נחזור. אנחנו מחכים בפעולה הזו עד שכל החוטים יגיעו לערך של התא שלו. ברגע שעברו את כל המערך וכולם זהים, ניתן לחזור.

ממשו Barrier עם שימוש כרצונכם באובייקטי סנכרון ופעולות אטומיות, תוך הקפדה על שימוש בזיכרון מינימלי

```c
typedef struct __Barrier {
    ...
} Barrier;

void init(Barrier *bar, int N) { ... }
void checkin(Barrier *bar) { ... }
void destroy(Barrier *bar) { ... }
```

ניתן לממש זאת ללא צורך של תא ייחודי לכל חוט, ושאף חוט לא יצטרך מזהה מיוחד להזנה.
- ב-checkin: כל חוט קורא ל-fetch_and_add של sum, שפעולה זו מגדילה באופן אטומי את הערך ב-1 ומחזירה את הערך שהיה שם מקודם.
- עכשיו כדי לדעת אם כולם עשו checkin, נבדוק את הסכום שהיה קודם לפעולת הנוכחי. כלומר נקבע פעולת חלוקה בין הסכום הקודם לבין הסכום הנוכחי.

ניקח שמספר החוטים הוא 10: אם הגעתי וראיתי 8 אז אני יודע שזה לא הפעם הראשונה שקוראים ל-checkin כי הסכום בין 0 ל-9. כך נוכל לדעת מה הקריאה הנוכחית. ובדוק האם הקריאה הנוכחית- checkin קטנה מהסכום חלקי מספר החוטים.

```c
Barrier {
    int N;
    int sum=0;
}

checking (...) {
    int v = ffa(sum);
    while (v/N <= sum/N);
}
```

