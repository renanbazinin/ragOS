מערכות הפעלה – שיעור 3

בשיעור זה נמשיך לדבר על תהליכים וביתר דיוק על תזמון תהליכים. היום נראה אלגוריתמי תזמון תהליכים.
לפני שנתחיל, מה שאנחנו מניחים:
Job – תהליך.
Workload – סט של ג'ובים (שהאלגוריתם מקבל כקלט).
Scheduler – האלגוריתם, הלוגיקה שלנו שמחליטה בכל רגע נתון מה רץ עכשיו.

* נניח היום שיש מעבד יחיד, כלומר שרץ רק תהליך אחד בכל רגע נתון והמתזמן שלנו צריך לבחור את התהליך שרץ בכל רגע.
* בנוסף, נניח שאנחנו יודעים את זמן הריצה של כל ג'וב.

First come, First Served (FCFS):
תזמון הג'ובים יהיה לפי סדר הגעתם, כמו בתור (הראשון שמגיע הוא הראשון שמוזמן).
- בדוגמה הזו, שלושת הג'ובים הגיעו בזמן 0, וכל אחד מהם רוצה לרוץ 10 שניות (כלומר סה"כ 30 שניות של זמן מעבד). התזמון נעשה לפי הסדר שהם הגיעו. אם כולם הגיעו בבת אחת – מניחים אותם באופן שרירותי אחד אחרי השני. כל ג'וב שמתוזמן רץ מתחילתו ועד סופו, ואז מתוזמן הג'וב שהגיע אחריו וכן הלאה.

• Example: 3 jobs
• A, B, and C run for 10 seconds each
[A,B,C arrive]
A B C
0 20 40 60 80

המדד לבחינת טיב האלגוריתם:
המדד הראשון שלנו: Turnaround Time – מדד שאומר כמה זמן לקח לג'וב לסיים מהרגע שהוא היה זמין (מהרגע שהוא נוצר) ועד שהוא הסתיים.
(מהרגע שהוא נוצר) ועד שהוא הסתיים.

• Turnaround time
• Time from job arrival to completion
A: 10s
B: 20s
C: 30s
A B C
0 20 40 60 80
Avg. turnaround: (10+20+30)/3 = 20 sec

למשל בדוגמה הזו –
ה-Turnaround של ג'וב A הוא 10 שניות.
של B לעומת זאת: 20 שניות, כי B היה זמין עוד בזמן 0 אבל תוזמן רק לאחר סיום התזמון של ג'וב A. ושל C: 30 שניות.
ה-Turnaround הממוצע הוא 20 שניות.

* ככל שתהליך יהיה Turnaround ארוך יותר, זה ירגיש לנו איטי יותר.

אז אם זה המדד שלנו, מתי אלגוריתם FCFS יהיה בעל ביצועים גרועים מבחינת Turnaround time ?
1. כשהגיעו הרבה תהליכים באותו זמן ואחד מהם יותר ארוך (בעיקר הראשון).

להלן המקרה האידיאלי עבור 3 תהליכים כאלה במקרה כזה: הרצה של B ראשון, C שני ו-A שלישי.
(ככה זה מה ש-FCFS היה עושה).

• When does FCFS perform poorly?
• Example: three jobs, but A runs for 60 seconds (B & C for 10)
• Ideal:
B: 10s
C: 20s
A: 80s
B C A
0 20 40 60 80
Avg. turnaround = (10+20+80)/3 = 36.67 sec

זה מה ש-FCFS היה עושה:
תזמון של A ראשון, ולוויה משמעותית ב-turnaround time.

• Example: three jobs, but A runs for 60 seconds (B & C for 10)
A: 60s
B: 70s
C: 80s
A B C
0 20 40 60 80
Avg. turnaround = (60+70+80)/3 = 70 sec

--------------------------------------------------------------------------------

Shortest Job First (SJF):
נרצה להימנע ממצב שבו התהליכים שממתינים לתהליך מאוד ארוך, נוציא קודם את התהליך הכי קצר, ואחריו הכי קצר הבא וכן הלאה.

• Run shortest job first, then next shortest, and so on
• Previous example:
B: 10s
C: 20s
A: 80s
B C A
0 20 40 60 80
Avg. turnaround = (10+20+80)/3 = 36.67 sec
ניתן לראות שקיבלנו את ה-turnaround האופטימלי.

מתי אלגוריתם SJF יהיה בעל ביצועים גרועים מבחינת Turnaround time ?

כאשר התהליכים הקצרים יגיעו באיחור לאחר התהליך הארוך יותר.
המתזמן שלנו לא מסתכל לעתיד, בזמן 0 הוא רואה רק את A ולכן תזמן רק אותו.

• When does SJF perform poorly?
• Example: A arrives at t=0, B & C arrive at t=10
A: 60s
B: 60s
C: 70s
[A arrives]
[B,C arrive]
A B C
0 20 40 60 80
Avg. turnaround = (60+60+70)/3 = 63.33 sec

Shortest Remaining Time First (SRTF):
לוקחים את התהליך שנשאר לו הכי פחות זמן ואותו אנחנו מתזמנים.
הרעיון הבסיסי הוא היכולת לעצור תהליך באמצע ולחזור אליו לאחר מכן, ולתזמן תהליך אחר במקומו (שנשאר לו פחות זמן).
המתזמן שלנו הוא Preemptive – כלומר, ניתן לעצור ג'וב אחד בשביל לתזמן ג'וב אחר.

• SRTF is a preemptive scheduler
[A arrives]
[B,C arrive]
B: 10s
C: 20s
A: 80s
A B C A
0 20 40 60 80
Avg. turnaround = (80+10+20)/3 = 36.67 sec
להלן ה-Turnaround האידיאלי.

--------------------------------------------------------------------------------

מדד נוסף – זמן תגובה: Response time :
המדד הזה בא למדוד את זמן התגובה, כמה המערכת שלנו אינטראקטיבית.
אם אנחנו מפעילים תהליך לוקח לו המון זמן עד שהוא מגיב בחזרה, זה לא מרגיש אינטראקטיבי.
נגדיר את זמן התגובה כזמן שלוקח לתהליך עד שהוא רץ בפעם הראשונה (עד הפעם הראשונה שניתן לו את התהליך, כלומר- מהרגע שהתהליך זמין עד הרגע שהוא רץ בפעם הראשונה).
זה לא משנה לנו כמה חלקים יש לתהליך, מה שנמדד זה הפעם הראשונה שהוא תוזמן.

• Response time
• Time from job arrival to first scheduling
• Important for interactive performance (user interaction)
[A arrives]
[B,C arrive]
B: 0s
C: 10s
A: 0s
A B C A
0 20 40 60 80

תהליך A הגיע בזמן 0 ונוזמן מייד. לכן זמן התגובה שלו הוא 0 שניות.
תהליך B הגיע בזמן 10 ומיד תוזמן ולכן גם זמן התגובה שלו הוא 0.
ג'וב C לעומת זאת – הגיע בזמן 10 (ביחד עם B) אבל תוזמן רק 10 שניות לאחר מכן, ולכן זמן התגובה שלו הוא 10 שניות.

שימו לב – SRTF מתפקד גרוע ב- Response Time:
• When does SRTF perform poorly?
• Example: A, B, and C arrive at t=0, run for 10 seconds each
[A,B,C arrive]
A: 0s
B: 10s
C: 10s
A B C
0 20 40 60 80
כל התהליכים מגיעים בזמן 0 וכל אחד מהם רוצה לרוץ 10 שניות.
A מתוזמן ראשון (בזמן 0), לכן זמן התגובה שלו הוא 0 שניות. B מתוזמן בזמן 10 ולכן זמן התגובה שלו הוא 10 שניות ו-C בזמן 20 וזהו גם זמן התגובה שלו – 20 שניות.

Round Robin (RR) – זמן מחזור:
הרעיון: ניתן לכל תהליך לרוץ למשך זמן קצר (קבוע מראש) ברגע שהוא מגיע, ואז ניתן לתהליך של כל תהליך יוקר משמעותית. כמו כן, נמשיך להריץ את התהליכים במחזוריות זמן הללו (לפי הזמן שנקבע) בתוריות עד שהתהליכים כולם יסיימו. time slice (scheduling quantum) – זהו הזמן שניתן לתהליכים לרוץ ברגע שהם מגיעים.

• Example: A, B & C arrive at t=0, run for 5 seconds each,
• Quantum: 1 second
Response Time:
A: 0s
B: 1s
C: 2s
Turnaround Time:
A: 13s
B: 14s
C: 15s
ABCABCABCABCABC
0 5 10 15 20
Good for response time, bad for turnaround time

כל התהליכים מגיעים בזמן 0.
ה-Quantum הוא של שנייה אחת.
נריץ את A למשך שנייה אחת ומכאן שזמן התגובה שלו הוא 0 שניות. לאחר שנייה נריץ את B ולכן זמן התגובה שלו הוא שנייה אחת ולאחר מכן נריץ את C ומכאן שזמן התגובה שלו הוא 2 שניות.
לאחר מכן נריץ כל אחד מהתהליכים למשך שנייה אחת- בתוריות, עד שיסיימו.

המתזמן הזה טוב עבור זמן תגובה אבל לא עבור Turnaround Time.
מרגיש כאילו הכל אינטראקטיבי, אבל מבחינת ביצועים – הכל מסתיים לאחר הרבה זמן.

שיפורים – (Round Robin (RR:
והקטנת חתיכות הזמן לקוואנטה קצרה יותר – כך נקבל זמן תגובה טוב יותר.
החיסרון בכך: פעולת ההחלפה בין התהליכים אינה חינמית, אם נעשה הרבה החלפות תוך זמן קצר, אנחנו נפגע בביצועים של המעבד.

-לעומת זאת: אם נגדיל את חתיכות הזמן לקוואנטה גדולה יותר, החלפת תהליכים תהיה זניחה מבחינת ביצועים אבל אז אנחנו נפגע בזמן התגובה.

מה קורה כשהתהליכים עושים קלט/פלט (I/O):
נניח ותהליך (ג'וב) עכשיו רץ 10 שניות, אבל אחרי 3 שניות הוא מחכה לקלט (מהמשתמש או קריאה מקובץ) פעולה שאין לנו מושג כמה זמן היא תיקח. יותר מזה, אין טעם לחכות בזמן שהתהליך מחכה את הזמן הזה.
לכן, בזמן שתהליך מחכה לפעולות קלט/פלט, הוא לא יקבל זמן מעבד, הוא נכנס למצב Blocked וזהו הזמן שבו היינו רוצים לתזמן תהליך אחר. כשהחומרה שלנו מוכנה (הנתונים מהקובץ נקראו) ניתן להוציא פסיקה (interrupt מהמשתמש)- רכיב החומרה שלנו גורם לפסיקה, והפסיקה הזו מוציאה את התהליך מהתנאים ב-Blocked והוא הופך להיות Ready.

- נוסיף את השיקול הזה למתזמן SRTF (שטוב ב- Turnaround time)
נניח שיש לנו 2 ג'ובים A,B וכל אחד מהם צריך 30 מילישניות של זמן מעבד, אבל בכל 10 מילישניות A מבצע פעולת קלט/פלט שלוקחת 10 מילישניות.

תהליך A מתחיל לרוץ בזמן 0, למשך 10 מילישניות ואז מתן לו 10 מילישניות לפעולות קלט/פלט, וכן הלאה, עד שהוא מסיים. יוצא שבכל מצב שיש 20 מילישניות מבוזבזות, בהן A ממתין, שיכלו להיות מנוצלות לדברים אחרים.

I/O: A A
CPU: A A A B
0 20 40 60 80

גם כאן יש לנו זמן מעבד מבוזבז, שהיינו יכולים לנצל יותר טוב.

I/O: A A
CPU: B A A A
0 20 40 60 80

פה עננו ל-B לרוץ בחלון זמן הראשון בו A ממתין לפעולות הקלט/פלט שלו.
אבל עדיין לא פתרנו את הבעיה, כי בנקודה הראשונה בה A סיים להמתין, לשני התהליכים נותרו 20 מילישניות ולכן נמשיך לתזמן את B ולא נקבע החלפה. עדיין לא פתרנו את הבעיה כי עדיין יש חלון זמן ריק שאינו מנוצל.

I/O: A A
CPU: A B A A
0 20 40 60

הפתרון – שינוי פשוט בנתונים שלנו:
אם אנחנו יודעים ש-A ל-30 מילישניות וכל 10 מילישניות עושה פעולת קלט/פלט, נשנה את ההתייחסות אליו: מעכשיו A לא יהיה ג'וב אחד, אלא יהיה 3 ג'ובים שונים, שכל אחד מהם מגיע בזמנים שונים ואורך 10 מילישניות.
ועכשיו ניתן לבצע חפיפה. נשתמש באותו מתזמן (SRTF) אבל עם חפיפה של ג'ובים (overlap):

• SRTF scheduler
• Common approach: treat each sub-job as independent job
• A is broken up into three 10ms jobs
• Allows for overlap of jobs
[A1,B arrive]
[A2 arrives]
[A3 arrives]
I/O: A A
CPU: A1 B A2 B A3 B
0 20 40 60 80

תהליכים A1,B מגיעים בזמן 0, A1 מתוזמן ראשון ולאחר מכן (ב-10 שניות הראשונות של קלט/פלט) B מתוזמן. כרגע מבחינתנו אין חלקים אחרים ל-A. לאחר מכן מגיע תהליך A2 ומתוזמן מיידית ושוב, ב-10 שניות ההמתנה שלו- מתוזמן המשך תהליך B. ואז מגיע החלק האחרון של A, הוא מתוזמן ומסיים וכך גם B.

הבעיה היא שכאשר תהליך מגיע אלינו, אין לנו יכולת לדעת מה הוא הולך לעשות.
אז על סמך מה שראינו עד עכשיו, אנחנו יודעים איך צריך לעבוד בהנחה שכן היינו יודעים מה כל ג'וב עושה.
עכשיו ננסה לנחש בעזרת ניתוח העבר של תהליך:
Multi-Level Feedback Queue (MLFQ) -מנגנון שמנסה לנחש את זמן הריצה של תהליך (מבלי לדעת אותו) בשביל לעשות קירוב ל-SRTF. אנחנו רוצים לשפר את ה-Turnaround Time כמה שניתן מבלי לדעת כמה זמן כל ג'וב ירוץ. בנוסף נרצה שהמערכת שלנו תהיה יותר אינטראקטיבית.
הרעיון הכללי של המנגנון הזה: יש לו סט של תורים כאשר לכל תור יש עדיפות שונה.
התור העליון הוא בעדיפות הגבוהה ביותר, התור שמתחתיו בעדיפות נמוכה יותר וכן הלאה.
כל ג'וב שמוכן לריצה (במצב Ready) יכול להיות בתור אחד בדיוק בכל זמן נתון.
Q2 -> A C
Q1
Q0 -> B

הרעיון הבסיסי של המתזמן הזה: כשרוצים לבחור איזה ג'וב ירוץ, הולכים לתור העליון ומסתכלים רק עליו. תמיד נסתכל על התור הכי גבוה שלא ריק. בתוך התור הזה, מפעילים את אלגוריתם round robin עבור התהליכים שנמצאים בתוכו. הרעיון הוא שאורך הזמן בו המתזמן לוקח, אנחנו נפיל ג'ובים בין התורים. נרצה שג'ובים שהם אינטראקטיביים יהיו בעדיפות גבוהה, וג'ובים שאינם כאלו יהיו בעדיפות נמוכה.
* העדיפויות של המתזמן לא קשורות לעדיפויות של המשתמש.

* אם התהליך מבצע הרבה פעולות קלט/פלט – השאיפה היא לזהות את התהליך הזה כג'וב אינטראקטיבי, ולכן נרצה להעלות לו את העדיפות. לעומת זאת, ג'וב שרק משתמש במעבד, עושה המון חישובים ואין לו קלט/פלט למשתמש, נעדיף לשים בעדיפות נמוכה יותר (כי בתור משתמשים לא נרגיש זאת).

נגדיר את החוקים הבאים:
1. בהינתן ג'וב חדש, ניתן לו את העדיפות הכי גבוהה (נניח שהוא קצר, אינטראקטיבי וכו'..) ונלמד עליו לאורך זמן.
2. אם הג'וב השתמש בכל הקוואנטה שניתנה לו, אז נוריד אותו לתור עם עדיפות נמוכה יותר.
3. אם הוא לא השתמש בכל הקוואנטה שניתנה לו, נשאיר אותו באותה עדיפות שהוא היה בה.

החסרונות של הגישה הזו:
1. הרעבה של תהליכים:
מתזמן כזה יפקד לא טוב במקרה של הרעבה. כאשר יש לנו למשל שני תהליכים אינטראקטיביים – ואל לשניהם יש פעולות קלט/פלט ולכן הם נמצאים בעדיפות גבוהה וגם נשארים בה, ומתזמנים לסירוגין, ולמעשה ג'וב אחר שאינו אינטראקטיבי והוא נמצא בעדיפות נמוכה יותר, ובגלל שני התהליכים הללו הוא לא יתוזמן, כלומר, הוא יורעב.

• Starvation
• Too many interactive jobs consume all CPU time
Q2 A [B C Q2 A]
Q1 A
Q0 AAAA
0 5 10

2. תהליכים "חכמים" מרמים את המתזמן: אם תהליך הוא זדוני ורוצה לקבל יותר זמן מעבד משאר התהליכים, ונגיד שהקוואנטה היא שנייה. אז הוא יכול למשל כל 900 מילישניות לבצע פעולת קלט/פלט, כך הוא ישתלט על המעבד וירעיב תהליכים אחרים.

• Game the Scheduler
• Before quantum is over, issue short I/O
• Remain in same queue, gain higher percentage of CPU time
Q2 A
Q1 A
Q0 AAAA
0 5 10

3. שינוי של תהליך- נניח בתחילת התהליך הוא לא היה אינטראקטיבי אבל בהמשך שלו הוא כן הפך להיות כזה. הבעיה היא שלא ניתן להעלות תהליכים לעדיפות גבוהה יותר, ולכן התהליך הזה יישאר בעדיפות נמוכה למרות שהוא הפך להיות אינטראקטיבי.

• Change behavior over time
• Start as CPU-bound
• Transition to interactivity

* ננסה לפתור את הבעיות הללו ע"י חוק שנקרא: priority boost. כל פרק זמן מסוים ניקח את כל הג'ובים ונעלה אותם לעדיפות הגבוהה ביותר לתור העליון, או במילים אחרות: כל פרק זמן מסוים, ניקח את כל הג'ובים ונשכח כל מה שלמדנו עליהם. עכשיו אם יהיו שני תהליכים אינטראקטיביים ואחד שלא, אז אחרי זמן מסוים התהליך שאינו אינטראקטיבי יעלה לתור עם העדיפויות הגבוהה יותר וגם הוא יתוזמן, וכך לא תהיה הרעבה.

כמו כן, כשהתהליך הופך לאינטראקטיבי לאחר זמן מסוים, לו לא תהיה בעיה כי כשהוא יעלה לתור עם העדיפות הגבוהה הוא פשוט יישאר שם.

• After some time, all jobs -> topmost queue
Q2 A
Q1 A
Q0 AAAA
0 5 10
• Solves two problems at once
• Guaranteed not to starve
• CPU-bound job that becomes interactive is treated properly

פתרון הבעיה שתהליכים "חכמים" מרמים את המתזמן:
נאמר שעל ידי פעולת קלט/פלט רגע לפני שנגמרת הקוואנטה, תהליכים יכולים לרמות את המתזמן ולנצל את המעבד וכך להישאר בתור העליון.
הפתרון: במקום לבדוק אם תהליך ניצל את כל הקוואנטה שלו או לא, נספור כמה זמן הוא רץ סך הכל, כלומר כמה זמן המעבד הוא ניצל. ברגע שנראה שתהליך ניצל קוואנטה שלמה שניתנה לו במצטבר, נוריד אותו בעדיפות (ולא משנה אם זה קרה בריצה אחת או ב-50 ריצות).

• Job used up time allotment (in total) -> reduce priority
• Regardless of how many times it has given up the CPU
Q2 A
Q1 A
Q0 AAABA
0 5 10

Tuning:
עדכון שבדרך כלל מוסיפים ל-MLFQ: משנים את חתיכות הזמן לפי התורים. אם בתור העליון נמצאים התהליכים האינטראקטיביים ובתור שתחתיו אלה שקצת פחות ובתור התחתון ביותר התהליכים שלא אינטראקטיביים בכלל, אז נשנה את חתיכות הזמן כך שהתור העליון יינתן קוואנטה של שנייה לכל תהליך, ובתור האמצעי יינתן קוואנטה של ארבע שניות ובתור התחתון ביותר יינתן קוואנטה של 10 שניות, כך שבתור העליון יישארו תהליכים שבאמת כמעט תמיד לוקחים זמן מעבד.

• Varying time-slice lengths
• High priority queues: shorter time slices
• Low priority queues: longer time slices
Q2 AB
Q1 AB
Q0 AB
0 5 10 15 20

סיכום MLFQ:
מטרת המתזמן הזה היא לשפר לנו את ה- response time ו- Turnaround time.
זה הבסיס של הרבה מאוד מתזמנים אחרים.

• Summary:
• Rule 1: if Priority(A)>Priority(B), A runs (B doesn’t)
• Rule 2: if Priority(A)=Priority(B), A & B run in RR
• Rule 3: new job -> highest priority
• Rule 4: job used up time allotment -> reduce priority
• Rule 5: after some time, all jobs -> topmost queue

Proportional Share Scheduler – משפחה אחרת של אלגוריתמים:
אלגוריתמים שרוצים לשפר את ההוגנות, לא מעניין אותם ה- response time או ה- Turnaround time אלא מעניין אותם שכל תהליך יקבל אחוז מסוים שאנחנו רוצים לתת לו מהזמן מעבד.
למשל בשרת של מערכת, לא מעניין אותנו כמה הוא אינטראקטיבי, אלא מעניין אותנו שירות כפי שביקשנו.
אנחנו נראה דוגמא לשני מתזמנים כאלה, שנותנים לנו את היכולת לחלק את זמן המעבד באופן פרופורציונלי.

Lottery scheduling :המתזמן הראשון:
נבחר אחד מהתהליכים שקיימים כרגע במערכת באופן אקראי וניתן לו לרוץ את הקוואנטה שלו.
זה אמנם יעשה באופן אקראי אך עם עדיפות גבוהה יותר (עם יחס מסוים) לתהליכים שהמשתמש קבע, כך שתהליכים שהמשתמש רצה- יקבלו יחס גבוה יותר (נבחר בהם בהסתברות גבוהה יותר).
הפעולה נעשית ע"י כרטיסים – Tickets. ניתן לכל תהליך מן כרטיסי הגרלה, ואז עושים "הגרלה" ובוחרים ג'וב מנצח. נניח שיש לנו תהליכים A,B ואנחנו נותנים ל-A 150 כרטיסים ול-B 50 כרטיסים (אז יש בסה"כ 200 כרטיסים). אם נסתכל על כל כרטיס כסיכוי לנצח, אז A מקבל 75% מזמן המעבד ו-B מקבל 25%. עכשיו נעשה הגרלה כך ש-A יזכה בסיכוי של 75% ו-B בסיכוי של 25%.

דרך העבודה: נניח ויש לנו 5 ג'ובים A עד E. הסתיימה הקוואנטה הקודמת ומגיע המתזמן והוא עכשיו צריך להחליט איזה תהליך ירוץ הבא בתור. המתזמן מגריל מספר מ-1 עד סך כמות הכרטיסים שחולקו (או מ-0 עד כמות הכרטיסים שחולקו פחות 1), נניח והתקבל לנו המספר 120 (זה הכרטיס הזוכה). נעבור על הרשימה של התהליכים (כאשר הם מסודרים לפי הכרטיסים שקיבלו) והתהליך שמחזיק את טווח הכרטיסים של הכרטיס הזוכה – הוא התהליך שיזומן.
למשל בדוגמא בתמונה: A קיבל כרטיס 1, ולכן זה עד לא 120. B קיבל כרטיס 1 אז אנחנו ב-2 וזה גם עדיין לא 120. C קיבל 100 כרטיסים ואז אנחנו בסה"כ 102 וזה עדיין לא 120. D קיבל 200 כרטיסים, והכרטיס ה-120 נמצא בטווח שלו ולכן D הוא התהליך שזוכה להיות מתוזמן. ככה נעשה בכל פעם שנגמרת הקוואנטה מחדש, ונגריל מספר ונבחר מבין התהליכים הקודמים שלא נבחרו.

• Implementation example:
• Keep jobs in a list
• Winning ticket 120 ->
head -> A(1) -> B(1) -> C(100) -> D(200) -> E(100) -> null
head -> A(1) -> B(1) -> C(100) -> E(100) -> null

* אז המתזמן הזה הוא הוגן, כל ג'וב יקבל את זמן המעבד היחסי לו. יש משהו שהאלגוריתם הזה תלוי בו: ניקח את ההוגנות של המתזמן הזה ונבדוק: לקחנו שני ג'ובים זהים לחלוטין, עם אותן לחן ריצה ושמים את אותם הדברים, ובדקו את ה- Turnaround time של כל אחד מהם, כלומר כמה זמן לקח להם מהרגע שהם היו זמינים לריצה עד הרגע שהם סיימו לרוץ, וחילקו את התוצאה אחד בשני.
- אם הג'ובים הם זהים והתזמן הוגן, אז הם יסיימו פחות או יותר באותו זמן, ואז המתזמן יחשב כהוגן, הם יסיימו בפער אחד מהשני. ככל שתוצאת החילוק שלהם תהיה קרובה יותר ל-1, זה יותר הוגן.
ראו שככל שהג'וב ארוך יותר, ההוגנות גדולה יותר. העניין קשור להסתברות: הסתברות תעבוד נכון אם נעשה המון הגרלות. לטווח קצר, אם שני ג'ובים הם קצרים ונעשה מספר קטן של הגרלות שיכול לקבל פחות זמן מעבד. בתור משתמשים, נעדיף להשתמש במתזמן הזה עבור מערכת שאנחנו יודעים שיש לה ג'ובים ארוכים בה.

מה עוד אפשר לעשות עם המנגנון הזה?
Ticket transfer- ג'וב יכול להעביר באופן זמני חלק מהכרטיסים שלו לג'וב אחר.
Ticket inflation- נותנים לתהליך את היכולת להוסיף לעצמו כרטיסים באופן זמני ולהוריד אותם חזרה, או להוריד לעצמו באופן זמני ולהעלות לעצמו חזרה לאחר מכן.

stride scheduling:
נגדיר לכל אחד מהג'ובים ערך מיוחד שנקרא PASS והוא שומר כמה הוא רץ עד עכשיו. בתור התחלה, לכל תהליך יהיה PASS של 0. בנוסף, נגדיר לכל ג'וב ערך שנקרא STRIDE והוא נאמר לו כמה זמן נרצה להריץ ג'וב (באופן יחסי), כך שאם A יהיה בעל ערך 100 ו-B יהיה בעל ערך 200, אז זה אומר שנרצה להריץ את A פי 2 פעמים כל פעם שנריץ את B.
כשנרצה לבחור ג'וב לריצה, נבחר את הג'וב עם ה-pass הנמוך ביותר, ואז כל ריצה נוסיף את ה- stride שלו לערך ה-pass שלו.

• Example: A, B, and C with 100, 50, 250 tickets respectively
• Divide some large number by it, e.g., 10,000
• A, B, C with 100, 200, 40 stride

A B C Who runs?
0 0 0 A
100 0 0 B
100 200 0 C
100 200 40 C
100 200 80 C
100 200 120 A
200 200 120 C
200 200 160 ...

