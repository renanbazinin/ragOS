מערכות הפעלה - שיעור 10

שבוע שעבר דיברנו על raid-0.
**Raid-1:** נקרא mirroring – בהינתן כמה דיסקים, נשכפל את הנתונים בין כולם (כל בלוק יהיה משוכפל בין כל הדיסקים).
mirroring level 2 - כל נתון משוכפל על פני שני דיסקים.
כשיש לנו יותר משני דיסקים, אנחנו קוראים לזה raid-01 / raid-10 (אבל בקורס כשנגיד raid-1 נכוון לזה).
אם אנחנו ב-mirroring level 2 למשל, ויש לנו 4 דיסקים פיזיים- נשכפל כל נתון רק על פני שני דיסקים ונעשה striping ביניהם. במקרה זה ניתן לאחד בין זוג דיסקים ולהפוך אותם לדיסק אחד וירטואלי שנמצא ב-raid-0.
כך יש שני דיסקים ב-raid-1.

| Disk 0 | Disk 1 | Disk 2 | Disk 3 |
| :--- | :--- | :--- | :--- |
| 0 | 0 | 1 | 1 |
| 2 | 2 | 3 | 3 |
| 4 | 4 | 5 | 5 |
| 6 | 6 | 7 | 7 |

נניח שאנחנו ב- mirroring level 2, אזי כל נתון משוכפל על פני שני דיסקים.
**ה-capacity** (כמה מקום אחסון יש לנו) במקרה זה יהיה: 2/(כמות הדיסקים x הגודל של כל דיסק) כלומר **(N x B) / 2**, כי כל נתון מופיע פעמיים (על פני שני דיסקים) ולכן אנחנו מנצלים רק חצי מהדיסקים.
**ה-reliability** (אמינות) במקרה זה: אם נוריד דיסק אחד בלבד, לא משנה איזה דיסק נבחר – לא נאבד נתונים כי יש לנו גיבוי. אבל אם נוריד שני דיסקים, עלול להיות אובדן נתונים (בבחירה של שני דיסקים שמאחסנים את אותם הנתונים). אז במקרה הזה – 1, או L-1 כאשר L הוא ה-mirroring level.
אם לפחות זאת נסתכל על המספר המקסימלי של דיסקים שיכולים להתקלקל מבלי לפגוע בנתן, זה יהיה: אחד מכל שכפול, כלומר **(L-1) x N ) / L**.
**ה-performance** (ביצועים) במקרה זה: אם נעשה הרבה קריאות סדרתיות נוכל לנצל את כל הדיסקים במקביל (רק בקריאה), ולכן עבור קריאה: **N x S**.
בכתיבה סדרתית, לא ניתן לכתוב לכל הדיסקים במקביל, כי ברגע שאנחנו כותבים לדיסק מסוים- אנחנו חייבים לכתוב גם לשכפול שלו, ולכן אנחנו יכולים לנצל רק חצי מהדיסקים במקביל, לכן עבור כתיבה סדרתית: **(N x S) / L**.
בפעולות אקראיות זה בדיוק אותו דבר, אם מדובר רק על פעולות קריאה- נוכל לפזר את הקריאות בין כל הדיסקים, ולהגיע ל-**N x R**, אבל אם זה כתיבות, אזי כל כתיבה לכל בלוק צריכה להיכתב גם לדיסק התואם. לכן זה יהיה **(N x R) / L**.

------------------------------------------------------------------------------------------------------------------

נזכיר בשלשות הבאות של ביטים (סדרה של ביטים), ובסוף נתונה הזוגיות שלהם (= התוצאה של xor על פני כל ביט):

| Stripe: | Disk0 101 | Disk1 010 | Disk2 000 | Disk3 001 | Disk4 110 (parity) |
| :--- | :--- | :--- | :--- | :--- | :--- |

למשל הזוגיות עבור הביט השמאלי בכל מספר: **1 xor 0 = 1 . 1 xor 0 = 1 . 1 xor 0 = 1 . 1 xor 0 = 1**
בביט השמאלי של הזוגיות יהיה כתוב 1.
לקחנו סט של ביטים וחישבנו את הזוגיות שלו. נניח עכשיו, שהלך לנו לאיבוד אחד המספרים (דיסק שהתקלקל).
אנחנו יכולים לשחזר את הנתונים שהיו בו. ברגע שיש לנו את כל הנתונים האחרים, ואת ה-parity שלהם, אם נעשה xor על הנתונים שכן נשארו (כל הביט המתאים בכל מיקום), נוכל להבין מה היה צריך להיות בדיסק שנעלם.
ל-xor יש את התכונה שאם אנחנו לוקחים קבוצה של N מספרים ומוצאים את ה-xor שלהם, אזי ה-xor של כל שלושה מהם, נותן את הרביעי. וזה נכון לכל גודל קבוצה של מספרים.

ברגע שיש לנו תכונה כזו, זה מאוד טוב עבור ה-raid שלנו. כי כך נוכל לקחת את כל הנתונים שיושבים על פני כל הדיסקים שלנו, ולעשות בין כל ביט וביט xor ולשמור את הזוגיות שלהם בדיסק מיוחד.
נניח שיש לנו 4 דיסקים פיזיים, ניקח את הדיסק הרביעי שלנו ובהתחלה נעשה רק striping – בלוק 0 ילך לראשון, בלוק 1 לשני, בלוק 2 לשלישי, וברביעי נשים את ה-xor של כל ה-stripe הזה. כל בלוק מורכב מהרבה ביטים, ונלך לפי ביט-ביט.
כלומר הבלוק בדיסק הרביעי, יכול להיות ביטים שהם תוצאה של xor על פני כל שאר הבלוקים.
**ה-capacity:** זה יהיה **(N-1) x B** כאשר B זה הגודל של כל דיסק.
וזאת כי אנחנו מנצלים את כל הדיסקים חוץ מדיסק אחד (שנקרא דיסק הזוגיות, שבו אנחנו לא שומרים נתונים של המשתמש אלא חישוב מסוים לקרינה, שהמשתמש לא רואה).
אנחנו מניחים שכל הדיסקים תמיד באותו גודל ולכן דיסק הזוגיות יספיק תמיד, לכל מספר של דיסקים.

**ה-reliability:** 1, כי לכל היותר דיסק אחד יכול להתקלקל מבלי שנאבד מידע. (אם דיסק הזוגיות מתקלקל אז לא אכפת לנו כי לא איבדנו שום מידע, אבל אם כל דיסק אחר מתקלקל, אנחנו יכולים לשחזר אותו).
**ה-performance** (ביצועים): בפעולות סדרתיות: **עבור קריאה:** בדיוק אותו דבר כמו בקריאה סדרתית, נוכל לקרוא מכל הדיסקים חוץ מדיסק הזוגיות, כלומר **(N-1) x S**. **בכתיבה:** כי ניתן לכתוב את הנתונים לכל הדיסקים במקביל (מלבד דיסק הזוגיות).
בפעולות אקראיות: **עבור קריאה:** אם מגיעות הרבה קריאות סדרתיות נקבל **(N-1) x R** כי אנחנו מפעילים את כל הדיסקים במקביל, חוץ מדיסק הזוגיות. **עבור כתיבה:** יש לנו בעיה. בכל פעם שכותבים בלוק כלשהו, חייבים לכתוב גם ל-parity, אולי זה לא אומר לנו שאנחנו יכולים לכתוב לכמה דיסקים במקביל, כי כל פעולות הכתיבה הללו יחכו לזוגיות. זה אומר שהפעולות הללו לא יכולות להתבצע במקביל. לומר לא ניתן לכתוב יותר מ-R. זה כמו כתיבה לדיסק אחד.
יש לנו בעיה נוספת בכתיבה אקראית. אמרנו שבכל כתיבת דיסק מסוים, צריך לעדכן את דיסק הזוגיות אבל אנחנו צריכים לדעת מה לעדכן בדיסק הזוגיות. אז צריך להתחיל לחשב מחדש, ביחד עם הנתון שרצינו להוסיף.
זה נקרא **small-write problem.**
יש שתי אפשרויות: 1. זוגיות של חיסור: נניח שאנחנו רוצים לכתוב לבלוק מספר 4, אנחנו נקרא את 3 ואת 5, נחשב מחדש ונכתוב.
2. זוגיות של חיסור: לפני הכתיבה, נקרא את 4 ואת הזוגיות הישנה. נסתכל מה שינינו עבור ביט-ביט, ובכל מקום בו ביט ב-4 השתנה, זה אומר שגם ביט הזוגיות צריך להשתנות. אז לא צריך לקרוא את כל הדיסקים, אלא רק את 4 ואת הזוגיות, לשנות את 4 ואת הזוגיות. את זה אפשר לעשות במקביל. אבל הפכנו כל פעולה ל-2 פעולות: במקום רק לעדכן את הזוגיות, אנחנו צריכים לקרוא ולכתוב. אז הביצועים שלנו במקרה הזה הם **R/2** (בשביל לקרוא בלוק אחד, אנחנו 3 צריכים לקרוא ולכתוב. כלומר אנחנו עובדים בחצי מהקצב כשמדובר בכתיבה אקראית).

- יש לנו עוד קצת בעיות ב-raid-4. אם אנחנו לא עושים כתיבות בכלל, אזי אנחנו לא משתמשים בדיסק הזוגיות. הוא מבוזבז ולפעמים אנחנו גם לא יודעים מה מצבו (כי כדי לדעת אם דיסק מקולקל, יש צורך לגשת אליו מדי פעם לעשות עליו פעולת ריקה, למשל לקרוא את הנתונים שיושבים בו, רק כדי לבדוק אם הוא תקין).
- בעיה נוספת: דיסק הזוגיות שלא עוזר לנו מבחינת ביצועים, צריך להיות הדיסק הכי מהיר שלנו. כל פעולת כתיבה הולכת להיכתב אליו. אם יש לנו דיסקים שונים במהירות שלנו, אז נרצה שהכי טוב יהיה הדיסק הזוגיות רק כדי שלא יפגע בנו.

------------------------------------------------------------------------------------------------------------------

**Raid-5:** בא לפתור את ה-small-write problem: הרעיון פה הוא אותו רעיון כמו ב-raid-4, לכל שורה הוא עושה striping ו-parity, אבל לא נשים את הזוגיות על אותו דיסק, תמיד.
למשל נשים את 0,1,2 בדיסקים 1-3 ואת הזוגיות בדיסק האחרון, ובשורה הבאה נשים את 3,4 ואת הזוגיות בדיסק 4 ואת בלוק 5 בדיסק 3. זה לא משנה על איזה דיסק ה-parity יושב. הבעיה ב-raid-4 מתחילה מכך שהזוגיות יושבת תמיד באותו מקום. אז נליך גם את הזוגיות ונסדר אותן בין הדיסקים.
**ה-capacity:** (N-1) x B כי בכל stripe אנחנו מאבדים בלוק (עבור הזוגיות). אולי זה לא משנה אם הנתון הזה הוא לא אותו דיסק, אלא פוזר בין דיסקים שונים. עדיין הפסדנו בלוק.
**ה-reliability:** 1. לא משנה איזה דיסק נפל, תמיד ניתן לשחזר אותו ע"י xor של כל שאר הבלוקים באותה שורה (באותו stripe).
**הביצועים:** פעולות סדרתיות: קריאה סדרתית: עכשיו אנחנו יכולים לנצל את כל הדיסקים, כי אם למשל יש לנו קריאה ב-0,1,2 ועוד קריאה ב-3,4,5 אז אנחנו יכולים לקרוא את 0,1,2,5 את כולם במקביל. אם נפזר את הפעולות על פני כל הדיסקים, נוכל כל הזמן להפעיל את כל ארבעת הדיסקים במערך שלנו. לכן מדובר על **N x S** קריאה סדרתית. בכתיבה סדרתית, כי בכתיבה סדרתית תמיד נצטרך לכתוב גם את הזוגיות. כלומר נוכל לתפוס N-1 בלוקים במקביל.
פעולות אקראיות: קריאה אקראית: **N x R**. כתיבה אקראית: **(R/2) x (N/2)**. עבור פעולת כתיבה לבלוק כלשהו, אנחנו צריכים לקרוא אותו ואת הזוגיות אליו, לקרוא ואת הזוגיות לכתוב אותה. אולי אנחנו צריכים לעשות שתי פעולות – קריאה וכתיבה. כבר הביצועים שלנו הם חצי (R/2). כאן, בניגוד ל-raid-4, כמה פעולות יכולות להתבצע במקביל. כי בלוקים שאנחנו קוראים את 4, אולי יש פעולה על 0, היא יכולה לקרות במקביל אליו, בלי שמפריע אחד לשני (כי הזוגיות מפוזרת בין הדיסקים ולכן זה לא גורם לבעיה). מכאן, ש-N/2 פעולות יכולות לקרות במקביל, אבל כל אחת מהן לוקחת כפול זמן (כי כל פעולה היא קריאה + כתיבה).
שיפרנו את הביצועים האקראיים לעומת raid-4, זה עדיין לא אידיאלי.

טבלה מסכמת:
latency- כמה זמן לוקח לפעולה אחת (מבחינת המשתמש). D אומר שזה מתבצע מייד. ב-raid-4/5 רואים שכל פעולת כתיבה לוקחת 2D כלומר 2 פעולות.

| Seq. Read | Seq. Write | Rand Read | Rand Write |
| :--- | :--- | :--- | :--- |
| RAID-0 | N·S | N·S | N·R | N·R |
| RAID-1 | (N/2)·S | (N/2)·S | N·R | (N/2)·R |
| RAID-4 | (N-1)·S | (N-1)·S | (N-1)·R | R/2 |
| RAID-5 | (N-1)·S | (N-1)·S | N·R | (N/4)·R |

| Capacity | Reliability | Read Latency | Write Latency |
| :--- | :--- | :--- | :--- |
| RAID-0 | N·B | 0 | D | D |
| RAID-1 | (N·B)/2 | 1 or N/2 | D | D |
| RAID-4 | (N-1)·B | 1 | D | 2D |
| RAID-5 | (N-1)·B | 1 | D | 2D |

איך נבחר במה להשתמש?
* Performance and no reliability -> RAID-0
* Random performance and reliability -> RAID-1
* Capacity and reliability -> RAID-5
* Sequential I/O and maximize capacity -> RAID-5
* RAID-5 is strictly better than RAID-4

אין סיבה להשתמש ב-raid-4.

------------------------------------------------------------------------------------------------------------------

מערכת קבצים:
* קובץ – מערך של בתים. יש לנו כל מיני פונקציות מיוחדות לכתוב ולקרוא ממנו, אבל בסופו של דבר מדובר על מערך של בתים.
אנחנו יכולים להסתכל עליו כמערך, כלומר לכל מיקום בקובץ – לקרוא ממנו, לכתוב אליו וכו'. ככה זה נראה עבורנו (מערכת ההפעלה מספקת את האשליה הזו).

* מערכת הקבצים-
1. אוסף הקבצים במחשב שלנו. כשאנחנו פותחים כונן C או תיקייה בלינוקס, אנחנו קוראים לזה מערכת הקבצים.
2. זה השם של החלק במערכת ההפעלה שמנהל את הקבצים (אותו קטע קוד שיודע לקחת את הפקודות שלנו ולתרגם אותן לפקודות על הדיסק).

- נרצה להחליט מה הממשק שאנחנו נותנים למשתמש. קבצים צריכים להיות שמות בכדי שהמשתמש יוכל לגשת אליו, ורק כאשר נותן שם, מערכת ההפעלה תוכל לדעת באיזה קובץ מדובר.

- איך הגענו לארגון הנוכחי והצורה הנוכחית שבה קבצים ותיקיות נראים במחשב?
* ב-kernel, יש לנו אובייקט שנקרא inode והוא מייצג קובץ.
* לכל קובץ במחשב שלנו משויך אובייקט כזה.
* ה-inode מכיל את ה-metadata (המידע על הקובץ, ולא את הקובץ עצמו), שמכיל למשל מידע: סוג הקובץ, הרשאות לקובץ, בעלים של הקובץ, גודל הקובץ, איפה הקובץ נמצא וכו'.
* ה-inode מיוצג ע"י מספר. ניתן למערכת ההפעלה מספר ולהגיד לה שאנחנו מעוניינים לגשת ל-inode 7 למשל.
* לכל קובץ במערכת הקבצים יש inode ייחודי משלו, ברגע שזה (id של) קובץ חי אז ה-inode הבא שיוצר יכול לקבל את אותו המספר) והוא ייחודי בתוך אותה מערכת קבצים (אם יש לנו שני כונני דיסקים, אז לכל אחד יש סט inodes משלו).
* כל המידע הזה שמור בתוך טבלת inode table) inode).

הרצת הפקודה ls -i במכונה הווירטואלית שלנו (של הלינוקס), נוכל לראות שחול מלכתוב את כל הקבצים בתיקייה, נראה גם מספרים שהם בעצם מספרי ה-inode של כל הקבצים בתיקייה שאנחנו מסתכלים עליה.

- בשביל לפעול לקובץ ספציפי במערכת ההפעלה, ובקש לקרוא לכתוב אותו בידינו מספר ה-inode שלו.
- טבלת ה-inode היא מערך (יכול להיות שמור בכל מיני דרכים) אבל זה נראה לנו כמו מערך, כך שבכל תא בטבלה יש את ה-inode של קובץ מסוים. אם ניגש למשל לתא 0, נקבל את הפרטים של קובץ 0. בכל תא יש את הפרטים של אותו קובץ.

- אם נרצה לקרוא למשל את inode 0, מערכת ההפעלה תלך לטבלת ה-inode, תקרא את המבנה בתא מספר 0, וממנו תחלץ את השדה המקדים שאומר איפה התוכן של הקובץ (איפה הנתונים שלו נמצאים על הדיסק בפועל).
כך גם לגבי כתיבה לקובץ.

- אם היינו עוצרים עכשיו, ה-API שהיינו נותנים למשתמש עבור גישה לקבצים:
המשתמש יספק לקריאות הללו מספר inode.
הבעיה בממשק הזה: מספרים זה דבר שקשה לזכור. אי אפשר לצפות מהמשתמש שיזכור את מספרי ה-inode.

1st attempt:
* read(int inode, void *buf, size_t nbyte)
* write(int inode, void *buf, size_t nbyte)
* seek(int inode, off_t offset)

* בעיה נוספת: אין לנו הבדל בין תהליכים שונים. נניח ואנחנו רוצים לקרוא את הביט ה-100 מקובץ כלשהו, אז עושים seek ל-100. אם יבוא תהליך אחר ויעשה seek לאותו inode, מערכת ההפעלה לא מבדילה בין תהליכים ולכן התהליך השני יתחיל לקרוא מ-100 offset. יש בעיית סנכרון.

* נזכיר נושא נוסף: מערכת הקבצים עדיין נשמרת במספרי inode, כי זה יותר נוח למחשב, אבל המשתמש ידבר בשמות קבצים (מחרוזות). נצטרך לשמור טבלת מיפוי בין שמות הקבצים לבין מספרי ה-inode. בדר"כ הטבלה הזו נמצאת ב-inode 2.
בטבלת ה-inode שלנו יהיו קבצים כמו מקודם, אבל inode 2 הוא מיוחד. בכל תא בטבלה יש סוג של הקובץ, אך עבורו יהיה כתוב סוג אחר- של תיקייה, והתוכן שלו מצביע לטור נתונים בדיסק, בדיוק כמו כל קובץ אחר, אבל כשנסתכל על הנתונים שהוא מצביע עליהם (ביטים מסוימים) הם יהיו במבנה מיוחד.
הנתונים שלו יהיו טבלה שמערכת ההפעלה מכירה ויודעת לקרוא בעצמה, כך שבכל תא בטבלה יהיה שם קובץ ומספר ה-inode שהוא מופנה אליו.
אם המשתמש רוצה לקרוא את הקובץ "hello", מערכת ההפעלה תקרא את קובץ מספר 2, שם תמצא את הטבלה, תקרא אותה, תחפש את hello, היא תראה למשל שה-inode שלו הוא 3, ואז תקרא את inode 3 ושם ייקח כל נתון שאנחנו צריכים, גם את תוכן הקובץ.

- ריכזנו את הכל לתוך inode 2 אבל זה לא באמת עובד ככה. וכלל את זה:
אם יש לנו מבנה שמתנהל רק עם שם לבין מספר inode, נכלול את זה לתוך.
לקובץ כזה יהיה רק שם, יהיה לו נתיב. יהיה לנו עץ של תיקיות, שיהיה הרבה יותר קל לארגון בתור משתמשים.
כך גם שם קובץ לא יצטרך להיות ייחודי, אלא רק הנתיב המלא שלו.

עכשיו במקום שב-inode 2 נשמור את כל המיפוי של כל הקבצים בכל מערכת הקבצים, נגדיר את אותו סוג חדש של תיקייה, כך שתיקייה תכיל מיפוי בין שם קובץ ל-inode.
כלומר, עכשיו כל inode יכול להיות תיקייה, או רגיל (אם לא כתוב סוג, אז זה קובץ רגיל).
תיקייה זה רגיל, פשוט מערכת ההפעלה יודעת להתייחס לנתונים שבה באופן מיוחד.
בכל תיקייה יהיה פירוט של כל הקבצים בתוכה.

| inode number | inode table | |
| :--- | :--- | :--- |
| 0 | location size type=dir | bashrc -> 3 |
| 1 | location size | |
| 2 | location size type=dir | etc -> 0, usr -> 5 |
| 3 | location size=6 | file contents |
| ... | | |

- אם עכשיו נרצה לגשת לקובץ כלשהו, למשל etc/bashrc/, אז מערכת ההפעלה עושה מעבר בשביל למצוא את ה-inode הרצוי.
1. מערכת ההפעלה תמיד מתחילה ב-inode 2, שזה שורש מערכת הקבצים באופן קבוע.
2. לאחר הגישה ל-inode 2, אנחנו יודעים איפה הטבלה שהוא מצביע אליה.
3. בטבלה הזו, נחפש את etc ונראה שהוא inode 0.
4. נלך ונקרא את inode 0. גם הוא תיקייה. נקרא אותו ונדע איפה הנתונים שלו.
5. בתוך הנתונים (תוכן התיקייה etc), מערכת ההפעלה תזכור ותמצא את הקובץ bashrc שהוא inode 3.
6. מערכת ההפעלה תלך לקרוא את inode 3 וממנו את התוכן של הקובץ הרצוי.

* בשביל פעולות קריאה אחרות שאנחנו עושים כמשתמשים, בפועל עשינו 6 פעולות קריאה.
- אם היינו עוצרים עכשיו, ה-API שהיינו נותנים למשתמש עבור תיקיות:
mkdir- יוצר לנו קובץ חדש שהוא inode כתיקייה (ומספר inode), תופס אותו, מגדיר את ה-type שלו בתור תיקייה, שם לו את התוכן וכו'.
readdir- מחזיר לנו את הרשומה הבאה בתיקייה. מחזיר לנו מעין struct של שם קובץ וה-inode שלו.
- אין את האופציה לעשות writedir, אנחנו לא יכולים לכתוב לתיקייה, כי כתיבה לתיקייה היא בעצם יצירת קובץ אחר וכו', וזה מעדכן את התיקייה.

* mkdir: create new directory
* readdir: read/parse directory entries
* No writedir

תמיד כשאנחנו יוצרים תיקייה חדשה, יש בה שני רשומות קבועות, ונקודה ונקודה נקודה.
נקודה- התיקייה הנוכחית.
נקודה ונקודה- התיקייה הקודמת.

$ ls -la
total 728
drwxr-xr-x 34 trh staff 1156 Oct 19 11:41 .
drwxr-xr-x+ 59 trh staff 2006 Oct 8 15:49 ..
-rw-r--r--@ 1 trh staff 6148 Oct 19 11:42 .DS_Store
-rw-r--r-- 1 trh staff 553 Oct 2 14:29 asdf.txt
-rw-r--r-- 1 trh staff 553 Oct 2 14:05 asdf.txt~
drwxr-xr-x 4 trh staff 136 Jun 18 15:37 backup

תמיד מערכת ההפעלה שמה באופן אוטומטי בטבלה של כל תיקייה - רשומה שנקראת נקודה, וה-inode שהיא משויכת אליו זה ה-inode של התיקייה אותה אנחנו רואים. כל פעולה שעושים על התיקייה, מערכת ההפעלה מעדכנת את מספרי ה-inode המתאימים כך שישונה.

- אם היינו עוצרים עכשיו, ה-API שהיינו נותנים למשתמש עבור גישה לקבצים:
מקודם היינו צריכים לתת את ה-inode של קובץ, נפתור אותה ע"י הכנסת הנתיב כחלק מפעולות הקריאה והכתיבה.
עכשיו ה-API הזה מאוד נוח עבור המשתמש.

2nd attempt:
* read(char *path, void *buf, off_t offset, size_t nbyte)
* write(char *path, void *buf, off_t offset, size_t nbyte)

הבעיה: כל פעולה מאוד יקרה. בכל פעולה יש צורך לעשות את כל תהליך התרגום משם הקובץ ל-inode המתאים לו.

**המטרה: לעשות את החיפוש הזה פעם אחת, לשם כך נוספו file descriptors.**
במקום לעשות את החיפוש הזה כל פעם מחדש, נשמור אותו בצד. ברגע שהמשתמש נותן לנו נתיב כלשהו ותרגמנו אותו ל-inode המתאים, נשמור אותו בצד. ועכשיו נפעל רק על ה-inode הזה.
אבל אנחנו לא רוצים להביא את מספר ה-inode למשתמש, ולכן ניצור אובייקט עבור המשתמש שנקרא file descriptor וכל מערכת ההפעלה נקרא לו file object. זה אובייקט שיכול נתונים בין היתר את מספר ה-inode ועכשיו כשהמשתמש ירצה לעשות פעולות הוא יספק לנו את ה-descriptor המתאים.
- לכל תהליך אנחנו נשמור טבלה של אותם file descriptors שהם integer.
למשל: 0 = fd עבור כל תהליך זה ה-stdin, כלומר מבחינת המשתמש אנחנו קוראים את הקלט (בברירת המחדל עבור התוכנית שלנו מדובר על המקלדת, גם המקלדת היא קובץ). 1 = fd זה ה-stdout שלנו החלון של הטרמינל בדיפולט. 2 = fd זה ה-stderr.

------------------------------------------------------------------------------------------------------------------

נניח והמשתמש רוצה לפתוח קובץ אזי הוא קורא ל-open.
אמרנו שלכל תהליך יש טבלת file descriptors שהם מצביעים לקבצים, שמערכת ההפעלה שומרת, ומשתמש אין גישה לטבלה הזו. כשאנחנו רוצים לפתוח קובץ, ראשית מערכת ההפעלה מוצאת את ה-inode המתאים. בדיוק באותו חיפוש שאמרנו קודם.
נניח ומדובר ב-inode 5 שהוא נמצא. השלב הבא: ניצור file descriptor, את האובייקט הזה שישב בקרן (בזיכרון של מערכת ההפעלה באופן זמני, אובייקט שנוצר בבלוק ריצה) בו יהיו כתובים פרטים על הקובץ (למשל ה-inode שלו, וכו'.) ועכשיו כדי שהמשתמש יוכל לפעול עליו, מערכת ההפעלה מוצאת את המקום הראשון שפנוי בטבלה, ומצביעה אליו.
בטבלה הכללית fd table היא טבלה של מצביעים לאובייקטים הנ"ל (כל תא בטבלה מצביע לאובייקט מסוג file object).
- לאחר כל זאת, נוכל להחזיר למשתמש את המספר (האינדקס) של האובייקט בטבלה. זה מה שחוזר מקריאת open.
עכשיו בכל פעם שנעשה פעולות, המשתמש יספק את ה-fd שהוא קיבל, וכך נהיה בגישה ישירה ל-inode מבלי לעשות את החיפוש בכל פעם.

נניח שאנחנו מריצים את הקוד הבא:

```c
int fd1 = open("file.txt"); // returns 3
read(fd1, buf, 12);
int fd2 = open("file.txt"); // returns 4
int fd3 = dup(fd2);         // returns 5
```

נוצר לנו fd והוא נמצא מצביע אליו.
מבקשים לקרוא ונותנים fd1, אז קוראים.
fd חדש שנוצר, מצביע על ה-offset תחילת הקובץ.
ברגע שעשינו את פעולת הקריאה הזו, ה-offset התעדכן. כך מערכת ההפעלה יודעת מאיפה התקבלו הנתונים.

שני יתרונות שהפעולה הבאה צריכה לקרות בו בתים אחרי ולתת הקובץ.
- כשאנחנו עושים seek, הפעולה נגשת ל-fd שלו ומייד משנה את ה-offset להיות מה שביקשנו.
- נניח ושנינו עוד פעם פתחנו את אותו קובץ. מבחינתנו זה מצביע לאותו קובץ. למרות שאנחנו רואים את ה-inode המתאים, ויוצרים fd חדש, שמחזיר את המספר הבא שפנוי במערך. אנחנו פותחים פעמיים את אותו הקובץ, אבל זה לא משנה כי בכל פעם שפתחנו, מדובר על file descriptor חדש, ולכן הוא גם מצביע על ה-offset תחילת הקובץ ברגע שהיה פתוח.
אם נקרא מ-fd1, אנחנו נקרא מה-offset של 10 בתים לאחר תחילת הקובץ.
למרות זאת, ביצוע קריאת dup על fd שסכר קיים- מקבלן מספר fd שכבר קיים ומשכפלת אותו. המספר אומנם מספר חדש, אבל הוא מצביע לאותו אובייקט. בביצוע dup, מערכת ההפעלה מוצאת את התא הראשון פנוי בטבלה, ואותה היא מצביעה לאותו אובייקט שה-fd שהעברנו מצביע עליו. אם נעשה פעולה על fd2 או על fd3, זה אותו דבר בדיוק. כמו כן, ה-offset בתוך האובייקט שה-fd שהעברנו מצביע עליו, מערכת ההפעלה תשנה את הנתון הזה בהתאם במערך (את ה-offset), אבל הוא לא נמחק יהיה לזה ביניהם. אם נעשה close ל-fd2, מערכת ההפעלה תפנה את התא הראשון במערך (אינדקס 4), אבל היא לא תמחוק את האובייקט שהוא הצביע עליו, מאחר ויש אליו הצבעות נוספות שלא נסגרו.
הקובץ ייסגר באמת רק כאשר אף אחד לא יצביע אליו יותר.

** כך זה גם ב-fork, כשאנחנו עושים fork, מערכת ההפעלה לוקחת את הטבלה הזו ומשכפלת אותה (כי הרי שני תהליכים יכולים להצביע לאותן דבר).

אל המנגנון המשפר שבאמת קיים אצלנו:

3rd attempt:
* int open(char *path, int flag, mode_t mode)
* read(int fd, void *buf, size_t nbyte)
* write(int fd, void *buf, size_t nbyte)
* close(int fd)

- קיבלנו גם שמות של מחרוזות, גם מערכת קבצים היררכית, היסט שנעון באופן חיובי (התהליך לא צריך להחזיק מצביע שיקודם כל פעם בקובץ, אלא מערכת ההפעלה דואגת לכך) וביצוע חיפוש פעם אחת בלבד.

------------------------------------------------------------------------------------------------------------------

**Hard Links:** אין לנו בלינוקס קריאת מערכת למחיקת קובץ. זאת משום שבלינוקס אנחנו לא מחליטים מתי קובץ נמחק.
אנחנו יכולים להיכנס לתיקייה ולמחוק בה קובץ, אבל בפועל לא באמת מחקנו אותו.
הסבר: לו אחת התיקיות במחשב שלנו. נכון אליה וראינו כל מיני קבצים שם.
מספרי ה-inode שלהם. אם נשים לב, יש בה שני קבצים עם אותו מספר inode.
המספרי ה-inode שלהם. אם נשים לב, יש בה שני קבצים עם אותו מספר inode.
זה דבר שלא קיים בוינדוס, אבל בלינוקס זה אפשרי ונפוץ.

| Hello | 1415 |
| readme | 1390 |
| file1.txt | 4200 |
| file2.txt | 505 |
| file3.txt | 4200 |
| a.out | 220 |
| testfile | 230 |

זה נקרא Hard link - שמות שונים לאותו קובץ. בפועל, file1.txt ו-file3.txt הם אותו קובץ, רק בשמות שונים.
השמות האלה יכולים להיות באותה תיקייה, בתיקיות שונות; יכולה להיות תיקייה נוספת שגם תכיל את ה-inode הזה.
בגלל באופן שבו אנחנו בונים את מערכת הקבצים, אז כל מבנה אנחנו יכולים לשים שם של קובץ שמפנה ל-inode מסוים.
בלינוקס, לקובץ אחד יכולים להיות הרבה לינקים. בתוך ה-inode, אחד השדות שיש בו זה כמה לינקים יש אליו.
אל אנחנו לא יכולים למחוק קובץ בלינוקס, אלא לבצע פעולה שנקראת unlink- זו קריאת המערכת בלינוקס למחיקת קובץ.
קריאת המערכת unlink מקבלת נתיב ומוחקת את השם של הקובץ. למשל ניתן unlink ל-file1.txt, ואז הרשומה הזו תימחק. ואז ה-inode הרלוונטי, מספר הלינקים ירד מ-2 ל-1. כאשר מגיעים למספר לינקים 0 ב-inode מסוים, רק אז הקובץ נמחק באופן סופי (ע"י ה-garbage collector).

**Symbolic Links:** נקראו גם soft links. כאן מדובר על משהו שדומה למה שמוכר לנו כמו "קיצור דרך" בוינדוס.
זהו סוג מיוחד של קובץ, כאשר ב-inode שלו מצוין שהוא כזה (וזה רק רק עבור Symbolic Links, וזה לא קשור למה שעשינו עד עכשיו).
נעשה ls -l, ונראה שזה אכן Symbolic Link (שונה ממה שראינו קודם).
בגלל שהסוג של הקובץ הזה הוא לינק, מערכת ההפעלה מתייחסת אליו באופן מיוחד. אנחנו לא יכולים לשנות תוכן של קובץ כזה לקרוא ולכתוב אליו.
למה בעצם קיצור דרך לקובץ אחר, כלומר, התוכן של קובץ כזה הוא השם של הקובץ שהוא קיצור דרך אליו.
כל פעם שנבקש לפתוח קובץ מסוג Symbolic Link, מערכת ההפעלה תראה שזה לינק, תקרא בעצמה את התוכן שלו, ותלך לפתוח את הקובץ שמופיע בתוכו.
בניגוד ל-hard link, ב-Symbolic Link שומרים שם, ולא inode.

| dir1 | | dir2 | |
| :--- | :--- | :--- | :--- |
| file1.txt | 4200 | file5.txt | 1213 |
| file2.txt | 505 | file6.txt | 4200 |
| file3.txt | 4200 | | |
| file4.txt | 306 | | |

דוגמא: נניח ויש לנו 2 תיקיות: dir1, dir2 והקבצים שלהם מפורטים למעלה.
נשים לב ש- inode 4200 יש שלושה hard links (הנמצאו בטבלאות הללו (שניים תחת dir1 ואחד תחת dir2). אם נמחק אחד מהם, הוא עדיין יהיה קיים.
כל עוד לא נמחק את שלושתם, הוא לא יימחק.
עכשיו למשל file4.txt מצביע ל-inode 306. הוא קובץ בפני עצמו, אבל אנחנו רוצים שיהיה לו קיצור של הקובץ file3.txt.
זה אומר, שאם נפתח את file1.txt, יויוצר לנו fd חדש, שיצביע ל-inode 4200.
אם נפתח את file3/file6, זה יהיה בדיוק אותו דבר, ייווצר fd חדש שיצביע ל-4200. אם נפתח את file4, גם ייווצר לנו fd חדש, כי מערכת ההפעלה תפתח את הלינק שיושב בתוך 306 inode.

* אם היינו מוחקים את file3, אזי file1,file6 היו ממשיכים לפעול אותו דבר. אבל אם היינו מנסים לפתוח עכשיו את file4, הוא הרי מצביע לפי שם (נתיב), היינו מקבלים "file not found".
* אם לאחר המחיקה של file3, היינו יוצרים חדש file3 עם 100 inode, אזי file1, file6 לא היו מושפעים כי הם עדיין מצביעים ל-4200. אבל אם היינו פותחים כעת את file4, הוא היה מחזיר לנו 100 inode.
- כלומר Symbolic Link זה לפי שם ולא לפי inode.

השוואה בין hard links ל- soft/symbolic links:
hard link זו הדרך הנוחה יותר. אנחנו לא תלויים לפי שום שם של קובץ; אם מישהו מחק אחד, השני עדיין חי.
אבל לפעמים Symbolic Links הוא הרבה יותר נוח והכרחי.
נניח שיש לנו תיקייה עם קובץ שכל הזמן אנחנו (הקובץ כל הזמן נמחק ונוצר מחדש, מעדכנים את הקובץ), לכן ה-inode שלו הקובץ הזה משתנה כל הזמן. אם אנחנו רוצים דרך לגשת לקובץ הזה דרך מקום אחר, ולא דרך אותה תיקייה שהוא נמצא בה, הדרך הקלה היא hard link. ברגע שנוצר ה- hard link לא יקרה פה.
למשל נרצה לשים בשולחן העבודה קיצור דרך לאותו קובץ, אז hard link לא יעזור. ובמיוחד אם הקובץ הוא מסוים (למשל 100), וכשנמחק את הקובץ הראשון ונוצר אחד חדש ונקבל לתוכו 110 inode, ה- hard link עדיין מצביע ל-100 inode. לכן במקרה זה עדיף להשתמש ב-Symbolic Link שיצביע לפי הנתיב של הקובץ לפי שם, ואז הוא תמיד יהיה מעודכן, לא משנה כמה פעמים נמחק ונוצר את הקובץ מחדש.

- מקרה נוסף בו נרצה להשתמש ב-Symbolic Link: במקרה בו אי אפשר בכלל להשתמש ב-hard link.
למשל, נניח ויש לנו דיסק אחד ובו קבצים b (inode 8), c (inode 9), a (inode 7).
ניקח עוד דיסק x, אם ניצור בו קובץ x וניצור hard link ל-inode 7, מערכת ההפעלה לא תאפשר לעשות את הפעולה הזו, היא תיכשל. שני הדיסקים האלה הם מערכות קבצים שונות, לכן דיסק אחד קובץ x לא יכול לאותו hard links של inode 7 של דיסק x אחר. (ברמה הטכנית רק באותה מערכת קבצים (ברמה הטכנית אי אפשר לעשות hard link לדיסק אחר, אלא רק soft links).

** אם אנחנו רוצים ליצור hard link, אזי הפקודה היא ln file1 link בטרמינל, וכן גם יש קריאת מערכת שנקראת ln. הפקודה בטרמינל מקבלת שם קובץ מקורי ושם קובץ חדש, ויוצרת inode זהה לשם הקובץ החדש.
** אם אנחנו רוצים ליצור קיצור דרך (soft link), מדובר על אותה פקודה רק עם -s :
ln -s file2 softlink.

מה קורה כשיש לנו כמה מערכות קבצים שונות? בווינדוס למשל אנחנו רואים כוננים שונים, כך שכל כונן זה התקן אחר.
בלינוקס, אין כוננים שונים. יש היררכיה אחת שמתחילה בשורש (/) והשורש נקרא super file system (מערכת הקבצים הראשית) וכל מערכות הקבצים נמצאות תחתיה.
כל תיקייה בהיררכיה, יכולה להיות מערכת קבצים אחרת. כלומר, אם נעשה את החלוקה, ייתכן שהתיקייה backups היא מערכת קבצים אחרת.
בלינוקס, כשאנחנו קוראים קובץ d // וכו', אנחנו מגדירים תיקייה מסוימת שתהיה השורש של אותה מערכת קבצים.
אז תחת מערכת הקבצים הראשית (/) יש כל מיני תיקיות. כל אחת מהתיקיות האלה יכולה להכניס אותנו לכונן אחר.
כלומר תמיד זה נראה לנו כאילו יש מערכת קבצים אחת אך כל תיקייה יכולה להיות שייכת למערכת קבצים אחרת.
יש לנו את הפקודה המיוחדת (שלא ניכנס אליה) שנקראת mount והיא בעצם יוצרת את מערכת הקבצים החדשה עבור תיקייה מסוימת.
- אם נחבר דיסק און קי, הוא יופיע כתיקייה רגילה ולא ככונן, וכדי להפוך אותו למערכת קבצים, נצטרך להשתמש ב-mount.

כשאנחנו עושים פעולות על מערכת הקבצים, לפעמים הפעולות הן אקראיות, כי יש מה שנקרא write buffering- כשאנחנו כותבים לקובץ, הפעולות שלנו לא מתבצעות באופן מידי. כי במערכת ההפעלה יש buffering והוא דואג לשיפור ביצועים. כאשר נצברו מספיק נתונים, הם ייכתבו, ואם לא, אז ייכתבו אח"כ.
אם אנחנו רוצים לוודא שהנתונים נכתבו, אנחנו צריכים קריאה fsync(int fd) שמקבלת fd ומוודאת שכל השינויים שעשינו על הקובץ באמת ייכתבו. כלומר, אנחנו מודיעים למערכת ההפעלה שאנחנו ממתינים שהשינויים ייכתבו, מערכת ההפעלה תבחר מתי לכתוב אותם והקריאה תחזור רק כאשר הם נכתבו (זה עדיין לא 100% כי הפעולה הזו אומרת למערכת ההפעלה לחכות שההארד דיסק יקבל את הנתונים ויחזיר ok אבל כפי שלמדנו, גם ההארד דיסק עצמו שומר בבאפר משלו, ועל זה אין לנו שליטה).

קריאת המערכת rename:
rename(char *old, char *new)
הקריאה הזו מקבלת שם של קובץ ושם חדש שנרצה לתת לו, והיא בעצם מחליפה את הקובץ ממקום למקום.
הקריאה הזו היא לא רק לשינוי נתיב מלא. למשל ניתן לשנות את הקובץ הבא: a/b/c.txt ל- x/y/z.bin/.
כלומר, קריאת המערכת הזו יכולה לשנות לחלוטין את שם הקובץ, להזיז אותו מיקום וגם להעביר אותו למערכת קבצים שונה.
אם b הלך להארד דיסק שונה מ- a זה הדיסק און קי שלי, אז לא רק שינינו את שם הקובץ, אלא הזזנו אותו למערכת קבצים שונה.

- כשאנחנו משנים שם של קובץ תחת אותה מערכת קבצים (העברנו מתיקייה a לתיקייה b כאשר a, b נמצאות תחת אותה מערכת קבצים) – זו פעולה פשוטה. כל מה שמערכת ההפעלה צריכה לעשות זה למחוק את הרשומה מתוך a ולהעביר אותה ל-b עם אותו inode. ואחר וזו אותה מערכת קבצים, ה-inode הרלוונטי עדיין נמצא בתוך אותה מערכת קבצים.
זה אחד היתרונות בשימוש ב-inode, אנחנו לא צריכים לעשות כלום חוץ מלשנות את שם הקובץ.

- אם לפעמים a, b היו במערכות קבצים שונות אזי עכשיו זה כבר לא אותו דבר. אם הקובץ היה בעל 100 inode למשל, אזי 100 inode תחת תיקייה a זה לא כמו 100 inode תחת תיקייה b.
זו פעולה מורכבת עבור מערכת ההפעלה, כי היא צריכה למחוק את הקובץ מ-a וליצור קובץ חדש עם אותם נתונים, תחת b.

** אל rename רק משנה את השם של הקובץ, לא צריך לעשות כלום, אלא אם אנחנו מעבירים בין מערכות קבצים שונות.
** rename באותה מערכת קבצים, מבוצע אטומי- אם נחזור לדוגמא המקורית בה a, b תחת אותה מערכת קבצים, אז מובטח לנו שהפעולה תתבצע באופן אטומי (בבת אחת), כלומר, שלא יקרה מצב שהמחשב שלן קרס ו-a יישאר בשתי התיקיות, או- לא יכול לקרות מצב בו המחשב קרס ו-a לא יהיה קיים יותר.

עדכון נתונים של קובץ:
נניח שיש לנו קובץ קיים, יש בו נתונים ואנחנו רוצים לכתוב אליו נתונים חדשים ולהחליף את ה-data שלו.
יש לנו בעיה עם מערכת הקבצים שלנו, כי יכול לקרות מצב שנקרא crash (מחשב נכבה, פעולה וכשלה).
נניח שהתחלנו לכתוב לקובץ הזה, וקרסנו באמצע, לפני שסיימנו לכתוב הכל.
fsync לא יעזור לנו במצב הזה, כי fsync מוודא שכל מה שכתבנו עד עכשיו נכתב בהצלחה, אבל ייתכן ודברים לא נכתבו.
אולי יש לנו פה בעיה. היינו רוצים פעולה אטומית- או שכל המידע החדש שנכתב ייכתב בבת אחת, או שכלום ממנו לא ייכתב.

- פעולת ה-rename יכולה לעזור לנו כאן. ניקח דוגמא: יש לנו קובץ בשם file.txt. אנחנו רוצים לשנות אותו ולוודא שהוא נכתב בהצלחה 100%, כלומר או שיש לנו את התוכן הישן, או שיש לנו את התוכן החדש. לא מצבי ביניים.
בין הדברים היחידים שאנחנו יכולים לעשות: ליצור קובץ חדש, אחר, שיקבל inode אחר ואליו נכתוב את כל ה-data החדש שלנו. אם קרסנו באמצע, אז קרה כלום, כי file.txt עדיין מכיל את המידע הישן, אולי יש לנו קובץ זמני אבל לא קרה כלום (אפשר גם לשים את הקובץ הזה בתיקייה מיוחדת של ריצה בלינוקס שנמחק בכל פעם שהמחשב נכבה).
ברגע שסיימנו לכתוב את כל הנתונים, נקרא ל-fsync ונבדוק שהנתונים שלנו נכתבו בפועל.
ואז ברגע ש-fsync הצליח ואנחנו יודעים שהקובץ "הזמני" מכיל את הנתונים שאנחנו רוצים, נכתוב את הקובץ ע"י פקודת rename. בטרמינל הפקודה לביצוע rename נקראת mv:
mv file.txt.tmp file.txt
rename מובטח להיות אטומי ולכן או שהשינוי יקרה או שהוא לא.
זו הדרך הכי טובה שיחידה שלנו לקחת קובץ ולשנות את תוכנו באופן אטומי, מבלי מצבי ביניים.

