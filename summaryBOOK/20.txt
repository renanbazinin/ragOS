מערכות הפעלה – שיעור 20

מימוש מערכת הקבצים:
עד עכשיו דיברנו על ממשק מערכת הקבצים בעיקר, עכשיו נראה איך מערכת הקבצים ממומשת.
ניקח מערכת קבצים לדוגמא (לא אחת שקיימת, אלא מערכת קבצים פשוטה לשם הדוגמא) כדי להבין איך מערכת הקבצים ממומשת.
תזכורת: ההארד דיסק הוא מערך גדול של בנקים. מערכת הקבצים היא חתיכת קוד שמקבלת את הפעולות שלנו ופוקדת לפעול על מערך הבתים כדי שהפעולות יעבדו כמו שאנחנו מצפים.
** למערכות הקבצים יש המון מימושים, אבל לכולן יש את אותו הממשק.
** אין לנו זיכרון נוסף, אנחנו לא יכולים כמו בזיכרון וירטואלי להחליט שאנחנו מחזיקים במערכת הקבצים רשימה מקושרת למשל. בלאן ריצה, אנחנו יכולים להשתמש בזיכרון, אבל אנחנו צריכים לקחת בחשבון שבכל רגע נתון המחשב עלול להיכבות והנתונים שלנו צריכים להישאר שם כשנדליק מחדש את המחשב.
- מערכת הקבצים היא קוד שעובד מול הדיסק שלנו.

מערכת הקבצים שנלמד עליה היום: vsfs
זו מערכת קבצים רק לצורך לימודי, היא לא בשימוש בשום מקום, אך אותם עקרונות נמצאים כמעט בכל מערכת קבצים של Unix.
מערכת הקבצים צריכה לנהל 2 דברים:
1. אילו אבני בניין יש לנו בדיסק – מה אנחנו מחזיקים על גבי הדיסק ואיך (מחזיקים רשימה של קבצים/רשימה של מקומות פנויים..).
2. איך אנחנו מממשים פעולות של המשתמש הפועלות על הכונן הקשיח (על הדיסק שלנו) – אם למשל המשתמש רוצה לקרוא קובץ, מה זה אומר לקרוא מקובץ, כי הרי יש לנו מערך ולא ידוע מה זה קובץ.

דבר ראשון שאנחנו עושים: נחלק את הדיסק לבלוקים.
זו חלוקה שכבר קיימת בדיסק, אבל מערכת הקבצים בדרך כלל מחלקת לבלוקים של 4KB. אז ניקח את כל הדיסק שלנו, יש לנו 1TB זיכרון ונחלק את כל הזיכרון הזה לבלוקים של 4KB.
נספור את הבלוקים מ-0 עד N-1.
ניקח דוגמא לדיסק עם 64 בלוקים הממוספרים מ-0 עד 63, כל בלוק הוא בגודל 4KB ולכן הדיסק כולו הוא בגודל 256KB.
אנחנו מגדירים שכל פעולה שתתבצע- היא בגודל בלוק (אם אנחנו קוראים או כותבים 4KB, אנחנו כותבים את כל כותבים 4KB, זה לא אומר שברמת החומרה זה צריך להיות ככה וזה לא אומר שהמשתמש צריך להתנהג ככה).
- אנחנו אנחנו מאחסנים בדיסק את הנתונים של הקבצים, אך זה לא הדבר היחידי שצריך להיות שם, אנחנו צריכים להחזיק גם מידע על אילו קבצים יושבים בדיסק, אילו תיקיות יש, איזה שטח פנוי ומה לא פנוי וכו'.
אז ניקח 60 מסיים של בלוקים ונגדיר אותם כבלוקים של מידע - data blocks, למשל 56 הבלוקים הראשונים ישמשו עבור שמירת נתונים של קבצים (התוכן עצמו של הקובץ).
עכשיו אם משתמש ירצה לקרוא/לכתוב לקובץ מסוים, נצטרך איפה הקובץ הרצוי נמצא מבין כל הבלוקים הללו ונבצע את הפעולה הרצויה אל הבלוק הזה.
אך אנחנו צריכים גם לדעת איזה קבצים יש, ואיפה יושבים כל הנתונים של כל קובץ וכו', זה גם צריך להיות שמור בתוך הדיסק בכדי שנוכל לקחת את הדיסק ממקום למקום, לנתק אותו ועדיין לדעת איפה דברים נמצאים.
לשם כך, נשמור איזור מסוים בדיסק שיכיל את ה-metadata, כלומר את כל המידע על הקבצים, ונקרא לאזור הזה inode.

---

• Inode
• Type (file / directory)
• UID (owner)
• rwx (permissions)
• Size (in bytes)
• Data blocks
• Times (access / create)
• Links count (# paths)
• ...

inode הוא בדרך-כלל בגודל 256 בייט. בבלוק אחד של 4KB, אנחנו יכולים להכניס 16 inodes.
כל inode אומר קובץ. למשל ב-inode 16 יש את כל הפרטים על קובץ מספר 16.
השדות ששם: inode: סוג, גודל, הרשאות גישה, איפה המידע שלו נמצא ועוד..
_________________________________________________________________________________
כעת, נרצה להגיע מ-inode ל-data.
ב-inode יש כל מיני פרטים על הקובץ, ובין השאר, מכיל את מספרי הבלוקים בהם נמצא התוכן של אותו קובץ (הבלוקים שמכילים את התוכן של הקובץ לא חייבים להיות רציפים בדיסק).
בנוסף, אנחנו צריכים שיטה שכאשר אנחנו צריכים קובץ או יוצרים קובץ חדש, יאפשר לנו להקצות את הבלוקים או להשתמש בבלוק פנוי.
שיטות הקצאה: דיברנו בעבר על שיטות הקצאת זיכרון וזה אותו רעיון.
- אנחנו רוצים לדעת איפה ה-data של כל קובץ, וכלות בשיטה שבה אנחנו שומרים את המידע- יש לנו כל מיני דרכים לבחון את שיטת ההקצאה.
1. הקצאה רציפה - Contiguous allocation - שיטת הקצאה פשוטה. ב-inode יהיה לנו מצביע (מספר) של בלוק, שהחל ממנו נמצאים הנתונים של הקובץ. זו הקצאה רציפה. כלומר, אם inode מסוים מצביע ב-data שלו על בלוק מספר 7, אז בהתאם לגודל הקובץ (הגודל גם כתוב ב-inode), נניח שגודל הקובץ הוא 10KB ולכן ה-data של הקובץ יימצא בבלוקים 7,8,9 (בבלוקים 7,8 יהיו 4KB מתוכן הקובץ ובבלוק 9 יהיו 2KB, למרות שיש בלוק, זה לא מעניין אותנו).
בשיטה הזו:
1. הפרגמנטציה החיצונית תהיה גרועה (כלומר, יהיה לנו הרבה שטח פנוי בדיסק, אבל הוא יהיה מפוזר ולא רציף, ולכן הוא לא לכך שנתן לשימוש). הקצאה רציפה שלא נעשית באופן מהיר, יוצרת פרגמנטציה חיצונית מאוד גרועה. ככל שיצרו, קבצים גדולים/קטנים ונשנה אותם, יתחילו להיווצר "חורים" ובעיות.
******* הפרגמנטציה הפנימית תהיה בערך דומה בין כל השיטות *******.
2. הגדלת קובץ תהיה בעייתית- נניח שיש לנו קובץ B בגודל 4 בלוקים (שזה אומר שהוא בגודל של עד 16KB, בין 12-16KB), אם נרצה להגדיל אותו ל-17KB, לא נוכל לעשות זאת באותו מקום ולא נוכל למצוא לו מקום חלופי שבו יהיה 5-בלוקים רציפים ולהעביר לשם את כל הקובץ.
3. גישה סדרתית היא מעולה- אם אנחנו כותבים תוכנית שפשוט קוראת את הקובץ באופן סדרתי מתחילתו ועד סופו, זו פעולה רציפה וסדרתית על גבי הדיסק ולכן גישה סדרתית הופכת במקרה זה לגישה סדרתית על הדיסק (קריאה סדרתית מקובץ לא תמיד בהכרח מתבטאת כפעולה סדרתית בדיסק, הכל תלוי איך שמרנו את הנתונים, ובמקרה הזה הנתונים שמורים באופן רציף ולכן מדובר בגישה סדרתית על הדיסק).
4. גישה אקראית גם טובה- גישה לנקודה אקראית בתוכו היתה יכולה. אם אנחנו רוצים לשנות את ה-kb ה-10 של קובץ מסוים, אנחנו יודעים כבר איפה הקובץ מתחיל ובעזרת חישובים ניתן למצוא את המיקום של אותו kb.
5. Metadata - כמה overhead, כמה זיכרון נוסף אנחנו תופסים בשביל שיטת האחסון שלנו (כמה נתונים צריך להוסיף ל-inode שלנו). פה ה-metadata הוא מצביע אחד בלבד (מעט מאוד overhead). כל inode צריך להכיל מצביע אחד שאומר איפה מתחילים הנתונים שלו.

- השיטה הזו של הקצאה רציפה היא אינה שיטת אחסון טובה, אל מערכת קבצים שיש לנו כוננים לא משתנה בה, חוץ מכונני דיסקים. כשאנחנו צורבים דיסק dvd למשל, אנחנו יודעים מראש מהם כל הקבצים שהולכים להיכנס אליו ומהו הגודל של כל קובץ, ואז השיטה הזו מעולה, כי בכונן דיסקים קובץ לא יכול לגדול אז לא משנה לנו שהגדלת קובץ היא בעייתית בשיטה זו, וגם לא תהיה פרגמנטציה בכלל כי אף קובץ לא משתנה בגודל. אנחנו שמים את כל הקבצים ברצף אחד אחרי השני על הדיסק, ובכל דיסק שקיים כיום, שיטת ההקצאה היא הקצאה רציפה. זה הכי יעיל ופשוט במערכת הקבצים של כונני דיסקים.

---

2. רשימה מקושרת – שיטת הקצאה זו פותרת את הבעיות של פרגמנטציה חיצונית והבעייתיות של הגדלת קבצים, כלומר בשיטה זו אין פרגמנטציה חיצונית בכלל וניתן להגדיל קבצים בקלות.
בשיטה זו, יהיה לנו מצביע ב-inode שיצביע לבלוק אחד. בנוסף, בכל בלוק יהיה 4 בתים (גודל של מצביע) שיצביעו על הבלוק הבא (אם הקובץ גדול יותר מבלוק), וההצבעות יהיו כמו רשימה מקושרת (זה ה-Metadata).
אם כל בלוק הוא בגודל 4KB, אנחנו נכניס שם 4KB - 4B ונתמש בארבעת הבתים עבור המצביע. ואז קובץ יכול להתפזר על פני הדיסק ולא חייב להיות רציף. לכן לא יכולה להיות פרגמנטציה חיצונית והגדלת קובץ היא גם מאוד קלה.
הביצועים בשיטה זו הם מאוד גרועים:
- גישה סדרתית: תלויה באופן סידור הנתונים. אם הבלוקים יהיו רציפים, אז הקריאה תהיה רציפה ולכן היא תהיה גם רציפה וסדרתית על פני הדיסק, אך אם בלוקים יהיו מפוזרים זה אלפה ומפסידים את הגישה הסדרתית ונהפוך לגישה אקראית (כי מדובר על גישה לכל מיני מקומות אקראיים בדיסק שאינם רציפים).
[D A A A D B B B B C C C B B D B D]
- גישה אקראית: אם נרצה לקרוא למשל את הבלוק האחרון של קובץ מסוים, נצטרך לקרוא את כל הבלוקים מההתחלה ועד הבלוק האחד לפני אחרון, כדי לדעת איפה יושב הבלוק האחרון. אנחנו לא יכולים לדעת איפה הקובץ מסתיים מבלי לעבור בלוק בלוק מההתחלה. גם אם היו לנו מצביעים דו-כיווניים, או אפילו מצביע לסוף ומההתחלה, קריאה מהאמצע הייתה גם לא יעילה.
- שיטת ההקצאה הזו לא בשימוש.

3. File-Allocation Table (FAT) – שיטת הקצאה שלקחה את הרעיון של רשימה מקושרת והייתה בשימוש עד לפני כעשור בערך. שיטה זו מנסה לטפל בבעיית הביצועים האקראיים של שיטת הרשימה המקושרת. שיטה זו מציעה לשמור אזור נוסף בדיסק, שם נשב הרשימה. כלומר, לא יהיה בכל בלוק מצביע לבלוק הבא, אלא תהיה לנו מעין רשימה של כל ה-next של כל בלוק (טבלה שנקראת file allocation table המכילה מספר בלוק ומה ה-next שלו).
ההנחה שנעשתה במערכת הקבצים הזו, זה שאת הטבלה הזו (או לפחות חלק משמעותי ממנה) אנחנו יכולים לשמור בזיכרון. כשהמחשב עולה נקרא אותה מהדיסק ונחזיק אותה בזיכרון וכך נוכל לגשת אליה מהר והיא לא תדרוש פעולות נוספות.
ואז אם נרצה לדעת איפה של מצביע מסוים הקובץ, לא תהיה בעיה, נעבור על הטבלה (הרשימה) ונקרא רק את הבלוק שאנחנו צריכים, בלי לעבור על כל הבלוקים.
- הבעיה בשיטה הזו: בעיית ביצועים. אמנם שיפרנו את הגישה האקראית אבל זה לא עושה scale. ככל שההארד דיסק גדל וגדול, הרשימה הזו מתחילה להיות ענקית עכשיו לא ניתן לשמור את כולה בזיכרון, אז צריך לשמור אותה בחלקים וזה נהיה לא אידיאלי. (מבחינת שאר הביצועים השיטה הזו דומה לרשימה המקושרת, רק שיפרנו את הגישה האקראית).

4. Extents- הקצאה יותר מודרנית, שרוצה להחליק ב-inode כמה מספרים (היה נהוג בין 2-6).
extent יכול מספר בלוק שמכיל את הנתונים (מצביע) ומה הגודל של הנתונים למשל אם יש extent שמכיל את הערכים 3,4 אז הנתונים נמצאים בבלוק 3 והם באורך 4, כלומר הקובץ נמצא בבלוקים 3,4,5,6.
עם כמות יחסית קטנה של extents, אנחנו יכולים להחזיק הרבה נתונים. למעשה, כמות לא מוגבלת של נתונים מבחינת הקובץ, שרק חלקם צריכים להיות רציפים.
מבחינת פרגמנטציה חיצונית, שיטה זו טובה יותר. אם יש למשל רק בלוק או שניים פנויים בדיסק, אפשר לדעתנו להשתמש בהם. שיטה זו טובה גם מבחינת הגדלת קבצים. אם קובץ צריך לגדול ואין לו לאן, ניתן להשתמש ב-extent הבא וגודל אותו לאן שפנוי. הוא לא חייב לגדול באופן מקום באופן רציף.
עדיין שמרו על היתרונות של הקצאה רציפה – גישה סדרתית היא מעולה (הקובץ אולי לא יהיה רציף לחלוטין על הדיסק, אבל הוא יהיה בכמות קטנה של מקטעים רציפים למשל שלושה מקטעים או שישה) והביצועים בקריאה סדרתית יהיו מעולים.
הביצועים בשיטה אקראית אם נרצה לגשת לבלוק ה-למשל של קובץ, יידרש חישוב פשוט ונוכל להבין איפה הוא נמצא ולגשת אליו בקלות.

---

גם מבחינת metadata הוספנו מעט מאוד, אם בדרך כלל ב-inode יש מספר אחד, אז עכשיו יתווספו מספר קטן של מספרים (בני-זוג).
הבעיה העיקרית בשיטת ה-extent היא קבצים שעושים בהם הרבה שינויים. אם נתחיל עם קבצים קטנים וכל פעם נוספים להם שינויים, יתחילו להיווצר לנו ה-extents. ברגע שסיימנו את כל ה-extents עבור קובץ מסוים אנחנו רוצים להגדיל אותו עוד ואין מקום, צריך למצוא לו מקום חדש על הדיסק (כמו בשיטה הרציפה) וזה לא תמיד אידיאלי.
לכן השיטה הזו הוחלפה כמעט לחלוטין בשיטה הבאה למעשה השילוב של שתיהן זה מה שיש היום):

Indexed allocation- שיטה זו לוקחת את הרעיון של extents אבל לא ה-extents, כלומר, יותר לכיוון של שמירת הגודל.
נשמור הרבה metadata (או כמה שצריך), שפשוט אומר באיזה בלוקים הקובץ נמצא, בלי אורך.
למשל: הקובץ נמצא בבלוק 7, ההמשך שלו ב-2 ואח"כ ב-4 וכן הלאה (..).
לשיטה הזו אין פרגמנטציה חיצונית כלל. כל קובץ יכול להופיע בכל בלוק, אין בעיה, תמיד אפשר להוסיף בלוקים או להגדיל את הקובץ.
מבחינת גישה סדרתית, זה כמו ברשימה המקושרת- זה תלוי איפה בלוקים יושבים. אם הבלוקים רציפים, אז מעולה, ואם הם אקראיים אז נקבל ביצועים מאוד גרועים.
מבחינת גישה אקראית, זה גם מעולה. אם רוצים למצוא את הבית ה-12 של הקובץ, אין בעיה. מסתכלים על הרשימה ובודקים.
מבחינת metadata-אנחנו מקבלים מקום בכמות המצביעים, זה יחסי לגודל הקובץ.
אחת ההנחות לגבי רוב מערכות הקבצים, זה שרוב ה-files הם קטנים ורק אחוז קטן מהם הם קבצים גדולים.
לכן אם נרצה לעשות אופטימיזציה, לבדוק ביצועים, נעשה זאת עבור קבצים קטנים, כי קבצים גדולים הם פחות נפוצים.

אז אמרנו שבשיטה של indexed allocation – בתוך ה-inode יש לנו set של מצביעים שמצביעים ישירות ל-data.
הבעיה פה היא שהגודל של הקובץ מוגבל. אם אנחנו רוצים להגדיל את הגודל של ה-inode לא
אנחנו לא יכולים לשים בו אינסוף מצביעים. אז יש לנו 2 אפשרויות:
1. הגודל של ה-inode יהיה דינאמי, משנה (שזו בעיה בפני עצמה, כי כך יהיה לנו הרבה יותר
קשה למצוא inode, הרבה יותר קל לעשות זאת כשכל inode הוא בגודל זהה).
2. נקבע מספר כלשהו של מצביעים קבוע, ונגדיר אותו בתור המקסימום מצביעים שיכולים להיות לקובץ. ואז אנחנו מאוד מגבילים את הגודל של הקובץ.
- שתי הגישות הללו בעייתיות לכן יש גישה אחרת במקומן:

Indirect pointers – שימוש במצביעים עקיפים.
לא נשים את ה-data של הקובץ בבלוק 7 למשל. ובבי בלוק כלשהו שהוא כביכול
ה-data. בלוק יחיד יכול להכיל עד 1024 מצביעים. ואז שם נכתוב את כל
הנתונים (במצביעים העקיפים). כעת, אם נשמר יש לנו 3 מצביעים, אז גודל הקובץ המקסימלי * 3 * 4MB . כבר הגענו ל-12kb-מ
-ל-12mb.
- הבעיה בגישה הזו היא שהיא בהחלט לא נותנת גם מבחינת ביצועים וגם מבחינת זיכרון. כל קובץ עכשיו צריך לתפוס בלוק רק עבור המצביעים שלו. אם יש לנו 1000 קבצים, אז 1000 בלוקים הלכו סתם. ואם כל הקבצים שלנו קטנים, אז בכל בלוק כזה נתפוס רק מצביע אחד. זה מאוד בזבזני (4kb עבור מצביע אחד).
בנוסף, שיטה זו בזבזנית מבחינת ביצועים. כל פעם שאנחנו רוצים לקרוא קובץ אנחנו צריכים לקרוא את ה-inode שלו, ואז נצטרך לקרוא את בלוק המצביעים, ורק אז נגיע ל-data. זה 3 קריאות (נוספה לנו קריאה נוספת) מהדיסק, על 2 הקריאות שדיברנו עליהן כבר לפני כן.

---

הגישה שבאמת קיימת – הגישה ההיררכית שמשלבת בין שתי השיטות. נחזיק מצביעים רגילים שמצביעים ישירות ל-data, ואם הם לא מספיקים, בסוף יהיה מצביע מיוחד. אנחנו נדע שהמצביע האחרון הוא מיוחד (מערכת הקבצים תדע).

למשל בדוגמא הזו: לכל inode יש 3 מצביעים רגילים שמצביעים ל-data, אז
בדוגמא הזו הם יכולים להכיל עד 12kb, ואם זה לא מספיק, אז המצביע
האחרון שלו יהיה מצביע עקיף- ואז אנחנו יכולים להגיע לעוד 4MB.
אז הקובץ עכשיו לא יוכל להיות 12mb אלא 4mb + 12 kb, שזה עדיין
יותר גדול ממקודם. זה מאוד יעיל עבור קבצים קטנים ועדיין תומך בקבצים גדולים.

- אבל אם יש לנו קבצים גדולים של ג'יגה, ואז המקום לא מספיק.
מה שנעשה: נוסיף עוד מצביעים עקיפים (עוד רמה בהיררכיה).
מה שמקובל ב-inode כיום: יש לנו בסביבות בין 8-12 מצביעים רגילים וה-3 האחרונים הם מיוחדים.
השלישי מהסוף: מצביע לשלושה בלוקים של data ובלוק אחד של מצביעים עקיפים (שכל אחד מהם מצביע לבלוק של data).
השני מהסוף: מצביע לבלוק שבו יש מצביעים עקיפים, שכל אחד מהם מצביע לבלוק נוסף של מצביעים (double indirect).
הראשון מהסוף: triple indirect – מצביע לבלוק שבו יש מצביעים עקיפים, שכל אחד מהם מצביע לבלוק נוסף של מצביעים עקיפים.
השיטה הזו מאפשרת לנו לייצר קבצים הרבה יותר גדולים.
אם למשל יש לנו 12 מצביעים ישירים, אחד סינגל, אחד דאבל ואחד טריפל:
אז קודם כל ב-inode יש לנו 12 מצביעים רגילים שמצביעים ישירות ל-data (כלומר 12 מצביעים שכל אחד מהם מצביע ישירות לבלוק של 4kb), פה הגודל של הקובץ הוא כבר 48kb.
יש מצביע אחד שהוא single indirect, כלומר, מצביע לבלוק של מצביעים, שם נכנסים 1024 מצביעים (גודל בלוק 4kb וגודל מצביע הוא 4 בתים ולכן יש 1k מצביעים). אז מצביע indirect אחד, מאפשר לנו להוסיף עוד 1024 בלוקים של מידע.
מצביע double indirect- יש לנו מצביע לבלוק של מצביעים, שכל אחד מהם מצביע ל-1024 מצביעים נוספים ל-data.
זה יוצא 1024 * 1024 * 4kb.
בסך הכל נקבל ככה בערך 4GB.

** ניתן לקחת מצביע דאבל ולאחסן רק את התא הראשון שלו. כלומר אנחנו מצפים לזיכרון לפי שימוש.
** המקסימום בבלוק שלנו זה 1023 מצביעים, כלומר אם נפספס בלוק נקבל מצביע אחד.

בהרבה מאוד מערכות קבצים השתמשו בשיטה הזו.
שמות מערכות הקבצים הסטנדרטיות של לינוקס: ext2, ext3.
כיום, מערכת הקבצים הסטנדרטית של לינוקס נקראת ext4, היא משתמשת ב-extents אבל במקום שכל מצביע יהיה לבלוק בודד, כל מצביע יהיה לבלוק ואורך. ואז לקחנו את היתרונות גם מהשיטה הקודמת כלומר, גם קבצים גדולים יוכלו להיכנס כי במצביעים הראשונים יהיה כתוב למשל מבלוק 10 עד 500, כל זה במצביע אחד. ואם נרצה להגדיל את המצביעים בהמשך, וכתוב שמבלוק 500 עד 520 וכו'. כלומר מדובר על set של extents. ואם נגמר לנו המקום, נעבור למצביעים עקיפים לבלוק של extents.
אם בבלוק אחד נכנסים 1024 מצביעים, אז נכנסים 512 extents (כי extent זה מצביע וגודל, שני מספרים במקום 1).
- כלומר, ההקצאה של ה-double, triple וכו' לא מתבצעת מההתחלה. בתור התחלה יהיה לנו 0 בכל מצביע. זה נעשה תוך כדי שימוש.

---

אלו אלה היו ה-inodes שלנו. הקצנו מקום ל-inodes, בכל inode אנחנו שומרים את המצביעים שלנו באחת הצורות שלמדנו.
ככה במערכת הקבצים שאנחנו משתמשים בה.
עכשיו, יש לנו בעיה קטנה נוספת. המשתמש בא ויוצר קובץ חדש, אנחנו צריכים לדעת איזה inode פנוי.
או אם המשתמש בא וכותב לקובץ, איך נדע איזה בלוק פנוי.
דיברנו בעבר על free list שזו רשימה מקושרת של בלוקים פנויים. רשימה מקושרת של בתים נמצאת בשימוש (נחזיק מספר של בלוק פנוי, ובתוך הבלוק הפנוי נחזיק את המספר של הבלוק הפנוי הבא וכן הלאה..), זה נוח ויעיל, אבל הבעיה בשיטת הרשימה המקושרת היא שקשה למצוא שטחים רציפים. אם נרצה למצוא 20 בלוקים ועדיף שיהיו רצופים לשם יעילות, אז free list לא תמיד תעזור.
במערכות קבצים יש מנגנון שנקרא bitmap- נקבה שני בלוקים.
בלוק ראשון לנתונים (i), נכתוב בו אילו inodes פנויים ואילה לא.
בלוק שני ל-data bitmap- (d), כלוק שאומר אותו דבר, רק עבור הבלוקים של ה-data, אילה בלוקים של data פנויים ואילה לא.
הרעיון של bitmap: אם למשל יש לנו 56 בלוקים של data, אז נשמור מספר בינארי בגודל 56, שבו בכל מקום שבלוק תפוס יהיה 1 ובכל מקום שבלוק פנוי יהיה 0.
עכשיו בקריאה אחת נוכל למצוא מקום פנוי לפי הנתונים שלנו.
אם נרצה לתפוס אותה, מחליפים את ערך הביט.
ואתן הדבר עבור inodes, אם יש לנו 16*5 inodes במערכת, נשתמש במספר בינארי, פשוט נקרא את הנתונים מתוך הבלוק של inode bitmap ונכניס את הביטים הראשונים בו כ-inodes.

Super Block - בדרך כלל הבלוק הראשון (לפעמים השני) שמור עבור בלוק שנקרא superblock.
זה בלוק אחד שמכיל נתונים על הכונן שלנו ועל מערכת הקבצים. יהיה כתוב בו אילו מערכת קבצים מישנן כדי לדעת איזה קוד להריץ על הדיסק, יהיה כתוב מה הגודל של הדיסק, כמה data block, inodes יש לו, איפה ה-bitmaps וכו'.
לפעמים לפני הסופרבלוק יהיה בלוק שנקרא boot, כשאנחנו מדליקים את המחשב, מערכת ההפעלה עולה. היא יודעת לעלות בעזרת קריאה של הבלוק הראשון שבו כתוב מה לטעון ואיזה קוד להריץ וכו'.

:Directory Organization
תיקייה היא קובץ רגיל לכל דבר, יש לה inode שבו type-שלה הוא תיקייה וב-data אנחנו שומרים טבלה.
הטבלה מכילה מספר inode, שם של כל רשומה בטבלה. ויש תוספות של עניין מימוש (אורך המחרוזת, גודל רשומה- שורה בטבלה וכו').
ונבון בכמה פעולות ונראה כמה כל גישה לדיסק משפיעה על ביצועי התוכנית שלנו מבלי שנשים לב:
inum | reclen | strlen | Name
5 | 12 | 2 | .
2 | 12 | 3 | ..
12 | 12 | 4 | Foo
13 | 12 | 4 | Bar
24 | 36 | 28 | foobar_is_a_pretty_longname

---

נניח שאנחנו רק רוצים לפתוח את הקובץ /foo/bar. כבר הזכרנו כמה יקרה הפעולה הזו. כשאנחנו רוצים לפתוח קובץ כזה-
• Open file /foo/bar (assume it exists)
• Traverse pathname to locate desired inode
• Begin at root: well-known, usually inode 2
• Read block that contains inode 2
• Look inside it – read data block to find inode number of foo
• Read inode of foo to find data block of foo
• Read data blocks of foo to find inode of bar
• Read inode of bar
• 5 reads just to open a file!

כל זאת רק עבור הפתיחה של הקובץ. לא קריאה אפילו. זה לקח 5 גישות לדיסק.

לפעמים אנחנו חושבים שאם אנחנו כותבים נתונים, אז הפעולת כתיבה היא פעולה אחת על הדיסק, אך זה שגוי:
• Write to /foo/bar (assume it is open)
• Read data bitmap
• Write updated data bitmap (newly-allocated block to use)
• Read the inode of bar
• Write updated inode with new block location
• Write the actual block itself

במערכת הפעלה יש את ה-file descriptor של foo לאחר שפתחנו אותו.
עכשיו לא ניתן לגשת לקובץ ופשוט לכתוב אליו. כי מה אם אין מקום? אז צריך להקצות בלוק של data חדש. אז יש צורך לקרוא את ה-data bitmap מחדש.
שכפי שאמרנו זהו בלוק שאומר אילו בלוקים של data פנויים, וצריך לכתוב אותו מחדש (כלומר למצוא מקום פנוי ולכתוב מחדש כאשר הביטים הרצויים ישונו לתפוסים).
לאחר מכן צריך לקרוא את ה-inode של הקובץ הרצוי לכתיבה, כי אנחנו רוצים לעדכן אותו, ולכתוב את ה-inode המעודכן עם המידע החדש. ורק אחרי כל זה, ניתן לכתוב לכתיבה לבלוק עצמו.
5 גישות לדיסק עבור פעולת כתיבה אחת. וכל זה בהנחה שהקובץ שלנו קטן. אם הקובץ מתפרס למצביעי /indirect
double indirect אז זה עוד פעולות ועוד גישות לדיסק בשביל לקרוא ולכתוב את הנתונים המעודכנים.
את ה-inode תמיד צריך לעדכן. כל פעם שאנחנו ניגשים לקובץ, ב-inode מעודכן זמן הגישה. לדוגמא בקריאה, כל פעולת קריאה שאנחנו מבצעים, חייבת לכלול גם עדכון של זמן הגישה ב-inode.
בכל קובץ במחשב יש זמן למן גישה (מתי הוא נוצר, מתי הוא שונה לאחרונה, מתי הוא נפתח). לכן אפילו פעולת קריאה כוללת לפחות 3 גישות לדיסק (שוב בהנחה שהקבצים קטנים).

• Read /foo/bar
• Read bar inode to find data block
• Read data block
• Write bar inode – update access time

---

יצירת קובץ:
בשביל ליצור קובץ חדש:
• Create file /foo/bar (doesn’t exist)
• Read inode bitmap, write updated bitmap with allocated inode
• Write inode itself for bar
• Find data block of foo
• Read block that contains inode 2 (root)
• Read data block to find inode number of foo
• Read inode of foo to find data block of foo
• Read and write data block of foo to add bar entry to directory
• Directory foo needs to grow? Additional I/O

כל הפעולות הללו רק בשביל ליצור קובץ.

כלומר פעולות מאוד פשוטות גוררות הרבה פעולות i/o על הדיסק. זו הסיבה שגישה לקבצים היא לא סתם איטית בגישה עצמה.
בשביל זה יש לנו כל מיני פתרונות שדיברנו עליהם: להשתמש בזיכרון שלנו בשביל לעשות caching, לזכור בלוקים חשובים, inodes חשובים וכו'. אגירת כתיבות, שמירת הביטמאפ של הדאטה. ועוד.
גם לפעמים אם אנחנו יוצרים קובץ ומוחקים אותו מאוד מהר, הוא בכלל לא נוצר, ואולי לא צריך לעשות כלום, הוא רק עבר בזיכרון ולא הגיע לדיסק בכלל. אז הכל שיקולים של מערכת ההפעלה ומערכת הקבצים.
מערכת הקבצים שראינו היא לא באמת בשימוש, היא לא יעילה מאוד ואיטית, אבל לה הבסיס.
בשיעור הבא נדבר על התמודדות עם קריסות.

