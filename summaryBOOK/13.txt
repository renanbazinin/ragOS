מערכות הפעלה – שיעור 13

בשיעור הקודם דיברנו על שני מנעולים שיש ביניהם פער משמעותי בביצועים, TAS, TTAS.
לכאורה שניהם עושים אותו דבר אבל כשאנחנו בודקים אותם בפועל הם לא עובדים אותו דבר.
דיברנו על ארכיטקטורה של מעבד מרובה ליבות- אמרנו שלכל מעבד יש cache פרטי משלו וכשאנחנו עושים פעולות, אז ראשית המעבד בודק אם יש עותק אצלו ואם לא אז הוא שולח בקשה (שיכולה להגיע מה-RAM שלנו, מהזיכרון המהיר).

ה-cache שיש לנו נקרא write back cache (זו השיטה בה ה-cache עובד)
ודרך פעולתו: אם עכשיו אחד המעבדים משנה ערך בזיכרון שלו, הוא לא צריך לפרסם את זה לכולם בכל שינוי (כי זה יעמיס על ה-BUS שבו יכולה לעבור רק הודעה אחת בכל רגע נתון) הוא שולח הודעת invalidate שנשלחת על ה-BUS ואז כל מעבד אחר שיש לו אולי עותק של X ב-cache הפרטי שלו – מוחק את העותק הנתון.
ברגע שהמעבד הזה שלח את הודעת ה-invalidate, יכול לגשת לאיזור הזה בזיכרון ולשנות אותו כמה שהוא רוצה. הוא יודע שמאז יש לו את העותק היחיד.
במידה ויגיע מישהו בהמשך ויפרסם הודעה על ה-BUS שהוא רוצה לקבל את הערך של הכתובת X אז המעבד שלנו ישמע את ההודעה לפני הזיכרון (כי תמיד המעבדים שלנו קרובים יותר אחד לשני מאשר לזיכרון) והוא ישדר את הערך של X ואז הוא ידע ש-X כבר לא שלו באופן בלעדי (ברגע שמישהו מבקש ערך של כתובת אנחנו מחזירים אותה ויודעים שאנחנו לא יכולים יותר לכתוב אליו).
כל הזמן הזה, העותק של הכתובת X בזיכרון לא חייב להיות מעודכן. איכשהו בהמשך אחד המעבדים יעדכן גם את הזיכרון, אבל זה לא חייב להיות באופן מיידי.
כל עוד זה ב-cache של אחד המעבדים הם יעבירו את הערך ביניהם (אולי אחד לא ניגש לזיכרון שלנו ולכן זה בסדר).

Mystery Explained
time
threads
TAS lock
TTAS lock
Ideal
Better than TAS but still not as good as ideal

ברגע שאנחנו יודעים את העניין הזה, זה מסביר לנו את התופעה המסתורית שקרתה.
מנעול ה-TAS: כל החוטים רצים כל הזמן בלולאה ועושים test and set (כותבים אל אותו המשתנה שייצג את המנעול). test and set זו פעולת כתיבה ולכן כל פעם המעבד הספציפי (ניקח מעבד א') עושה invalidate לכולם ומשנה את הערך ואז למעבד ב' אין בטחון את הערך של המנעול ולכן הוא עושה invalidate לכולם וכן הלאה... ובעצם ה-BUS שלנו מתמלא בהודעות, והוא יכול לטפל רק בהודעה אחת בכל רגע נתון. אז אנחנו יוצרים עיכוב סדרתי. ככל שיש לנו יותר מעבדים (יותר חוטים שמנסים לתפוס אחד במקביל) אז יש יותר ויותר הודעות שמתנייעות/שידור על פני אותן BUS ואנחנו גורמים לעיכוב.
כל גישה למנעול נהיית הרבה יותר איטית, ואם מעבד א' למשל מחזיק את המנעול ורק רוצה לשחרר אותו, אז עכשיו השחרור שלו ייקח זמן, כי הוא רוצה לכתוב למנעול שהוא פנוי, ולשם פעולת הכתיבה הוא צריך לעשות invalidate לכולם ובשביל זה הוא צריך לחכות בתור כי יש עוד הרבה מעבדים במקביל שרוצים לעשות invalidate לכתוב למנעול שהוא תפוס. הכל מעכב לוקח המון זמן וה-BUS סותם אותנו את הביצועים של התוכנית שלנו.

והסיבה שמנעול ה-TTAS עובד:
ברגע שחוט מסוים ראה שהמנעול עדיין תפוס, הוא שומר אצלו בעותק המקומי שמתאר שהמנעול תפוס, והוא עושה spinning על העותק המקומי, כי הוא רק קורא (הוא לא כותב כל פעם ועושה פעולת test and set), אלא רץ בלולאה כלשהי שקוראת את מצב המנעול ומחכה שהוא יהיה פנוי. אז כל חוט טוען את ערך המנעול אליו למחסן, רואה שהמנעול תפוס ועושה spinning על העותק המקומי, וב-BUS לא עוברות הודעות.
הבעיה נוצרת ברגע שחוט מספר 1 משחרר את המנעול, כלומר כותב אליו 0, כי אז הוא עושה invalidate לכולם, וכל חוט שמקבל invalidate ומנסה לקרוא שוב את המנעול, אין לו את זה במחסן ולכן הוא משדר הודעה ב-BUS כדי לקבל את הערך החדש, ואז הוא משדר הודעה ב-BUS כי הוא רוצה לכתוב למנעול 1 (מנסה לתפוס את המנעול), וכן הלאה כך עבור כל חוט.
כך נוצר לנו תור של שיירה שקט- ברגע שמשחררים את המנעול, כל חוט עושה invalidate בתורו, עד שכל החוטים עשו זאת ונחזור למצב השקט בו כולם עושים spinning על עותק מקומי.
** אז זה יותר טוב ממנעול ה-TAS, אבל עדיין יש פער משמעותי מהביצועים האידיאליים.
-----------------------------------------------------------
איך בכל זאת נוכל לכתוב מנעול שעובד טוב גם אחרי הוספת מעבדים?
נציג שלושה פתרונות:
1. נסיון דחוי – backoff – אם הבעיה קורית כשכל החוטים באים בבת אחת ומנסים לתפוס את המנעול. עושים invalidate ויהיה תור, נחכה קצת. ברגע שחוט רואה שהמנעול פנוי ומנסה לתפוס אותו ע"י test and set ונכשל, זה אומר שכנראה יש הרבה תחרות כרגע על המנעול (ראינו שהוא פנוי ובפקודה הבאה ניסיון תפיסה אותו ונכשלנו, אז מישהו הצליח לתפוס אותו לפנינו). אז במקום לחזור ולנסות לתפוס אותו שוב מיד, נחכה קצת.
זה נקרא backoff. אז נעשה דיליי ונחכה קצת זמן לפני שאנחנו מנסים לתפוס שוב את המנעול.
הרעיון הוא לקחת את מנעול ה- TTAS ולהוסיף לו Exponential Backoff.
שתי השורות הראשונות הן כמו ה- TTAS כולל הלולאה החיצונית.
אנחנו מחכים כל עוד המנעול תפוס. ברגע שהמנעול נראה פנוי (קראנו שהוא פנוי) אנחנו יוצאים מהלולאה ומנסים לתפוס אותו ע"י test and set, במידה ולא הצלחנו, אנחנו לא חוזרים מיד ללולאה אלא קוראים ל-sleep כלומר שולחים את החוט ללישון (לזמן אקראי כלשהו) וגם מכפילים את הדיליי לפעם הבאה (כל פעם מכפילים ב-2).
כך נמנע את התחרות ולא כולם יקפצו על המנעול בבת אחת.

Exponential Backoff Lock
void lock()
{
  int delay = MIN_DELAY;
  while (1) {
    while (state) {}
    if (!getAndSet(state, true))
      return;
    sleep(random() % delay);
    if (delay < MAX_DELAY)
      delay = 2 * delay;
  }
}
Back off for random duration
Double max delay, within reason

אל הפתרון הזה עובד הרבה יותר טוב, יחסית שמרנו את העקומה אבל עדיין המגמה היא כלפי מעלה, אז זה לא המצב האידיאלי עדיין.
העיקרון העיקרי של מנעול ה- TTAS עם backoff הוא שכל חוט משלו ולא תופס כמעט זיכרון. הוא הרבה יותר טוב ממנעול ה-TTAS.
החיסרון העיקרי הוא בחירת הפרמטרים שלו – בחירת הדיליי, ומה הדיליי המקסימלי.
ברגע שכיוונו את המנעול למחשב מסוים זה לא מתאים למחשב אחר וצריכים לבדוק כל פעם מחדש מה הערכים שיהיו הכי טובים.

time
threads
TTAS Lock
Backoff lock

2. מנעול שמנסה לפתור את הבעיה בדרך מכוון אחר:
מנעול ה- backoff מטפל במקרה בו ברגע שמשחררים את המנעול- כולם באים בבת אחת ועושים invalidate.
יש סוג של מנעולים שנקראים "מנעולי תור" שבאים לטפל במקור הבעיה, כלומר למנוע את הסיבה שבגללה כולם באים בבת אחת ל-BUS. במקום שהמנעול שלנו יהיה משתנה אחד, נדאג שהמנעול יהיה כמה משתנים, ואז לכל חוט יהיה ערך משלו ונעשה invalidate. בצורה הזו נמנע מראש את הלינקי הזה על ה-cache.
נראה שני מנעולים כאלה:
מנעול אנדרסון – ANDERSON QUEUE LOCK:
המנעול עובד ע"י מערך של דגלים (שמייצג תור), במערך זה כל תא הוא true/false והתאים מייצגים את חוט שהראשון הוא true וכל שאר התאים הם false.
חוץ מהמערך, אנחנו מחזיקים מצביע (מספר) next – התא הנוכחי במערך (אנחנו יכולים להיות תא 0 במערך).
המטרה שלנו זה למנוע מהחוטים לעשות invalidate בבת אחת.
עכשיו כשאחד בא לתפוס את המנעול, זה דומה ל-tickets שנדענו: חוט בא לוקח מספר (שהוא תא במערך, אז הוא מקדם בצעד 1 את המערך).
נניח ויש לנו חוט ורוד שרוצה לתפוס את המנעול, הוא ניגש למשתנה next ומשנה לו ערך (עושה fetch_and_add באופן אטומי). אם היה במשתנה next את הערך 0 אז מיד יהיה כתוב 1 והפעולה מחזירה לנו מה היה בתוכו קודם.
אז החוט הוורוד קידם את next להיות 1 וקיבל חזרה את תא מספר 0.
לאחר מכן הוא בודק האם מותר לו להיכנס לקטע הקריטי (האם המנעול שלו, האם כתוב true) ואכן כתוב true בתוך שהוא קיבל ולכן כרגע המנעול אצלו והוא יכול להיכנס לקטע הקריטי.
אם מגיע חוט נוסף, נניח חוט אדום שגם רוצה לתפוס את המנעול- הוא עושה את אותן התהליך – ניגש למשתנה next, עושה fetch_and_add, משנה ל-spinning על התא שהוא קיבל.
בתא הזה כתוב false אז הוא לא קיבל את המנעול ולכן הוא עושה spinning ומחכה למנעול.
כשהחוט הוורוד סיים עם המנעול ורוצה לשחרר אותו, הוא ניגש לתא הבא במערך ומודיע לבא בתור שהגיע תורו.
(זה לא מופיע בשקפים אבל הוא גם כותב לתא שלו false וכותב לתא הבא true).
עכשיו החוט האדום שעושה spinning על התא הזה יראה שכתוב לו true והוא ידע שהמנעול שלו.
אבל זה ישפיע רק עליו. אם יבוא עוד חוט, הוא יעדכן את next והוא יסתכל על התא הבא. כל חוט מסתכל על תא מסוים, ולכן ברגע שאנחנו מעדכנים תא במערך, רק חוט אחד יקבל invalidate, כל השאר ממשיכים לעשות spinning על העותק המקומי שקיים במחסן והוא לא משתנה ולכן הם לא יקבלו invalidate.
רק כאשר אנחנו משחררים את המנעול אנחנו גורמים ל-invalidate.
זה ציקלו, קיבלנו מעין תור. גודל המערך צריך להיות כמספר החוטים המקסימלי שאנחנו מתכוונים להחזיק במערכת.

TTAS
Shorter handover than backoff
queue
Curve is practically flat
Scalable performance

ביצועים: הקו דיי שטוח. יש איזושהי קפיצה בהתחלה אבל הרעיון אידיאלי.
שיפרנו את הביצועים, אין לנו בעיה כעת ואנחנו יכולים להוסיף עוד ועוד חוטים ולא נפגע בביצועים של התוכנית שלנו. הגענו למנעול דיי טוב.
הבעיה במנעול הזה: אם יש לנו 100 חוטים במערכת אנחנו צריכים מערך של 100 תאים. אלו 100 תאים שלא כל אחד מהם לוקח ביט/בייט אלא הוא צריך להיות גדול כי כל ערך ב-cache הוא גדול (בערך 128 בתים). אז אנחנו צריכים מערך מאוד גדול, וכל המערך הזה הוא זיכרון משותף, ואנחנו רוצים להימנע מהימנעות ככל הניתן כי זה מביא לביצועים פחות טובים (כל פעם שניגשים לזיכרון משותף, אנחנו שולחים הודעות ב-BUS, אמנם לא המון אבל עדיין, וזה רק עבור מנעול אחד. אם יש לנו 100 חוטים במערכת ואולי יש 100 מנעולים וכבר יש 10,000 שורות cache שכל אחת מהן היא 128 בתים וזה המון זיכרון.

CLH LOCK: מנעול אחר שעושה את אותו הרעיון כמו אנדרסון אבל בלי הדרישה למערך.
כל חוט שמגיע מקבל תא, והחוט שלפניו יודיע לו כשהגיע תורו.
יתרון נוסף במנעול אנדרסון וגם CLH נותנים לנו: הוגנות (FCFS- first come first served).
כשהחוטים מנסים לתפוס את המנעול, הם יתפסו אותו לפי הסדר. זה לא היה לנו במנעולים המקוריים (TAS,TTAS,BACKOFF).

אז CLH עושה אותו הדבר כמו מנעול אנדרסון, אבל עם גודל קבוע של זיכרון.
הרעיון: נתפוס זיכרון ככמות החוטים שבאמת מנסים לתפוס את המנעול.
אם 100 חוטים באמת מנסים לתפוס את המנעול, אז נתפוס 100 תאים, אבל אם רק 2 חוטים, אז רק 2. זה יהיה דינאמי כמספר החוטים. הוא עושה זאת באמצעות משהו שדומה לרשימה מקושרת.
יש לנו משתנה tail (שהוא באמת מצביע ולא מספר), שמצביע לערך בוליאני שהקטינו דינאמית ובתורו בן false, זה אומר שהמנעול פנוי. (דגש: ב-CLH כתוב false זה אומר שהמנעול פנוי ובאנדרסון המנעול פנוי כאשר כתוב true).

עכשיו כשחוט בא ורוצה לתפוס את המנעול, הוא מקצה לעצמו בוליאני חדש וכותב בו true (שהמנעול תפוס).
ברגע שהוא הגדיר איבר חדש (כרגע זה מקומי אצלו ואף אחד לא מכיר את האיבר הזה),
אבל עכשיו החוט הוורוד ייגש למנעול וייקח את הערך שיושב שם ע"י פעולת swap – מחליפים בין מה שהמנעול מצביע עליו לבין מה שהחוט הוורוד מצביע עליו.
ברגע שעשינו את פעולת ה-test_and_set, זה מה שיקרה.
עכשיו כשיש את זה, צריך רק לזכור שהחוט הוורוד אומנם עשה swap, אבל הוא מודע לאיבר הזה שהוא הקצה (זה משנה שיושב בדף). עכשיו הוא עושה spinning על הערך שהוא קיבל. כתוב שם false כלומר הוא יכול להיכנס לקטע הקריטי ולהחזיק בו.
כשחוט חדש יבוא וירצה לתפוס את המנעול, הוא מקצה לעצמו איבר שכתוב בו true, עושה swap עם מה ש-tail מצביע אליו, ועושה spinning על הערך שהוא קיבל (וכל אחד עדיין זוכר את האיבר שהוא הקצה).
נוצרה לנו מעין רשימה מקושרת. זו לא רשימה אמיתית, אבל זו כן רשימה של חוטים שמתניינים, כאשר בראש הרשימה נמצא החוט שכרגע בקטע הקריטי ובזנב שלה נמצא האיבר האחרון שהתווסף.
האיבר הראשון הוא false וכל איבר שהתווסף אחר מכן הוא true.
ברגע שהחוט שנמצא בראש הרשימה סיים ויצא מהקטע הקריטי, אז הוא כותב לאיבר שהחוט הבא עושה עליו spinning (הוא יודע מי הבא בתור).

עכשיו מה שיש לנו לגבי המנעול:
כל מה שהמנעול תופס זה את המצביע של הזנב ואת האיבר היחיד הזה.
כל חוט שמגיע גורם להוספה של עוד איבר אחד בלבד למנעול הנוכחי שהוא מחכה לו.
המנעולים שדנו עכשיו תופסים הרבה פחות זיכרון.
אם נגדיר ל-L זה מספר המנעולים שיש לנו בקוד ו-N זה מספר החוטים שיש בקוד, אז:
במנעול אנדרסון כל הזיכרון שהיינו תופסים זה N*L (אם יש לנו 100 חוטים, כל מנעול צריך לתפוס 100 תאים, כלומר כל מנעול יחזיק מערך בגודל 100).
מנעול ה-CLA תופס: N + L (יש את הזנב שמצביע לאיבר שלו וכל חוט שמגיע מוסיף עוד איבר, לכן זו כמות החוטים + כמות המנעולים).

מנעול ה- CLA שיפר לנו את רוב הבעיות של מנעול אנדרסון, מנגנון התור מאוד ידידותי ל-cache, הוא קצת יותר מורכב למימוש אבל סך הכל בסדר. הבעיה העיקרית של מנעול זה – NUMA. לא נדבר עליה.
אילו בעיות עדיין נשארו לנו?
בעיה אחת מהותית שעדיין נשארה לנו היא abortable locks- מנעולים שאני רוצה להפסיק לחכות להם.
לדוגמא במנעול של לינוקס אנחנו יכולים לנסות לעשות pthread mutex trylock לנסות לתפוס את המנעול פעם אחת ולחזור) או time lock (לנסות לתפוס את המנעול למשך שנייה ואם לא הצלחנו אז לוותר).
מנעולים כאלה הם חשובים לפעמים, כתלות במערכת שלנו.
בעצם אנחנו ממתינים למנעול ובאמצע ה-spinning החלטנו שאנחנו רוצים לוותר.
בכל המנעולים: אם נמאס לנו לחכות אנחנו יכולים פשוט לחזור מבלי בעיה, ולא צריכים לדאוג לשום דבר.
אבל במנעולי התור שלנו זו בעיה, אנחנו לא יכולים סתם כך לצאת, כי אם חוט שממתין במנעול אנדרסון פשוט יחליט שהוא יוצא ומסיים, אז החוט הבא בתור אף פעם לא יקבל את תורו. כלומר יגיע התור של החוט שהחליט לוותר אבל הוא לא קיים ולא לוקח את התור שלו ואף פעם לא מעביר את התור לבא בתור אחריו, ואנחנו צריכים למצוא דרך יותר טובה לצאת מהמנעול.
זו הבעיה העיקרית שנשארה לנו במנעולי התור.
אנחנו לא נפתור את הבעיה הזו.

איזה מנעול נבחר בסופו של דבר?
זה תלוי בשימוש. יש שימוש לכל סוג מנעול, זה תלוי מה אנחנו רוצים בתוכנה שלנו.
אם בתוכנה שלנו אין הרבה חוטים שמנסים לתפוס את המנעול שלנו כלומר יש לנו קטע קוד שמדי פעם נקרא ע"י חוט ומכיל קטע קריטי מאוד קצר – אין סיבה להשתמש ב- CLA או באנדרסון, זה לא ייתן שיפור בביצועים אלו עלול לפגוע בהם אפילו. עדיף להשתמש כבר במנעול BACKOFF .
לעומת זאת, אם יש לנו הרבה תחרות, מנעול שהרבה וישנים אליו בו זמנית, הרבה spinning והמון מעבדים ובעיות ביצועים על ה-BUS , נשתמש במנעול CLA.
אם יש לנו תוכנה שאנחנו צריכים להפסיק להמתין למנעול אז נשתמש ב- abortable lock .
המנעול שלינוקס מספקת לנו (linux pthread mutex) מנסה להיות הטוב מכל העולמות, אבל הוא לא יהיה הכי טוב אף פעם.

נושא חדש: אובייקטי סנכרון
מנעול הוא בעצם סוג אחד של אובייקט סנכרון. דיברנו על בעיית סנכרון (עם הכבישים והנתיבים והרמזורים) והרמזור ששמנו בכביש הוא המנעול – הוא בעצם אובייקט סנכרון שיש לו פקודות lock, unlock שמספקות לנו מניעה הדדית (בכל רגע נתון, רק חוט אחד נמצא בקטע הקריטי).
זה לא אובייקט הסנכרון היחידי, הוא פותר לנו בעיה מאוד ספציפית (שיש לנו קטע קוד שאנחנו רוצים להריץ ע"י חוט יחיד) אבל יש עוד הרבה בעיות שלא קשורות, יש אובייקטי סנכרון אחרים ומענייני סנכרון אחרים שניתן להשתמש בהם.
לדוגמא: מה קורה אם אנחנו מוכנים שיהיו 2 חוטים בקטע הקריטי?
או מה קורה אם יש לנו מספר שאנחנו פשוט רוצים להגדיל אותו ב-1? אפשר לפתור אותן עם מנעול אבל זה לא יהיה יעיל.
אז אנחנו נראה מנגנונים נוספים מלבד למנעול.

הגדרת אובייקט סנכרון: מגדירים את ה-API שלו: אילו פעולות הוא יכול לבצע.
מצד שני, אנחנו כותבים את המימוש. העניין כאן הוא שהמימוש שלנו חייב להיות נכון ובטוח, וצריך לספק סט של תכונות שאנחנו מבטיחים למי שמשתמש באובייקט שלנו. כמו שמנעול סיפק מניעה הדדית והוגנות ו-deadlock freedom, אז אותן דבר- לכל אובייקט סנכרון יהיו פעולות משלו שהוא צריך לספק.
החלק החשוב- אנחנו לא יכולים להניח כלום על אופן השימוש של המשתמש. כלומר אנחנו לא יכולים למשל להניח שרק שני חוטים יבצעו את הקריאה וכו'. אנחנו רק יכולים להניח שמשתמשים באובייקט בצורה הנכונה למשל אם צריכים לאתחל אותו לפני השימוש אז שיאתחלו אותו).

אובייקט הסנכרון הראשון שנראה היום: Reader-Writer Lock
מנעול קוראים כותבים. לפעמים יש לנו מבנה נתונים/משתנה משותף שאנחנו כן רוצים למעלה חוטים במקביל לגשת אליו, למשל אם החוטים הללו רק רוצים לבצע פעולות קריאה על המשאב ולא לשנותו.
הרעיון של אובייקט הסנכרון הזה: יש לנו משאב, ואם חוט רק רוצה לבצע פעולת קריאה, אנחנו לא רוצים שהוא יחסום חוטים אחרים. אבל אם חוט מבצע פעולת כתיבה והולך לשנות משהו, נחסום את כולם, והחוט הזה יהיה בקטע הקריטי לבד.
באופן הזה אם יש כמה חוטים שרק רוצים לקרוא, אז יתאפשר לכמה חוטים להיות בקטע הקריטי יחד.
זה סוג של מנעול שיש לו עכשיו 4 פעולות:
במקום נעילה ושחרור, יש עכשיו נעילה ושחרור לקריאה ונעילה ושחרור לכתיבה.
כל חוט שרוצה לבצע פעולה, צריך לקרוא לפעולה המתאימה.
דוגמא:
יש לנו חוטים A,B,C שרצים ומבצעים קטע קוד שלא דורש סנכרון.
חוט A מגיע והוא רק רוצה לקרוא את המשאב המשותף אז הוא קורא ל-()read_lock, כלומר נועל את המנעול לקריאה בלבד. המנעול לא אצל אף אחד ולכן הוא ייתפס אותו ויקבל הרשאות קריאה ויוכל להתקדם להיכנס לקטע הקריטי.
מגיע חוט B ורוצה לכתוב ולעשות משהו שמשנה את המשאב המשותף באיזושהי צורה, לכן הוא קורא ל-()write_lock ועכשיו הוא נחסם. הוא לא יכול לבצע פעולת כתיבה במקביל לחוט אחר. יש לנו את חוט A שנמצא כרגע בקטע הקריטי.
חוט C רוצה לבצע פעולת קריאה בלבד, אז הוא עושה ()read_lock ומצליח לתפוס את המנעול.
בנקודה הזו אנחנו שונים ממנעול רגיל. המנעול אמנם תפוס אבל הוא תפוס ע"י חוט שרק מבצע פעולות קריאה, לכן C מקבל גישה. כעת חוטים A,C נמצאים בקטע הקריטי במקביל. כאשר כל חוט מסיים, הוא קורא ל-()read_unlock ובנקודה הזו המנעול לא יפול, ועכשיו B כבר יכול להתקדם ולהיכנס לקטע הקריטי.
עכשיו אם חוט A רוצה עוד פעם לבצע פעולת קריאה ולתפוס את המנעול, אז הוא נחסם כי כרגע B נמצא בקטע הקריטי בפעולת כתיבה, אל חוט A נחסם עד ש-B משחרר את המנעול.

הרעיון: יש לנו משאב והרעיון של המנעול: נשים מחסום לכל המשאב, זה יהיה המנעול שלנו. המחסום יכול להיות סגור/פתוח.
כאשר מנעול פנוי- המחסום פתוח. כאשר חוט רוצה לגשת למשאב, הוא נכנס וסוגר את המחסום, אם המחסום סגור אל חוט לא יתנו לו לעד שהמחסום ייפתח ורק אז הוא נכנס.
אם חוט מסוים רוצה לבצע פעולת כתיבה, הוא ניגש ומחכה למחסום כרגיל. אם המחסום פתוח, הוא סוגר אותו ונכנס לקטע הקריטי, ואז הוא סוגר אותו אל הוא מחכה עד שהוא יהיה פתוח ואז כשהוא נפתח הוא נכנס וסוגר לקטע הקריטי.
בעצם החוט הכותב שלנו מתנהג עם המחסום הזה בדיוק כמו עם מנעול רגיל.
ההבדל יהיה בקוראים- כאשר חוט קורא רוצה להיכנס לקטע הקריטי, נפריד לשני מצבים:
- אם המחסום פתוח, אז אין בעיה, הוא יכול להיכנס לקטע הקריטי ולסגור את המחסום בדיוק כמו מנעול רגיל.
- אם המחסום סגור, החוט הקורא לא יחסם בהכרח. במקרה זה, החוט הקורא בודק:
- אם החוט שנמצא כרגע בקטע הקריטי מבצע פעולת כתיבה, אז החוט הקורא ימתין שהוא יסיים ורק אז ייכנס.
- אם החוט שנמצא כרגע בקטע הקריטי מבצע פעולת קריאה, אז החוט הקורא ייכנס גם הוא.
כאשר חוט כותב יוצא מהקטע הקריטי, הוא פותח את המחסום.
כאשר חוט קורא יוצא מהקטע הקריטי, הוא לא יכול לפתוח כך סתם. הוא צריך לבדוק: אם יש עוד חוטים קוראים בקטע הקריטי ואם כן הוא לא יבצע כלום. החוט האחרון שיסיים, יראה שאין אף אחד אחר שלא משתמש במשאב, לכן הוא יבצע פתיחה של המחסום.

מימוש אובייקט הסנכרון הזה:
עבור חוטים כותבים: המימוש יתייחס למשאב שלנו כאילו מנעול רגיל.
בקוראים: הקורא הראשון שמגיע, סוגר את המחסום. הקורא האחרון, משחרר את המחסום.
הקוראים שלנו מתייחסים לאותו מנעול, אבל הם לא תמיד סוגרים ומשחררים אותו.
בשביל לממש מנעול Reader-Writer Lock אנחנו נשתמש בשני מנעולים:
1. מנעול ה-read lock.
2. מנעול ה-write lock.
בנוסף, יהיה לנו משתנה שנקרא num_reader שיספק לנו מידע על כמות החוטים הקוראים שנמצאים בקטע הקריטי.

מימוש צד הכותב:
כמו מנעול רגיל

void acquire_writelock() {
  lock(&writelock);
}
void release_writelock() {
  unlock(&writelock);
}
מימוש צד הקורא:
מימוש ולוגיקה קצת שונה.
החוט מקדם את מספר הקוראים. ואז מתבצעת בדיקה- האם אני החוט הראשון. במידה וכן, אני סוגר את המחסום (תופס את המנעול).
כל קורא שיבוא אחריו יקדם את מספר הקוראים אבל הוא לא הראשון ולכן הוא לא יסגור את המנעול. כלומר כל קורא שאינו הראשון, ייכנס ישר לקטע הקריטי.
ביציאה מהקטע הקריטי, אנו מורידים את מספר הקוראים ב-1 ובודקים האם אני הקורא האחרון, אם כן אני משחרר את המנעול.
מנעול ה-write_lock נועד כדי להגן על המשתנה num_readers כי אם יבואו כמה חוטים במקביל וינסו לשנות, זה יכול ליצור בעיות.

void acquire_readlock() {
  lock(&readlock);
  if (++numReaders == 1)
    lock(&writelock);
  unlock(&readlock);
}
void release_readlock() {
  lock(&readlock);
  if (--numReaders == 0)
    unlock(&writelock);
  unlock(&readlock);
}

חסרונות ה-Reader-Writer lock:
אובייקט הסנכרון הזה עלול ליצור הרעבה- כל להרעיב את הכותב.
אם עכשיו מגיעים הרבה קוראים ויוצאים ונכנסים קוראים ללא הפסקה, אז הכותב מורעב.
כיצד נמנע הרעבה במקרה כזה?
1. מימוש הפוך- הכותב ירעיב את הקוראים (גם לא אידיאלי).
2. שימוש במנעול הוגן אבל אנחנו נתקלנו בבעייתיות, רק כדי להשלים סדר.
למשל אם היינו מפצלים את החוטים לקבוצות, נפצל את הגישה למשאב לקבוצות, לא נכנס קוראים חופשי.
נוכל להגדיר שכל אחד מחכה למי שלפניו אם הוא שווה ממנו.
אפשר להשתמש בפתרון בסגנון ticket lock וכו'.
-------------------------------------------------------------
אובייקט סנכרון הבא: CONDITION VARIABLE
אובייקט סנכרון נוסף שהמטרה שלו היא להודיע הודעות.
בעזרתו, חוט אחד יכול להודיע הודעה לחוט אחר, או להמתין שיודיעו לו.
ראינו דוגמא לכך עם join- חוט מסוים יכול להמתין שחוט אחר יסיים.
אנחנו מגדירים אירוע (תנאי) וברגע שנוצר אירוע קורה (שנקרא condition variable),
אובייקט הסנכרון הזה נותן לנו 3 פעולות שחוט יכול לבצע:
1. פעולת WAIT- ברגע שחוט מסוים קורא לפעולת wait, הוא הולך לישון. הוא חסום עד שיודיעו לו את ההודעה שהוא ממתין לה (ה-condition variable).
2. Signal - מעיר חוט אחד. ברגע שאנחנו עושים signal, מערכת ההפעלה בוחרת חוט אחד שמחכה ומעירה אותו.
3. Broadcast – מערכת ההפעלה מעירה את כל החוטים שמחכים.

דוגמא:
יש לנו חוט B שמבצע פעולה. חוט A רוצה להתקדם אבל הוא רוצה להתקדם רק אחרי שהפעולה של חוט B בוצעה.
אז חוט A יכול לקרוא ל-wait על האובייקט cv1 שהוא ה-condition variable.
חוט A קורא ל-wait וממתין. ברגע שחוט B סיים הוא קורא ל-signal שמעירה את החוט A.

Thread A (Blocked)
...
wait(&cv1,...);
// after signal

Thread B
...
mmmBop();
signal(&cv1);

(חוט B רץ ומבצע את הפעולה שלו, וברגע שהוא מסיים הוא קורא ל-signal על cv1 של חוט A-לשם עליו ללכת הוא שולח הודעה למישהו שממתין ובגלל שרק חוט A ממתין כרגע אז זה בהכרח אליו. ברגע ש-A מקבל את ההודעה הוא לא חסום יותר, והוא ממשיך לשורה הבאה).
כשעשינו wait יש 3 נקודות בקריאה, והסיבה היא שהקריאה ל-wait מקבלת תמיד מנעול. כאשר אנחנו משתמשים להודעה, מעבירים את ה-cv שלנו ומנעול כלשהו שאנחנו מחזיקים עליו.
בפועל, wait משחררת את המנעול שאנחנו מחזיקים ורק אז מחכה ל-signal.
לאחר שחוט התעורר, מערכת ההפעלה מנסה לתפוס את המנעול מחדש ורק לאחר שהצלחנו ממשיכה לשורה הבאה.
כשאנחנו קוראים ל-wait ומחכים למסר, אנחנו משחררים מנעול והולכים לישון (זה אטומי, בו זמנית).
ברגע שהשינוי מתקיים, החוט שלנו מתעורר, תופס את המנעול מחדש ורק אז ממשיך.

Wait call takes a mutex as parameter
lock(&m1);
wait(&cv1, &m1);
unlock(&m1);

-> Atomic:
unlock(&m1);
wait_for_signal(&cv1);
// after waking up:
lock(&m1);

דוגמא נוספת:
נניח ויש לנו שני חוטים- חוט A וחוט C. שניהם קוראים ל-wait. כל אחד מהם מחזיק את המנעול בקריאה ל-wait.
חוט B כרגע בקטע הקריטי.
אל חוט A רץ והוא קורא ל-wait והוא חסום. בנקודה הזו, הוא שחרר את המנעול וכרגע חוט A חסום עד שישלחו לו signal. במקביל חוט C רץ, ותופס את המנעול, קורא ל-wait, שחרר את המנעול.
כרגע אף אחד לא מחזיק את המנעול ושני החוטים ממתינים למסר.
כאשר חוט B סיים, הוא שולח signal לחוט שרירותי מבין החוטים שמחכים (מערכת ההפעלה בוחרת לאחד, ואחד מבין החוטים מתעורר. אם היינו רוצים להעיר את כולם, היינו משתמשים ב-Broadcast.

lost signal - נניח וחוט A רוצה לתפוס את המנעול ולקרוא ל-wait, הוא מחכה לחוט B שיבצע את הפעולה שלו לפני שחוט A מבצע את שלו. אל חוט A תופס את המנעול וממתין. אבל יש מה שנקרא lost signal - ייתכן וחוט B יסיים לפני שחוט A יבצע את הפעולה שלו ואז יקרא ל-signal. ה-signal הזה לא נשמר בשום מקום, מערכת ההפעלה בודקת מי ממתין ומעירה, ואם אף אחד לא ממתין אז הסיגנל נזרק. זה נקרא lost signal.

Thread A (Blocked)
lock(&m1);
// wait for mmmBop
wait(&cv1, &m1);
baDuBop();
unlock(&m1);

Thread B
...
mmmBop();
signal(&cv1);
Lost signal

בצורה הזו, חוט A ממתין לסיגנל שלעולם לא יגיע.
כיצד נפתור זאת?
נוסיף משתנה בוליאני done. כאשר חוט B יסיים את הפעולה שלו, הוא ישנה משתנה done שייצג שהפעולה שלו הסתיימה, וישלח את הסיגנל.
ואז חוט A יבדוק קודם את המשתנה. אם done=1 אז הוא לא צריך להמתין בכלל כי חוט B סיים.
אבל אם done=0 אז אנחנו נרוץ.
ואז חוט A תופס את המנעול ובודק את חוט B עוד לא סיים, אז הוא קורא ל-wait ומחכה עד שישלחו לו signal.
גם במקרה הזה יש לנו בעיה- אם חוט A מתחיל לפני חוט B והוא נקטע באמצע.
בצורה הזו, כאשר חוט A יבוא לבדוק אם done=1, הוא יראה שחוט B לא סיים ולכן הוא עומד לקרוא ל-wait.
כש-B ירוץ, הוא יבצע את הפעולה וישלח את הסיגנל אבל שוב הסיגנל אובד כי אף אחד לא ממתין לו.

Thread A (Blocked)
lock(&m1);
// wait for mmmBop
if (!done)
  wait(&cv1, &m1);
baDuBop();
unlock(&m1);

Thread B
mmmBop();
done = 1;
signal(&cv1);
Lost signal

הפתרון לכך הוא שימוש במנעול גם בצד השני. גם חוט A יתפוס את המנעול ויחכה אם done=0 וגם חוט B יתפוס את המנעול ויסמן את ה-done. עכשיו הם לא יכולים להתערבב.

Thread A
lock(&m1);
// wait for mmmBop
if (!done)
  wait(&cv1, &m1);
baDuBop();
unlock(&m1);

Thread B
lock(&m1);
mmmBop();
done = 1;
signal(&cv1);
unlock(&m1);

