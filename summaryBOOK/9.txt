מערכות הפעלה - שיעור 9

נכון / לא נכון:

1. טענה: במקרים מסוימים, תהליכי משתמש יכולים לבטל פסיקות.
הטענה לא נכונה. פסיקות קורות ב-kernel mode. תהליכי משתמש לא יכולים להשפיע על פסיקות, הם יכולים אולי לקבל איזושהי הודעה בעקבות פסיקה, אבל לא יכולים להשפיע על פסיקה ובטח שלא לבטל אותה.
לעומת זאת, ב-signals (סיגנלים) תהליכי משתמש כן יכולים להתערב (סיגנלים נקראים פסיקות תוכנה אבל הם לא פסיקות). רק מערכת ההפעלה יכולה לבטל פסיקות.

2. טענה: אלגוריתם התזמון SRTF פותר את בעיית ההרעבה של תהליכים.
הטענה לא נכונה. אלגוריתם SRTF מריץ את התהליך שנשאר לו הכי מעט זמן.
אם יש לנו תהליך A ארוך שלוקח 60 שניות ותהליך B שלוקח 10 שניות הגיע בזמן 0 אז תהליך B ינוזמן לפני A, ונניח שרגע לפני הסיום של תהליך B הגיע תהליך נוסף C שגם הוא אורך 10 שניות, אז הוא ינוזמן לפני A וכן הלאה... A עלול להיות מורעב להרבה מאוד זמן, או לנצח.
כלומר אם כל הזמן מגיעים תהליכים קצרים, תהליכים ארוכים עלולים להיות מורעבים.
- אלגוריתמים שכן פותרים את בעיית ההרעבה: MLFQ , RR.

3. טענה: בדפדוף יש בעיה של קיטוע חיצוני (external fragmentation).
הטענה לא נכונה. קיטוע חיצוני קורה כאשר יש לנו שטח מסוים של זיכרון שאנחנו מנהלים וכל מיני קטעים בו תפוסים בצורה כזו שנשאר לנו זיכרון פנוי אבל לא מספיק, למשל עבור הקצאה גדולה שרוצה הרבה זיכרון אבל אנחנו לא יכולים לספק אותה למרות שסך כל הזיכרון כן מספיק, זה קורה בגלל שהזיכרון הפנוי שלנו קטוע ומחולק לכל מיני מקטעים קטנים כך שיש לנו הרבה זיכרון פנוי אבל כל חלק הוא קטן מדי.

בדפדוף קיימת בעיה אחרת בהקשר הזה:
internal fragmentation (קיטוע פנימי) - כשמשהו מקבל כמות כלשהי של זיכרון, אבל משתמש בפועל רק בחלק ממנה. למשל אם גודל כל דף הוא 4KB ואנו נצרוך רק 100B אז 3900+ בתים מבוזבזים.

4. טענה: אלגוריתם השעון בוחר לפנות את הדף הכי ותיק.
הטענה לא נכונה. Lru בוחר לפנות את הדף הכי ותיק, זה בדיוק הרעיון שלו (בהגדרה שלו).
אלגוריתם השעון לא עושה את זה.
נראה דוגמא: נניח שיש לנו מחסן בגודל 3 שמכיל את A,B,C (השעון שלנו כרגע מצביע על C).
ונניח שניגשו ל-B ואז ל-C. ה-used bit של B משתנה כרגע ל-1 וכן גם של A ושל C.
את הדף שניגשו אליו הכי רחוק בעבר זה B. כלומר B הכי ישן.
כעת כשהאלגוריתם השעון יצטרך לפנות דף כלשהו: הוא יגיע ל-A, יכבה את ה-used bit שלו, ויעלה ל-B יכבה אותה גם ואז ל-C יכבה אותה ואז הוא יחזור ויפנה את A (ויחליף אותו בדף אחר).
אז אלגוריתם השעון מפנה דף ישן כלשהו, ולא את הכי ישן.

***

תהליכים:
בואו נעבור על התהליכים ומה הפלט (של כל דמות בתוך כל הקוד באופן כללי):

```c
fork();
if (fork() == 0) {
  printf("B");
} else {
  wait(NULL);
  printf("A");
}
```

כאשר אנחנו מריצים קוד כזה, קודם כל יש לנו את תהליך המקור (תהליך האב, זה שמריץ את פונקציית ה-main מההתחלה ועד הסוף).
נסמן תהליך מספר 1 (זהו לא מזהה תהליך, אלא רק לשם הנוחות). הפקודה ראשונה שהוא מבצע: ()fork. ברגע זה נוצר לנו תהליך בן, נסמן אותו תהליך מספר 2.
עכשיו תהליכים 1,2 ממשיכים לשורה הבאה.
יש קריאה נוספת ל-()fork בתוך ה-if, אז שניהם יוצרים לעצמם תהליכי בנים (תהליך בן אחד לכל אחד, נסמן 3 ו-4). בשלב הזה, בתוך ה-if, נכנסים רק תהליכי הבנים שנוצרו מהקריאה ל-fork הזו (תהליכים 3,4) אז כל אחד מהם מדפיס "B". תהליכים 1,2 שיצרו את התהליכים 3,4 לא מקיימים את תנאי ה-if ולכן הם ממשיכים ל-else, הם ממתינים שתהליכי הבנים שלהם יסיימו, ולאחר מכן מדפיסים "A".

על התהליכים של הקוד הזה:
(תרשים עץ תהליכים)
1 A
↙ ↘
2 A 3 B
↓
4 B

הפלט של הקוד:
כל הורה מחכה לבן שלו לפני שהוא מדפיס A.
יכולים להיות מספר מצבים (הקשורים לתזמון תהליכים):
1. יכול להיות ששני הבנים ירוצו קודם כלומר 3 ידפיס B ואז גם 4 ידפיס B. ואז ההורים יכולים לרוץ ולכן תהליכים 1,2 ידפיסו שניהם A. מכאן שהפלט במקרה זה יהיה: BBAA.

2. יכול להיות שתהליך 4 הוא הראשון שרץ אז הוא מדפיס B, הוא סיים ואז 2 רץ ומדפיס A, ורק אחרי זה 3 מדפיס את ה-B שלו וכשהוא מסיים אז 1 מדפיס את ה-A שלו. אז במקרה זה הפלט: BABA.

3. יכול לקרות מצב בו תהליך 4 מדפיס B, ואז 2 רץ ומדפיס A ואז אחרי שתהליך מספר 2 סיים, תהליך מספר 1 יכול לצאת מה-wait שלו (כי הוא מחכה שתהליך בן כלשהו יסיים לרוץ) אז תהליך מספר 1 ידפיס A ואז תהליך מספר 3 ידפיס B.

***

המשך - תהליכים:
בואו נעבור על התהליכים ומה הפלט (של כל דמות בתוך כל הקוד באופן כללי):

```c
int i = 0;
if (fork()) {
  ++i;
  fork();
} else if (fork()) {
  ++i;
}
printf("%d\n", i);
```

תהליך האב (התהליך המקורי, נסמן תהליך 1) קורא ל-()fork. אז נוצר תהליך בן, נסמן תהליך 2 והוא נכנס ל-if כי תוצאת ה-()fork שעשה שונה מ-0. מקודם בתהליך מספר 1 להיות 1. בתהליך מספר 2 ה-i כרגע עדיין 0.
לאחר מכן, תהליך מספר 1 עושה ()fork נוסף (לאחר קידום i) ולכן נוצר לו תהליך בן נוסף, נסמן תהליך 3. בתהליך 3, ה-i הוא 1.
תהליך מספר 2 נוצר ב-if הראשון ולא נכנס אליו, אלא הוא הולך ל-else if, שם הוא מבצע ()fork בעצמו, ויוצר תהליך בן, נסמן תהליך מספר 4. תהליך מספר 4 מקבל i=0 בגלל שבעת יצירתו, i היה 0 בתהליך האב שלו. לאחר מכן, תהליך מספר 2 נכנס לתוך הסוגריים של ה-else if (בגלל שתוצאת ה-()fork שעשה שונה מ-0) ומקדם את i להיות 1.
לסיום, כל אחד מהתהליכים מדפיס את התוצאה שלו. מכיוון שאף תהליך לא מחכה לילד שלו, ייתכנו 4 פלטים אפשריים. אבל בגלל שיש 3 אחדות, ייתכון 4 פלטים שונים (בכל פעם ממוקם את ה-0 במקום אחר).

על התהליכים של הקוד הזה:
(תרשים עץ תהליכים)
1 i=1
↙ ↘
2 i=1 3 i=1
↓
4 i=0

הפלט של הקוד:
4 פלטים אפשריים: 0111, 1011, 1101, 1110.

***

זיכרון וירטואלי:

* נתונה מערכת עם זיכרון וירטואלי של 32GB, גודל דף 4KB
* טבלת דפים ליניארית תופסת 24MB, כל כניסה (PTE) מכילה מספר מסגרת ועוד שלושה ביטים בלבד (ללא תוספות או עיגול)
* מה גודל הזיכרון הפיזי המקסימלי?

תזכורת:
1K = 2^10
1M = 2^20
1G = 2^30

- יש לנו 32GB של זיכרון וירטואלי ולכן הזיכרון הווירטואלי של כל תהליך הוא 2^35 בתים.
- גודל דף הוא 4KB שהם 2^12 בתים.
- יש טבלת דפים ליניארית שתופסת 24MB זיכרון.
- נתון שכל כניסה בטבלת הדפים (כל רשומה, כל pte) מכילה מספר מסגרת ועוד שלושה ביטים בלבד (ללא תוספות או עיגול לחזקה של 2). כלומר גודל כניסה הוא number of bits for pfn+3 bits.

נתון לנו שכל רשומה היא בגודל pfn+3 bits. אם נגלה את גודל ה-pfn, אז גודל pfn * 2^pfn הוא גודל הזיכרון הפיזי המקסימלי.

אם הזיכרון של תהליך הוא 32GB וכל דף הוא 4KB, אז בתהליך יש 2^35 / 2^12 = 2^23 דפים.

אם גודל כל טבלת הדפים הוא 24MB וכל שורה תופסת 2^23 דפים, אז גודל רשומה = 24MB / 2^23
כלומר גודל רשומה הוא 3B (3 בתים, 24 ביטים).
אם גודל רשומה (גודל כניסה / גודל שורה) בטבלת הדפים הוא 24 ביטים, ונתון שכל כניסה מכילה מספר מסגרת ועוד שלושה ביטים בלבד, נסיק שמספר המסגרת (ה-pfn) הוא 21 ביטים.
מכך שגודל מסגרת הוא 21 ביטים, נובע שיש לכל היותר 2^21 מסגרות בזיכרון הפיזי, שכל אחת מהן בגודל 2^12.
כלומר הזיכרון הפיזי הוא בגודל: 2^21 * 2^12 = 2^33 בתים.

במחשב כזה נוכל להחזיק עד 8GB של זיכרון, יותר מזה לא נוכל.
(אם נשים במחשב כזה 16GB, 8 ג'יגה בייט מהם יהיו מבוזבזים).

***

דפדוף:

* נתונה מערכת עם זיכרון פיזי של 64KB, גודל דף 512B
* כל טבלת דפים תופסת דף יחיד, אין swapping או copy-on-write
* מריצים תהליך עם 10 דפי קוד ו-5 דפי מחסנית, שמבצע fork בלולאה.
* חצי מהזיכרון משוריין למערכת ההפעלה. כמה תהליכים ייווצרו סך הכל?

ה-RAM במקרה זה הוא 64KB (2^16 B).
גודל דף 512B (2^9 B).
מכך שנתון שכל טבלת דפים תופסת דף יחיד, נובע שכל רמה תופסת דף (כל חלק מטבלת הדפים צריך להיכנס בדף אחד, ובמקרה הזה ספרנו כל טבלת הדפים נכנסת בדף אחד).
* נתון שלא כתוב בשאלה: טבלת הדפים היא לינארית.
אין swapping ולכן ניתן להסיק שלא משתמשים בדיסק במערכת הזו (לאחסון).

הרץ של תהליך מסוים שהקוד שלו תופס 10 דפים בזיכרון ועוד 5 דפים של מחסנית (זה כל הזיכרון שלו).
הקוד של התהליך עושה fork בלולאה, כלומר הוא ייצר לעצמו המון תהליכי בנים (שכפולים שלו) והוא יפסיק את הלולאה כאשר ייגמר הזיכרון.

אם חצי מהזיכרון משוריין למערכת ההפעלה (תפוס), והזיכרון שלנו הוא 2^16 בתים אז אנחנו יכולים להשתמש רק בחצי מהזיכרון כלומר ב- 2^15 בתים.

מסתכלים על תהליך האב- הוא עושה fork ונוצר תהליך בן שיתפוס 15 מסגרות (הוא תופס רק עבור המחסנית, כי הקוד שלהם משותף). אל התהליך המקורי תפס 15 מסגרות אבל כל תהליך בן שנולד יצור יתפוס גם 15 מסגרות פיזיות בלבד (עבור המחסנית). כרגע אין לנו copy-on-write, המחסנית משתכפלת, כלומר אולי חלק מהמחסנית לא משתתפת בתהליכים. אם היה לנו copy-on-write, תהליך חדש היה תופס מספר לא ידוע של בתים.

התהליך תופס 15 דפים (10 עבור הקוד שלו ועוד 5 עבור המחסנית) אבל הוא צריך עוד דף עבור טבלת הדפים, וכל תהליך שנוצר גם צריך דף עבור טבלת הדפים שלו.
אל סך הכל יש לנו את התהליך המקורי שתופס 16 דפים, וכל תהליך נוסף תופס 6 דפים.
אנחנו רוצים לדעת כמה תהליכים נוצרו סך הכל:
נסמן את מספר התהליכים שנוצרו ב- X
16 + 6x <= 2^6
(חיצים לתרשים):
מספר תהליכים הילדים -> X
כמות דפים לכל ילד -> 6
כמות הדפים של האב -> 16

אם הזיכרון הפיזי הוא 2^15 בתים וגודל כל דף (מסגרת) הוא 2^9 בתים, אז סך הכל יש 2^6 מסגרות בזיכרון הפיזי.
כמו כן, כמות הדפים של האב ועוד כמות הדפים של ילדיו, לא תעלה על מספר המסגרות בזיכרון הפיזי.
X זו התשובה.

***

זיכרון וירטואלי:

* נתונה מערכת עם זיכרון וירטואלי של 32GB, גודל דף 4KB
* כל כניסה בטבלת הדפים (PTE) מכילה 32 ביטים בכל רמה, ונדרש שכל טבלה תאוחסן בדף אחד בדיוק
* כמה רמות של טבלאות דרושות כדי למפות את המרחב הווירטואלי?

יש לנו כתובת וירטואלית, היא מכילה מספר ביטים כגודל הזיכרון הווירטואלי, ולכן גודל כתובת וירטואלית הוא 35 ביטים. את הכתובת הווירטואלית אנחנו מחלקים להיסט וכל השאר. ההיסט תלוי בגודל הדף - במקרה זה ההיסט הוא 12 ביטים. השאר זה ה-vpn ולה 23 הביטים שנותרו.
ידוע שכל טבלה מאוחסנת בדף אחד בדיוק, וכעת עלינו לחשב את כמות הרמות.
אם כל טבלה צריכה להיות מאוחסנת בדף אחד בדיוק, זה אומר שגודל הטבלה הוא 2^12 בתים (גודל דף).
אם גודל טבלה הוא 2^12 בתים וגודל כל כניסה בטבלת הדפים הוא 4 בתים, אז כמות הרשומות בטבלה היא 2^10.
אם בטבלה יש 2^10 כניסות, אז כדי לייצג מספר אנחנו צריכים 10 ביטים (כלומר ה-page table index הוא 10 ביטים).
ה-page directory הבא הוא תמיד אותה כמות ביטים (חוץ מהאחרון שעשוי להשתנות והוא יקבל את כמות הביטים שנותרה) ולכן הוא גם יהיה 10 ביטים.
נותרו לנו 3 ביטים ל-page directory האחרון.

אז דרושות 3 רמות למיפוי המרחב הווירטואלי.

***

טבלת הדפים:

* מרחב כתובות וירטואלי של 30 ביטים, גודל דף 2KB
* כל כניסה בטבלת הדפים כוללת 8 בתים, ונדרש שכל טבלה תאוחסן בדף אחד בדיוק
* כמה רמות של טבלאות דפים דרושות כדי למפות את המרחב הווירטואלי?

מרחב כתובות וירטואלי של 30 ביטים משמעו שכל כתובת וירטואלית היא ברוחב 30 ביטים, כלומר, גודל הזיכרון הווירטואלי הוא 2^30 בתים.
אנחנו יודעים שכל כניסה היא 8 בתים וכל טבלה צריכה לתפוס דף אחד.
כמות הרשומות שנכנסות בדף: גודל דף הוא 2^11 ואורך כניסה (רשומה) בטבלת הדפים הוא 2^3 בתים ולכן נכנסות 2^8 רשומות (כניסות) בדף.

ההיסט הוא 11 ביטים (לפי גודל הדף) ונותרו פה ביטים ל-vpn, ונחלק שוב לפי כמות הרשומות שנכנסות בדף:
בכל דף נכנסות 2^8 רשומות ולכן נדרשים 8 ביטים לייצוג רשומה בדף.
החלק הראשון יתפוס 8 ביטים, החלק השני 8 ביטים והחלק השלישי נותרו 3 ביטים.

אז דרושות 3 רמות למיפוי המרחב הווירטואלי.

***

ניהול זיכרון:

* נתון free list בגודל 4KB, וסט פקודות הקצאה ושחרור.
* יש לתאר את מצב הזיכרון לאחר ביצוע כל הפקודות בסט
* עבור: Best fit, first fit, next fit

```c
int *p1 = malloc(100);
int *p2 = malloc(200);
free(p1);
int *p3 = malloc(50);
```

תחילה יש לנו זיכרון בגודל 4096 בתים שהכל בו פנוי.
המשתמש ביקש לאלוק 100, ניצלו 108 בתים (8 בתים ל-header, לטובת ניהול הזיכרון), כמו כן אם לא נאמר אחרת, נניח שהאלוק נותן לנו את 108 הבתים הראשונים בזיכרון.

השטח הפנוי בגודל 3988 בתים כרגע.
לאחר מכן המשתמש ביקש לאלוק 200. ניקח 208 וניתן למשתמש.

המשתמש מבקש לשחרר את ההקצאה של p1, ניקח את ה-108 בתים הראשונים שניתנו למשתמש ונשחרר אותם.
כרגע יש 108 בתים פנויים בתחילת הזיכרון ועוד 208 תפוסים לאחר מכן.
כעת ה-head מצביע אל תחילת ה-108 בתים הראשונים.

עד כה הכל היה זהה לכל השיטות. כעת זה משתנה.

כאשר המשתמש מבקש לאלוק 50:
* best fit ייתן 50 בתים מתוך הבלוק הראשון (של 108 הבתים) כי הוא בוחר את הכי קטן שגודלו מספיק.
* next fit בוחר את הראשון ואחר כך מצביע לשני (עבור ההקצאה הבאה, אבל אין פה עוד הקצאות).
* worst fit גם יבחר מהבלוק הראשון.

***

ניהול זיכרון:

* נתון free list בגודל 4KB, וסט פקודות הקצאה ושחרור.
* יש לתאר את מצב הזיכרון לאחר ביצוע כל הפקודות בסט
* עבור: Best fit, first fit, next fit

```c
int *p1 = malloc(3000);
int *p2 = malloc(200);
free(p1);
int *p3 = malloc(100);
free(p2);
int *p4 = malloc(50);
```

בתור התחלה יש לנו 4096 בתים פנויים.

המשתמש מבקש 3000 בתים אז אנחנו תופסים 3008 בתים.
לנו נשארו 1088 בתים.

ביקשו מאיתנו עוד 200 בתים. כל עוד הרשימה שלנו מכילה איבר אחד, אין הבדל בין שלושת השיטות.
אל ה-1088 נפחית 208 ל- 880.

שחררו את p1 אז כל ה-3008 הבתים הראשונים שתפסנו הפכו להיות פנויים, וזה גם ה-head שלנו.

עכשיו כשביקשו 100 בתים:
* Best fit ייתן אותם מתוך ה-880 (הכי קטן שמספיק).
* first fit, next fit יתנו מה-3008 הראשונים.

עכשיו ב-best fit עדיין יהיו ה-3008 בתים בתחילה ואת ה-208 באמצע שהיה p2 ומתוך ה-880 ביקשו 100 ואז יהיו 108 תפוסים.

בשתי השיטות השניות יתפסו 108 בתים בתחילה וכל השאר מה-3008 יהיו פנויים.

שחררו את p2 שתפס 200 בתים.

כעת מבקשים להקצות p4 של 50 בתים:
* Best fit ייתן אותם מתוך ה-272 בתים הפנויים (הכי קטן שמספיק).
* first fit, next fit יתנו מהבתים הראשונים ברשימה.

***

טבלת הדפים:

* נתון שכל רשומה בטבלת הדפים תופסת את מינימום המקום האפשרי (מספר מסגרת בלבד)
* במערכת זיכרון וירטואלי של 1MB, גודל דף של 2KB, וזיכרון פיזי של 4MB
* מה גודל ה-PFN, VPN, וכמה זיכרון פיזי תתפוס טבלת הדפים של תהליך?

כשאומרים שכל רשומה בטבלת הדפים תופסת את מינימום המקום האפשרי, הכוונה היא שכל רשומה מחזיקה בתוכה רק את ה-pfn וזהו, ללא סיגנל-z או ביטים נוספים וכו', אלא מספר מסגרת בלבד - אז הגודל של ה-pte הוא הגודל של ה-pfn.

גודל זיכרון וירטואלי הוא 1MB כלומר גודל כתובת וירטואלית הוא 20 ביטים.
גודל דף 2KB לכן ההיסט הוא 11 ביטים.
מכאן שגודל ה-vpn הוא 9 ביטים (גודל כתובת וירטואלית פחות ההיסט).
הזיכרון הפיזי בגודל 4MB לכן נצטרך 22 ביטים לייצוג כתובת פיזית.
גודל מסגרת (כגודל דף) 2KB לכן מספר המסגרות הפיזיות הוא 2^11 ומכאן שגודל ה-pfn הוא 11 ביטים.

מספר הדפים הווירטואליים: גודל הזיכרון הווירטואלי חלקי גודל דף: סך הכל 2^9 דפים ולכן גודל ה-vpn הוא 9 ביטים.
ידוע שכל רשומה היא בדיוק בגודל של ה-pfn ולכן כל רשומה בטבלת הדפים היא בגודל 11 ביטים בדיוק.

אז מספר הדפים הווירטואליים הוא 2^9 וכל רשומה בגודל 11 ביטים לכן נקבל שכמות הזיכרון הפיזי שתתפוס טבלת הדפים של תהליך היא: 2^9 * 11 ביטים.

טבלת הדפים:

• נתון שכל רשומה בטבלת הדפים תופסת את מינימום המקום האפשרי
(מספר מסגרת בלבד)
• במערכת זיכרון וירטואלי של 4MB, גודל דף של 1KB, וזיכרון פיזי של 8MB
• מה גודל ה-VPN, PFN, וכמה זיכרון פיזי תתפוס טבלת הדפים של תהליך?

גודל הזיכרון הווירטואלי הוא 4MB ולכן נדרשים 22 ביטים לייצוג כתובת וירטואלית.
גודל הזיכרון הפיזי הוא 8MB ולכן נדרשים 23 ביטים לייצוג כתובת פיזית.
גודל דף הוא 1KB ולכן נדרשים 10 ביטים לייצוג היסט.

מספר הדפים הווירטואליים: גודל הזיכרון הווירטואלי חלקי גודל דף, ולכן מספר הדפים הווירטואליים הוא
2^12 ומכאן שגודל ה-vpn הוא 12 ביטים.

מספר המסגרות הפיזיות: גודל הזיכרון הפיזי חלקי גודל דף (מסגרת פיזית), ולכן מספר המסגרות הפיזיות הוא
2^13 ומכאן שגודל ה-pfn הוא 13 ביטים.

מהנתון שכל רשומה בטבלת הדפים תופסת את מינימום המקום האפשרי, נסיק שכל רשומה היא בגודל ה-pfn
כלומר pte=pfn שזה 13 ביטים.

קיימות 2^12 רשומות בטבלת הדפים (כחזקת ה-vpn)
כל רשומה תופסת 13 ביטים ולכן כמות הזיכרון הפיזי שתפוס טבלת דפים של תהליך: 13 * 2^12 .

