מערכות הפעלה – שיעור 2

בשיעור זה נדבר על הנושא הראשון שלנו בקורס: תהליכים.

ראשית, נדבר קצת על ההיסטוריה של מערכות ההפעלה:
המחשב הקלאסי שהיה פעם, עבד עם סרט מנוקב שמכניסים לתוכו או עם חוטים שמגדירים תוכנית.
הייתה מתבצעת הזנה של אותו סרט או אותה תוכנית כקלט, ועל ידי לחיצה על כפתור "start" התוכנית התחילה לרוץ מההתחלה ועד הסוף. ברגע שהתוכנית הסתיימה, הייתה פקודה מיוחדת שנקראת halt שאומרת שסיימנו ועל זה נעצר ויכולנו להכניס את הסרט הבא או את התוכנית הבאה.
כל המנגנון הזה מייצג תהליך אחד (ברגע שהתוכנית רצה זה נקרא תהליך, וברגע שהיא נעצרה התהליך הסתיים ואז המחשב שלנו פנוי להריץ את התוכנית הבאה, כלומר לייצר תהליך חדש).
כמובן שמחשב כזה יודע להריץ רק תוכנית אחת בכל פעם.

במערכות ההפעלה הראשונות שקמו, היו למעשה רק ספריות (כל מיני פונקציות ספרייה).
עם הזמן, תוכניות שאנשים כתבו – עשו את אותם הדברים פחות או יותר, ובמקום שכל אחד יממש בעצמו כל מיני פונקציות (למשל קלט/פלט), נוצרו ספריות קוד שישבו במחשב שלנו וזו הייתה מערכת ההפעלה.
מערכת ההפעלה לא ניהלה יותר מדי דברים ולא עשתה אבסטרקציות, אלא רק היו בה ספריות קוד, ואלו התוכניות שהיו מזינים למחשב יכלו להשתמש באותם שירותים של מערכת ההפעלה.

- אלו לא היו אבסטרקציה של מערכת ההפעלה ולא הייתה וירטואליזציה.
רק תוכנית אחת יכולה לרוץ בכל רגע נתון, ובאותו זמן, אותו התהליך הוא היחידי שיושב במחשב ועושה מה שבא לו וכשהוא מסיים יכולה לרוץ התוכנית הבאה. זה נקרא Batch mode (דברים רצים אחד אחרי השני).

בהמשך הוסיפו למערכת ההפעלה פונקציונליות להריץ באופן אוטומטי סט של תוכניות שיוצבו אחת אחרי השנייה ומערכת ההפעלה בכל פעם הייתה טוענת תוכנית, מריצה אותה, טוענת את התוכנית הבאה ומריצה אותה וכן הלאה.. וכן סיפקה את פונקציות הספרייה המוזכרות.

* בשלב מאוחר יותר, התעורר הצורך בהגנה- יש יותר תוכניות ויותר תוכניות ויש צורך בהגנה על המחשב.
אי אפשר לתת לתוכניות לעשות מה שהן רוצות כי פתאום יכול להגיע מישהו זדוני ולפגוע ברכיבי החומרה שלנו ולעשות דברים שאסור, או לחילופין - יכולה להגיע תוכנית שיש בה באג ולעשות דברים שלא צריך או להיכנס ללולאה אינסופית ואז נוצרות בעיות.
אז במערכות ההפעלה המודרניות יותר, נעשתה הפרדה – הפרידו בין תהליכי משתמש (שרצים ב-user mode, כלומר רצים תחת הרשאות מוגבלות) לבין קוד של מערכת ההפעלה.
אז כיום כשאנחנו מריצים תהליך, הוא רץ עם הרשאות מוגבלות. אם תהליך כזה רוצה לעשות דברים מעבר להרשאות האלו או דברים שאסור לו, הוא צריך לבצע קריאת מערכת - כל פעם שאנחנו רוצים לבצע פעולה אסורה, אנחנו מבקשים שירות ממערכת ההפעלה, ברגע שאנחנו מבקשים שירות ממערכת ההפעלה אנחנו למעשה מעבירים את השליטה למערכת ההפעלה וכך גם מעלים את רמת ההרשאות.
ברגע שהעברנו את השליטה למערכת ההפעלה, יש לה הרשאות לעשות הכל, היא יכולה לבחון את הבקשה שלנו ואם הבקשה תקינה היא יכולה לבצע אותה. עכשיו למערכת ההפעלה יש גישה מלאה לחומרה לכל הדברים שלנו (אסור לגשת למעבד, לזיכרון וכו'..). מערכת ההפעלה יכולה לגשת אליהם באופן חופשי ולאט, לטפל בבקשה שלנו וברגע שהיא סיימה להחזיר את השליטה אלינו עם אותן הרשאות מוגבלות.

ב-10-15 שנים האחרונות המודל הוא Multiprogramming.
עם הזמן התחלנו להריץ על המחשבים יותר ויותר תהליכים ותוכניות, והיום יש לנו יותר ממעבד אחד במחשב, וכן עלה הצורך לנצל יותר טוב את המשאבים שלנו. יש המון מעבדים והמון זיכרון ואנחנו רוצים שהכל ירוץ ביחד, בו זמנית כמה שניתן ובאופן יעיל, ומערכת ההפעלה צריכה לדאוג שזה יקרה – שכל אחד ירוץ באופן יעיל ומהיר, ושכל העניין ייעשה גם באופן בטוח. אז עכשיו אם הרבה דברים רצים בו זמנית זה מעלה לנו בעיות חדשות: לא רק מבחינת הקוד והתוכנית שלו אלא גם מבחינת אבטחה: אנחנו לא רוצים שתהליך אחד ישפיע על תהליך אחר, או שמישהו ייקח את כל המשאבים במחשב ולאחרים לא יישאר, וכו'.. וזו הנקודה של מערכות הפעלה שבה אנחנו נמצאים כיום.
על כל מכשיר פשוט רצים המון דברים בבת אחת וצריך לדאוג למקום ביניהם ולהגן עליהם אחד מהשני, וגם להגן על מערכת ההפעלה מפני התהליכים הללו כדי שלא בטעות ישפיעו עליה בצורה שאסור להם.

-----------------------------------------------------------------------------------------------------------

כעת נדבר על תהליכים:
תהליך- ריצה של תוכנית. בכל פעם שאנחנו מריצים תוכנית אנחנו מייצרים תהליך.
במערכת ההפעלה שלנו רצים הרבה מאוד תהליכים בו זמנית, והיא זו שמנהלת את התהליכים.
* ניתן לראות את התהליכים שרצים בזמן מסוים על המחשב ע"י מנהל המשימות.
האתגר: יש מעט מעבדים אבל הרבה תהליכים, ומערכת ההפעלה רוצה לתת את האשליה כאילו יש לנו המון מעבדים (כאילו הכל רץ במקביל, בו זמנית).

- לכל תהליך שרץ יש מרחב כתובות משלו (את הזיכרון שלו), שמורכב מכמה סגמנטים (חלקים):
1. Text (code) - מקטע זה מכיל את הקוד (פקודות מכונה) של אותו התהליך.
2. Data – הנתונים של התהליך: כולל את הקבועים שהגדרנו בקוד ואת המשתנים הגלובליים.
3. Heap (ערימה) – כל ההקצאות הדינמיות שאנחנו עושים נמצאות שם. מקטע הזיכרון הזה גדל וקטן בהתאם, תוך כדי זמן ריצה (בניגוד למקטעי ה-text וה-data שגודלם קבוע בהתאם לקוד שלנו).
4. Stack (מחסנית) – כל הזיכרון הסטטי יושב שם (הפונקציות, משתנים מקומיים, ארגומנטים לפונקציות). גם מקטע הזיכרון הזה גדל וקטן תוך כדי ריצת התוכנית.

* המחסנית והערימה יושבים באופן מנוגד אחד לשני כדי שכל אחד מהמקטעים יוכל לנצל את מקסימום הזיכרון תוך כדי שהם גדלים.
* לכל תהליך שאנחנו מריצים, יש את מרחב הכתובות הזה שמכיל את כל ארבעת הסגמנטים (יש עוד סגמנטים, אבל הארבעה הללו הם המרכזיים ואלה שמעניינים אותנו).

[תרשים: Address Space הכולל את Text, Data, Heap עם חץ למטה, ו-Stack עם חץ למעלה]
{לעיתים מאחדים את שני המקטעים הללו (Heap ו-Stack) למקטע אחד}

ההבדל בין תוכנית לתהליך:
* תוכנית – קוד ומידע סטטי. אנחנו כתבנו את הקוד שלנו, קימפלנו אותו, מה שיצא לנו זה תוכנית (קובץ הריצה שלנו).
בתוכנית הזו יש את הקוד שלנו ואת המשתנים הגלובליים ואת הקבועים, זה לא רץ כרגע, אלא רק נתונים שיושבים באזור ומכילים את המידע שצריך כדי שנוכל להריץ אותה.
* תהליך – מופע דינמי של התוכנית. בכל פעם שאנחנו מפעילים את התוכנית נוצר תהליך. אם נפעיל את התוכנית 4 פעמים, ייווצרו 4 תהליכים. כל תהליך הוא מופע של תוכנית מסוימת.

ייצור תהליך:
כאשר אנחנו מייצרים תהליך, יש שלושה רכיבים ששותפים ליצירה:
- המעבד
- הזיכרון (ה-RAM, הזיכרון הפיזי)
- מערכת הקבצים
כל הרכיבים הללו מתקשרים ביניהם עם קווי תקשורת.

[תרשים: Process Creation המראה קשר בין CPU, Memory הכולל Process (Code, Data, Heap, Stack), ו-File System הכולל Program (Code, Data)]

כשאנחנו מפעילים קוד, מקבלים קובץ ריצה שהוא התוכנית שלנו, והקובץ הזה מכיל את הקוד של התוכנית (פקודות מכונה של אותה תוכנית) ואת ה-data (כלומר המשתנים הגלובליים והקבועים).
ברגע שאנחנו מריצים את התוכנית הזו, מערכת ההפעלה תופסת שטח בזיכרון עבור תהליך (מי שבפועל מבצע את הפקודות זה המעבד, הקוד הוא של מערכת ההפעלה).
לאחר שנוצר האיזור בזיכרון עבור התהליך, נרצה לאתחל את האיזור הזה ולטעון אליו עניינים.
- הדבר הראשון שנטען לתוך איזור זה את התוכנית.
- לאחר מכן, נותר להקצות מקום ל-Heap (הערימה) וה-Stack (המחסנית) ואז ניתן לתת לתהליך לרוץ ולבצע את פקודותיו.
* אם נריץ שוב את אותה התוכנית, ייווצר עוד שטח בזיכרון כפי שתיארנו לעיל וכו'.

הרצת שני תהליכים מאותה תוכנית:
נניח והרצנו שני תהליכים של אותה התוכנית, אז אנחנו תופסים שני מקטעים בזיכרון, שלשניהם יש את כל ארבעת הסגמנטים של: text, data, heap, stack. אבל התוכן לא חייב להיות זהה.
נניח והרצנו את החלון של המחשבון המובנה בוינדוס פעמיים, ובחלון אחד עשינו חישוב אחד ובחלון השני עשינו חישוב אחר, לפי הקלט והריצה שלנו – שני התהליכים האלה הם נפרדים.

איך זה מתבטא בזיכרון? אם נסתכל על הזיכרון של כל תהליך לפי ארבעת המקטעים שציינו, ניתן לראות שהמקטע של ה-text (הקוד של התוכנית) תמיד יהיה זהה (אותו גודל ואותו תוכן), זאת כי הקוד הוא קוד של אותה תוכנית. לא משנה כמה פעמים נפעיל את אותה התוכנית, תמיד מקטע זה יהיה זהה לכל התהליכים של אותה התוכנית.
לעומת זאת, המקטע של ה-data (קבועים ומשתנים גלובליים) יכול להיות שונה. בזמן ריצה, המשתנים הגלובליים יכולים להשתנות. הגודל של המקטע יהיה זהה, אבל הערך של אותם משתנים בתוכו יכול להשתנות. הגודל של מקטע זה יהיה אותו גודל עבור תהליכים שונים, אך הערכים בפנים עלולים להיות שונים.
לערימה ולמחסנית אין חוקים – זה משתנה תוך כדי ריצה וזה אף פעם לא משהו קבוע (יכול להיות גודל שונה ותוכן שונה).

וירטואליזציה של המעבד:
יש לנו הרבה מאוד תהליכים שרצים במחשב ומערכת ההפעלה רוצה לספק את האשליה כאילו יש לנו גם הרבה מעבדים, למרות שבפועל יש לנו מעבדים בודדים. המטרה היא לתת למשתמש את התחושה שהרבה דברים רצים בבת אחת במקביל.
האשליה הזו נעשית ע"י Time sharing של המעבד, כלומר חלוקה של המעבד ליחידות זמן. לוקחים את כל התהליכים שקיימים כרגע ומריצים כל אחד מהם לפרק זמן קצר מאוד תוך כדי החלפה ביניהם.

מערכת ההפעלה בוחרת תהליך אחד מבין התהליכים הקיימים באותו רגע וטוענת אותו לתוך המעבד. התהליך הזה רץ. אחרי כמה זמן, מערכת ההפעלה לוקחת את התהליך שרץ כרגע, מקפיאה אותו ומוציאה אותו מהמעבד, שמה אותו בצד ואז טוענת תהליך חדש במקומו – לתוך המעבד (והוא ממשיך מאותה נקודה שבה הקפיאו אותו לפני כן).
המנגנון הזה נקרא "context switch" (החלפת הקשר / החלפה בין תהליכים).

בשביל לקיים את המנגנון הנ"ל, יש שני אתגרים עיקריים:
1. ביצועים – אם המנגנון של החלפה בין תהליכים יהיה איטי, הוא יהיה מיותר (כי אז תיעלם האשליה של המקביליות).
2. שליטה – כשנהליך רץ, זה אומר שהמעבד מבצע את הפקודות של אותו תהליך, ולכן בזמן זה מערכת ההפעלה לא רצה, ואז נוצרת בעיה כי מערכת ההפעלה צריכה שליטה, היא צריכה להפעיל קוד שינהל את יחידות הזמן של התהליכים.

כמה ניתן להיעזר לשם התמודדות עם האתגרים הנ"ל:
* במערכת ההפעלה יש לנו מבנה נתונים שנקרא "טבלת התהליכים" (process table). זהו מבנה נתונים של מערכת ההפעלה והוא נמצא בתוך ה-kernel (הגרעין של מערכת ההפעלה) והוא מחזיק את כל התהליכים הפעילים באותו רגע. בכל פעם שאנחנו יוצרים תהליך, נוצרת רשומה בטבלת התהליכים. ברגע שתהליך מסתיים, הרשומה שלו נמחקת מטבלת התהליכים. לנו אין גישה לטבלת התהליכים, זה שייך למערכת ההפעלה ורק ל-kernel יש גישה אליה.

בתוך טבלת התהליכים, כל תהליך מיוצג ע"י רשומה שנקראת PCB (process control block) - זהו מבנה הנתונים של כל רשומה, זה סוג של struct ששמור בו המידע עבור התהליך. ב-PCB יש את כל המידע לניהול התהליך:
1. PID (process identifier) - מספר מזהה ייחודי של התהליך. בכל פעם שאנחנו מריצים תהליך, הוא מקבל מספר ייחודי. בדר"כ המספרים האלה הולכים וגדלים ב-1. בנוסף, אין שני תהליכים עם אותו מזהה באותה מערכת.
2. state - המצב הנוכחי של התהליך (האם התהליך כרגע רץ או לא...).
3. related processes - תהליכים שקשורים (בעיקר הורה). בלינוקס תהליכים מייצרים היררכיה.

- מידע על התהליך בעת הקפאון שלו – שמירת מצב הרגיסטרים במעבד כשהקפאנו את אותו התהליך, מצב הזיכרון (המיקומים וכו') שקשורים לאותו תהליך
- מה הקבצים הפתוחים שאותו התהליך מחזיק. בקיצור כל המידע שנדרש עבור הריצה של אותו תהליך

• CPU context, e.g., registers (saved when suspended)
• Memory locations
• Open files

כעת עם מבנה הנתונים הזה נרצה לממש את המנגנון של ה-context switch (החלפה בין תהליכים).
השיטה הראשונה שהוצעה לכך (בשימוש מועט היום): Direct Execution: אם עכשיו בחרנו איזהשהו תהליך ואנחנו רוצים להריץ אותו, אז נטען אותו לתוך המעבד (ניקח את המצב שהקפאנו ונחזיר את כל הרגיסטרים והזיכרון וכל מה שצריך) וניתן לו לרוץ. בזמן שתהליך רץ, הוא שולט באופן מלא במעבד (המעבד מריץ את הפקודות שלו) ומערכת ההפעלה מעבירה את השליטה הבלעדית אליו. הרעיון בשיטה הזו: ירוץ התהליך כביכול עד שהוא יסיים.

השיטה הזו בעייתית מכמה סיבות:
1. ברגע שנתנו שליטה מלאה לתהליך, יש לו גם גישה מלאה לכל הדברים במחשב (הוא יכול לגשת לרכיבי חומרה, להיכנס ללולאה אינסופית וכו'..) וזה לא טוב לנו.
2. השיטה הזו מריצה תהליך מההתחלה ועד הסוף. אבל אנחנו לא רוצים להריץ תהליך מההתחלה ועד הסוף.

השיטה שמשתמשים בה היום היא שיטה דומה עם תיקון קטן: limited direct execution:
הרעיון בשיטה זו הוא שהשליטה במעבד תהיה מוגבלת ולא מלאה.
הצורך בשליטה במעבד הוא לשם ביצועים מהירים. אם מערכת ההפעלה תבחן כל פקודה שעתידה להתבצע זה יפגע בביצועים, כי במקום שהמעבד ישר יבצע פקודה, הוא בעצם הולך למערכת ההפעלה ומאריך את הזמן. אז אנחנו כן רוצים למצוא מנגנון שהמעבד יוכל להריץ באופן ישיר את הפקודה.
אם כן, המנגנון של limited direct execution ניתן למעבד להריץ באופן ישיר את הפקודה, אבל עדיין עם פיקוח.
הפיקוח נעשה בעזרת החומרה (במקום שמערכת ההפעלה תפקח על כל פקודה, יש לנו חומרה שעושה זאת).
המעבד שלנו ידע להבדיל בין שני מצבי ריצה ע"י ביט שנמצא במעבד:
1. User mode – יש פקודות שלא ניתן להריץ. למשל אם תופיע פתאום פקודה של גישה לרכיב חומרה- תעלה שגיאה.
2. Kernel mode - אין מגבלות. ניתן להריץ כל פקודה באופן חופשי.

כעת לא נדרש פיקוח של מערכת ההפעלה על כל פקודה, אלא זה נעשה ברמת החומרה, וזה לא מבזבז זמן.
- כשאנחנו מריצים תהליכי משתמש רגילים, נרצה לעבוד ב-user mode. הקוד שלו הוא מוגבל ואי אפשר לעשות דברים אסורים. ובזמן קוד של מערכת ההפעלה, המעבד מריץ את הקוד במצב kernel mode שבו מותר לעשות הכל.

כעת נראה כיצד מנגנון ה-context switch מתממש בשיטה זו:
דרך ראשונה: system call: כאשר התוכנית שלנו רצה ומדי פעם אנחנו רוצים לבצע פעולות שאסור לנו (הפעולות הללו נקראות privileged operations כלומר פעולות שדורשות kernel mode כמו למשל גישה לחומרה / הקצאת זיכרון) אז נשתמש במנגנון של system call (קריאת מערכת). קריאת מערכת היא סט של פונקציות (מוגדרות קצת שונה מפונקציות רגילות) שה-kernel חושף כלפי חוץ ומערכת ההפעלה חושפת עבור תהליכים - פתיחה של קובץ או כתיבה אליו, הקצאת זיכרון וכו'. לכל קריאת מערכת יש מספר ידוע שלפיו אנחנו מזהים את הקריאה, ואז התהליך יכול לבקש את קריאת המערכת הספציפית ממערכת ההפעלה, וברגע שתהליך מבצע קריאת מערכת – ההרשאות שלו עולות. מתבצעת החלפה מ-user mode ל-kernel mode. אבל אמרנו שתהליך לא יכול לקבל הרשאות של kernel mode באופן עצמאי, לכן יש את המנגנון של קריאת מערכת כך שבכל פעם שמתבצעת קריאת מערכת, זה לא רק משנה את המצב במעבד אלא גם לוקח מהתהליך את השליטה וכשהיא מסתיימת השליטה חוזרת לתהליך.

פירוט התהליך של system call:
כשתהליך רץ – הוא מריץ קוד משתמש, עד שבשלב מסוים הוא מבצע קריאת מערכת כלשהי.
כל קריאת מערכת היא פונקציית ספרייה שכתובה בשפת C. כשקוראים לפונקציית הספרייה ומעבירים לה ארגומנטים, המימוש של הפונקציה הזו לוקח את הארגומנטים ושם אותם במקום מוסכם כלשהו. בנוסף, המימוש לוקח את המספר של קריאת המערכת הספציפית ושם אותו באותו מקום ידוע ומוסכם. לאחר מכן, פונקציית הספרייה הנ"ל עושה פקודת מכונה מיוחדת שנקראת Trap (במאמבלי הפקודה נקראת INT 0x80) שתפקידה להעביר את השליטה למערכת ההפעלה, ל-kernel. ברגע שזה קרה, המעבד מעביר אוטומטית את המצב ל-kernel mode (בעקבות ה-trap) ומריץ את הקוד לטיפול באירוע. כלומר המעבד מקפיא את התהליך שלנו כרגע, מעביר את ה-bit ל-kernel mode ומריץ את הפונקציה המתאימה של ה-kernel לטיפול בקריאת המערכת.

אחרי ביצוע הפעולה הנ"ל, ה-kernel בודק את ההרשאות המתאימות והוא מסתכל באותו מקום מוסכם ויודע ששמרנו את הנתונים ומחפש את המספר של קריאת המערכת והארגומנטים ופשוט מבצע את הפעולה שביקשנו לבצע (בהנחה שהיא תקינה). ברגע שה-kernel סיים, הוא עושה Return from Trap (גם זו פקודת מכונה מיוחדת שמשנה חזרה את המצב מ-kernel mode ל-user mode) ואז הקוד של התהליך חוזר לרוץ. כעת פונקציית הספרייה מסתכלת על התוצאה של קריאת המערכת.

המנגנון של ה-system call עוזר לנו להתמודד עם בעיה אחת מבין השתיים שהיו לנו:
בעיית האבטחה נפתרה. ברגע שהוספנו שני מצבים למעבד, ונתנו מנגנון של קריאת מערכת, מנענו גישה של תהליכים לרכיבי חומרה, ותהליך לא יכול לבצע מה שהוא רוצה אבל עדיין יש לו את האפשרות לבקש שירותים ממערכת ההפעלה והיא תבצע זאת עבורו בצורה בטוחה.

נותרה לנו בעיה שנייה – איך מערכת ההפעלה שומרת על שליטה במעבד?
ברגע שתהליך רץ, המעבד מריץ אותו פקודה אחרי פקודה ואז מערכת ההפעלה לא רצה ולא יכולה להריץ קוד.

גישה נוספת שפחות נהוגה כיום: Cooperative approach: גישה זו מבקשת לסמוך על התהליכים. תהליך לכל אורך ריצתו יבצע קריאות מערכת וקורים לו אירועים. אירוע או קריאת מערכת גורמים להעברת השליטה ל-kernel, ואז אפשר בנוסף לטיפול באירוע, להחליט אם לעצור את אותו התהליך שרץ.
כמו כן הוסיפו קריאת מערכת מיוחדת שנקראת yield, היא לא עושה כלום, כל המטרה שלה היא לוותר על המעבד, היא לא מבקשת שום דבר מיוחד ממערכת ההפעלה. זו הדרך של תהליך להגיד שהוא מוותר על המעבד ומחזיר את השליטה למערכת ההפעלה ושהיא יכולה לתת לתהליך אחר (למשל כמו בהמתנה לקלט).
הגישה הזו הייתה נהוגה פעם והבעיה בה היא שיש סומכים יותר מדי על התהליכים.

Preemptive approach: מצד אחד אנחנו לא רוצים לסמוך על התהליך שיקרא לפקודה שתיעצר, אבל מצד שני, יש לנו בעיה כי התהליך הוא זה שרץ כרגע ולא ניתן להריץ פקודות אחרות. במקום זה - פונים לחומרה בשביל פתרון:
נוסף רכיב חדש – שעון: כשהמחשב נדלק, מערכת ההפעלה מאתחלת אותו, ולאחר כל פרק זמן מסוים מתרחשת פסיקת שעון – אירוע חיצוני שקורה באופן קבוע. נניח והמעבד מריץ תהליך p1 ויש תהליך נוסף p2 שממתין. לאחר פרק זמן מסוים תגיע פסיקת שעון. פסיקה היא אירוע ולכן השליטה עוברת למערכת ההפעלה (כי זה מה שהמעבד עושה בעת אירוע). ברגע שהתקבלה פסיקת השעון ומערכת ההפעלה קיבלה חזרה את השליטה, היא יכולה להחליט מה לעשות. ובדוגמא שלנו היא יכולה להחליט להחליף בין p1 ל-p2. כך אנחנו לא צריכים יותר לסמוך על התהליך, מערכת ההפעלה יודעת שכל כמה זמן השליטה תחזור אליה והיא תוכל לעשות מה שהיא רוצה.

הבהרה:
1. פסיקת שעון לא בהכרח אומרת שתתבצע בה החלפה בין תהליכים. היא רק מחזירה שליטה למערכת ההפעלה, והיא כבר תחליט מה היא רוצה לעשות.
2. פסיקת שעון לא עוצרת את פעולת המעבד באופן מידי, אלא נשלח אות חשמלי למעבד (נדלק ביט), כך שהמעבד תמיד יסיים את הפקודה הנוכחית שלו ורק אז יבדוק אם נדלק הביט לפסיקה.

מה קורה בעת פסיקת שעון:
תהליך כלשהו A מריץ קוד שלו ← פקודה מסוימת, לאחר פרק זמן מסוים מתקבלת פסיקת שעון ← פסיקת שעון היא סוג של אירוע שמופעל אל ה-kernel, אבל לפני שהקוד של ה-kernel רץ יש כמה דברים שקורים בחומרה (קורים בכל אירוע, אך בפסיקת שעון הם חשובים במיוחד):
1. בכל אירוע אנחנו עוצרים את מה שרץ כרגע ומריצים קוד של ה-kernel, כלומר השליטה עוברת במעבד ל-kernel, ויש חשיבות גדולה בשמירת מצב המעבד (שמירת ערכי הרגיסטרים שלו שקדמו לאירוע).
2. כעת החומרה עוברת ל-kernel mode ומריצה את הקוד של ה-kernel. הקוד של ה-kernel בפסיקת שעון הוא context switch (החלפה בין תהליכים, אבל שוב, זה לא תמיד ככה, נניח לצורך הדוגמא שעכשיו אכן מדובר על החלפת תהליכים).
3. ה-kernel לוקח את הרגיסטרים שנשמרו בצד ושומר אותם בתוך ה-PCB של תהליך A (בתוך טבלת התהליכים שלו). בנוסף, הוא מוצא את הרשומה של תהליך B שרוצים לטעון במקום תהליך A, וטוען את הרגיסטרים של תהליך B חזרה לזיכרון. כמו כן מתבצעת החלפה של החומרה שאומרת למעבד להשתמש ברגיסטרים החדשים שנטענו.
4. כעת ה-kernel סיים והוא מבצע את פקודת החזרה.
5. החומרה טוענת את מצב הרגיסטרים שהיה קודם (של תהליך B) ונותנת לתהליך B להמשיך לרוץ עכשיו במקום A.
6. כעת כשנחזור למצב user mode, החזרה תהיה לתהליך B ולא ל-A.

מחזור החיים של תהליך:
כשהסברנו על ה-PCB (מבנה הנתונים של תהליך), אחד השדות היה state (מה המצב של התהליך כרגע).
כל תהליך נמצא במצב כלשהו מתוך כמות מסוימת של מצבים, ויש כל מיני אירועים שמעבירים אותו בין המצבים הללו והמצבים הללו חשובים בשביל הריצה של התהליך. המצבים העיקריים ב-state:
1. Running - אם תהליך במצב זה, המשמעות היא שהוא רץ כרגע. המעבד מריץ כרגע את הפקודות שלו. ברגע שהחלטנו להפסיק את התהליך (פסיקת שעון / קריאת מערכת..) ולהריץ תהליך אחר במקומו, זה נקרא שעשינו לתהליך Descheduled (החזרנו אותו למחסן).
2. Ready - זהו מצב של תהליך שהוא מוכן לרוץ. תהליך נכנס למצב זה לאחר שעשינו לו Descheduled. כשמערכת ההפעלה בוחרת את התהליך הבא להרצה, היא בוחרת אותו מתוך רשימת התהליכים שהם במצב Ready. ברגע שתהליך מסוים נבחר להרצה, אז הוא עובר מ-Ready ל-Running. זה נקרא שעשינו scheduled לתהליך, כלומר ששיבצנו את התהליך ועברנו לרוץ על המעבד.
3. Blocked - התהליך קיים אבל אין טעם להריץ אותו כרגע. הוא ממתין למשהו, ואם ננסה לתת לו מעבד / לתת לו לרוץ זה יהיה בזבוז כי הוא רק ממתין ולא יכול לבצע כלום עד שמה שהוא ממתין לו יסתיים. מערכת ההפעלה בכלל לא מסתכלת על תהליכים שהם Blocked.
לדוגמא למצב Blocked כאשר עושים פקודת קלט/פלט. נניח ורצינו לקרוא מקובץ, קריאה מקובץ היא פקודה איטית שבכלל מתרחשת בחומרה, עד שזה יחזור ייקח הרבה זמן, ואין טעם להריץ תהליך כזה. תהליך פסיק להיות Blocked כאשר החומרה תסיים, ברגע שהקריאה מהקובץ הסתיימה, יש פסיקה כי גם זה אירוע. הפסיקה מודיעה שפעולת הקלט/פלט הסתיימה ואז רואים איזה תהליך המתין והופכים אותו ל-ready. בדר"כ המעבר מ-Blocked ל-ready הוא מעבר ל-ready בעדיפות גבוהה.

שני מצבים נוספים הם created (תהליך שהרגע נוצר עד שהוא הופך להיות ready) ו-terminated (תהליך שהסתיים לעבור למצב זה עד שמוחקים אותו מטבלת התהליכים).

