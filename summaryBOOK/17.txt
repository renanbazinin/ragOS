מערכות הפעלה – שיעור 17

היום נתחיל את הנושא החדש שלנו: **persistence**.
זיכרון בעבר על המעבד שלנו- יש לנו את המעבד והזיכרון שמחוברים בעלוץ תקשורת (ה-**memory bus**), אבל חוץ מערוץ התקשורת הזה יש ערוצי תקשורת נוספים שמחברים חלקים אחרים. כולם בסופו של דבר מחוברים למעבד אשר מתקשר איתם. כל שקו התקשורת רחוק יותר, הוא איטי יותר, אבל גם הרכיבים שמחוברים אליו איטיים יותר, בהתאם.

בשביל לתקשר עם כל מיני התקנים שונים, צריך להיות מבנה מקובל.
**נסתכל על רכיב קנוני כלשהו (canonical device). כל רכיב באופן כללי בנוי כך:**
1. **ממשק הרכיב (hardware interface)-** ממשק שאינו מערכת ההפעלה מדברת, כשאנחנו מחברים **disk on key** למשל, מערכת ההפעלה/המעבד שלנו לא משנה את הזיכרון בהתקן לה בעצמו, אלא שולח פקודות שיעשו זאת. בשביל שהדיסק און קי יחסה זאת, יש ממשק מסוים שאיתו אנחנו מדברים.
2. **מבנה פנימי של הרכיב (internal structure).**

**ממשק הרכיב בנוי מרגיסטרים. בדרך כלל יש 3 סוגים:**
1. **status-** רגיסטר שאנחנו יכולים לקרוא בו את המצב הנוכחי של הרכיב (בדרך כלל רגיסטר זה הוא לקריאה בלבד). בדרך כלל המצב הוא עסוק / פנוי.
2. **command-** רגיסטר שאנחנו רק כותבים אליו, אומרים לרכיב את הפעולה שאנחנו רוצים לבצע. למשל לכתוב / לקרוא.
3. **data-** רגיסטר שאינו אנחנו מעבירים נתונים שהרכיב יכול להשתמש בהם עבור הפעולה.
למשל אם אנחנו רוצים לכתוב לקובץ, נסביר לרגיסטר את הנתונים שאנחנו רוצים לכתוב וב-**command** נציין שאנחנו רוצים פעולת כתיבה.

מערכת ההפעלה / המעבד של הרכיב מתקשר בדרך כלל עם הרגיסטרים הללו.

**תקשורת טיפוסית עם התקן כלשהו (פרוטוקול קנוני):**
כשאנחנו רוצים להשתמש ברכיב:
1. **מבצעים polling-** דוגמים את ה-**status** של הרכיב וממתינים כל עוד הוא עסוק, עד שיתפנה לטפל בבקשה שלנו.
2. **ברגע שאנחנו רואים שהרכיב פנוי, אנחנו יכולים לכתוב את המידע שלנו לרגיסטר הנתונים ברכיב,** וזאת בהינתן שיש לנו מידע לכתוב (בקריאה אין לנו **data** לכתוב). (האנגנון הזה נקרא **pio- programmed i/o**, נדבר על זה בהמשך).
3. **כותבים ל-command,** את הפקודה שרצה שתתבצע למשל, כתיבה של הנתונים לתוך מיקום X בדיסק.
4. ברגע שכתבנו את הפקודה, **הרכיב מתחיל לעבוד,** זה היה האות שלו להתחיל לעבוד.
5. לאחר מכן, אנחנו חוזרים שוב ל-**polling**, דוגמים אותו עד שהוא מסיים את פעולתו.

---

הפרוטוקול שתיארנו הוא פרוטוקול קנוני לכתיבה. אם היינו רוצים לקרוא (קבלת נתונים מהרכיב):
- לא היינו כותבים את ה-**data** (כי אין מידע לכתוב).
- אחרי הכל, ברגע שהוא סיים, היינו יכולים לקרוא את ה-**data** שהמתין לנו.
כלומר הפרוטוקול עבור קריאה: **polling, write commands, polling, read data.**
ניתן גם לכתוב ולקרוא: **polling, write data, write commands, polling, read data.**

* אם רצינו לכתוב הרבה נתונים, ולא תמיד יש מקום (אזור ה-data של הרכיב - מוגבל בגודלו), אז פשוט חוזרים על הפעולה, כלומר כותבים בחלקים. אחרי שביצענו פעולת כתיבה וראינו שהרכיב סיים אותה, חוזרים שוב וכותבים את ה-data הנוסף (החלק הבא של המידע שאנחנו רוצים לכתוב) וכן הלאה, עד שנסיים לכתוב את כל מה שרצינו.

**אם נסתכל על ציר הזמן:**
יש לנו את המעבד ואת מה שהוא מריץ, ואת הדיסק ואת מה שהוא מריץ.
נניח של תהליך A על המעבד ובשלב כלשהו הוא רצה לעשות פעולת **i/o (קריאה/כתיבה)**
נניח שהוא רוצה לכתוב אל הדיסק. הדיסק שלנו כרגע עסוק ומטפל בבקשה קודמת של תהליך C שכבר ביצע פעולה והוא כרגע מתבצע.
הדבר הראשון ש-A צריך לעשות זה להמתין. בעת ביצוע פעולת i/o, תהליך A בשלב ביצוע קריאת מערכת, וכעת המעבד עושה **polling עד שהרכיב יהיה זמין.**
ברגע שהדיסק סיים לטפל ב-C, הוא כבר לא עסוק ולכן ה-**polling** הסתיים ו-A יכול לכתוב לדיסק את המידע הרצוי.
המעבד לוקח את הנתונים ש-A רצה לכתוב ומעתיק אותם לתוך הרגיסטר המתאים ברכיב החומרה.
לאחר כתיבת ה-**data**, נכתוב את הפקודה לביצוע (**command**), ועכשיו הרכיב מתחיל לעבוד ומטפל בפקודה ש-A שלח.
בזמן הזה, המעבד שוב עושה **polling**, צריך לחכות עד שהרכיב שוב יהיה פנוי (שלחנו לו פקודה ועכשיו אנחנו ממתינים עד שהוא יסיים). לאחר שהוא סיים, ה-**polling** שלנו החזיר שהכל תקין ואז A סיים את פעולת ה-i/o שלו והוא יכול להמשיך לרוץ כרגיל, והמעבד שלנו חוזר למצב ריצה תקין.
* כל מה שקרה מהרגע ש-A רצה לעשות i/o ועד הרגע שהוא חוזר, זו קריאת המערכת.

--------------------------------------------------------------------------------------------------------------------------

הפרוטוקול הקנוני משתמש ב-**polling** אך זה לא יעיל כל הזמן לדגום את הרכיב ולבדוק אם הוא סיים. היינו רוצים לנצל את הזמן של ה-**polling** (הקוביות האדומות בציור) למשהו אחר.
ראינו בעבר את מנגנון הפסיקות שעושה בדיוק את זה. אנחנו יודעים לקבל הודעות מהרכיבים אלינו, אז לא צריך לחכות להם ולדגום אותם, ניתן לרכיב להודיע לנו כשהוא מסיים.
**השיפור לפרוטוקול הלאה: נשלח את הפקודה, לא נמתין שהרכיב יסיים, אלא הרכיב יודיע לנו כשהוא יסיים.**
אם נשתמש בפסיקות, התזמון שלנו ייראה שונה:
- מתחילים באותו מצב: כרגע הדיסק שלנו עסוק בפעולה כלשהי ותהליך A רוצה לבצע את פעולת ה-i/o שלו (כתיבה, write).
- כעת במקום לדגום את הרכיב, נעצור את רכיב A. כעת מערכת ההפעלה תעלה תהליך אחר שיכול לרוץ (**ready**).
- ברגע שהרכיב יסיים את הפעולה, הוא יגרום לפסיקה שתגיע למעבד, המעבד יפסיק למערכת ההפעלה ועכשיו נטפל ב-A שהמתין לו. ברגע שהפסיקה הגיעה, A יכתוב את ה-**data** שלו ואת הפקודה.
- גם כאן, לא מבצעים **polling** לאחר שליחת הבקשה, אלא מחכים שהרכיב יודיע לנו שהוא סיים ובינתיים תהליך אחר יתזמן.
- ברגע שהרכיב סיים, נעלה את A והוא יוכל לרוץ באופן רגיל ולחזור לריצה תקינה של המעבד.

---

נחסכו לנו חלונות הזמן של ההמתנה ב-**polling**.
מנגנון הפסיקות הוא פתרון טוב, אבל לא תמיד הכי טוב. הרבה פעמים זה עדיף מאשר לדגום את הרכיב כל הזמן. אבל אם עניינים רכיבים מאוד מהירים, שנשלח פקודה מהם ולאחר שנייה הם לאיזשהו שוב. במקרה כזה לא ודרשת פסיקה. מנגנון הפסיקות הוא יקר. אם כל הזמן נשתמש בפסיקות ויהיו לנו רכיבים מהירים, ייתכן שהמערכת שלנו לא תכל להתקדם, כי כל הזמן יהיו פסיקות ולא תרצו.
**לכן מערכת ההפעלה חוסכת בגישה היברידית- Two-phased approach:**
- נבצע דגימה (**polling**) לזמן קצר. אם הדגימה לא הסתיימה תוך זמן קצר, נשתמש בפסיקה. אחרת הרווחנו.

**שיפור נוסף שניתן להוסיף:**
בביצוע פקודת **i/o** יש שני חלקים: כתיבת המידע וכתיבת הפקודות.
כתיבת המידע היא בלבול של זמן. יש לנו את ה-**ram** ואת הדיסק, ואנחנו מעבירים נתונים מה-**ram** לדיסק (או ההפך, בקריאה).
**programmed i/o: המעבד שלנו מעביר את הזיכרון – הוא קורא מה-ram ומעביר לרכיב (או ההפך).**
זאת פעולה שהיא בלבול עבור המעבד שלנו. עדיף שהמעבד שלנו יעשה דברים אחרים מתוחכמים יותר, ואת הפעולה הטריוויאלית הזו נחסוך לו.
**Direct memory access (DMA)- זהו רכיב שכל תפקידו הוא העברת מידע (העברת זיכרון ממקום למקום).**
לרכיב הזה יש מעבד מאוד פשוט. הרכיב בא לחסוך למעבד את הפעולה הטריוויאלית של העברת המידע. אנחנו יכולים למנוע את הרכיב הזה, לומר לשלוח לו פקודות כמו לכל רכיב חומרה אחר, ובעצם נגיד לו לקחת את הזיכרון מה-**ram** ולשים אותו בדיסק ולהפך.
אנחנו נספק ל-**dma** 3 נתונים: המיקום בזיכרון (כתובת ב-**ram** שבה המידע נמצא), כמה מידע להעתיק, ומתי לקרוא / מתי לכתוב את המידע הלה (איזה רכיב).
ואז ה-**dma** ייקח מה-**ram** את המידע וישים ברכיב, או מהרכיב אל ה-**ram**.

**אם נסתכל על ציר הזמן:**
הדיסק שלנו עדיין עסוק בפקודה אחרת של תהליך c. תהליך A לו ורוצה לבצע פעולת **i/o**. קודם בשביל לבצע פקודת **i/o** היינו צריכים לחכות לפסיקה/לדגום. מה שעכשיו נעשה, נבצע **context switch** וניתן לתהליך אחר לרוץ. ברגע שהדיסק פנוי (הוא הודיע באמצעות פסיקה שהוא זמין), נשלח פקודה אל ה-**dma**. לא נכתוב את ה-**data** אלא נכתוב ל-**dma** מה אנחנו רוצים לעשות, ניתן לו את כל הפרטים שהוא צריך, ועכשיו הוא זה שיטפל בהעברת המידע. בזמן הלה, המעבד שלנו יכול לעשות מה שהוא רוצה, הוא לא תפוס. ה-**dma** כותב את ה-**data** ושולח את ה-**command** כלומר הוא עובד מול הדיסק, הדיסק מתחיל לעבוד וכאשר הוא מסיים הוא שולח פסיקה אל ה-**dma** ומודיע לו שהוא סיים. ברגע שהדיסק סיים, ה-**dma** מודיע לנו ואז המעבד יכול להמשיך לרוץ ולדעת שהפקודה הסתיימה.
- **החשיבות לכך שהדיסק שולח את הפסיקה ל-dma שהוא סיים ולא לנו:** ה-**dma** יודע לטפל גם בהעברות גדולות, ולכן אם יש לנו הרבה מידע להעביר אנחנו לא מעבירים בחלקים כמו לפני כן, אלא מספקים ל-**dma** את הכתובת בה הנתונים נמצאים ואת כמות המידע להעברה. כאשר הדיסק מסיים, ה-**dma** בודק אם יש עוד מידע בכתובת הנתונה ואם כן אז הוא בעצמו יכתוב את המשך המידע והתהליך. ה-**dma** ישלח לנו פסיקה כאשר הוא יסיים את כל הפעולה שביקשנו ממנו לעשות.

---

**תקשורת עם רכיב החומרה – קריאת הפקודות:**
איך אנחנו כותבים פקודות מכונה שקוראות מהמקלדת? שכותבות לדיסק? לאו פקוד שאינו נעשו קריאות מערכת, אלא פקוד של מערכת ההפעלה). יש שני דרכים לתקשר עם רכיבי חומרה (שני הדרכים בשימוש במערכות הפעלה):
1. **תקשורת באמצעות פקודות מכונה מיוחדות-** יש פקודות מכונה שנקראות **in, out** (לקרוא ולכתוב). הפקודות הללו מפרטות מספר שאינו מאילה רכיב חומרה אנחנו רוצים לקרוא או לאילה רכיב לכתוב לכל רכיב יש מספר ייחודי) וגם מפרטים כתובת ששנה לוקחים את המידע לכתיבה / מאחסנים את המידע לקריאה. הפקודות הללו "מיוחסות", אנחנו לא יכולים לכתוב אותן בקוד שלנו. אסור לנו המעבד לא ייתן לנו. אפשר להריץ את הפקודות הללו רק ב-**kernel mode**, לכן רק מערכת ההפעלה יכולה להריץ את הפקודות הללו.

למשל, יש לנו את המעבד, שני רכיבי חומרה אימינו ואת הזיכרון המשמש. אם אנחנו רוצים למשל לכתוב לדיסק, מערכת ההפעלה מריצה פקודת **out** אשר תגרום למעבד לכתוב ענן כלשהו מהזיכרון אל הדיסק, ו-**in** תגרום לקריאה מהמקלדת ואחסון במיקום בזיכרון שאותו בחרנו. השימוש בפקודות הללו מובטח, רק מערכת ההפעלה יכולה להריץ אותן וכך התקשורת עם רכיבי החומרה נעשית בצורה מוגנת.
**חיסרון (והסיבה לכך שלא נעצור כאן) לדרך התקשורת הזו:** זה לא תמיד נוח. אם אנחנו רוצים לקרוא המון נתונים, אז נקרא ל-**in** המון פעמים. ואם המשתמש רוצה לבצע מחשבת בעלת הרבה קריאות, כל פעם תהיה קריאת מערכת בשביל שמערכת ההפעלה תעשה עבור המשתמש **in** כי אסור לו לקרוא מהחומרה.

2. **memory mapped i/o-** גם למשתמש וגם למערכת ההפעלה תהיה גישה לרכיבי החומרה, ללא צורך בשימוש בפקודות מיוחדות והמעבר ל-**kernel mode**. פשוט ניקח את הזיכרון ונשתמש בו. הרי כבר יש לנו מנגנון של זיכרון וירטואלי בו יש חלקים של זיכרון / דפים שאנחנו יודעים למפות ל-**ram** או לדיסק וכו', אז נשתמש באותן מנגנון ונמפה לחומרה.
לדוגמא ניקח דף חלק מהזיכרון ונמפה אותו לחומרה. זאת יהיה לנו כמו מערך בקוד- כשנפנה לטא 0 במערך, אנחנו פונים לפיקסל הראשון במסך, ניתן לכתוב אליו, לשאול מה יש בו וכו'.
**הרעיון הוא:** אנחנו מקבלים מערך טיפוס כלשהו (יש קריאה שאנחנו יכולים לעשות, דומה ל-**mmap**, הקריאה הלו מחזירה מערך). המערך הלה מייצג רכיב חומרה כלשהו (בדרך כלל קובץ, ואם נרצה למשל את ה-V במערך, זה יהיה כאילו גשת לקית מספר 4 בקובץ). כך אין צורך בשימוש בפקודות מכונה מיוחדות קריאות מערכת פשוט כותבים למערך משנים את הערכים הכתובים בו וכוהו. בבקשת המערך, אנחנו שולחים מספר שאינו את הגודל שאנחנו הולכים לגשת אליו למשל נבקש מיפוי לרכיב, בגודל 300).

בזיכרון שלנו יש חלקים מיוחדים שאינם כאו מיוחדים (ע"י קריאת מערכת ומערכת ההפעלה). מהרגע בו חלק מהזיכרון סומן כמיוחד, כל פעם שניגש לאיזור המיוחד הלה, אנחנו בעצם ניגשים לדיסק. אנחנו יכולים למפות כל רכיב חומרה לשטח זיכרון כלשהו ואז כשאנו כאילו אנחנו ניגשים לרכיב החומרה, בלי קריאות מערכת או קריאת **in**.
- **מערכת ההפעלה לא ניתן לנו למפות דברים שאנחנו עלולים לשבש.**
למשל: לא נוכל לגשת לרגיסטרים של ההארד דיסק. מערכת ההפעלה לא תיתן לנו. אבל היא כן תיתן לנו למפות את הנתונים שבתוכו (למשל קובץ). כלומר היא לא תיתן לנו למפות רק דברים שאנחנו לא יכולים להזיק בהם.

--------------------------------------------------------------------------------------------------------------------------

אז יש לנו דרך לתקשר עם רכיבי החומרה, אבל צריך לזכור שיש לנו המון סוגים של רכיבי חומרה. למשל, יש המון סוגים של הארד דיסקים, מקלדות, דיסק און קים, ומערכת ההפעלה צריכה לדעת לדבר עם כולם. לה לא ריאלי ליצור מערכת הפעלה שיודעת לדבר עם כל רכיב חומרה בעולם. זה המון רכיבים, וגם- אם מחר יצא אחד חדש, היא לא תוכל לדבר איתו.

לשם כך קיים מנגנון **הדרייבר- מנהל ההתקן**, שהוא אבסטרקציה לתקשורת בין רכיבים. במקום שמערכת ההפעלה תכיר כל רכיב חומרה שקיים בעולם, היא פשוט מגדירה ממשק אחיד (שהדרייבר לה המימוש שלו). הדרייבר הוא קוד שנכתב את הממשק ויודע לתקשר עם רכיב חומרה מסוים (אחד או יותר, ייתכן דרייבר יחיד לכמה רכיבי חומרה). כעת כשמערכת ההפעלה מתקשרת עם המקלדת למשל, לא מעניין אותה איך המקלדת עובדת, היא קוראת לפונקציה כלשהי בדרייבר לשם קריאת נתונים. הדרייבר יתקשר עם הרכיב, הוא ספציפי עבורו ויודע מה צריך לעשות, ויחזיר את התשובה למערכת ההפעלה.
- במערכת ההפעלה נצטרך מנגנון של טעינת קוד.
התקנת דרייבר במחשב היא בעצם טעינת קוד קיים שישנו כתב, לתוך מערכת ההפעלה.
ואותן רגע שמערכת ההפעלה מכירה את הקוד הזה, כל פעם שהיא תיגש לרכיב החומרה המתאים, היא תפעיל את הקוד הזה.

מאחר ודרייברים ניגשים לרכיבי חומרה, הם רצים ב-**kernel mode**, יש להם הרשאות מיוחדות לעשות הרבה יותר מאשר תכניות משתמש.
- **דרייברים הם הגורם העיקרי לבאגים במערכת ההפעלה.**
באגים במערכת ההפעלה עצמה הם נדירים. כמעט תמיד הבאגים מגיעים מתוך הדרייברים.
- בלינוקס, 70% מהקוד של מערכת ההפעלה הוא דרייברים.

--------------------------------------------------------------------------------------------------------------------------

**דיסקים קשיחים:** הפכו להיות היום פחות ופחות נפוצים.
דיסקים קשיחים הם דיסקים שיש בהם חלקים מסתובבים. רוב הטכנולוגיה שיש לנו היום מסתמכת על ההתנהגות של דיסקים.

**מבנה הדיסק:**
- עבור מערכת ההפעלה, דיסק קשיח (**hard disk**) נראה כמערך גדול של סקטורים (כל תא במערך נקרא סקטור).
- כל סקטור הוא בדרך כלל בגודל 512 בתים (אם זה דיסק סטנדרטי), ואנחנו יכולים לכתוב אליו או לקרוא ממנו (קוראים/כותבים 512 בתים בבת אחת כל פעם).
- הסקטורים ממוספרים מ-0 עד n-1, כמו במערך.
- כאשר מערכת ההפעלה מתקשרת עם דיסק מסוים, היא שולחת פקודות למשל כתיבה של 512 בתים לסקטור 7).
- לפעמים אנחנו עושים פעולות על כמה סקטורים בבת אחת. למשל, אם נרצה לכתוב **1KB** נתונים, זה שני סקטורים. לה אפשרי, אבל החומרה שלנו לא מבטיחה לנו שום דבר. כלומר ייתכן שנצליח לכתוב אחד מבין הסקטורים והשני ייכשל. החומרה מבטיחה שבעת ביצוע פעולה על סקטור בודד: או שהכל נכתב או ששום דבר לא נכתב. לא ייתכן מצב בו נכתבו רק חלק מ-512 הבתים. לה מתבצע בבת אחת. לכן בעת ביצוע פעולה על יותר מסקטור אחד, ההבטחה היא פר סקטור. אנחנו לא יודעים איך הפעולה תתבצע, ואנחנו אפילו לא יודעים את הסדר בה ייכתבו, אם בכלל. אין לכך חוקיות.
- **Torn Write:** מקרה בו עשינו כתיבה גדולה, ורק חלק ממנה הצליח (מכל סיבה שהיא). במצב לה, קיבלנו מצב לא תקין, כי ייתכן שחלק מהנתונים נכתבו, וחלק לא.
- ההנחה המאוד נפוצה עבור הארד דיסקים: גישה סדרתית היא הכי מהירה. כלומר, אם נרצה לקרוא / לכתוב, הרבה יותר מהיר לעשות זאת לפי הסדר: כתיבה למקום מסוים, סיום ומעבר לכתיבה במקום אחר. לה הרבה יותר מהיר מאשר לכתוב בגישה אקראית (פעם לכתוב להתחלה, לסוף, לאמצע), והסיבה, לומר כל הזמן לקפוץ ולבצע פעולות במיקומים שונים על הדיסק).

---

**בתוך הדיסק יש לנו:**
1. **פלטה (platter)-** הצלחת היא דיסק מגנטי, שעליו באופן מגנטי יושבים הנתונים שלנו (הביטים). לצלחת יש שני צדדים, נתונים נשמרים משני הצדדים. כל צד של הצלחת נקרא **משטח (surface)**.
- בכל דיסק יש פלטה אחת או יותר, כאשר הצלחות מחוברות יחד על **מוט שנקרא spindle**. המוט הזה מחובר למנוע והוא בעצם מסובב את הצלחות בכיוון מסוים (פתוח או יותר כל הזמן). הסיבוב של הצלחות הוא במהירות קבועה שנונה (זה חלק מהנתונים של הדיסק, לה נקרא **RPM- rotations per minute** - כמות הסיבובים שהמוט מבצע בדקה). כל הצלחות מסתובבות ביחד.
כל משטח של צלחת (**surface**), מחולק לעיגולים- **כל עיגול נקרא track** – זה האזור בו אנחנו שומרים את הנתונים (נזכרו הפרדה בין הנתונים). יש לנו **track0, track1, track2**.
סט של עיגולים (**tracks**) זהים על פני צלחות שונות נקראים **צילינדר (cylinder)** (אותה טבעת בכולם, למשל רק העיגול החיצוני בכל הצלחות).

הדיסק מחולק לסקטורים (אותם סקטורים מהמערך מקודם), שביחד לה נראה כמו מערך, אבל בפועל לה יושב על הדיסק באופן מגנטי (פיזי), וכל סקטור ממוספר לפי הסדר (0-7) ואז (8-15) וכן הלאה.. בפועל יש הרבה יותר tracks והרבה יותר סקטורים, זו רק דוגמה מוקטנת.

בדוגמא הזו, הצלחת מסתובבת נגד כיוון השעון, מחולקת ל-**tracks** וכדי לקרוא נתונים מהדיסק, יש לנו **ראש קורא כותב (disk head)-** הראש הזה יודע לקרוא/לכתוב נתונים לכל הסקטורים שעוברים דרכו, תוך כדי סיבוב. הראש קורא כותב מחובר לזרוע שיודעת להזיז אותו פנימה והחוצה. הראש קורא כותב הוא משני הצדדים של הזרוע. אם נסתכל מהצד על הדיסק שלנו:

יש לנו את הצלחות, כל אחת מחולקת ל-**tracks**, כל רצף של עיגולים זהים הוא צילינדר וכל **track** מחולק לסקטורים.
הזרוע מחזיקה שני ראשים קוראים כותבים- אחד לכל משטח. כל הראשים האלה יכולים לקרוא באופן כללי את הנתונים שעוברים דרכם, אבל רק ראש קורא כותב אחד יכול לקרוא / לכתוב בכל רגע נתון (קשור לרוחב פס, יש מספיק רק עבור ראש יחיד).

--------------------------------------------------------------------------------------------------------------------------

- **Servo burst -** כל כמה סקטורים, יש אזור מיוחד שמהווה הפסקה עד הסקטור הבא, שכתובים בו נתונים על מיקום (כאילו מיקום הראש קורא כותב). זו עזרה לדיסק, לה צרוב על הכונן. אם הראש קורא כותב לא לאן בדיוק איפה שהוא נמצא, הוא לא יודע מתי להבין את זה והוא יתחיל בהתחלה. כלומר תוך כדי עבודה, כל ראש קורא/כותב שזה רלוונטי עבורו- קורא את ה-**servo burst** ויודע לתקן את עצמו (הלרוע מזיזה אותו למקום שהוא צריך בדיוק).

- כל החלקים בדיסק הם חלקים נעים, תולדה של חלקים מכניים לוקחת זמן. נראה כמה זמן:
נניח שאנחנו רוצים לבצע פעולה בדיסק. ביצוע פעולת קריאה כלשהי. מערכת ההפעלה קיבלה את לה, ונראה, הכניסה שהנתונים שאנחנו רוצים נמצאים בסקטור 12 בדיסק. לה נמצא ב-**track האמצעי**. כרגע הראש קורא/כותב נמצא מעל סקטור 12 ב-**track החיצוני**. בשביל לקרוא את הנתונים, יש צורך ב-**seek**- שזו בעצם הזזת הזרוע למקום הנכון. היא כרגע ב-**track החיצוני** ואנחנו רוצים שהיא תזלזל ל-**track הפנימי** (שהראש קורא/כותב יהיה מעל ה-**track הפנימי**).
אז הזרוע ללה לאט, עד שהיא מגיעה ל-**track** הנכון ומייצבת כרגע שהראש קורא/כותב נמצא ב-**track** הנכון, הוא צריך לחכות לסיבוב. הוא נמצא שם והוא לא יכול ללכת יותר על ה-**track**, הוא צריך לחכות ש-12 יגיע אליו.
ברגע ש-12 הגיע לראש קורא כותב, הסקטור המתאים הגיע אליו ועכשיו אנחנו יכולים לקרוא את הנתונים הרצויים. תוך כדי שה-**track** עובר מתחת לראש קורא/כותב, הוא קורא את הנתונים ומעביר אותם לספר 1773 (רגיסטר של data שראינו קודם) וברגע שהוא סיים את כל לה, הוא סיים את הפעולה והסתיימה.

--------------------------------------------------------------------------------------------------------------------------

**מה כוללת כל פעולה ואיך נחשב כמה זמן כל פעולה לוקחת?**
**הפעולה seek:** בפעולה זו, הזרוע מזיזה את הראש קורא/כותב ל-**track** הנכון.
לה כולל כמה דברים (כשאנחנו עושים הזזה, זה לא מגיע מיד למקום כן הוא צריך להיות):
1. בבית תנועה (**Acceleration**)- כאשר לה מכני, אנחנו צריכים להתחיל קודם.
2. **Coasting-** הגעה למהירות המקסימלית לאחר ההאצה והתקרבות ל-**track** אליו רצינו להגיע.
3. **Deceleration –** ההאטה של הזרוע.
4. **settling-** לאחר שהזרוע נמצאת על ה-**track** המתאים, הראש קורא/כותב ממקם בדיוק במקום הנכון.
רק הזמן של ההתמקמות בלבד לוקח בין **0.5-2 ms**. במושגים של מחשב לה המון זמן, המעבד שלנו יכול להריץ המון פקודות בזמן הזה.
* **כל ה-seek כולל לוקח בין 4-10 ms.**
לאחר שעשינו **seek**, צריכים לחכות לסיבוב (**rotation**) ואחרי שנחכה לסיבוב, רק אז נוכל להעביר את המידע ולבצע את הפעולה שרצינו לבצע.
כל אלה יחד, עבור פעולה אחת של קריאה.

--------------------------------------------------------------------------------------------------------------------------

**הפעולה rotation:** נניח שאנחנו ב-**track** הנכון ואנחנו רוצים לקרוא סקטור שנמצא קו.
נניח שסיבוב שלם לוקח שניה (360 מעלות). כמה זמן אנחנו צריכים לחכות עד שנעלה? אנחנו רוצים לקרוא, בממוצע? אנחנו לא יודעים איפה ה-**track** שאנחנו מחפשים. אם בממוצע ייקח לנו חצי שניה (כי יכול להיות שייקח לנו במרחק של שניה מאיתנו, יכול להיות שהוא ממש קרוב אלינו וזאת הגיע אלינו). בממוצע נפטר לחכות חצי סיבוב. בשביל להבין כמה זמן לוקח ה-**rotation**, נצטרך להבין כמה זמן לוקח סיבוב ולקחת חצי מזה.

**חישוב הזמן שלוקח לסיבוב:**
נסתכל על הנתונים של הדיסק. ענן סטנדרטי של הדיסקים הוא שהם עושים 7200 סיבובים לדקה (**7200 RPM**). אנחנו רוצים לדעת כמה זמן לוקח סיבוב אחד, עדיף ביחידות של מילישניות.
7200 סיבובים בדקה = 120 סיבובים בשנייה = סיבוב אחד ב- 8.3 מילישניות.
**לכן זמן ה-rotation הממוצע שלנו הוא חצי מלה = 4.15 מילישניות.**

--------------------------------------------------------------------------------------------------------------------------

**הפעולה transfer data:** כמה זמן לוקח לנו להעביר את המידע? אנחנו רוצים לקרוא את סקטור 12 שהוא סקטור אחד והוא 512 בתים. אנחנו רוצים לדעת כמה זמן ייקח לנו לקרוא את הסקטור הזה. בכל דיסק חוץ מסיבובים לדקה, מציג גם נתון של קצב העברה מקסימלי (הוא בדרך כלל 100 מגה לשנייה ומעלה). אנחנו יודעים שהדיסק שלנו מעביר 100 מגה בייט לשנייה. אנחנו רוצים לדעת כמה זמן ייקח לו להעביר 512 בתים. בשנייה אחת אנחנו מעבירים 100 מגה בייט, אז ב- 1/100 שניות אנחנו מעבירים מגה בייט אחד. אבל אנחנו רוצים לחשב בבתים- נזכיר ל-**kb** ואז לבתים.
אם לוקח לנו 1/100 שניות להעביר מגה אחד (שהוא **1024kb**), אז זה אומר
שלוח לנו **1/(100*1024) שניות להעביר 1kb.**
אז נחלק שוב ב-1024 כדי לעבור לבתים – ייקח לנו
**1/(100*1024*1024) שניות להעביר בייט אחד.**
אבל אנחנו רוצים במילישניות, אז נחלק את הכל ב-1000. לה הזמן להעברת בייט בודד במילישניות. אנחנו רוצים להעביר 512 בתים ולכן נכפול ב-512.
(החישוב מפורט בצד שמאל). התוצאה הסופית היא 5 מיקרו שניות.

[מתמטיקה בכתב יד:]
$100 \frac{MB}{s} = \frac{1}{100} \frac{s}{MB}$
$MB = 10^3 KB = 1024 KB$
$\frac{1}{100 \times 1024} \frac{s}{KB} = \frac{1}{100 \times 1024^2} \frac{s}{B} = \frac{1000}{100 \times 1024^2} \frac{ms}{B}$
$s = 1000 ms$
$= \frac{10 \times 512}{1024^2} ms$ (עבור 512 בתים)

---

**i/o time:** וסכום את כל הנתונים שקיבלנו, כי הזמן שייקח לנו לקרוא סקטור יחיד הוא:
$T_{I/O} = T_{seek} + T_{rotation} + T_{transfer}$

כלומר הזמן שייקח לנו לעשות **seek + הזמן שייקח לנו לחכות לסיבוב + הזמן שייקח לנו להעביר את המידע.**
לנו העברת המידע הוא זניח מבחינתנו, הוא כ"כ קטן ולכן הוא זניח. הזמן שנשאר לנו הוא ה-**seek** וה-**rotation**.
אל ייקח לנו בין 8 ל-14 מילישניות להעברת 512 בתים.

ניקח מספר נוח במאנד, נניח שזה לוקח לנו 10 מילישניות.
מעניין אותנו לחזור לשאלה- כמה מהיר הדיסק שלנו עד עכשיו חישבנו לזמן לקריאה של סקטור בודד. אנחנו רוצים לדעת מה הקצב. את הקצב אנחנו מודדים בדרך כלל ב-מגה בייט לשנייה (**MB/SEC**).

**הנוסחה לחישוב הקצב:**
$\text{I/O Rate: } R_{I/O} = \frac{Size_{transfer}}{T_{I/O}}$

אנחנו יודעים שכל 10 מילישניות אנחנו מעבירים 512 בתים. אנחנו רוצים לתרגם את לה למגה בייט לשנייה. נתחיל לפי הנוסחה: גודל / זמן ולכן אנחנו מעבירים 512 בתים ב-10 מילישניות. נרצה לעבור לשניות (כי מדובר על מגה בייט לשנייה).
10 מילישניות = 10/1000 שניות, לכן מדובר ב- 512 בתים ב- 10/1000 שניות.
נקבל שאנחנו מעבירים **512,000 / 10 בתים לשנייה.**
אנחנו לא רוצים להתעסק ביחידות של בתים, אלא ביחידות של מגה בייט ולכן נחלק את כל המספר הלה ב-1024 בחזקת 2. לה הקצב שלנו, ביחידות של מגה בייט לשנייה.

[מתמטיקה בכתב יד:]
$\frac{10 \text{ ms}}{512 \text{ B}} = \frac{512 \text{ B}}{10 \text{ ms}} = \frac{512 \text{ B}}{\frac{10}{1000} \text{ s}} = \frac{512000}{10} \frac{\text{B}}{\text{s}} = \frac{51200}{\text{1024}^2} \frac{\text{MB}}{\text{s}}$
$\approx 0.05 \text{ MB/s}$

--------------------------------------------------------------------------------------------------------------------------

מה שאנחנו חושבנו, לה המקרה הגרוע ביותר- בו אנחנו קוראים רק סקטור אחד בכל פעם בלבד. נניח ואנחנו רוצים לקרוא כמה סקטורים ביחד, למשל 100 סקטורים רצופים. עכשיו לא צריך לעשות **100 rotation** ו-**100 seek** פעמים, כי כבר הגענו למקום. כלומר, אם היינו קוראים 100 סקטורים רצופים, היינו צריכים לעשות **seek פעם אחת ו-rotation פעם אחת,** ואז היינו עושים 100 פעמים. אלו אחריו שזמן ה-**transfer** הוא הכי מהיר והוא זניח. לה אומר לנו: קריאה באופן סדרתי היא הרבה יותר מהירה. אם כבר הגענו למקום מסוים בדיסק, שווה לנו לקרוא מהמקום הזה והלאה, לה יהיה הרבה יותר מהיר מאשר בכל פעם לקרוא ממקומות שונים.

--------------------------------------------------------------------------------------------------------------------------

יש לנו דוגמאות לשני הארד- דיסקים: צ'יטה וברקודה (עם נתונים אמיתיים): אנחנו יכולים לחשב את הקצב שלהם בפועל. הקצב שנתון לנו הוא קצב ההעברה המקסימלי. אנחנו יכולים לקחת תרחישים שונים, איך משתמשים בדיסק, ולהבין מהם מה לה אומר על התוכנית שלנו. מה לה אומר על הביצועים שיהיו לנו. למשל: תרחיש אקראי: נעשה קריאות ממקומות שונים בדיסק, של **4KB** בכל קריאה. זואת זאת, נסתכל על תרחיש סדרתי: נגש לנקודה ונקרא ממנה והלאה **100MB**. ברגע שנעשה את החישובים האלה (בשיעור הבא) נראה את הפער המשמעותי בהארד דיסקים בין קריאה סדרתית לקריאה אקראית. יש מקומות שאנחנו פותחים קובץ וקוראים אותו לפי הסדר, לה יהיה מהיר בערך פי 30 מאשר אם נקרא את קצהו מכל מיני מקומות שונים ונקרא מהם. ה-**seek** וה-**rotation** הם מי שיקבעו את העלות הכוללת, כי הם החלק הכי יקר.

| Feature | Cheetah | Barracuda |
| :--- | :--- | :--- |
| Capacity | 300GB | 1TB |
| RPM | 15,000 | 7,200 |
| Average Seek | 4 ms | 9 ms |
| Max Transfer | 125 MB/s | 105 MB/s |
| Platters | 4 | 4 |
| Cache | 16 MB | 16/32 MB |

