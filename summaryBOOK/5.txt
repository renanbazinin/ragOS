מערכות הפעלה - שיעור 5

אמרנו שאם לא קראנו ל-wait עבור תהליך שהסתיים, התהליך הזה נקרא "זומבי".
כלומר, התהליך עצמו הסתיים אבל עדיין קיימת רשומה של התהליך בטבלת התהליכים וגם בעץ התהליכים.
wait לא רק ממתינה שהתהליך יסתיים, אלא גם מפנה תהליכים שהסתיימו.

שתי דרכים להימנע מזומבים:
1. לבצע קריאה ל-wait : אם נעבור כל תהליך בן שיצרנו ונקרא ל-wait ונתמין שהוא יסיים, אז לא יהיו לנו תהליכים זומבים.
2. סיום תהליך האב : אם תהליך האב הסתיים בעצמו, כל תהליכי הבנים שלו הופכים להיות תחת init-, ו-init לא משאיר זומבים.

- שני הדרכים הללו לא מספיקות, למשל ה-shell, הטרמינל שלנו: מריץ פקודות והוא גם לא רוצה להשאיר זומבים.
אם הטרמינל תמיד היה עושה wait לתהליכים, אז כשהיינו כותבים למשל 10 sleep היינו נתקעים במחכה לפי הפרמטר שכתבנו, אז הטרמינל מחכה. בעצם הוא קרא ל-wait ורק אחרי שה-sleep יסתיים הוא ימשיך בקוד שלו. אבל הטרמינל מריץ הרבה תהליכים והוא יודע גם להריץ דברים ברקע.
אם נכתוב 10 sleep & - סימן ה-& אומר לו לא להמתין, כלומר להריץ את התהליך של ה- 10 sleep אבל לא לחכות לו, לא לבצע wait. זה אומר שאפשר להמשיך לכתוב פקודות תוך כדי. אבל אם אנחנו לא עושים wait, והטרמינל גם לא הסתיים, אז לכאורה היה נשאר זומבי! אבל הטרמינל מתמודד עם זומבים. אנחנו גם רוצים לדעת איך מתמודדים עם זומבים.

הפקודה PS : הפקודה מציגה לנו את כל התהליכים שרצים תחת התהליך הזה (אותו ואת כל מי שנתחתיו בעץ).
להו הפלט של הפקודה ps (הרצה ב-wsl).
ה-bash זה הטרמינל, ותחתיו יש פקודה אחת (ps שהרצנו).

PID TTY          TIME CMD
  9 tty1     00:00:00 bash
 71 tty1     00:00:00 ps

אם נכתוב 10 sleep & ונכתוב ps לאחר מכן, נוכל לראות שה-sleep הוא חלק מפלט הפקודה ps.
אבל אחרי שה-sleep ייגמר, כבר לא נראה אותן כחלק מפלט הפקודה ps. זה אומר ש-sleep אינו זומבי!

נראה דוגמא לקוד שגורם לזומבים:
הקוד הזה מבצע fork, ואנחנו שהצלחנו ומבדיל בין תהליך הבן לתהליך האב.
תהליך הבן מדפיס פלט ומסיים, ולעומת זאת תהליך האב מדפיס גם פלט אבל אז נכנס ללולאה אינסופית.

```c
int main(int argc, char *argv[])
{
    printf("hello world (pid:%d)\n", getpid());
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
        exit(1);
    }
    else if (rc == 0) {
        // child (new process)
        printf("hello, I am child of %d (pid:%d)\n",
               getppid(), getpid());
    }
    else {
        // parent
        printf("hello, I am parent of %d (pid:%d)\n", rc, getpid());
        while (1);
    }
    return 0;
}
```

מה שיקרה זה בדיוק המצב של זומבי: p ירוץ, עשה fork, יצר תהליך בן, תהליך הבן מסתיים אבל p ימשיך לרוץ בלולאה אינסופית. אם נריץ את הקוד הנ"ל עם סימן & שייתן לנו להמשיך לכתוב פקודות תוך כדי שהתהליך רץ, ונריץ את הפקודה ps, נוכל לראות שיש תהליך זומבי אחד שה-pid שלו זה ה-pid של הקוד שהרצנו. אבל יהיה זומבי נוסף- שהוא תהליך הבן של הקוד של הזומבי (הבן שלו רץ, הסתיים, אבל לא נעשה עליו wait, וגם תהליך האב לא הסתיים ולכן תהליך הבן נותר גם הוא זומבי). על תהליך זומבי תהיה כתובה המילה "defunct" – להו תהליך שהסתיים אבל הרשומה שלו עדיין קיימת בטבלת התהליכים.

איך נדאג שהתהליך לא יישאר זומבי (באופן ידני)?
ניתן פשוט להרוג את תהליך האב (שעדיין רץ). הפקודה 9- kill מקבלת process id של תהליך והורגת אותו. ברגע שהרגנו את תהליך האב, תהליך הבן הופך להיות הבן של init שידאג לפנות אותו.
אז אם נקרא עכשיו ל-ps נראה שאין יותר זומבים.
מדוע מערכת ההפעלה לא עושה פינוי לתהליכים שהם זומבים? מכיוון שתהליך האב עלול לעשות לתהליך הבן wait.

איך נכתוב קוד שלא משאיר זומבים?
הפקודה wait יכולה לקבל ארגומנטים. אחד מהארגומנטים אומר כמה זמן לחכות. אפשר להפעיל כך את wait ולהגיד לה לא לחכות עד שהבן יסיים, אלא לחזור לא משנה מה, לפי ערך ההחזר נדע מה קרה.
אם אף בן לא סיים או שאין תהליכים בנים, נקבל ערך החזר 1-, אם כן זה יפנה.
זה בעצם אומר- תפנה תהליך אחד ותחזור, אם אין מה לפנות, תחזור בכל מקרה.
- כך ה-shell עובד. כל כמה זמן הוא עושה לולאת wait שאינה ממתינה, היא פשוט מפנה את כל התהליכים שסיימו, ואז היא ממשיכה הלאה.
אבל זה לא נוח. אז יש פקודה שיודעת לפנות את מה שסיים (בלי להמתין), אבל אם אנחנו כותבים קוד, זה לא נוח להכניס wait בכל מיני מקומות. נרצה דרך נוחה יותר לפנות זומבים.

מנגנון signals:
מנגנון זה נקרא גם לפעמים פסיקות תוכנה. אבל חשוב להבין שזו לא פסיקה.
פסיקה- אירוע שמערכת ההפעלה מקבלת - יכול להיות אירוע חיצוני כמו לחיצה על מקש במקלדת או הזזה של העכבר או פסיקת שעון, אירוע חיצוני שמגיע מהמעבד ומפעיל קוד מיוחד של מערכת ההפעלה, או אירוע פנימי כמו קריאת מערכת או גישה לזיכרון לא תקין.
בשביל לטפל בפסיקה יש למערכת ההפעלה טבלה של כתובות שאומרת איך מטפלים בכל פסיקה, וכשקורית פסיקה מסוימת, המעבד מסתכל על התא המתאים ומריץ את קטע הקוד של ה-kernel לטיפול באירוע זה.

signals- רעיון דומה עבור תהליכים. אם נגיד שפסיקה זה כמו אירועים במערכת ההפעלה, אז signals זה אותו דבר עבור תהליכים. לכל תהליך יש מעין טבלת אירועים כזו, של משהו שנקרא signal, ולכל אירוע יש קטע קוד שמטפל בו. ההבדל הוא שלכל תהליך יש את הטבלה הזו, ואנחנו יכולים להשפיע על הטבלה הזו.
בעצם סיגנלים זה אירועים של התהליך, הודעות שמערכת ההפעלה רוצה להודיע לתהליך שלנו. סיגנלים יכולים גם לשמש לתקשורת: אם תהליך אחד רוצה להודיע משהו לתהליך אחר (לשלוח סיגנל).
יש כל מיני סיגנלים וכבר היום ראינו שניים. כשהרגנו את הקוד של הזומבי שנכנס ללולאה אינסופית כאשר לחצנו

ctrl+c כדי לעצור את פעולת התהליך. זהו אינו צירוף מקשים מיוחד במחשב שלנו. כל מה ש-ctrl+c עושה זה לשלוח סיגנל מיוחד (שנקרא keyboard interrupt) לתהליך שלנו שרץ כרגע, ואומר לו לעצור. כשלוחצים ctrl+c, ה-shell קולט את המקש הזה ושולח סיגנל. זו מוסכמה שקיימת בכל מיני מקומות. אנחנו יכולים לבנות shell שבו צירוף מקשים אחר בו יגרום לכך.

סוגי סיגנלים:
יש 256 סוגי סיגנלים. הסיגנל שנשלח כאשר אנחנו לוחצים ctrl+c הוא סיגנל שנקרא SIGINT. סיגנל זה הוא keyboard interrupt.
יש סיגנל שנקרא SIGSEGV- אם כתבנו קוד והוא קרס כי קיבלנו segmentation fault, מה שקרה זה שהוא ניגש לזיכרון שלא היה תקין, ומערכת ההפעלה זיהתה את זה ושלחה לו סיגנל והתהליך הוציא את ההודעה הזו וקרס. סיגנל נוסף שנקרא SIGKILL- מבקש מהתהליך לעצור.
הסיגנל העיקרי שמעניין אותנו היום: SIGCHILD- בכל פעם שתהליך בן מסתיים, מערכת ההפעלה שולחת לתהליך האב את הסיגנל הזה שאומר שתהליך בן כלשהו שלו הסתיים. ואז במקום שנחכה לתהליך בן, מערכת ההפעלה תוכל להודיע לנו שתהליך בן הסתיים ונוכל לטפל בזה.

אם נרצה שבעת לחיצה על ctrl+c יקרה משהו אחר? הטבלה של טיפול בסיגנלים היא בשלטוננו, היא נמצאת ב-kernel, אין לנו גישה ישירה אליה אבל אנחנו יכולים לשנות את הערכים שכתובים בה ע"י פקודה של מערכת ההפעלה, ע"י קריאת מערכת.
אפשר לעשות זאת לחלק מהסיגנלים. יש שני סיגנלים שבהם אנחנו לא יכולים לשלוט: SIGKILL ו- SIGSTOP. ברגע שסיגנל כזה נשלח לתהליך שלנו מערכת ההפעלה תופסת אותו ואנחנו לא יכולים לשלוט בו. אבל כל שאר הסיגנלים מטופלים ע"י signal handler- זוהי כמו פונקציה בקוד. בקוד שלנו, באופן שקול לנו, יש כל מיני פונקציות לטיפול בסיגנלים. יש signal handler לכל סיגנל, שהוא אומר מה לעשות במקרה שנתקבל הסיגנל הזה. כולם אותות לערכי ברירת מחדל כלשהם. למשל, SIGINT אותנו גורם לעצירת התהליך.
ערכי ברירת המחדל מתקבלים בתהליך האב (זה חלק מהדברים שמועתקים ב-fork), ואנחנו יכולים להחליף אותם ע"י קריאת מערכת שנקראת ()sigaction.

קטע קוד שעושה את ההחלפה הזו:
הדבר האחרון שקורה בקטע הקוד הזה: לולאה אינסופית ((1)while). אם נריץ אותו הוא ייכנס ללולאה אינסופית. לחיצה על ctrl+c והתהליך לא נעצר. התהליך הזה הגדיר שהוא מתעלם מ-sigint, במקום לעצור, הוא מתעלם. עכשיו לא ניתן לעצור אותו עם ctrl+c. במקרה כזה אם נרצה לעצור- נלחץ ctrl+z וזה יחזיר לנו את השליטה בטרמינל.

```c
// signall.c
int main(int argc, char *argv[])
{
    struct sigaction act;
    sigemptyset(&act.sa_mask);
    act.sa_handler = SIG_IGN;
    act.sa_flags = 0;
    
    if (sigaction(SIGINT, &act, NULL) == -1) {
        fprintf(stderr, "sigaction failed\n");
        exit(1);
    }
    
    while (1);
}
```

בשורה 5 של המיין מבצעת קריאת מערכת ל-sigaction (כמו כל קריאת מערכת היא עלולה להיכשל ולהחזיר 1-). אם היא לא נכשלה, אז היא גורמת לשינוי בטיפול כל פעם שמתקבל הסיגנל שכתוב כארגומנט הראשון שלה. השינוי בטיפול יהיה פעולה לפי הארגומנט השני. הארגומנט השני ( act& ) הוא struct שיש בו כל מיני שדות שאומרים מה לעשות במקרה שנתקבל סיגנל. זה בעצם אומר למערכת ההפעלה להשתמש בנתונים שבטבלה ולשנות את הסיגנל שכתבנו. נחזור לשורה הראשונה במיין: יש struct מסוג sigaction שקוראים לו act.
* מבחינתנו כרגע הדגלים הם תמיד 0.
בשורה ה-3 במיין: יש struct הוא act. בתוכו את השדה sa_handler שהוא מצביע לפונקציה שמערכת ההפעלה תקרא לה כל פעם שנתרחש הסיגנל. אצלנו בקטע קוד הזה לא שמנו פונקציה אלא קבוע שנקרא SIG_IGN – הכוונה בקבוע הזה: אנחנו לא רוצים שיקראו לפונקציה, אנחנו רוצים להתעלם מהסיגנל הזה.
אל הקריאה ל-sigaction אומרת שבכל פעם שנתקבל הסיגנל sigint, נסתכל בסטרוקט act. הארגומנט השלישי בקריאה ל-sigaction הוא מצביע לסטרוקט, אם נרצה לדעת מה היה בטבלה לפני ששינינו, אז נשים כאן מצביע. אם לא נשים אז נכתיר NULL.

----------------------------------------------------------------------------------------------------------------------------------

אם לא נרצה להתעלם מה-sigint ונרצה שמשהו אחר יפעל במקום? אם הקוד הזה לא ייוצרו זומבים. הקוד הזה מאתחל את הסטרוקט שלנו ומגדיר את הטיפול בסיגנל. הפעם הטיפול לא יהיה התעלמות, ניקח את הטיפול של sigchld ונרצה שכשנתקבל הסיגנל, יקרא לפונקציה אחרת. לכן ב- sa_handler נתן את השם של הפונקציה שנרצה שפעל (היא לא חייבת להיקרא signal handler).
החתימה של הפונקציה צריכה להיות כפי שכתוב- היא מחזירה void ומקבלת int.
אז אנחנו קוראים ל-sigaction בדיוק כמו מקודם, נשנה את sa_handler ל- sigchld_handler. המשמעות היא שבכל פעם שנתקבל סיגנל sigchld, מערכת ההפעלה תקרא לפונקציה שכתבנו לה.
- מי שייכנס ל-if זה רק תהליך האב, הוא נכנס ללולאה אינסופית, אבל זה לא משאיר זומבי, כי ברגע שתהליך הבן יסיים, מערכת ההפעלה תשלח סיגנל sigchld לאבא, באותו רגע תהליך האב יקרא לפונקציה signal_handler בעקבות הסיגנל שבתוכה מתבצעת הקריאה ל-wait. כלומר, במקום לחכות באופן יזום, כאשר תהליך הבן מסתיים, wait פשוט ימחק אותו ולא יישארו זומבים.
שיטה נוספת למנוע זומבים- כפי שכתבנו מקודם: אם במקום ignore היינו רושמים SIG_IGN, היינו אומרים שבכל פעם שנתקבל הסיגנל sigchld אנחנו מתעלמים ממנו. אך ורק במקרה כזה של התעלמות מסיגנל sigchld, מערכת ההפעלה לא תיוצר זומבים. כלומר, היא מיד תפנה אותו ורק לא תודיע לו, כי הוא

```c
// signal2.c
void signal_handler(int signal) {
    if (signal == SIGCHLD) {
        int rc = wait(NULL);
        printf("child terminated %d (pid:%d)\n", rc, getpid());
    }
}

int main(int argc, char *argv[])
{
    struct sigaction act;
    sigemptyset(&act.sa_mask);
    act.sa_handler = signal_handler;
    act.sa_flags = 0;
    
    sigaction(SIGCHLD, &act, NULL);
    if (fork()) {
        while (1);
    }
}
```

רואה שאנחנו מתעלמים מ-sigchld. צריך לשים לב לא להשתמש ב-wait יותר מפעם אחת.

()kill - קריאת מערכת נוספת:
זו קריאת מערכת ששולחת סיגנל לתהליך אחר (יש סיגנל שנקרא kill, אבל קריאת המערכת הזו לא בהכרח את הסיגנל kill). הקריאה הזו מקבלת מזהה תהליך (process id) וסיגנל, ושולחת את הסיגנל לתהליך המתאים. אפשר לשלוח איזה סיגנל שרוצים, לאיזה תהליך שרוצים, אם יש לנו את ההרשאות לכך.

כשכתבנו בטרמינל : 9- kill pid : יש תוכנה שנקראת kill שקוראת את הארגומנטים וקוראת לקריאת המערכת kill עם ה-pid שכתבנו ועם המספר סיגנל שיש לאחר המינוס.

איך ה-shell עובד?
ה-shell פועל בלולאה אינסופית עד שאנחנו יוצאים ממנו. כל פעם הוא קורא את הפקודה הבאה מהמשתמש (ע"י read_user). ברגע שקראנו את הפקודה הבאה, נניח שהיא הייתה 10 sleep ונעשה fork, כלומר נוצר תהליך בן שהוא בעצם שכפול, גם הוא bash. עכשיו יש לנו שני תהליכים- אב ובן.

בתהליך הבן אנחנו עושים execvp, שזה כבר לא מריץ את ה-bash, אלא את sleep 10.
לעומת זאת, תהליך האב עושה wait ומחכה עד שהתהליך הבן יסיים, וברגע שהתהליך הבן סיים, תהליך האב חוזר ללולאה וקורא את הפקודה הבאה וכן הלאה.

* How does a shell work?
  * Read user command
  * fork() a child
  * Set up process (e.g., redirection)
  * exec() relevant program
  * Wait for it to finish
  * Repeat

```c
while (1) {
    char **args = read_user();
    pid_t rc = fork();
    
    if (rc == 0) {
        /* set up process */
        execvp(args[0], args);
    }
    else {
        /* if not background */
        waitpid(rc, NULL, 0);
    }
}
```

אם נשים & (הרצה ברקע) ולא נרצה לחכות, אז הוא לא עושה wait.

זיכרון וירטואלי:
החלק הראשון של הקורס שלנו דיבר על וירטואליזציה- האשליה שמערכת ההפעלה נותנת לתהליך שגורמת לו לחשוב שהוא פועל לבד ושיש לו מעבד רק משלו. החלק השני לזה, זה הזיכרון. לכל תהליך יש זיכרון וכל תהליך מקבל את האשליה כאילו כל הזיכרון הפיזי (ה-ram) ושהוא רק שלו, כשבפועל יש לנו רק זיכרון אחד.
מערכת ההפעלה מספקת לתהליכים שלנו אשליה.

* Match the address location
```c
int x;
int main(int argc, char *argv[]) {
    int y;
    int *z = malloc(sizeof(int));
}
```

Address Space:
[Text]
[Data]
[Heap]
  |
  v
  ^
  |
[Stack]

Address | Location
---|---
x | Data
main | Text
y | Stack
z | Stack
*z | Heap

המשתנה x הוא משתנה גלובלי ולכן יימצא באזור ה-data (שם נמצאים משתנים גלובליים וקבועים של הקוד).
main יימצא בחלק הטקסט, כי זה קטע קוד.
המשתנה y יימצא במחסנית (stack) שאכלה משתנים מקומיים, ארגומנטים לפונקציות וקריאות לפונקציות.
גם z יימצא במחסנית כי הוא משתנה לוקאלי.
המשתנה z מכיל כתובת. לעומת זאת *z יימצא בערימה, כי התוכן לה הזיכרון הדינאמי.

ניהול הזיכרון הפנימי:
הזיכרון של המחסנית (stack) הוא זיכרון שקל לנהל כי יש בו סדר. כל פעם שאנחנו קוראים לפונקציה או מגדירים משתנה, הוא מתווסף למחסנית וכשהפונקציה מסתיימת אז לה יוצא מהמחסנית (כלומר זה תמיד לפי הסדר ובגלל זה מבנה הנתונים הוא גם של מחסנית). לעומת זאת, את הזיכרון שקשור לערימה (heap) יותר קשה לנהל, כי בערימה אין חוקים ואין סדר, המשתמש יכול להקצות זיכרון ולשחרר אותו בסדר אחר. אז יש לנו שטח שלם של זיכרון שצריך לנהל. לכל תהליך יש זיכרון משלו עם ערימה משלו והוא צריך לנהל אותו.

אלגוריתמים לניהול הזיכרון:
יש לנו שטח של זיכרון כלשהו (אולי זה הזיכרון הפיזי או הזיכרון של כל תהליך, זה לא משנה).
הנחה מקלה: נניח שהמשתמש מבקש מאיתנו גודל של זיכרון בכל פעם.

free list: ניקח את הזיכרון ונחלק אותו לחלקים שווים בגודלם. נניח שהזיכרון שלנו הוא בגודל 800MB וכל חלק הוא בגודל 100MB. נחלק אותו לבלוקים ונחזיק רשימה מקושרת שתגיד לנו מה הבלוקים פנוי.
בשלב ההתחלתי, כל הבלוקים פנויים ולכן כולם ברשימה. כשהמשתמש רוצה להקצות זיכרון (קורא למאלוק או נוצר תהליך חדש), נחזיר לו איבר מהרשימה (בדר"כ נחזיר לו את הראשון או את האחרון, אבל זה לא משנה מה נביא לו). לצורך הדוגמא נניח שהמשתמש את בלוק מספר 3, אז עכשיו כולם יהיו ברשימה חוץ מבלוק מספר 3.
אם המשתמש ירצה להקצות עוד פעם, נתן לו עוד איבר וכן הלאה. זה מאוד יעיל וזה מאוד פשוט.
אך אם הוא משחרר איבר (נניח והוא סיים עם 3 והוא משחרר אותו), אז נוסיף אותו שוב לתחילת הרשימה.
עכשיו שוב הכל פנוי, אין חשיבות לסדר, לא צריך למיין את הרשימה, כל הבלוקים באותו גודל.

הבעיה ב-free list: אנחנו מגבילים את הזיכרון, אין לנו מקום שנתן רשימה (רשימה צריכה הקצאות זיכרון משל עצמה). הפתרון: יש לנו זיכרון והוא פנוי, אולי אחד לא משתמש בו אז אנחנו נשתמש בו. נחזיק זיכרון קטן מאוד, רק מצביע לראש הרשימה, ובתוך הזיכרון שלנו נחזיק את הרשימה עצמה.

- זה פשוט, יעיל אבל לא מציאותי. המשתמש לא תמיד מבקש 100MB, אם ננסה להחיל את אותם הכללים על גדלים משתנים, זה כבר הופך להיות בעייתי.
עכשיו ניקח את הזיכרון וכעת הוא לא יחולק לחלקים שווים, כי אי אפשר, אלא נחלק אותו לפי מה שיוצא.
יכול לקרות מצב שחלקנו את מה שיצא למשל יש חלק של 10kb יש חלק של 5kb ואחריו תפוס ואחריו 5kb פנוי.
ונניח שהמשתמש מבקש 15kb, אין לזיכרון כנל לתת לו.
אם נרצה להשתמש ב-free list, הרשימה המקושרת שלנו צריכה להיות יותר מורכבת, היא לא תכלול מספר, אלא כתובת שבה מתחיל הזיכרון הפנוי (כי הוא יכול להתחיל בכל נקודה בזיכרון, הוא כבר לא מחולק לחלקים שווים) והוא צריכה להכיל גודל (כי הגודל לא קבוע). הרשימה תכליל רק את השטחים הפנויים.

קיטוע חיצוני / פרגמנטציה חיצונית (External fragmentation)- בעיה שבה יש לנו מספיק זיכרון פנוי לטפל בבקשה מסוימת, אבל אנחנו עדיין לא יכולים לטפל בבקשה הזו.

יש לנו את הבעיה של מקודם, איך ננהל רשימה מקושרת? נכניס את הרשימה המקושרת לזיכרון, הפעם זה יתפוס קצת יותר מקום - בכל תחילת בלוק פנוי יהיה מקטע זיכרון שאומר לנו מה הגודל שלו ומה הכתובת של הבלוק הפנוי הבא.
נניח והמשתמש ביקש עכשיו זיכרון, למשל 12kb, ויש לנו 15kb פנויים, אז ניתן לו את ה-15kb אלא נבצע פעולה שנקראת split- ניקח את ה-15kb הפנויים ונפצל אותם לשניים: ל-12kb שהוא ביקש ולעוד 3 שנשארו. אחד מהחלקים נסמן כתפוס, ואת החלק השני נחליף ברשימה.

כשרוצים לשחרר זיכרון, יש לנו את הפעולה ההפוכה שנקראת Coalesce.
קורה מצב שבו המשתמש שחרר זיכרון. נניח את הזיכרון המשוחרר כאיבר ברשימה המקושרת, אם הזיכרון שלנו יחולק למשל לבלוק של 5 ואז בלוק של 10 ואז בלוק של 15 (משוחרר ועכשיו פנויים) זה בלוקים, כי אם המשתמש ירצה שטח זיכרון של 20, אנחנו נגיד לו שאין (למרות שברור שיש). אז coalesce מבקש לאחד את השטחים הסמוכים הללו לשטח אחד גדול (כלומר לאחד שטחי זיכרון סמוכים).

אז בהקצאת זיכרון אנחנו עושים split, ובשחרור זיכרון בודקים אם יש שטחי זיכרון סמוכים שיש לעשות להם coalesce.

כשאנחנו מקצים זיכרון, אנחנו אומרים כמה זיכרון אנחנו רוצים להקצות. כשאנחנו משחררים זיכרון אנחנו לא אומרים כמה אנחנו רוצים לשחרר (כי זה מסוכסך על המשתמש שיגיד לנו כמה לשחרר), ובמקום זה, אנחנו צריכים לזכור את המידע הזה. בדר"כ כשאנחנו מקצים זיכרון, מקצים קצת יותר ממה שהמשתמש ביקש.
נניח והמשתמש ביקש להקצות 100 בתים, נקצה לו 108 ו-8 הנתונים נשמור מידע עליהן.
בתחילת הבלוק של ה-108 נשמור את ה-8 שלנו בהתחלה וניתן לו מצביע לכתובת שהיא ה-100 הבתים הנותרים.
כשהמשתמש יבקש לשחרר את הזיכרון הנ"ל, נסתכל כמה בתים אחורה כדי לראות כמה זיכרון הוקצנו לו, לפי זה נשחרר.

