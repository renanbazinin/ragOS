מערכות הפעלה – שיעור 14

בשיעור הקודם התחלנו לדבר על condition variables.
אמרנו שחוט A רוצה לבצע את הפעולה שלו רק אחרי חוט B. הגענו לכך שהפתרון להצלחה של פעולה זו הוא שימוש במשתנה משותף (דגל) ואז חוט A הוא כל ראשון הוא בודק את המשתנה done וממתין חוט B יסיים ויודיע לו בעזרת signal, ואילו אם חוט B כל ראשון, הוא יעדכן את המשתנה done, הסיגנל ישלח אבל זה לא משנה כי לאחר מכן A ירוץ ויראה את המשתנה done. ובגלל שהשתמשנו במנעול, הם לא יכולים להתערבב בצורה לא נכונה.

בעיית הסנכרון שראינו עד עכשיו היא בעיה מוכרת שנקראת producer / consumer (יצרן / צרכן), והיא נקראת גם בעיית ה-bounded buffer.
נחשוב על מקרה שבו אין לנו רק חוט A יחיד וחוט B יחיד, אלא כמה חוטי A וכמה חוטי B ואנחנו רוצים שהחוטים יחכו אחד לשני.

יש חוטים שהם היצרנים (ה-producers) וחוטים שהם הצרכנים (ה-consumers).
זה תהליך מעיין בעיוני לדוגמא במבנה נתונים כמו תור – יש לנו חוטים שעושים פעולות כמו להוסיף לתור ויש פעולות של להוציא מהתור. היצרנים מייצרים איברים חדשים שנכנסים לתור, והצרכנים מוציאים מהתור.
או לדוגמא, ב-קבצים- אם אנחנו קוראים קובץ אל אחסון הצרכן (מערכת ההפעלה קוראת את הנתונים של הקובץ ושהה לנו בבאפר ואנחנו צורכים אותם).

בגרסה שלנו אנחנו רוצים שכל פעם שחוט B קורא לחוט A, נוצרת תשובה אחת.
אם מישהו הוסיף איזשהו איבר לתור, אנחנו רוצים שמישהו אחד יצרוך אותו (אבל אחד בלבד), שלא יקרה מצב ששניים יצרכו איבר יחיד, או שיהיה איבר ואף אחד לא יצרוך אותו.

דרך נוספת להגדיר את בעיית ה-bounded buffer: נניח שיש לנו מחסן ובמחסן יש מדפים, יש חוטים שמייצרים מוצרים ומניחים אותם על המדפים והלו יש חוטים שצורכים אותם.
הסיבה שלה וקראו bounded buffer היא כיוון שבד"כ המקום במחסן מוגבל, יש לנו כמות מוגבלת של מדפים.
כשאנחנו קוראים קובץ אנחנו מעבירים למערכת ההפעלה קובץ, אנחנו מעבירים באפר של 1000 בתים למשל, אז אנחנו קוראים עד 1000 בתים. ואז היצרן מוגבל בכמות המדפים.

אם כל המדפים מלאים במוצרים, יצרן שמגיע ורוצה להוסיף מוצר, צריך לחכות עד שיהיה לו מדף פנוי להוסיף את המוצר אליו.
והכיוון ההפוך- אם כל המדפים ריקים, אז צרכן שרוצה לקחת מוצר מאחד המדפים ולצרוך אותו- ממתין עד שיהיה מוצר, עד שמישהו ייצר מוצר. זה תהליך קבצים, שרתים (שרת שמטפל בבקשות מקבל בקשות מקומות ומפצל אותם לחוטים שונים)..

הרבה בעיות של סנכרון מעשיות הן בנויות ככה של יצרן / צרכן וכל הדוגמאות של ה-condition variable שראינו עד עכשיו מעשיות להן גם. כל פעם שחוט B קורא ל-mmmbop הוא בעצם הוסיף מוצר שחוט A צרך אותו.

אז נרחיב את זה ונתן שם לכל חוט:
בבעיית היצרן/צרכן יכולים להיות לנו כל מספר של חוטים מכל סוג (הרבה צרכנים/הרבה יצרנים, אנחנו לא יודעים את הסדר).

---

דוגמת קוד ראשונה:
קוד דומה לקוד שראינו בשיעור הקודם, רק שכאן אין משתנה done אלא count.
עכשיו אין לנו רק מוצר אחד על המדף, אלא כמה מוצרים, וכרגע המחסן לא מלא.
כל פעם שחוט שרוצה לייצר מוצר, הוא תופס את המנעול, מגדיל את ה-count ומודיע שנוצר מוצר.
חוט שרוצה לצרוך מוצר, תופס את המנעול ובודק האם המחסן ריק, אם המחסן ריק הוא הולך לישון ומחכה שיצרן יתן לו סיגנל ויגיד לו שיש מוצר במחסן. ברגע שהודיעו לו שיש מוצר, הוא מתקדם, צורך את המוצר ומוריד את המונה (שימו לב שיש מוצר אחד פחות).

Producer:
```c
lock(&m1);
mmmBop();
++count;
signal(&cv1);
unlock(&m1);
```

Consumer:
```c
lock(&m1);
if (count == 0)
    wait(&cv1, &m1);
baDuBop();
--count;
unlock(&m1);
```

יש בעיית נכונות בקוד הבא.
נניח והצרכן רץ ראשון, תפס את המנעול. ראה שהמונה הוא 0 ולכן הלך לישון ושחרר את המנעול.
עכשיו היצרן רץ, מייצר את המוצר, מגדיל את המונה ל-1 ושולח סיגנל ומעיר את הצרכן. אבל עכשיו משהו נוסף. זה שהערנו את החוט שנעצר, לא אומר שהוא זה שיגיע לצרוך מיד. יכול להגיע צרכן אחר שיהיה מהיר יותר והוא יתפוס את המנעול ראשון, לפני החוט שישן. ואז הוא יצרוך את המוצר ויוריד את המונה ל-0.
עכשיו לאחר שהצרכן הקודם סיים עם המנעול, החוט שישן יצליח לתפוס את המנעול ולכן הוא יצרוך את המוצר ויקטין את המונה ב-1. כלומר היצרן שלנו ייצר מוצר אחד אבל הגענו אליו פעמיים.

כיצד נפתור את בעיית הנכונות הזו: ננסה לשנות את ה-if ב-while, כל פעם שמעירים חוט, הוא יבדוק את התנאי מחדש.

Producer:
```c
lock(&m1);
mmmBop();
++count;
signal(&cv1);
unlock(&m1);
```

Consumer:
```c
lock(&m1);
while (count == 0)
    wait(&cv1, &m1);
baDuBop();
--count;
unlock(&m1);
```

זה כלל אצבע ב-condition variable, השימוש בו תמיד יהיה בתוך לולאת while. אנחנו בודקים תנאי כלשהו, אם אנחנו לא יכולים להתקדם, אנחנו הולכים לישון, וכל פעם שמעירים אותנו – קודם כל נבדוק את התנאי שוב.

עכשיו נוסיף את המגבלה של: המחסן מלא. כפי שאמרנו יש לנו כמות מוגבלת של מקום.
כשצרכן רוצה לצרוך מוצר, הוא בודק האם count = 0, ואם זה אכן כך הוא הולך לישון.
כשיצרן רוצה לייצר מוצר, הוא יבדוק אם המונה הגיע למספר המקסימלי שהוא יכול להיות.
עכשיו היצרן גם בודק את המונה.
אם המחסן מלא, הוא ממתין עד שיתפנה מקום אחד לפחות.
כמו כן, לאחר שצרכן צרך מוצר, הוא שולח סיגנל למקרה והוא צריך להעיר יצרן שהתפנה מקום.

Producer:
```c
lock(&m1);
mmmBop();
while (count < MAX)
    wait(&cv1, &m1);
++count;
signal(&cv1);
unlock(&m1);
```

Consumer:
```c
lock(&m1);
while (count == 0)
    wait(&cv1, &m1);
baDuBop();
--count;
signal(&cv1);
unlock(&m1);
```

- כשאנחנו מבצעים signal, אנחנו לא מחליטים את מי להעיר.
כאשר עושים signal ל-cv1, ייתכן ואנחנו רוצים להעיר צרכן אבל במקום זאת בטעות יצרן שמחכה לסיגנל יתעורר.
דוגמא למנגנון כזה:
1: consumer -> count==0 -> wait
2: consumer -> count==0 -> wait
3: producer -> produces, signal -> consumer 1
4: producer -> count==MAX -> wait
5: consumer -> consumes item, signal -> consumer 2
1 & 2 -> count==0, wait
Deadlock

---

זה מקרה של קיפאון, יש צרכן שחוסם (כי אין מוצרים במחסן) ויצרן חסום (כי אין מקום פנוי במחסן) למרות שיש מקום פנוי במחסן.

הפתרון: שימוש בשני condition variables
לא נשתמש ב-condition variable אחד עבור 2 סוגי הודעות אלא באחד עבור כל הודעה.
לא נערבב בין הודעות, כל הודעה היא בפני עצמה.
אז נשתמש באותו קוד, רק שנוסיף עוד condition variable שנקרא empty שהצרכנים מחכים עליו (כשהצרכן רואה שהמחסן ריק, הוא עושה wait ל-empty) והיצרנים שולחים לו סיגנל בעת הוספת מוצר.
ונחזיק עוד אחד שנקרא full – שהיצרנים מחכים עליו (כשהיצרן רואה שהמחסן מלא, הוא עושה wait ל-full) והצרכנים שולחים לו סיגנל בעת צריכת מוצר (פינוי מקום במחסן).

Producer:
```c
lock(&m1);
mmmBop();
while (count < MAX)
    wait(&full, &m1);
++count;
signal(&empty);
unlock(&m1);
```

Consumer:
```c
lock(&m1);
while (count == 0)
    wait(&empty, &m1);
baDuBop();
--count;
signal(&full);
unlock(&m1);
```

המימוש של condition variables בלינוקס:
Declare a condition variable:
`pthread_cond_t cv;`

Operations:
```c
// wait:
pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);
// signal:
pthread_cond_signal(pthread_cond_t *c);
// broadcast:
pthread_cond_broadcast(pthread_cond_t *c);
```
* כמו במנעולים, גם ב-condition variable צריך לאתחל לפני השימוש ולשחרר ברגע שסיימנו איתו. זה נקרא pthread_cond_init ו- pthread_cond_destroy.

אובייקט הסנכרון האחרון שנלמד עליו: SEMAPHORE
היה לנו condition variable שזה בשביל להמתין ולקבל הודעות, היה לנו מנעול שזה בשביל מניעה הדדית.
ה-semaphore הוא אובייקט סנכרון שמשמש עבור שני השימושים הללו יחד.
הוא מכיל את הרעיון של condition variable ושל מנעולים ומספק לנו פונקציונליות מעבר לכך, וכל זה עם שתי פעולות בלבד שנקראות: wait, post (לפעולות הללו יש שמות נוספים: p, down : wait עבור wait, v, up : עבור post).

לכל semaphore יש ערך מספרי (integer), בדרך כלל משהו שמעיד גדולה/שווה 0.
את הערך הזה אנחנו קובעים באתחול של ה-semaphore, זה הערך שהוא מתחיל איתו. מהרגע שהגדרנו את הערך הזה, אנחנו לא יכולים לגשת אליו (או לקרוא אותו). יש דרך לשנות אותו אבל אנחנו לא יכולים לקבוע ערך חדש.
הדבר היחידי שניתן לעשות איתו זה לקרוא ל-wait ו-post.

---

פעולת ה-(up) post: פעולה זו מעלה את הערך הפנימי של ה-semaphore ב-1 (בצורה אטומית).
זה נותן סוג של שליטה על הערך הפנימי, אנחנו יכולים להגדיל אותו ב-1 אבל אנחנו לא יכולים לשאול מה פעם מה הערך שלו.
הערה ב-*.

פעולת ה-(down) wait: פעולה זו מורידה את ערכו הפנימי של ה-semaphore ב-1 (בצורה אטומית).
אמרנו שיש תנאי: הערך של ה-semaphore צריך תמיד להיות גדול/שווה 0.
המשמעות: אם חוט קורא ל-wait (down) והערך הוא כבר 0, אז החוט הזה הולך לישון, הוא ממתין, אנחנו לא יכולים להוריד 1 מערכו של ה-semaphore במקרה זה, אז החוט שלנו ילך לישון עד שהערך יהיה יותר גדול מ-0.

* כשעושים post (up), אנחנו לא רק מעלים את הערך ב-1, אלא אנחנו גם מעירים מישהו ומדיעים לו שהגדלנו את הערך ב-1 וכשהוא יתעורר הוא ינסה להוריד את הערך ב-1.
פה אין לנו בעיה של lost signal כי אם הערך הוא 1 (ו-N-0-1) ואף אחד לא התעורר עדיין, כשהוא יגיע ל-wait הוא יראה שהערך הוא 1.

Wait logic:
```c
while (value <= 0)
    wait_for_signal(&s1);
--value;
```

Post logic:
```c
++value;
signal_1_thread(&s1);
```

שימוש בקוד של semaphore לצורך מימוש מנעול:
לפנינו הקוד של מנעול:
נרצה שכל פעם שחוט ירצה לתפוס את המנעול הוא יקרא ל-wait ע"י semaphore שייצרנו.
המנעול. כל פעם שהוא ירצה לשחרר נעשה unlock (הוא יקרא ל-post). אז מה צריך להיות בסימן השאלה האדום? איזה מספר נצטרך לשים באתחול הראשון של ה-semaphore בשביל שהקוד הזה יתנהג בדיוק כמו מנעול רגיל ויספק לנו מניעה הדדית?

```c
init(&semlock, ?);
...
wait(&semlock);
// critical section
post(&semlock);
```

התשובה: 1.
קודם כל, ה-semaphore הזה נקרא binary semaphore - סמפור בינארי – זה מנעול והערך שלו יכול להיות רק 1 או 0. אנחנו נותנים את הסמפור להיות 1. עכשיו כשאחד רוצה לתפוס את המנעול הוא קורא ל-wait ועקב פעולת ה-wait, ערך הסמפור קטן ב-1. לכן אם הערך של הסמפור היה 1, הוא ישתנה ל-0, והחוט נכנס לקטע הקריטי.
כל מי שיבוא אחריו, ממתין, לא יכול להיכנס לקטע הקריטי כי הערך הוא 0. ברגע שהחוט סיים את הקטע הקריטי, הוא עושה post ומעלה את ערכו של הסמפור ב-1. אז הערך גדל מ-0 ל-1 ובנוסף נשלח סיגנל שמעיר את אחד החוטים הממתינים.
הסמפור הבינארי שהוא או 1 או 0, מייצג האם המנעול פנוי (ערכו 1) או תפוס (ערכו 0).

שימוש בקוד של semaphore לצורך מימוש condition variable:
אנחנו רוצים ש-wait של הסמפור יהיה ה-wait של CV ו-post יהיה ה-signal של ה-CV.
לשם כך, באתחול נשים בערך ההתחלתי של הסמפור: 0. ברגע שחוט יגיע ויעשה wait, הוא ייחסם (בדיוק כמו ב-CV), כי אי אפשר להוריד את 0 ב-1. כאשר חוט ירצה לעשות סיגנל, הוא יעשה post. הוא יגדיל את הערך ב-1 (הערך כבר לא יהיה 0) והחוט החסום יתעורר ויוריד את ה-1 חזרה להיות 0 ויתקדם.
עכשיו לא רק שמשתמשים ב-CV עם semaphore, אלא אין לנו צורך בלולאה הזו שבודקת, או מנעולים וכו'.

`init(&semcv, 0);`

---

חוקיות: הערך ההתחלתי של ה-semaphore צריך להיות לפי הבעיה שאנחנו פותרים.
מנעול אתחול ב-1 כי כשאנחנו מתחילים מנעול חדש, הוא כביכול פנוי, יש לנו משאב זמין לקטע הקריטי. כרגע שהתחלנו מישהו יכול להשתמש בו.
לעומת זאת, CV, כאשר אנחנו ממתינים להודעה- הוא לא זמין. אנחנו מחכים לידיעה שיש להמתין לה. ההודעה הזו עוד לא קיימת ולכן הערך ההתחלתי במקרה זה יהיה 0.

נכלול זאת: הערך ההתחלתי של ה-semaphore הוא כמות המשאבים שיש לנו (כרגע האתחול).
במנעול- המשאב שלנו זה כניסה לקטע הקריטי, ובתחילת התוכנית יש לנו משאב אחד כזה (מותר לחוט אחד להיכנס לקטע הקריטי). ברגע שחוט רוצה להיכנס לקטע הקריטי הוא לוקח את המשאב אליו, לוקח את ה-1 הזה ולא נשאר לאחר אף חוט אחר. וברגע שהוא מסיים הוא קורא ל-post ומשחרר את המשאב.
ב-CV, כשאנחנו מייצרים איזה מנגנון הודעה. ה-CV זה אני ממתין להודעה. כאשר התחלנו אנחנו, אין עוד הודעה ולכן כמות המשאבים בתחילה היא 0. כאשר חוט רוצה לשלוח הודעה הוא מייצר משאב.

* ניתן להשתמש ב-semaphore לדברים אחרים ולא רק למנעול ו-CV.

שימוש בקוד של semaphore לצורך מימוש bounded buffer (producer/consumer):
את הבאפר שלנו נייצג הפעם ע"י באפר אמיתי. אנחנו מגדירים מערך עם גודל מקסימלי (זו כמות המדפים במחסן), כל מדף במחסן זה איבר במערך שלנו.
יש לנו 2 סמפורים: full, empty שמקבילים ל-cv שלנו.
הסמפור full מייצג כמה מדפים מלאים, ובתור התחלה אף מדף לא מלא ולכן הוא מאותחל ל-0.
הסמפור empty לעומת זאת מייצג כמה מדפים פנויים יש לנו (זה לא שאנחנו משאב, אפילו שהם משלים אחד של השני), ולכן בתור התחלה יש לנו MAX מדפים פנויים (במחסן שלנו יש MAX מדפים).

```c
init(&empty, MAX);
init(&full, 0);
int fill = 0;
int use = 0;
int buff[MAX];
```

Consumer:
```c
wait(&full);
// consume item
int val = buff[use];
use = (use+1) % MAX;
return val;
post(&empty);
```

Producer:
```c
wait(&empty);
// produce item
buff[fill] = val;
fill = (fill+1) % MAX;
post(&full);
```

- צרכן שרוצה לצרוך משהו מהמחסן, יעשה wait על full כי הוא מחכה שיהיה מדף מלא.
ברגע שהוא סיים את ה-wait, הוא יודע שיש מדף שהוא יכול לצרוך. ואז הוא יכול לגשת לבאפר במקום ה-used ולצרוך.
הקוד של היצרן והצרכן די דומים, רק שה-empty, full הפוכים אצלם.
היצרן מחכה שיהיה מדף פנוי כלומר שיהיה מקום פנוי במערך.
כשהוא עושה wait, הוא מוריד ב-1 את כמות המקומות הפנויים במערך ואז ממלא את המדף.

המימוש מייצג מערך ציקלי, כאשר:
used: מייצג איפה אנחנו מתחילים להשתמש בו.
fill: מייצג איפה האיבר האחרון.

הבעיה בקוד שראינו מעלה: נניח שיש לנו מערך בגודל 3. בתחילה, המערך ריק, fill = 0, empty = 3.
אם יש לנו שני יצרנים שרוצים לגשת למערך, מה שיקרה: היצרן הראשון יכול ויעשה wait ל-empty ואז יוסיף את הערך שלו למערך (כי יש מדף פנוי במערך) אל הוא מוריד את empty ל-2.

---

ואז היצרן הראשון נכנס ל- `buff[fill]`, ומוסיף את האיבר למערך ושם בו את הערך שלו.
הדבר הבא שהוא הולך לעשות: לקדם את fill, כדי שהחוט הבא שייצר איבר ישים אותו במקום הבא במערך.
ברגע שעושים פעולה כזו, זה מעלה נורה אדומה כיוון שלא ניתן לשנות ערך של משתנה משותף בלי סנכרון. לא טיפלנו בסנכרון של המשתנה fill. אז היצרן הבא שיגיע גם יעשה wait ל-empty, יוריד אותו ל-1, אבל ה-fill לא יתעדכן. הוא ישים את הערך שלו באותו מיקום במערך, כלומר ישכתב את הבאפר. בהמשך שניהם יתקדמו והערך fill יהיה 2. אז שניהם כתבו למספר 0 ודילגו על מספר 1. וכן הלאה וכן הלאה. וכן דאגנו לסנכרון את ההוספה שלהם למחסן.

אז הפתרון: להוסיף סמפור נוסף שקראנו לו mutex, הוא מאותחל ל-1 (ברגע שאנחנו רואים סמפור שמאותחל ל-1, זה לרוב יהיה סמפור בינארי, כלומר מנעול).

```c
init(&empty, MAX);
init(&full, 0);
init(&mutex, 1);
int fill = 0;
int use = 0;
int buff[MAX];
```

Consumer:
```c
wait(&mutex);
wait(&full);
int val = buff[use];
use = (use+1) % MAX;
return val;
post(&empty);
post(&mutex);
```

Producer:
```c
wait(&mutex);
wait(&empty);
buff[fill] = val;
fill = (fill+1) % MAX;
post(&full);
post(&mutex);
```

הבעיה הבאה: הוספנו מנעול וכרגע שני חוטים לא יכולים לגשת למחסן בבת אחת, אבל הכאן הדרך שבה שמנו את החוטים לא יכולה לעבוד ביחד ככה.
נניח שמגיע צרכן, הוא תופס את המנעול. הוא מחכה על full, הוא רואה שהמחסן ריק ולכן הוא נתקע כי המחסן ריק.
אם יצרן מגיע הוא יכול לתפוס את המנעול ולא יכול להוסיף איברים. קיבלנו deadlock.

הפתרון לכך: נשתמש במנעול רק סביב הקטע הקריטי, במינימום שנדרש, אחרת זה גורם לבעיות.
הקטע הקריטי שלנו זה הגישה למערך (למחסן). לכן נשים את ה-wait, post במיקומים הנכונים.

Consumer:
```c
wait(&full);
wait(&mutex);
int val = buff[use];
use = (use+1) % MAX;
return val;
post(&mutex);
post(&empty);
```

Producer:
```c
wait(&empty);
wait(&mutex);
buff[fill] = val;
fill = (fill+1) % MAX;
post(&mutex);
post(&full);
```

עכשיו אם חוט רואה שהמחסן ריק הוא ממתין מבלי להחזיק במנעול, ואז חוטים אחרים יכולים להגיע, להוסיף איברים למחסן, ולהעיר חוטים מחכים לסיגנל. זה הפתרון שעובד 100%.

השימוש ב-semaphore ב-linux:
יש את הפעולות sem_wait, sem_post עליהן דיברנו והפונקציות האחרות: כפרמטרים לאתחול שולחים:
- כתובת של הסמפור
- נשלח את המספר 0 תמיד. פרמטר זה מייצג האם אנחנו רוצים לשתף את הסמפור הזה בין תהליכים. כאשר אנחנו נותנים כפרמטר 0, זה סמפור רגיל, אבל אם נכתוב 1, הסמפור הזה יישאר תקף גם לאחר שנעשה ()fork כלומר זה יהיה אותו סמפור עם אותו ערך, הוא לא ישוכפל, אלא זה זיכרון משותף דרך מערכת ההפעלה שבו אפשר להשתמש גם בסנכרון בין תהליכים שונים.
- הערך ההתחלתי שרצוי שיהיה בסמפור.

```c
#include <semaphore.h>
sem_t s;
sem_init(&s, 0, init_value);
...
sem_wait(&s);
sem_post(&s);
...
sem_destroy(&s);
```

---

THREAD THROTTLING:
שימוש נוסף לסמפורים. לפעמים יש לנו קטע קוד שנועד הרצה לזיכרון, ואנחנו רוצים להריץ הרבה חוטים במקביל.
הקטע קוד הזה הוא לא קטע קריטי ולכן אין לנו בעיה שירוצו במקביל ולא צריך לסנכרון כלום, אבל הזיכרון שלנו מוגבל, אנחנו לא יכולים למשל- 100 חוטים להקצות 1GB של זיכרון כל אחד.
אז שימוש נוסף בסמפורים: הגבלת כמות החוטים בקטע קוד מסוים, מסיבות אחרות (לא בהכרח בגלל סיבות של סנכרון).
נאתחל את הסמפור שלנו לכמות המקסימלית שאנחנו רוצים להחזיק במקביל, ואז כל חוט לפני שהוא מבצע את קטע הקוד יעשה wait ויקח את המשאב הזה (משאב שמאפשר לו להקצות זיכרון) וכשהוא יסיים הוא יעשה post.
ואז אם בתוך קטע הקוד שלנו הוא מקצה 1GB של זיכרון, אז אנחנו יודעים שזה בסדר כי מקסימום נתפוס 4GB של זיכרון במקביל (לדוגמא).

בעיה מוכרת בתחום המקביליות ומערכות הפעלה: בעיית ה-dining philosophers:
בעיה שבאה להדגים לנו בעיית סנכרון.
יש 5 פילוסופים, כולם יושבים מסביב לשולחן, מול כל אחד מהם מונחת צלחת של ספגטי ומימין ומשמאל מונח מזלג אחד בלבד. הפילוסופים שלנו אוכלים עם שני מזלגות את הספגטי שלהם.
כל פילוסוף צריך מזלג, צריך לתפוס שני מזלגות ולהתחיל לאכול. (פילוסוף משל חוט).
הפילוסופים הוגים, אוכלים ואז שוב הוגים.

אם ננסה את זה בקוד:
כל פילוסוף הוגה וכאשר הוא רוצה לאכול הוא קורא ל-(get_forks(p כאשר p הוא המספר של ההוגה- בין 0 ל-4.
לאחר שפילוסוף סיים לאכול, הוא קורא ל-(put_forks(p.
מימוש עיקרי יהיה: נגדיר סמפור בינארי לכל מזלג – כל פילוסוף שרוצה לאכול, יפקיד את המזלג שלו ואז יקח את המזלגות הצמודים אליו (הימני והשמאלי):

```c
void get_forks(int p) {
    sem_wait(&forks[left(p)]);
    sem_wait(&forks[right(p)]);
}

void put_forks(int p) {
    sem_post(&forks[left(p)]);
    sem_post(&forks[right(p)]);
}
```

הבעיה במימוש הזה:
אף אחד מהפילוסופים לא יוכל לאכול. Deadlock !
יכול לקרות מצב שבו כל פילוסוף לוקח את המזלג של לשמאלו ואז אף אחד לא יכול להרים את המזלג מצד ימין- כולם יושבים עם מזלג אחד ומחכים. כל אחד מחכה לפילוסוף מצד ימין שלו שיסיים לאכול ויניח את המזלג.

הפתרון לכך: שבירת הסימטריה
הבעיה מתחילה מכך שכל פילוסוף מרים את המזלג משמאלו ואז הם תקועים.
בשביל לפתור בעיה כזו, נרצה לשבור את הסימטריה.
מספיק פילוסוף אחד (אפשר יותר) שירים את המזלגות בסדר הפוך, כלומר ירים את המזלג מימין ורק לאחר מכן את המזלג משמאלו. וכל השאר ירימו את המזלג משמאל ואז מימין. מספיק שהפכנו אחד מהם, וכבר לא תהיה לנו את הבעיה.

---

```c
void get_forks(int p) {
    if (p == 4) {
        sem_wait(&forks[right(p)]);
        sem_wait(&forks[left(p)]);
    } else {
        sem_wait(&forks[left(p)]);
        sem_wait(&forks[right(p)]);
    }
}
```
עלולה להיות לנו הרעבה, אבל לא קיפאון. לפחות אחד יוכל בכל מקרה (ע"י שבירת הסימטריה).

הדוגמא הזו הראתה מצב של deadlock.

נזכיר כעת על באגים בקוד מקבילי.
הבאגים בקוד מקבילי הם מאוד קשים והם לא דטרמיניסטיים.
בניגוד לקוד סדרתי שאנחנו יכולים להריץ הרבה פעמים עם קלטים לבדוק את הפלטים, בקוד מקבילי זה לא ככה.
אנחנו יכולים להריץ עם קלט מסוים ולקבל אולי תוצאות שונות, אנחנו תלויים בתזמון.
בנוסף, גם אם הרצנו את הקוד מיליון פעם וזה רץ נכון, יש מצב שבהפעם המיליון ואחת זה לא ירוץ נכון.
זאת כיוון שקוד מקבילי הוא בעייתי וזה שרץ נכון לא אומר שום דבר.
גם אי אפשר כל-כך לדבג קוד מקבילי.
דיברנו על כך ש-printf הורסת את המקביליות של הקוד.
הרבה פעמים אנחנו נריץ קוד מקבילי שלא עובד נכון וברגע שהוספנו הדפסה הוא כן עובד נכון, וזה בגלל שהוספת ההדפסה גרמה לסנכרון.
אז כתיבת קוד מקבילי נכון הוא מאוד קשה.

איך נוכל לבחון את הקוד ולקבל אינטואיציה האם הוא נכון או לא?
נחלק את הבאגים בקוד מקבילי לשני סוגים:
1. deadlock- חוטים תקועים וממתינים אחד לשני.
2. non-deadlock- יש לנו ריצה לא נכונה.

Non-Deadlock Bugs:
הכוונה בבאגים שאינם קיפאון היא שיש לנו קטע קוד שרץ לא נכון והתוצאות שלו לא נכונות, אבל זה תלוי בתזמון שלנו (כי זה קוד מקבילי). כלומר, זה לא שיש לנו באג בקוד כשהוא רץ לפי הסדר, אלא רק כשהוא רץ באופן מקבילי הוא עלול לתת תוצאות לא נכונות. נראה שתי דוגמאות מרכזיות לכך:

דוגמא מקטע קוד של MySQL:
שני חוטים ניגשים לשדה proc_info במשתנה המשותף thd. החוט הראשון בודק שהשדה הזה שונה מ-NULL והחוט השני שם NULL. הם עלולים לרוץ במקביל ואז נניח שהחוט הראשון בדק וזה אכן שונה מ-NULL והחוט השני ישים NULL ברגע שהחוט הראשון ייכנס לבצע את הפקודה בתוך ה-if. התוכנית עלולה לקרוס או לתת התנהגות לא צפויה.

Thread 1:
```c
if (thd->proc_info) {
    fputs(thd->proc_info, ...);
}
```

Thread 2:
```c
thd->proc_info = NULL;
```

הבעיה שמתוארת כאן נקראת atomicity violation.
זו בעצם הפרת אטומיות. אנחנו התכוונו ששתי השורות שתהליך 1 מבצע יהיו אטומיות.

---

אבל לא הבטחנו את זה בשום צורה. כתבנו קוד מקבילי אבל לא וידאנו את זה בשום צורה.
הפתרון לכך: מנעול. אם התכוונו שזה יהיה אטומי (ירצו בבת אחת), אז נקח את המשאב המעניין אותנו וניתן לו מנעול. נתפוס את המנעול בקטע הקוד שהתכוונו שיהיה אטומי, ונתפוס את המנעול בכל קטע קוד אחר שעלול להפריע לנו. עכשיו זה יהיה אטומי.

Thread 1:
```c
pthread_mutex_lock(&proc_info_lock);
if (thd->proc_info) {
    fputs(thd->proc_info, ...);
}
pthread_mutex_unlock(&proc_info_lock);
```

Thread 2:
```c
pthread_mutex_lock(&proc_info_lock);
thd->proc_info = NULL;
pthread_mutex_unlock(&proc_info_lock);
```

קטע קוד נוסף:
גם כאן יש שני חוטים שמריצים בו זמנית. שני חוטים משתמשים במשתנה mThread.
הבעיה כאן היא שאנחנו מניחים בתהליך 2 שכבר נקרא ה-init שיוצר אותו.

Thread 1:
```c
void init() {
    mThread = PR_CreateThread(mMain, ...);
}
```

Thread 2:
```c
void mMain(...) {
    mState = mThread->State;
}
```

הבעיה שמתוארת כאן נקראת Order violation.
הנחנו שיש סדר מסוים שקורה בין החוטים. הנחנו שחוט 2 רץ אחרי שחוט 1 סיים את ה-init שלו ולא וידאנו את זה בשום צורה.

הפתרון לכך: שימוש ב-condition variable.
החוט השני בודק האם המאותחל מסוים, ואם לא הוא עושה wait וממתין עד שיודיעו לו שהאותחל הסתיים, ורק לאחר מכן הוא ימשיך.

```c
int mtInit = 0;

// Thread 1:
void init() {
    mThread = PR_CreateThread(mMain, ...);
    pthread_mutex_lock(&mtLock);
    mtInit = 1;
    pthread_cond_signal(&mtCond);
    pthread_mutex_unlock(&mtLock);
}

// Thread 2:
void mMain(...) {
    pthread_mutex_lock(&mtLock);
    while (mtInit == 0)
        pthread_cond_wait(&mtCond, &mtLock);
    pthread_mutex_unlock(&mtLock);
    mState = mThread->State;
}
```

