מערכות הפעלה - שיעור 11

היום נדבר על מנעולים, חוטים ומקביליות ונתעסק בפתרון בעיות שנגרמות עקב השימוש בחוטים מרובים.

משל דוגמא:
נניח שיש לנו כביש, בכביש יש כל מיני מכוניות שנוסעות ויש צומת בכביש.
אם לא נשים בצומת הזה רמזורים, תהיה לנו בעיה/התנגשות וכו'. הרעיון: זה דומה לקוד שלנו.
אנחנו כותבים קוד עם חוטים מרובים (שניים או יותר חוטים), שעושים דברים במקביל, והקוד הזה לפעמים עלול להתנגש אחד עם השני. ייתכן שהחוטים ייגשו למשאבים בו זמנית ותהיה בעיית סנכרון עקב כך.
אנחנו רוצים לטפל בבעיה הזו.
אם ניקח את הרעיון של הצומת ונוכל להניח שכל נתיב הוא כמו חוט ריצה, ומכונית היא קריאה לפונקציה/פקודה וכו'.
אנחנו רוצים למנוע התנגשויות והצומת כולה היא משאב שכולם רוצים להשתמש בו (עקרונית, בו זמנית) ולנו אין שליטה מתי מכוניות מגיעות (מתי החוטים יפעלו, זה תלוי במתזמן/במערכת ההפעלה).
בצמתים יש לנו פתרון קל: להוסיף רמזור. אם נוסף רמזור לצומת נוכל להגדיר מי ילך אחד אחרי השני/לחלופין.
כאשר לנתיב אחד יהיה אור ירוק, הנתיב הזה יוכל להתקדם וכל שאר הנתיבים יעצרו.
כך בכל זמן נתון רק נתיב אחד יוכל להתקדם.
המטרה שלנו היא להשיג משהו דומה בקוד שלנו.
כלומר להשיג מנגנון שאינו יכול להגיד לכולם לעצור ("מתן להם אור אדום") ורק לחוט שרוצה לבצע פעולה חשובה יהיה "אור ירוק", וכשהוא יסיים הוא יחליף את הרמזור של האדום. אנחנו המנהלים של הרמזור, ונבקש מתי הוא יהיה אדום/ירוק.
החלק החשוב: בזמן שהמכונית בצומת אחת, אנחנו לא חוסמים כבישים אחרים.
ואותו דבר נרצה בקוד שלנו. אם אנו ניגש לאיזשהו משאב, נרצה להגביל כל אחד אחר שלא יוכל לגשת למשאב הזה גם.
אבל מי שלא ניגש למשאב הזה, יוכל לגשת למשאבים אחרים ולרוץ במקביל אליו.

דוגמא:
יש לנו קוד שמנהל מערך גדול שיש בו תאים ואנחנו רוצים להוסיף ערך לתא הפנוי הבא (אולי גם יש לנו חוטים שבאים ולוקחים ערכים מהמערך). נסמן כל תא האם הוא פנוי/תפוס כרגע.
כשנרצה להכניס נתון, נמצא את התא הפנוי הבא ונכניס בו ערך.
דרך קלה לממש זאת: משתנה next שאומר מה התא הפנוי הבא.

    Taken
arr[4] Taken
arr[5] Taken
arr[6] Free
arr[7] Free
arr[8] Free
    Free

נסתכל על הקוד שמוסיף איבר למערך:
כל פעם שנרצה להוסיף ערך לאותו מערך, נקרא את המשתנה next, נוסיף את הערך לתא הכתוב ונקדם את next ב-1. אם היינו מריצים את הקוד הזה באופן רגיל, הוא היה פועל בסדר.
אבל אם נפגוש שני חוטים שיקבלו ויריצו את אותו הקוד, נתקל בבעיה, כל אחד מהם רוצה להוסיף איבר למערך והם רצים במקביל (זה לא באמת משנה האם באמת במקביל כלומר יש לנו כמה מעבדים או לא באמת במקביל כלומר יש לנו מעבד אחד שעושה context switch ביניהם) הם רצים בו זמנית ואנחנו לא יודעים באיזה סדר יתבצעו הפקודות.

Thread A
my_slot_A = next;
arr[my_slot_A] = value_A;
next = next+ 1;

Thread B
my_slot_B = next;
arr[my_slot_B] = value_B;
next = next+ 1;

יש מצב שהריצה תתבצע בסדר הזה:
A יקרא את המשתנה next ויזכור את מה שהוא קרא (בדוגמה הוא זוכר 6) ואז יהיה context switch ו-B גם קורא עכשיו 6. שניהם מסתכלים על next שהערך שלו כרגע הוא 6. לפי התכנון שקיבלנו במצגת - B ימשיך, יכתוב את הערך שלו למערך ויקדם את next ל-7.
אבל חוט A שעצרנו באמצע, לא יודע מה קרה, הוא זוכר שהאיבר הפנוי הבא הוא בתא 6, ולכן בתורו שלו הוא יכתוב את הערך שלו לאותו מספר 6 וידרוס את מה ש-B כתב לשם.
זו בעיה קלאסית של סינכרון: שני חוטים שרוצים לגשת למשאב משותף אבל מפריעים אחד לשני בקוד.

דוגמא נוספת:
יש לנו רשימה מקושרת, יש לה ראש שמצביע לאיבר x שמצביע לאיבר y שמצביע ל-null.
אנחנו רוצים להוסיף איבר לרשימה המקושרת. נניח וכבר הקצנו איבר עם ערך בתוכו, רק רוצים להוסיף אותו לראש הרשימה לצורך הדוגמא. הקוד שעושה זאת:

item_A->next = head;
head = item_A;

כשנריץ את זה באופן סדרתי, הכל יהיה תקין ויעבוד.
אבל אם יש לנו שני חוטים שמבצעים זאת במקביל: אנחנו לא יודעים איך זה ייגמר. יהיו לנו תופעות לא צפויות.
למשל בתכנון הבא: A לוקח את האיבר שלו ומגדיר שה-next שלו זה ה-head, אבל לפני שהוא מספיק לעדכן את ראש הרשימה, בא חוט B ועושה את אותו הדבר - הוא לוקח את האיבר שלו ומגדיר שה-next שלו זה ה-head, ובנוסף מעדכן את ראש הרשימה להיות האיבר שלו. כלומר חוט B לא רואה את השינוי ש-A עשה כי A עדיין לא סיים.
באותה מידה, חוט A לא יודע מה ש-B עשה ומשנה מאותה נקודה שהוא עצר ומעדכן את ראש הרשימה להיות האיבר שלו. חוט A שלא במודע, הוציא את האיבר ש-B שם מהרשימה.
אז גם קיבלנו רשימה לא תקינה וגם יש לנו זליגת זיכרון (האיבר של B נעלם ולאף אחד אין את הכתובת שלו).
אז מה שראינו עכשיו (שני קטעי הקוד) זה מה שנקרא קטע קריטי - קטע קוד שניגש למשאב משותף כלשהו (המערך, הרשימה, המשתנה next) וזה קטע קוד שהיינו רוצים שלא יבוצע בו זמנית.
היינו רוצים שקטע קוד שמוסיף איבר לרשימה המקושרת יתבצע לבד, מבלי שיהיו חוטים שיפריעו באמצע.
התופעות שראינו נקראות מצב ריצה או מרוץ - מצב שבו הנכונות של הקוד שלנו תלויה בתזמון.
אם חוט A היה רץ מההתחלה ועד הסוף ללא הפרעות, ואחריו חוט B, אז התוצאה הייתה נכונה.
אחרת, התוצאה עלולה להיות לא נכונה.
לזה דבר שאנחנו לא רוצים שיקרה, כי אנחנו לא יודעים איך המתזמן יפעיל את הקוד שלנו.
אז המטרה שלנו היא להבטיח איפה בקוד יש קטעים קריטיים כלומר, קטעים מסוימים שניגשים למשאב משותף, ולוודא שהם רצים בצורה נכונה בלי סיכון להגיע למצב ריצה/מרוץ.
נעשה זאת באמצעות סימן מיוחד: כל פעם שנהיה בקטע קריטי, נסמן אותו, כלומר נעשה קריאות מיוחדות בקוד שלנו כדי לוודא שהוא רץ כמו שצריך.

איך נראה קטע קריטי?
הניהול הוא החלק היותר קשה. אבל יש לנו כמה קווים מנחים שאנחנו יכולים לפעול לפיהם.
בשביל שנוכל להיות בבעיית סינכרון, יש 3 תנאים וכל שלושת התנאים הללו צריכים להתקיים:
1. זהו קטע קוד שרץ לפחות ע"י שני חוטים/תהליכים (אם זה קטע קוד סדרתי אז כמובן שאין בעיה).
2. זהו קטע קוד שניגש לאותו משאב משותף. כלומר צריכים להיות לפחות שני חוטים והם צריכים לגשת לאותו משאב.
3. לפחות אחד מהחוטים/תהליכים משנה את המשאב. כלומר אם כולם ניגשים לאותו משאב ורק קוראים אותו, אז אין בעיה. לעומת זאת, אם אפילו חוט אחד משנה את המשאב (מעדכן/משנה את הערך) בצורה כלשהי ומשאב יכול להיות משתנה, מערך, אובייקט כלשהו, מדפסת... אז צריך לסנכרן את כולם (גם החוטים שכותבים וגם אלו שרק קוראים).
אם שלושת התנאים הללו מתקיימים, אז עלולה להיות בעיית סינכרון (לא בוודאות תהיה) וזה אומר שזה קטע קוד קריטי ועכשיו צריך לבחון אותו ולראות שהוא רץ כראוי.
ברגע שכל שלושת התנאים הללו מתקיימים, אנחנו צריכים לעבור על כל הקוד ולחשוב על כל דרכי הריצה שהקוד הזה עלול לרוץ ולבדוק האם יש תזמון שיכול להיות בעייתי.
דבר אחד חשוב שחייבים לזכור: חוטים מריצים פקודות מכונה ולא שורות קוד בשפת C.
אז שורת קוד אחת שאנחנו מריצים יכולה להיות 3 שורות פקודות מכונה.
צריכים להבין איך הקוד שלנו מתרגם לפעולות במעבד.
כמו שראינו בשיעור הקודם: אם אנחנו כותבים counter++ זה מתפרש ל-3 פקודות מכונה ולא פקודה אחת.

איך נפתור את הבעייתיות של קטע קריטי?
ברגע שראינו שיש לנו קטע קריטי ועלולה לקרות התנגשות, אחד הפתרונות שאנחנו יכולים להשתמש בהם: מנעול - mutex
הוא אובייקט חדש שנועד לסנכרן בין החוטים.
למנעול יש שני מצבים:
1. פנוי - מייצג את המצב שאף אחד לא משתמש במשאב כרגע (אולי מכונית לא נמצאת בצומת כרגע, הצומת פנויה).
2. תפוס - מייצג את המצב שמישהו (חוט אחד בלבד) מחזיק את המשאב כרגע (כלומר הוא בא ונעל את המנעול) והוא הבעלים של המשאב עד שהוא ישחרר את המנעול.
בקוד שלנו אנחנו יכולים לבקש לנעול את המנעול. למנעול יש שתי פעולות:
1. lock - מבקשים לנעול את המנעול (מנסים לנעול). לא בטוח שהבקשה שלנו תצליח: אם המנעול פנוי, הבקשה תצליח, אבל אם המנעול נעול, נצטרך לחכות עד שהוא יתפנה ואז נוכל לתפוס אותו בעצמנו. זו פעולה שנקראת blocking, היא חוסמת (אנחנו קוראים לפעולה, והחוט שלנו יהיה חסום עד שהוא יצליח לתפוס את המנעול). רק חוט אחד יכול לתפוס את המנעול בכל רגע נתון.
2. unlock - שחרור המנעול. אם נעלנו את המנעול, אנחנו יכולים בהמשך הקוד לשחרר את המנעול, ומישהו אחר יוכל לתפוס את המנעול אחרינו.

דוגמאות לשימוש במנעול:
דוגמא 1: יש לנו שני חוטים: A,B וכל אחד מהם מריץ איזשהו קטע קוד.
בתור התחלה: שני החוטים רצים ורוצים קטע קוד שאינו קריטי.
בנקודה כלשהי בקוד של A הוא מגיע לפקודה שניגשת למשאב משותף, כל שלושת התנאים שהצגנו מקודם מתקיימים במקרה הזה ו-A רוצה לוודא שאף אחד לא יפריע לו והוא קורא לפעולה (lock().
כרגע המנעול פנוי, אלו שני החוטים היחידים בתוכנית (כלומר אם יש מנעול איפשהו בקוד - הוא פנוי) ו-A מצליח לתפוס את המנעול. הוא נעל (באופן לוגי) את המנעול. הוא נכנס לקטע הקוד הקריטי שלו ומבצע אותו.
חוט B המשיך לרוץ ואז בנקודה כלשהי גם חוט B רוצה להיכנס לקטע קריטי (לגשת לאותו משאב).
לפני שהוא נכנס לקטע קוד הקריטי שלו, B מנסה לתפוס את המנעול (קורא ל-lock()), אבל המנעול תפוס, ולכן B חסום. הקריאה ל-lock() לא חוזרת.
ברגע ש-A סיים את קטע הקוד הקריטי שלו, הוא קורא ל-unlock(). ברגע ש-A שחרר את המנעול, עכשיו B כבר לא חסום והוא מצליח לתפוס את המנעול וגם הוא יכול לבצע את קטע הקוד הקריטי שלו, עד שיסיים גם הוא ויקרא ל-unlock().
אז כל פעם לפני שיש לנו קטע קוד שיכול להיות בעייתי, אנחנו תופסים מנעול, ואחרי שסיימנו את הקוד, משחררים. כך מובטח לנו שאף אחד לא יוכל לגשת למשאב הזה במקביל אלינו.

דוגמא 2: יש לנו את קטע הקוד הבא שמוסיף איבר למערך בתא הפנוי הבא:
קטע הקוד זהה למקודם, מלבד השורה הראשונה והאחרונה.
לפני הגישה למערך, גם A וגם B ניגשים למשתנה שנקרא arrlock (הוא המנעול שלנו) ומנסים לנעול אותו. ובסוף קטע הקוד, הם משחררים אותו.
לא כך נראות הקריאות של מנעול בפועל, אבל זה קוד לדוגמא.
נריץ את זה ונוודא שקיבלנו את אותו התכנון כמו מקודם, בצורה הבאה:
- ברגע שחוט A מריץ את הפקודה הראשונה, הוא תופס את המנעול.
- חוט A מתקדם וקורא את המשתנה my_slot ונעשה context switch לקטע הקוד של חוט B.
- חוט B גם רוצה להריץ את קטע הקוד שלו, אז ראשית הוא ינסה לתפוס את המנעול, אבל הוא נחסם. המנעול כרגע תפוס ע"י חוט A ולכן חוט B כרגע חסום. הוא לא יכול להמשיך לשורה הבאה, הוא תקוע על השורה של ה-lock().
לכן לא משנה כמה חוט A יתעכב או כמה חוט B יהיה מהיר, חוט B לא יוכל להמשיך לפקודה הבאה, ואז קטע הקוד שלנו יסודר אחרת: בהכרח קטע הקוד של חוט A יהיה חייב להתבצע קודם. ולכן בסוף התזמון ייראה כך:
A הוסיף את הערך שלו למערך, עדכן את המשתנה next ואז קרא ל-unlock ושחרר את המנעול. ברגע זה, חוט B הצליח לתפוס את המנעול והמנעול עכשיו אצלו. כלומר רק כש-A סיים את הפעולה שלו, המנעול עבר ל-B. כש-B יחזור לקטע הקוד שלו ולאחר תפיסת המנעול, הוא יקרא את ה-next המעודכן (ש-A עדכן) וישים את הערך שלו בתא הנכון.
הם לא יכולים לשכתב ערכים אחד של השני בגלל שהם עושים זאת אחד אחרי השני בהכרח.

Thread A
arrlock.lock();
my_slot_A = next;
arr[my_slot_A] = value_A;
next = next+ 1;
arrlock.unlock();

Thread B
arrlock.lock();
my_slot_B = next;
arr[my_slot_B] = value_B;
next = next+ 1;
arrlock.unlock();

המנעול מפריד בין החוטים וגורם לכל חוט לבצע את קטע הקוד שלו בנפרד, ללא הפרעות.
גם אם נקבל context switch באמצע, חוטים אחרים לא יוכלו להתקדם ולבצע קוד בעייתי בגלל המנעול.
- נראה שקטעי הקוד אכן יוכלו לרוץ במקביל, שילמנו ביעילות (בביצועים) לשם נכונות.

דוגמא 3: רשימה מקושרת עם אותו קטע קוד כמו בדוגמא הקודמת (של הרשימה), מלבד הוספת השורה הראשונה והאחרונה לכל חוט (נעילה ושחרור של המנעול).
אם המתזמן שלנו יריץ באותה הצורה כמו מקודם, אז A יתפוס את המנעול ויצור את האיבר שלו כשהוא מעדכן את ה-next.
גם כאן, אם חוט B ירצה לרוץ ב-enqueue, אז חוט B ינסה לתפוס את המנעול אך הוא לא יצליח, והוא יישאר חסום עד שחוט A יסיים את פעולתו. הקריאה lock לא חוזרת.
בשלב כלשהו נחזור ל-A והוא ישלים את הפעולה כמו שצריך, ישחרר את המנעול ואז חוט B יוכל להמשיך עם הערכים הנכונים.

Thread A
lstock.lock();
item_A->next = head;
head = item_A;
lstock.unlock();

Thread B
lstock.lock();
item_B->next = head;
head = item_B;
lstock.unlock();

הרעיון הוא לזהות מתי יש לנו קטעי קוד בעייתיים ולתפוס את המנעול לפני ואחרי.
חשוב שהתפיסה של המנעול תהיה מינימלית - למצוא קטע קוד כמה שיותר מצומצם וקצר שבו עלולה להיות בעיית סינכרון, ושם אנחנו קוראים ל-lock ולפני סיום ביצוע קטע קוד ל-unlock.
נניח והיו לנו שתי רשימות מקושרות בקוד, אז זה כמו שתי צמתים, ולכל רשימה היינו מחזיקים מנעול משלה.

מימוש מנעול שיהיה יעיל:
1. פתרון שהיה פעם בשימוש: מימוש מנעול ע"י ביטול פסיקות - אם נבטל את הפסיקות במחשב אז לא יכול להיות context switch - ואם לא תהיה פסיקת שעון, מערכת ההפעלה לא תקבל חזרה שליטה, החוט שלנו לא יכול לעצור ואז נדע שבזמן שאנחנו מריצים את קטע הקוד הקריטי, לא יחליפו אותנו. וכשנסיים נבצע קריאת unlock. זה פתרון שהיה בשימוש פעם, והוא עבד אבל הוא היה בעייתי.
החסרונות העיקריים הם:
1. אנחנו נותנים כוח לתהליכי משתמש (כוח שלא צריך להיות להם). אם יש תהליך זדוני הוא יכול לקחת את כל זמן המעבד לעצמו ולא להחזיר את הפסיקות כשהוא מסיים.
2. יכול להיות באג - אם תהליך מסוים מבטל פסיקות ונכנס ללולאה אינסופית, המחשב ייתקע.
3. אין אפשרות לנהל כמה מעבדים כי ברגע שביטלנו פסיקות, רק אנחנו רצים. אין התייחסות לחוטים אחרים.
4. אם יש לנו קטע קריטי ארוך - ביטלנו פסיקות. אם המשתמש לחץ על מקש במקלדת, המקלדת שלחה פסיקה והיא לא תתייחס לזה מיד, הוא יחכה. כך נאבד עניינים.
5. זה לא עובד בימינו כשיש לנו כמה מעבדים. ברגע שיש יותר ממעבד אחד ודברים רצים באמת במקביל, אנחנו יכולים לבטל פסיקות, אבל מעבדים אחרים רצים במקביל אלינו והם יכולים להריץ חוטים וקטעי קוד שישפיעו על בעיות.
מערכת ההפעלה עדיין משתמשת במנגנון הזה - היא מבטלת פסיקות - כשהיא רוצה לבצע דברים רגישים שיש בהם בעיות סנכרון, היא מבטלת פסיקות. אבל היא יודעת שהיא לא זדונית, שקטע הקוד אינו פגום ושהקטע הקריטי יהיה מאוד מאוד קצר, כלומר נבטל פסיקות ומיד נחזיר אותן, וגם היא יודעת להתמודד עם כמה מעבדים.
אז זה לא מנגנון שניתן לתהליכים שלנו, אבל מערכת ההפעלה כן יכולה לבטל פסיקות כשמנהלת קטעים קריטיים.

2. ננסה לממש מנעול בעצמנו מבלי לבטל פסיקות וכלי עזרה ממערכת ההפעלה בתור התחלה.
בעיות הסנכרון נובעות מכך שעל הזיכרון של המחשב אנחנו יכולים לבצע רק פעולות כתיבה וקריאה (load, store).
כל הפעולות החשבוניות והלוגיות נעשות על רגיסטרים (אוגרים של המעבד), כלומר קוראים נתון מהזיכרון, מבצעים עליו פעולות ואז כותבים אותו בחזרה לזיכרון.
זה מה שיוצר לנו הרבה מבעיות הסנכרון, כי אנחנו לא יכולים לבצע הרבה מהפעולות ישירות על הזיכרון.

דוגמאות למימושים של מנעול לשני חוטים - נניח מראש שיש לנו רק שני חוטים שרצים במקביל בתוכנית שלנו, זה לא כזה משנה בעיה לממש ליותר חוטים, כל המימושים שנראה יכולים להיות מורחבים ליותר חוטים, פשוט יותר קל לדבר על דוגמאות של שני חוטים.
1. ניסיון למימוש של זיכרון הדגלים: המנעול משתמש בדגל (ביט, משתנה בוליאני) שאומר אם המנעול תפוס/פנוי כרגע. אם הוא 0 המנעול פנוי ואם הוא 1 הוא תפוס. חוט שירצה לתפוס את המנעול, ישים 1 במשתנה הזה. אם המנעול תפוס אז נחכה, עד שיתפנה.

קטע קוד לדוגמא: שני חוטים שמריצים בדיוק את אותו הקוד. שתי השורות הראשונות הן הקריאה ל-lock, השורה האחרונה היא ה-unlock.

Thread A
while (flag == 1)
  ; // busy-wait
flag = 1;
// critical section
flag = 0;

Thread B
while (flag == 1)
  ; // busy-wait
flag = 1;
// critical section
flag = 0;

כשחוט רוצה לתפוס מנעול, הוא רץ בלולאה כל עוד הדגל של המנעול הוא 1 (כל עוד המנעול תפוס).
ברגע שהוא רואה שהדגל הוא 0, הוא כותב אליו 1 ותופס את המנעול ואז הוא יכול לבצע את קטע הקוד הקריטי.
ברגע שהוא מסיים את קטע הקוד הזה, הוא משחרר את המנעול והופך את הדגל ל-0.
שני החוטים עושים בדיוק את אותו הדבר.
למה הקוד הזה לא יעבוד? קטע הקוד הזה הוא בעייתי. אם נשים לב, יש שתי שורות שלא מתבצעות בבת אחת (בדיקה שהדגל למטה + הרמה שלו). ברגע שרואים שהדגל למטה ואחר מכן מרימים אותו, חוט אחר יכול להתערב באמצע ולתפוס אותו.

מנעול טוב הוא מנעול בעל 3 תכונות ולא כולן חייבות להתקיים:
1. מניעה הדדית - התכונה הבסיסית שצריכה להיות למנעול: בכל רגע נתון יש לכל היותר חוט אחד בקטע הקריטי.
כלומר חוט אחד בלבד מחזיק במנעול. (יש רק נתיב אחד עם אור ירוק לכל היותר, לא יכולים להיות שני נתיבים עם אור ירוק כי אז תהיה תאונה). לכל היותר חוט אחד יכול להיות גם אף אחד, כלומר מניעה הדדית לא מבטיחה שהמנעול ייפתח.
2. deadlock freedom - במנעול שלנו לא יהיה קיפאון (deadlock). אם מנסים לתפוס את המנעול, אז מישהו מצליח.
(אם יש מכוניות בצמתים ותמיד למישהו יש אור ירוק. לא ייתכן שלכל הנתיבים בצומת יהיה אור אדום).
תכונה זו מבטיחה שלא ייווצר מצב שכולם תקועים וממתינים ואף אחד לא מתקדם.
3. הוגנות (starvation-freedom) - כל חוט יצליח לתפוס את המנעול בסופו של דבר.
בדרישה למניעה הדדית ו-deadlock freedom זה אומר שלא יכולים להיות שני נתיבים עם אור ירוק ותמיד יהיה נתיב אחד עם אור ירוק, אבל זה לא אומר מי. ייתכן שחוט אחד יתפוס את המנעול ואז ישחרר ואז יתפוס עוד פעם, בזמן שחוטים אחרים כל הזמן עוקפים ומחכים. זה מקיים את שני התנאים הראשונים: כל הזמן מישהו תופס את המנעול ואף פעם אין יותר מאחד, אבל זה אינו הוגן בגלל שלנתיב אחד יש תמיד אור ירוק ונתיבים אחרים ממתינים לנצח.
הוגנות חופש מהרעבה - אם אני מנסה לתפוס את המנעול, אז מתישהו יהיה לי אור ירוק, כלומר מישהו יצליח לתפוס את המנעול. או - לא יכול להיות שיעקפו אותי מספר אינסופי של פעמים.

המנעול שראינו קודם - לא מקיים את התנאים שראינו עכשיו.
יש לנו מנעול עם דגל שאומר האם המנעול תפוס/פנוי. בתור התחלה המנעול פנוי (הדגל הוא 0).
כאשר חוט רוצה לתפוס את המנעול, הוא קורא את הדגל ומחכה כל עוד הדגל למעלה, וכשהוא למטה הוא מרים אותו.
יכול להיות בתזמון הבא שהחוטים שלנו ירוצו בצורה הזו:
חוט A יראה שהדגל הוא 0 ויוכל לעבור את ה-while (כי הדגל הוא 0).
כך גם חוט B יעשה. הוא יתפוס את המנעול וייכנס לקטע הקריטי.
כשחוט A ימשיך לרוץ, הוא זוכר שהדגל היה למטה, ואז הוא מרים את המנעול (שכבר מורם) ותופס את המנעול.
אין פה מניעה הדדית, שני החוטים חושבים שהם תפסו את המנעול ומבצעים את הקטע הקריטי בו זמנית.

ננסה לשפר את המנעולים:
ניתן דגל לכל חוט. במקום שיהיה דגל שאומר אם המנעול תפוס/פנוי, לכל חוט יהיה דגל משלו שאומר האם הוא מעוניין להיכנס לקטע הקריטי. הקוד ייראה כך:

Thread A
flag_A = 1;
while (flag_B == 1)
  ; // busy-wait
// critical section
flag_A = 0;

Thread B
flag_B = 1;
while (flag_A == 1)
  ; // busy-wait
// critical section
flag_B = 0;

כל חוט צריך לבצע 3 דברים:
2 השורות הראשונות בקטעי הקוד הם נעילת המנעול.
נסתכל על A: ברגע שחוט A רוצה לבצע קטע קוד קריטי, כלומר רוצה להכניס איבר לרשימה, הוא מרים את הדגל שלו.
ואז הוא בודק האם הדגל של חוט B גם למעלה, כלומר הוא בודק האם גם חוט B מעוניין להיכנס לקטע הקריטי.
חוט A ימתין עד שחוט B יוריד את הדגל, ורק אז הוא נכנס לקטע הקריטי, וכנ"ל הפוך.
לסיום, משחררים את המנעול (הופכים את הדגל ל-0).

המנעול הנוכחי מקיים מניעה הדדית - לא ייתכן ששני חוטים יבצעו ביחד קטע קריטי.
מה שאין במנעול הזה - deadlock freedom. יכול לקרות מצב שבו המנעול ירוץ את החוטים בצורה הזו:
A מרים את הדגל ואז B מרים את הדגל (לפחות אחד מהם יתעכב יותר במקביל).
עכשיו כשהם ימשיכו, חוט A יחכה שחוט B יסיים וחוט B יחכה שחוט A יסיים.
שניהם הרימו את הדגל וממתינים. שניהם חסומים עכשיו ותקועים בלולאה שהם אף פעם לא ייצאו ממנה.
כל אחד מחכה לשני ואין deadlock freedom.

הבעיה שלנו פה נובעת מכך ששני החוטים רוצים להיכנס לקטע קריטי, אם הם באים בבת אחת, הם נתקעים.
ננסה למנוע זאת בעזרת המנעול הבא, שבו נשתמש בדגלים אלו בתור - המנעול שלנו יגיד תור מי לתפוס את המנעול.
כאשר חוט ירצה לתפוס את המנעול הוא פשוט יבדוק האם זה תורו כעת, אם כן - יתפוס את המנעול, אחרת - יחכה לתורו.
ברגע שחוט יסיים את קטע הקוד הקריטי, הוא יעביר את התור לחוט השני.
כך מובטח לנו שלא יהיו שני חוטים בקטע הקריטי.
למה המנעול הזה לא יעבוד?
אנחנו מניחים פה ש-A ו-B בכלל רוצים לתפוס את המנעול. אבל אולי אחד מהם לא רוצה.
יש לנו שני חוטים במערכת, אבל יכול להיות שחוט מסוים עושה דברים אחרים.

Thread A
while (turn != A)
  ; // busy-wait
// critical section
turn = B;

Thread B
while (turn != B)
  ; // busy-wait
// critical section
turn = A;

נחשוב על ריצה שבה יש מנעול וכרגע התור הוא של חוט A אבל חוט A מבצע דברים אחרים כרגע ולא קטע קריטי. כשאנחנו אומרים שיש לנו מנעול לשני חוטים, זה אומר שלכל היותר שני חוטים ישתמשו בו, אבל זה לא מבטיח שיהיה בו שימוש בכל זמן נתון.
אנחנו רוצים שחוט יוכל לתפוס את המנעול במידה והחוט השני לא רוצה אותו כרגע ואין צורך לחכות לו אם הוא לא צריך בכלל, אחרת חוט B ייכנס ללולאה אינסופית ויחכה. שוב קורה לנו deadlock - חוט B מחכה לתורו אבל אף פעם לא יגיע תורו.

ננסה לשלב בין השיטות:
נשתמש בקודם עם הדגלים שהיה בעייתי כששני חוטים באים ביחד (שניהם מרימים את הדגל וחוסמים אחד את השני).
השיטה עם התור בעייתית כשרק חוט אחד מגיע והשני לא מגיע כלל.
נשלב את שני הרעיונות כך שהמנעול שלנו יתפקד בכל מקרה.
מנגנון פטרסון (Peterson) - המנגנון משתמש בשני הרעיונות - לכל חוט יש דגל האם הוא מעוניין, ובנוסף יש תור שאומר תור מי. כשחוט רוצה לתפוס את המנעול: הוא מרים את הדגל, ואז הוא נותן את התור לצד השני.
המשתנה turn לא אומר מי יתפוס את המנעול, אלא למי יש קדימות.
אם שני החוטים רוצים לתפוס את המנעול, זה אומר מי יקבל את התור ראשון. אבל אם רק חוט אחד רוצה לתפוס את המנעול, ה-turn לא מעניין, לא מסתכלים על המשתנה turn.
אז שני החוטים כאשר הם רוצים לתפוס את המנעול, מרימים את הדגל ונותנים את התור לצד השני. ההמתנה היא כל עוד הדגל של השני למעלה וגם תורו של השני.
כלומר, אם הדגל של B למטה, זה אומר שהוא לא מעוניין לתפוס את המנעול, אז לא מעניין אותי התור - אני נכנס לקטע הקריטי. אם לעומת זאת הדגל של B למעלה, אז נסתכל מי בקדימות/של מי התור (turn). ברגע שמסיימים, החוטים מורידים את הדגל ומעבירים את התור לצד השני.

Thread A
flag_A = 1;
turn = B;
while ((flag_B == 1) &&
       (turn == B))
  ;
// critical section
flag_A = 0;

Thread B
flag_B = 1;
turn = A;
while ((flag_A == 1) &&
       (turn == A))
  ;
// critical section
flag_B = 0;

* המנעול הזה עובד: יש בו מניעה הדדית, deadlock freedom והוגנות.
אבל המנעול משתמש ביותר מדי זיכרון. כל חוט צריך דגל במנהל הזה.
בכל פעם בשביל להיכנס לקטע הקריטי, נצטרך לבצע לולאת המתנה.
כשאנחנו מדברים על קטע קוד מקבילי, נרצה לגשת כמה שפחות לזיכרון משותף, זה דורש הרבה זיכרון וזה בעייתי.
עם פעולות קריאה וכתיבה בלבד יש הוכחה שלפיה: חייבים לפחות n תאים של זיכרון כגודל מספר החוטים.
אין דרך לממש מנעול עם פחות זיכרון.
לכן, נפנה לחומרה - למעבד שלנו. במעבדים יש פעולות יותר חזקות מקריאה/כתיבה. אמרנו שעל הזיכרון אנחנו יודעים רק לכתוב/לקרוא אבל זה לא נכון רק לגבי פעולות סטנדרטיות. יש לנו פעולות אטומיות - פעולות חומרה שיש במעבד, שבבת אחת עושות כמה פעולות.
הן פקודות שאנחנו יכולים להשתמש בהן ובאמצעותן לעשות פעולות שלא היו זמינות לנו אחרת. כך הן כתובות בשפת C:

type __sync_fetch_and_add(type *ptr, type value, ...)
type __sync_bool_compare_and_swap
type __sync_lock_test_and_set

דוגמא: קטע הקוד הבא לוקח את המשתנה counter ומגדיל אותו ב-1. כאן זה נעשה באמצעות פקודת חומרה מיוחדת שעושה זאת באופן אטומי. אם נריץ קוד זה ע"י כמה חוטים, נראה שזה עובד בצורה נכונה, כי זה מתבצע בפקודה אחת (במקום 3).

void* mythread(void *arg) {
  for (int i = 0; i < 1e7; ++i) {
    __sync_fetch_and_add(&counter, 1);
  }
  return NULL;
}

אז למה שלא נשתמש בזה כל פעם?
יש שיקולים שגורמים לפקודות הללו להיות פחות יעילות. אם אנחנו לא צריכים סינכרון, אל לנו להשתמש בהן. פעולת הגדלת מונה פשוטה יכולה להיות יותר יעילה מאשר ביצוע פעולה אטומית.

הפקודה test_and_set: פקודת מכונה שמבצעת את הקוד הבא:
המימוש של הפקודה מתבצע באופן אטומי. זה נקרא sequential specification - הגדרה סדרתית - אנחנו כותבים קטע קוד שהוא כביכול סדרתי, שאומר מה הפקודה עושה, אבל בפועל, פקודת המכונה test_and_set עושה את קטע הקוד הזה באופן אטומי בבת אחת. הפעולה הזו מקבלת מצביע לערך שנרצה לשנות וערך חדש, כותבת אותו ומחזירה מה היה בו לפני כן.
באמצעות הפקודה הזו, אנחנו יכולים לחזור לממש מנעול הרבה יותר בקלות.

int TestAndSet(int* old_ptr, int new) {
  int old = *old_ptr;
  *old_ptr = new;
  return old;
}

מימוש מנעול לדוגמא: TAS (TEST_AND_SET) LOCK:
חוזרים לרעיון של הדגל (דגל יחיד למנעול) - אם הוא 0 נתפוס אותו, נרים אותו ל-1.
ברגע שיש לנו את פקודת המכונה test_and_set, נוכל לרוץ בלולאה ולהריץ את הפקודה הזו על הדגל שלנו עם הערך 1.
כלומר, אנחנו כותבים 1 ומקבלים חזרה מה היה בדגל לפני כן - וכל זה בבת אחת.
אם כתבנו 1 וקיבלנו חזרה 1: זה אומר שהמנעול כבר היה תפוס. במקרה הזה נמשיך בלולאה עד שנקבל ערך החזר 0 שזה אומר שהמנעול היה פנוי בעת הכתיבה.
אם כתבנו 1 וקיבלנו חזרה 0 - זה אומר שבדגל היה 0 ואנחנו כתבנו 1, כלומר המנעול היה פנוי, ובגלל שהפעולה אטומית - מובטח לנו שכל חוט אחר שינסה לבצע את הפעולה הזו במקביל אלינו יקבל בחזרה 1.
אז ראינו שהמנעול פנוי ובו זמנית נעלנו אותו כך שהוא יהיה תפוס לכל מי שיבוא אחרינו.
ברגע שסיימנו, פשוט נעדכן את המנעול להיות 0, ואז חוט אחר שרוצה לתפוס את המנעול יראה שהוא פנוי ויוכל להיכנס לקטע הקוד הקריטי.

while (TestAndSet(&flag, 1))
  ; // spin-wait
// critical section
flag = 0;

* מבחינת נכונות - המנעול הזה נכון. הוא מקיים deadlock freedom (מניעת קיפאון). אין בו הוגנות מלאה מבחינת תזמון - ייתכן שחוט יתפוס את המנעול מיד לאחר ששחרר אותו ולא ייתן לחוטים אחרים להשתמש בו.

הפקודה compare_and_swap: פקודה אטומית שגם היא כותבת ערך ומחזירה את מה שהיה קודם, ההבדל הוא שהכתיבה נעשית עם תנאי. ההגדרה הסדרתית של הפעולה הזו:
הפקודה מקבלת מצביע לערך שנרצה לשנות, ושני ערכים: ערך מצופה וערך חדש. הפקודה מבצעת שינוי של הערך רק אם הערך הקודם היה ה-expected. בכל מקרה מוחזר מה שהיה לפני כן.

int CompareAndSwap(int* ptr, int expected, int new) {
  int original = *ptr;
  if (original == expected)
    *ptr = new;
  return original;
}

מימוש מנעול לדוגמא: CAS (COMPARE_AND_SWAP) LOCK:
מנעול עם דגל יחיד. הפעם נבצע compare_and_swap לדגל עם 0 כ-expected והערך 1 כ-new. אנחנו בודקים: אם המנעול הוא 0 (כלומר פנוי) נכתוב לו את הערך 1 (נתפוס אותו) ואם יש בו כבר 1 אז שום דבר לא יתבצע. הפעולה מחזירה לנו מה היה קודם, כלומר אם המנעול היה פנוי או תפוס לפני הפעולה.
המנעול הזה דומה למנעול TAS רק שיש בו שימוש בפקודת מכונה אחרת.

while (CompareAndSwap(&flag, 0, 1))
  ; // spin-wait
// critical section
flag = 0;

שני המנעולים הללו דומים, שניהם מונעים deadlock אבל אינם בהכרח הוגנים.
נראה רעיון למנעול שיש בו הוגנות: TICKET LOCK:
במנעול זה, כל חוט שרוצה להחזיק במנעול - לוקח תור, ויש משתנה שאומר מי הבא בתור להיכנס לקטע הקריטי.
נניח ויש לנו 3 חוטים: A,B,C.
אם A רוצה להיכנס לקטע הקריטי אז הוא לוקח כרטיס (מספר).
הוא ייקח את המספר 0 ויגדיל את ה-ticket להיות 1.
עכשיו הוא מסתכל על ה-turn ורואה שזה תורו.
חוט B רוצה להיכנס לקטע הקריטי אז הוא לוקח כרטיס 1, הוא רואה שלא תורו אלא הוא מחכה בלולאה עד שיגיע תורו. כך גם לגבי חוט C.
ברגע שחוט A סיים, הוא זורק את המספר שלו ומעדכן את ה-turn (מקדם אותו ב-1), ואז חוט B יראה שהגיע תורו, וכן הלאה. אם A ירצה להיכנס שוב לקטע הקריטי, הוא ייקח מספר חדש וכו'.

Turn 0
Ticket 0
Threads: A, B, C

הפתרון למימוש הנ"ל - פעולת חומרה נוספת שנקראת fetch_and_add:
הפקודה מקבלת כתובת של משתנה ומגדילה אותו ב-1 (באופן אטומי).
בעזרת פעולה זו, נוכל להגדיל את ערך ה-ticket ב-1 באופן אטומי, וכך נוכל לממש את המנעול.

int FetchAndAdd(int* ptr) {
  int old = *ptr;
  *ptr = old + 1;
  return old;
}

