**מערכות הפעלה – שיעור 6**

בשיעור הקודם דיברנו על **free list**. עולה השאלה- איזה איבר מהרשימה נבחר בכל פעם? 
כשההקצאות שלנו הן בגודל קבוע לא משנה איזה איבר ניקח (כל האיברים זהים), אבל כשההקצאות בגודל משתנה, הצורה שבה אנחנו בוחרים מהרשימה – משפיעה על כמה פרגמנטציה אנחנו יוצרים.

**שיטות לבחירת איבר מהרשימה:**
1. **Best fit** - לכל איבר יש את גודל הזיכרון הפנוי שלו. שיטה זו בוחרת את האיבר עם הזיכרון הפנוי הכי קטן שעונה על הדרישות. למשל אם המשתמש ביקש הקצאה של 20 והייתה לנו רשימה עם 10,15,25 אז ניקח את ה-25 נבצע **split**, את ה-5 נחזיר לרשימה ואת ה-20 ניקח.
* השיטה הזו מנסה יחסית טוב למנוע את המצב של **external fragmentation**.
**external fragmentation** - מצב שבו יש הקצאות בזיכרון שמפוזרות/חלקים ואז סה"כ יש לנו הרבה זיכרון פנוי אבל בגלל שהוא לא רציף, אנחנו לא יכולים לנצל אותו טוב (אם מישהו מבקש הקצאה גדולה, אז לכאורה יש לנו מספיק זיכרון אך הוא לא רציף ולכן אנחנו לא יכולים לספק את הבקשה).
* מבחינת ביצועים, השיטה הזו פחות טובה. על רשימות ארוכות זה יכול להיות נורא איטי למצוא את התוצאה הטובה ביותר.

2. **worst fit** – נעבור על הרשימה ונבחר את האיבר הכי גדול (האיבר שיש לו את הכי הרבה זיכרון). שיטה זו עדיין בעייתית מבחינת ביצועים (בדומה לשיטה הקודמת), וגם גורמת להרבה מאוד פרגמנטציה (כל פעם שיש לנו שטח זיכרון גדול, במקום לשמור אותו לנצל אותו מתי שצריך, אנחנו מפרקים אותו ויוצרים הרבה חלקים קטנים).

3. **First fit** - שיטה זו מחזירה את האיבר הראשון שמתאים. שיטה זו מורידה את בעיית הביצועים והופכת אותה ליעילה יותר, לרוב לא צריך לסרוק את כל הרשימה. מצד שני, גם כאן עלולה להיות פרגמנטציה, אבל לא הכי גרועה (לפעמים משהו טוב, לפעמים משהו רע). חיסרון נוסף- בגלל שעוברים מההתחלה ומחזירים את האיבר הראשון שמתאים, בדרך כלל נחזיר איברים מההתחלה ואז מה שיקרה זה שנלכלך את תחילת הרשימה (יהיו לנו המון איברים קטנים בתחילת הרשימה, זה יפגע לנו בביצועים).

4. **Next fit** - שיטה זו באה להתמודד עם הבעייתיות של **First fit**. זוהי השיטה שיותר בשימוש כיום. שיטה זו פועלת כמו **first fit**, כלומר נעבור על הרשימה ונחזיר את הראשון שמתאים, אבל כל פעם לא נתחיל מתחילת הרשימה אלא מאיפה שעצרנו בפעם האחרונה.

-----------------------------------------------------------------------------------------

**Segregated list** - אמרנו שכש ההקצאות הן בגודל קבוע, ניתן להקצות מהר מאוד וקל לנהל ככה את הרשימה. שיטה זו מנסה לשמור חלק מהזיכרון שנקרא לו **slab**. ב-**slab** יהיו מקטעים בגודל שווה. שאר הזיכרון יהיה כרגיל. נניח שהמקטעים ב-**slab** שלנו הם בגודל 100 ועכשיו כשהמשתמש יבקש להקצות זיכרון, אם הוא יבקש למשל 100 בנימ בדיוק, אז ניתן לטפל בו מאוד מהר, פשוט נחזיר לו אחד מהאיברים ב-**slab** שלנו. 

לעומת זאת, אם הוא יבקש מספר אחר, למשל 110 בנימ, אז נלך לזיכרון הרגיל ונשתמש באלגוריתמים הפחות טובים ונטפל בו כרגיל. זה טוב כי יש אובייקטים שאנחנו יודעים מראש שירצו להקצות אותם הרבה והגודל שלהם כבר ידוע, למשל אובייקטים ידועים של מערכת ההפעלה, לכן הם גודל המקטעים ב-**slab** ייקבע.
אם נגמר הזיכרון ב-**slab**, אז מקצים עוד (מהזיכרון הרגיל).

-----------------------------------------------------------------------------------------

**Buddy Allocation** - בא לפתור את הבעיה של **coalesce** (איחוד שטחי זיכרון בודדים ופנויים). ניקח את הזיכרון שלנו וכל פעם שהמשתמש מבקש זיכרון, אנחנו מפצלים את הזיכרון הנתון ל-2. 
נניח שהזיכרון שלנו הוא בגודל 64kb ונניח שהמשתמש ביקש להקצות 7kb. אנחנו מפצלים את הזיכרון לשני חלקים, כל אחד בגודל 32kb. זה עדיין גדול מדי, אז לוקחים שוב אחד מהחלקים ומפצלים אותו לשני חלקים של 16kb. עד שהגענו לגודל הכי קטן שיכול להיות 8kb (נפצל לשניים כי אז יהיה 4 וזה לא מספיק. אז 8 זה הכי קטן שניתן להשתמש באחד הבלוקים.
אם נסתכל על הכתובות של הזיכרון, הכתובת של שני שכנים נבדלת בביט אחד, ואז קל לייצר מבנה נתונים שמתאר מתי שני שכנים פנויים. ברגע שהמשתמש מפנה את הבלוק הזה שגודלו של ה-8kb, רק נחליף ביט אחד ונבדוק את הבלוק של השכן שלו- אם שניהם פנויים, נאחד אותם ויהיה לנו בחזרה 16kb.

- החיסרון העיקרי בשיטה הזו: **internal fragmentation**: מצב בו אנחנו נותנים למשתמש יותר זיכרון ממה שהוא ביקש. זה בזבוז.

-----------------------------------------------------------------------------------------

יש לנו את הזיכרון הפיזי שלנו, למשל **8GB**. בדרך כלל, תהליך אחד תופס **4GB** (כמו מרחב הכתובות שלו). 
אבל זה אומר שבכל הזיכרון שלנו נכנסים רק שני תהליכים. מצד שני יש לנו המון תהליכים (בבדיקה על המחשב בביתי יש **8GB** זיכרון ו-335 תהליכים שרצים באותו רגע, ולכל אחד מהם יש **4GB** של זיכרון).
אז יש פה משהו שמערכת ההפעלה עושה. אנחנו כביכול מספקים לכל תהליך **4GB** של זיכרון כשבפועל אין לנו מספיק זיכרון לכך. הדבר נעשה ע"י **וירטואליזציה של הזיכרון**.

נניח ויש לנו שני תהליכים, כל אחד מהם צורך **4GB** של זיכרון, ובזיכרון הפיזי אין מספיק מקום לכל התהליכים. מה שתהליכים רואים זה זיכרון וירטואלי, זה זיכרון שלא באמת קיים.
כל תהליך חושב שיש לו גישה לכל כתובת במרחב הכתובות של ה-**4GB** שהוא צריך אבל זה לא קיים. במקום זה, מערכת ההפעלה מחזיקה מיפויים (כל תא בזיכרון, כל משתנה וכו' מופנים למקום מסוים בזיכרון הפיזי). כשאנחנו חושבים שאנחנו ניגשים לזיכרון, אנחנו בעצם ניגשים למקום אחר.
חלק מהזיכרון של התהליכים מופנה להארד-דיסק (מערכת ההפעלה משתמשת בהארד דיסק כמקום אחסון נוסף). יכול גם להיות שתהליך בכלל לא יהיה בשום מקום. יכול להיות שיהיה תהליך **4GB** אבל בפועל רוב התהליכים לא משתמשים ביותר מ-**1GB** ולכן לא צריך להחזיק את כל השטח הזה בזיכרון אם לא משתמשים בו.

**כיצד המיפוי נעשה?**
אנחנו רוצים לממש זיכרון וירטואלי. המטרות שלנו:
1. **שקיפות** – אנחנו לא רוצים שהקוד של התהליך יושפע מהמנגנון שבחרנו. מבחינת התהליך, יש לו מרחב כתובות של 4GB והוא ניגש לזיכרון, והוא לא צריך לדעת שום דבר מעבר. 
2. **יעילות**- כל פעם שתהליך מסוים ניגש לכתובת מסוימת נצטרך קוד שמבצע תרגום. נחזיק טבלה/איזשהו מבנה נתונים, נעשה את התרגומים. אבל כמעט כל פקודה מצריכה גישה לזיכרון ולכן אם נבצע קוד כל פעם שיש גישה לזיכרון, זה יהיה מאוד לא יעיל ואיטי. אנחנו חייבים מנגנון שיהיה מהיר.

3. **הגנה**- נרצה שכל תהליך יהיה את הזיכרון הנפרד שלו, ואף תהליך לא תהיה גישה לזיכרון של תהליך אחר.

- בשביל יעילות אנחנו חייבים לעבור לחומרה. תהיה לנו חומרה שמבצעת תרגום בכל פעם שנעשה ניגש לזיכרון. החומרה תתרגם מכתובת וירטואלית לכתובת פיזית, מערכת ההפעלה תנהל את הנתונים שרכיב החומרה משתמש בהם. 

**דוגמה 1: Base & Bounds:** כל תהליך במחשב, נטען באיזור כלשהו בזיכרון (במלואו).
ב-**pcb** (מבנה הנתונים של כל תהליך) נשמור את המיקום של הזיכרון של אותו תהליך. נשמור את זה ע"י שני ערכים:
1. **Base** – איפה מתחיל הזיכרון של התהליך.
2. **Bounds** – מה הגודל של הזיכרון.
* בשיטה הזו לכל תהליך יכול להיות גודל משתנה של זיכרון. 
כידוע, במעבד יש **kernel mode** – מצב שבו מותר לעשות מה שאנחנו רוצים, ויש **user mode** – מצב מוגבל ואין לנו הרשאות לעשות מה שאנחנו רוצים. 
ה-**Base&Bounds** לא רק נשמרים עבור כל תהליך ב-**pcb** (ה-pcb הוא מבנה הנתונים של ה-**kernel**), ה-**Base&Bounds** הם גם רגיסטרים במעבד. 
בכל פעם שמתבצעת גישה לזיכרון, אנחנו מתייחסים לרגיסטרים הללו. מי שמשתמש בהם הוא רכיב חומרה שנקרא **mmu (memory management unit)** – רכיב חומרה שמצוי בתוך המחשב שתפקידו שלו זה לקבל כתובת וירטואלית ולתרגם אותה לכתובת פיזית. 
אם הייתה איזושהי בעיה (תהליך ניגש לכתובת שאסור לו / לא חוקית) אז ה-**mmu** מייצר שגיאה.

**צד של מערכת ההפעלה:** מערכת ההפעלה שומרת ב-**pcb** עבור כל תהליך את ה-**Base&Bounds** שלו (איפה הוא נמצא בזיכרון וכמה זיכרון הוא תופס), ואז ב-**context switch** כשמתבצעת החלפה בין תהליכים, מערכת ההפעלה מעדכנת את ה-**Base&Bounds** במעבד (גם במעבד יש רגיסטרים **base** ו-**bounds**). כלומר, כשמתבצעת החלפת תהליך, מערכת ההפעלה לוקחת את ה-**base** של התהליך וטוענת אותו ל-**base** של המעבד וכן לגבי ה-**Bounds**. 
עדכון של שני הרגיסטרים הללו במעבד מותר רק ב-**kernel mode**, לכן רק מערכת ההפעלה יכולה לעשות זאת. ואז ה-**mmu** משתמש בהם בכל גישה לזיכרון. 
ה-**mmu** לוקח את הכתובת הוירטואלית לתרגום ובודק שהיא נמצאת בתוך ה-**bounds**, כלומר בודק שהתהליך לא חרג מגבולות הזיכרון. אם התהליך חרג, זו שגיאה. אחרת, מוסיפים את ה-**base** לכתובת הוירטואלית (הכתובת שהמשתמש חושב שהיא 0 למשל, יכולה להיות 3000 שלה ה-**base** במקרה הזה).

כאשר נעשית החלפת תהליכים (**context switch**), מערכת ההפעלה מחליפה את ערכי הרגיסטרים במעבד בהתאם לתהליך הנכנס (טוענת את ה-**base** וה-**bounds** של התהליך הנכנס). 

**הבעייתיות בשיטת Base & Bounds** – בזבוז של זיכרון. ייתכן וכל השטח בין הערימה למחסנית לא בשימוש. לרוב התהליכים יש **4GB** כתובות אבל בדרך כלל הם לא משתמשים בכל הזיכרון הזה. 
הפתרון הזה עונה על כל שלושת התנאים שציינו מקודם (הוא מאוד יעיל, הוא שקוף ואין לו דרך לחרוג מהזיכרון שלו) אבל הוא לא כלכלי. אנחנו מבזבזים הרבה זיכרון סתם. ניתן לנצל תהליך הרבה יותר זיכרון ממה שהוא צריך. 

הפתרון לכך: **סגמנטציה – segmentation:** ניקח את הרעיון של **Base&Bounds** צעד אחד קדימה. במקום שיהיה לנו רק **base** ו-**bounds** יחידים לכל תהליך, ניתן לכל תהליך כמה כאלה. ניקח כל סגמנט של התהליך (מחסנית, ערימה וכו') ונשים אותן במקום אחר בזיכרון. הם לא צריכים להיות סמוכים. לכל סגמנט כזה יהיו **base,bounds** משלו. במידע של התהליך תהיה טבלה קטנה של **base** ו-**bounds** המשויכים לכל סגמנט. ה-**bounds** והמחסנית והערימה יגדלו וישתנו תוך כדי ריצה ככל שמקצים זיכרון.

**segmentation fault**- שגיאה שקורית כאשר ניגשים לזיכרון, ה-**mmu** מתרגם את הכתובת שלנו והתברר שהכתובת היא מחוץ לגבולות הסגמנט (גישה לזיכרון שאסור לגשת אליו וכו'). ה-**mmu** מזהה זאת וגורם לשגיאת **out of bounds** והודיע למערכת ההפעלה שמשהו לא תקין קרה, ומערכת ההפעלה הקריסה לנו את התהליך (כלומר מערכת ההפעלה שלחה לנו סיגנל שהקריס לנו את התהליך).

**חלוקת קוד בסגמנטציה:**
בסגמנטציה אפשר לחלק זיכרון בקלות בהקשר של ה-**ram**: נניח והרצנו תהליך **p1**, אז את הקוד של תהליך זה אנחנו שמים בזיכרון. אם הרצנו תהליך נוסף **p2**, אז אנחנו טוענים גם את הקוד של **p2**.
אם **p1** ו-**p2** הם אותה תוכנית, אז לא צריך לטעון את הקוד פעמיים, כי זה בדיוק אותו הקוד, ואז בסגמנטציה נגיד ל-**p2** שהקוד שלו נמצא במיקום הקוד של **p1**. הערימה בין שני התהליכים היא נפרדת, אבל הקוד משותף. הקוד לא משתנה בזמן ריצה, הקוד שקומפל זה הקוד הסופי. 
יש צורך להוסיף דגל של הרשאות – זה קיים בטבלת הסגמנטים. 

| Segment | Base | Size | Grows Positive | Protection |
| :--- | :--- | :--- | :--- | :--- |
| Code | 32K | 2K | 1 | Read-Execute |
| Heap | 34K | 3K | 1 | Read-Write |
| Stack | 28K | 2K | 0 | Read-Write |

למשל אם זו הטבלה שנקבל עבור תהליך מסוים: ניתן לראות שהסגמנט של הקוד שלו מתחיל ב-**32k** (זה ה-base) וגודלו (ה-bounds) הוא **2k**, אז הוא בין **32k** ל- **34k** וההרשאות של סגמנט זה הן **read, execute** כלומר ניתן לקרוא ממנו ולבצע פקודות מכונה אך לא ניתן לכתוב אליו ולשנות אותו, ולכן אין בעיה שהוא יהיה משותף לשני תהליכים (כי אחד מהתהליכים חושב שזה שלו). למקטעים אחרים בזיכרון יש הרשאות של קריאה וכתיבה. 

**Grows positive**- לאיזה כיוון הסגמנט גדל. אם המספר הוא **1**, הסגמנט גדל כלפי מעלה למשל עבור השורה הראשונה בטבלה, זה מ-**32 ל-34**. ואילו אם המספר הוא **0**, הסגמנט גדל כלפי מטה למשל עבור השורה השלישית בטבלה, זה מ-**28 ל-26**. 

- למערכת ההפעלה יותר להקצות / לשחרר זיכרון לסגמנטים. 
כמו כן, סגמנט גדל, מערכת ההפעלה מגדילה אותו. 

**compaction- קומפקטיפיקציה:**
כאשר קורה מצב בו נשאר המקום באיזור בו הוקצה הסגמנט (אבל לא בזיכרון עצמו), כלומר בזיכרון שלנו יש פרגמנטציה, כל מיני סגמנטים מפוזרים ברחבי הזיכרון והשטח הפנוי לא רציף. אז נשתמש בקומפקטיפיקציה. הרעיון אומר: נעצור את כל התהליכים שרצים כרגע במחשב ונעתיק את כל הזיכרון (את כל הערכים שיש בזיכרון) ונאחד אותם באיזושהי צורה. 
נעדכן את הטבלאות של כל תהליך (את ה- **base & bounds**) וניתן לתהליכים להמשיך לרוץ. מבחינת התהליכים זה שקוף. 
הרעיון הוא בעצם פיזור יותר אחיד של סגמנטים על פני הזיכרון ואז כשתהליכים רוצים לגדול יהיה להם מקום לגדול אליו, ושטח רציף. 
קומפקטיפיקציה מנסה למנוע את הבעיה, אבל זו פעולה מאוד יקרה. אם כל תהליך משתמש ב-**500mb** לזיכרון ויש לנו 300 תהליכים, אז יהיו המון העתקות וזה ייקח המון זמן רק תהליך ההעתקה.

ראינו את שיטת ה-**base&bounds** ואת הסגמנטציה. מה שבשימוש היום זה ה-**paging (דפדוף)**:
הדפדוף לוקח את הרעיון של סגמנטציה צעד קדימה, כך שלא נצטרך אף פעם לעשות קומפקטיפיקציה. 
הדפדוף פותר את העובדה שההקצאות הן תמיד בגודל קבוע, כך קל לנהל את הזיכרון. 
לא ניקח תהליך ובמקום לחלק אותו לסגמנטים, נחלק אותו לחלקים בגודל קבוע ונתעלם מהסגמנטים (לא מעניין את מערכת ההפעלה אם זה קוד/מחסנית/ערימה). 

אז עכשיו אין לנו בכלל **base&bounds**. יש את הזיכרון הוירטואלי של תהליך (שזה מה שהוא חושב שיש) ויש את הזיכרון הפיזי של תהליך (שזה מה שבאמת יש). 

לוקחים את הזיכרון הוירטואלי של התהליך ומחלקים אותו לחלקים שווים. לכל חלק אנחנו קוראים **דף**. 

על כל כתובת בזיכרון אנחנו יכולים להגיד באיזה דף היא נמצאת. 

| לוקחים את הזיכרון הוירטואלי של התהליך ומחלקים אותו לחלקים שווים. לכל חלק אנחנו קוראים **דף**. על כל כתובת בזיכרון אנחנו יכולים להגיד באיזה דף היא נמצאת. | • **Divide address space** into fixed-size pieces<br>• Each unit is a (virtual) **page**<br>• **Divide physical memory** into **page frames**<br><br>• Example:<br>• 64KB address space<br>• 16KB page/frame<br>• 128KB RAM | ![diagram mapping virtual pages to physical frames] |
| :--- | :--- | :--- |

בדומה, נחלק את הזיכרון הפיזי למסגרות. מסגרת תהיה באותו גודל של דף (כי דף זה הוירטואלי ומסגרת זה הפיזי). הרעיון הוא שכל מסגרת מכילה דף. 
הזיכרון של תהליך, מפוזר על פני הזיכרון הפיזי שלנו. אז התהליך חושב שהזיכרון שלו רציף, אבל בפועל פירקנו את הזיכרון לחלקים ושמנו כל חלק במקום אחר. 

**שיפור ראשון שנוכל לעשות:** אם יש חלקים בזיכרון שלא משתמש בהם בכלל, אז לא נמפה אותן בכלל (הדף שלהן לא יהיה באף מסגרת). 

- כדאי לשים לב שמה שיש לנו בפועל זה רק החלק הסגול (במצגת) שזה ה-**ram**, הזיכרון הוירטואלי לא באמת קיים. 

- התפקיד של ה-**mmu** זה לעשות את ההמרה בין **דף וירטואלי למסגרת**.

דבר נוסף שצריך לשמור זה את המיקומים של כל הדפים ששייכים לתהליך מסוים. את זה נשמור במבנה נתונים שנקרא "**טבלת הדפים**". זוהי טבלה שקיימת לכל תהליך, אשר נשמרת ב-**kernel** כחלק מהמידע של כל תהליך. 
כאשר ניגשים לזיכרון, ה-**mmu** נעזר בטבלת הדפים לתרגום מול הסגמנט. 

**תהליך התרגום:**
נניח ותהליך ניגש לכתובת **33k**. אנחנו רוצים לתרגם את הכתובת כי **33k** היא לא באמת כתובת אמיתית אלא כתובת וירטואלית. לפי הדוגמא הקודמת, כתובת זו תימצא בדף מספר 2. הכתובת בתוך הדף (ההיסט בתוך הדף, כלומר המרחק מתחילת הדף) הוא **1kb** (כלומר **1024**). 
למספר הדף אנחנו קוראים גם **vpn (virtual page number)** ולמרחק מתחילת הדף אנחנו קוראים היסט **offset**. 
בחזרה לדוגמא: דף מספר 2 מיתרגם למסגרת מספר 5 (שמתחילה בכתובת **80k**). 
ההיסט בתוך המסגרת נשאר זהה להיסט שהיה בדף, לכן התהליך ירצה לפנות לכתובת **81k** בתוך המסגרת. 

**נעשה את התרגום הזה יותר לעומק:**
מרחב הכתובות הוירטואלי של התהליך (מה שהתהליך חושב שיש לו) זה **64kb** (לפי הדוגמא שלמעלה). 
כלומר **2^16** בייטים. מכאן שכל כתובת שהתהליך ניגש אליה (כתובת וירטואלית) מיוצגת ע"י 16 ביטים. 
אז נכתוב בבינארי את הכתובת שנרצה לגשת אליה (הוירטואלית, **33k**). 
כל דף הוא בגודל **16kb** ויש לנו **64kb** גודל זיכרון וירטואלי, לכל תהליך יש 4 דפים, כלומר נדרשים 2 ביטים לייצג את מספר הדף. אם נסתכל על החלק הכי שמאלי בכתובת שלנו (ל-2 הביטים השמאליים) זה בדיוק הביטים לייצג מספר דף. 
גודל דף הוא **16kb** שזה **2^14** בייטים, ולכן כדי לייצג ערך בתוך הדף (היסט), נדרשים 14 ביטים. 

הזיכרון הפיזי הוא בגודל **128kb** ולכן יש 17 ביטים לייצוג כתובת פיזית. 
אנחנו יודעים שה-**mmu** מקבל קלט של 16 ביטים (כתובת וירטואלית) וייצר פלט של 17 ביטים (כתובת פיזית). 
מספר המסגרת מיוצג ע"י **ppn (physical frame number)** – מספר מסגרת פיזית. 
מספר הביטים לייצוג של המסגרת הפיזית בדוגמא הנ"ל הוא 3 (כי יש 8 מסגרות). 

• **Let's examine the translation:**
• Virtual address space: 64KB (2^16)
• Virtual address: 33K (33792)
• Page size: 16KB (2^14)
• # of virtual pages: 4 (2^2)

16 bits (address space)
Virtual address: 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
VPN (# pages): 1 0 (Page 2)
Offset (page size): 0 0 0 1 0 0 0 0 0 0 0 0 0 0 (Offset 1024)

• Physical memory (RAM) size: 128KB (2^17)
• Frame size = page size: 16KB (2^14)
• # of physical frames: 8 (2^3)

Virtual address: [1 0] [0 0 0 1 0 0 0 0 0 0 0 0 0 0] (VPN | Offset)
Page Table: 2 -> 5
Physical address: [1 0 1] [0 0 0 1 0 0 0 0 0 0 0 0 0 0] (17 bits RAM size)
PFN (# frames): 1 0 1 (physical frame number)
Offset (frame size): 0 0 0 1 0 0 0 0 0 0 0 0 0 0

