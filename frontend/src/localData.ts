/**
 * Local data service — replaces FastAPI calls for Practice page.
 * Reads bundled JSON from public/data/ (generated by bundle_data.py).
 */
import type {
  AIQuestionsResponse,
  AIStats,
  ExamSummary,
  ExamData,
  QuestionJSON,
  ExamQuestion,
  AllExamQuestionsResponse,
  ExamFilterOptions,
} from './types';

const BASE = import.meta.env.BASE_URL;

// ── Caches ──────────────────────────────────────────────────────────────────

interface RawExam {
  filename: string;
  metadata: {
    course_name: string;
    year: string;
    semester: string;
    moed: string;
    exam_date: string;
    source_file: string;
  };
  questions: QuestionJSON[];
}

let _examsCache: RawExam[] | null = null;
let _aiCache: (QuestionJSON & {
  _source_file: string;
  _topic_hint: string;
  _requested_type: string;
  _requested_difficulty: string;
  _generated_at: string;
  _subject: string;
})[] | null = null;

async function loadExams(): Promise<RawExam[]> {
  if (_examsCache) return _examsCache;
  const res = await fetch(`${BASE}data/exams.json`);
  _examsCache = await res.json();
  return _examsCache!;
}

async function loadAI() {
  if (_aiCache) return _aiCache;
  const res = await fetch(`${BASE}data/ai-questions.json`);
  _aiCache = await res.json();
  return _aiCache!;
}

function shuffle<T>(arr: T[]): T[] {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// ── Practice API (local equivalents) ────────────────────────────────────────

export async function getAIQuestions(params: {
  topic?: string;
  topics?: string[];
  subject?: string;
  question_type?: string;
  difficulty?: string;
  page?: number;
  page_size?: number;
}): Promise<AIQuestionsResponse> {
  const all = await loadAI();
  let filtered = [...all];

  if (params.subject) {
    const s = params.subject;
    filtered = filtered.filter(q => q._subject === s);
  }
  if (params.topics && params.topics.length > 0) {
    const selected = params.topics.map(t => t.toLowerCase());
    filtered = filtered.filter(q => {
      const qTopics = Array.isArray(q.topic) ? q.topic : [String(q.topic || '')];
      return selected.some(sel => qTopics.some(tp => tp.toLowerCase().includes(sel)));
    });
  } else if (params.topic) {
    const t = params.topic.toLowerCase();
    filtered = filtered.filter(q => {
      const topics = Array.isArray(q.topic) ? q.topic : [String(q.topic || '')];
      return topics.some(tp => tp.toLowerCase().includes(t));
    });
  }
  if (params.question_type) {
    filtered = filtered.filter(q => q.type === params.question_type);
  }
  if (params.difficulty) {
    filtered = filtered.filter(q => q.difficulty_estimation === params.difficulty);
  }

  const page = params.page ?? 1;
  const pageSize = params.page_size ?? 20;
  const total = filtered.length;
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  const start = (page - 1) * pageSize;
  const pageQuestions = filtered.slice(start, start + pageSize);

  return {
    questions: pageQuestions.map(q => ({
      metadata: {
        source: 'ai_generated',
        topic_hint: q._topic_hint,
        requested_type: q._requested_type,
        requested_difficulty: q._requested_difficulty,
        generated_at: q._generated_at,
        examples_used: 0,
        subject: q._subject,
      },
      question: q as QuestionJSON,
      _filename: q._source_file,
    })),
    total,
    page,
    page_size: pageSize,
    total_pages: totalPages,
  };
}

export async function getAIStats(): Promise<AIStats> {
  const all = await loadAI();
  const types: Record<string, number> = {};
  const difficulties: Record<string, number> = {};
  const topics: Record<string, number> = {};
  const subjects: Record<string, number> = {};

  for (const q of all) {
    const t = q.type || 'Unknown';
    types[t] = (types[t] || 0) + 1;
    const d = q.difficulty_estimation || 'Unknown';
    difficulties[d] = (difficulties[d] || 0) + 1;
    const tl = Array.isArray(q.topic) ? q.topic : [String(q.topic || '')];
    for (const tp of tl) {
      if (tp) topics[tp] = (topics[tp] || 0) + 1;
    }
    const s = q._subject || 'Unknown';
    subjects[s] = (subjects[s] || 0) + 1;
  }

  return { total: all.length, types, difficulties, topics, subjects };
}

export async function getExams(): Promise<ExamSummary[]> {
  const exams = await loadExams();
  return exams.map(e => ({
    filename: e.filename,
    course_name: e.metadata?.course_name || '',
    year: e.metadata?.year || '',
    semester: e.metadata?.semester || '',
    moed: e.metadata?.moed || '',
    exam_date: e.metadata?.exam_date || '',
    question_count: e.questions?.length || 0,
  }));
}

export async function getExam(filename: string): Promise<ExamData> {
  const exams = await loadExams();
  const exam = exams.find(e => e.filename === filename);
  if (!exam) throw new Error(`Exam not found: ${filename}`);
  return {
    metadata: exam.metadata,
    questions: exam.questions,
  };
}

export async function getExamFilterOptions(): Promise<ExamFilterOptions> {
  const exams = await loadExams();
  const topics: Record<string, number> = {};
  const types: Record<string, number> = {};
  const difficulties: Record<string, number> = {};
  const years = new Set<string>();
  const subjects: Record<string, number> = {};

  for (const exam of exams) {
    if (exam.metadata?.year) years.add(exam.metadata.year);
    for (const q of exam.questions || []) {
      const t = q.type || 'Unknown';
      types[t] = (types[t] || 0) + 1;
      const d = q.difficulty_estimation || (q as any).difficulty || 'Unknown';
      difficulties[d] = (difficulties[d] || 0) + 1;
      const tl = Array.isArray(q.topic) ? q.topic : [String(q.topic || '')];
      for (const tp of tl) {
        if (tp) topics[tp] = (topics[tp] || 0) + 1;
      }
    }
  }

  return {
    topics: Object.fromEntries(Object.entries(topics).sort((a, b) => b[1] - a[1])),
    types: Object.fromEntries(Object.entries(types).sort((a, b) => b[1] - a[1])),
    difficulties: Object.fromEntries(Object.entries(difficulties).sort((a, b) => b[1] - a[1])),
    years: [...years].sort(),
    subjects,
  };
}

export async function getAllExamQuestions(params: {
  question_type?: string;
  difficulty?: string;
  year?: string;
  topic?: string;
  topics?: string[];
  filenames?: string[];
  limit?: number;
  shuffle?: boolean;
}): Promise<AllExamQuestionsResponse> {
  const exams = await loadExams();
  let allQuestions: ExamQuestion[] = [];

  for (const exam of exams) {
    if (params.filenames && params.filenames.length > 0 && !params.filenames.includes(exam.filename)) {
      continue;
    }
    for (const q of exam.questions || []) {
      allQuestions.push({
        ...q,
        _source_exam: exam.filename.replace('.json', ''),
        _exam_year: exam.metadata?.year || '',
        _exam_semester: exam.metadata?.semester || '',
        _exam_moed: exam.metadata?.moed || '',
        _exam_date: exam.metadata?.exam_date || '',
      });
    }
  }

  // Filters
  if (params.question_type) {
    allQuestions = allQuestions.filter(q => q.type === params.question_type);
  }
  if (params.difficulty) {
    allQuestions = allQuestions.filter(q => q.difficulty_estimation === params.difficulty);
  }
  if (params.year) {
    allQuestions = allQuestions.filter(q => (q._exam_year || '').includes(params.year!));
  }
  if (params.topics && params.topics.length > 0) {
    const selected = params.topics.map(t => t.toLowerCase());
    allQuestions = allQuestions.filter(q => {
      const qTopics = Array.isArray(q.topic) ? q.topic : [String(q.topic || '')];
      return selected.some(sel => qTopics.some(tp => tp.toLowerCase().includes(sel)));
    });
  } else if (params.topic) {
    const tl = params.topic.toLowerCase();
    allQuestions = allQuestions.filter(q => {
      const topics = Array.isArray(q.topic) ? q.topic : [String(q.topic || '')];
      return topics.some(tp => tp.toLowerCase().includes(tl));
    });
  }

  if (params.shuffle) {
    allQuestions = shuffle(allQuestions);
  }

  const totalAvailable = allQuestions.length;
  const examsSet = new Set(allQuestions.map(q => q._source_exam).filter(Boolean));

  if (params.limit) {
    allQuestions = allQuestions.slice(0, params.limit);
  }

  // Stats
  const typeCounts: Record<string, number> = {};
  const diffCounts: Record<string, number> = {};
  const topicCounts: Record<string, number> = {};
  const yearCounts: Record<string, number> = {};

  for (const q of allQuestions) {
    const t = q.type || 'Unknown';
    typeCounts[t] = (typeCounts[t] || 0) + 1;
    const d = q.difficulty_estimation || 'Unknown';
    diffCounts[d] = (diffCounts[d] || 0) + 1;
    const tl = Array.isArray(q.topic) ? q.topic : [String(q.topic || '')];
    for (const tp of tl) {
      topicCounts[tp] = (topicCounts[tp] || 0) + 1;
    }
    const ey = q._exam_year || '';
    if (ey) yearCounts[ey] = (yearCounts[ey] || 0) + 1;
  }

  return {
    questions: allQuestions,
    total: allQuestions.length,
    stats: {
      total_available: totalAvailable,
      returned: allQuestions.length,
      exams_count: examsSet.size,
      types: typeCounts,
      difficulties: diffCounts,
      topics: Object.fromEntries(Object.entries(topicCounts).sort((a, b) => b[1] - a[1])),
      years: Object.fromEntries(Object.entries(yearCounts).sort(([a], [b]) => a.localeCompare(b))),
    },
  };
}
