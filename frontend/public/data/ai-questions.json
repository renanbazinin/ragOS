[{"id": 1, "type": "MultipleChoice", "topic": ["Processes", "Process States"], "content": {"text": "מה קורה למצב התהליך (Process State) כאשר הוא מבצע קריאת מערכת הממתינה לפעולת קלט/פלט (I/O), כגון קריאה מדיסק או המתנה לקלט מהמקלדת?", "code_snippet": null, "options": ["א. התהליך עובר למצב Ready כדי שיוכל להמשיך לרוץ מיד.", "ב. התהליך נשאר במצב Running ומבצע Busy Waiting עד שהמידע מגיע.", "ג. התהליך עובר למצב Blocked (או Waiting) עד לסיום פעולת הקלט/פלט.", "ד. התהליך מסיים את ריצתו (Terminated) ומערכת ההפעלה מוחקת אותו."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "כאשר תהליך מבצע פעולת I/O, הוא אינו יכול להמשיך בביצוע פקודות עד שהמידע יהיה זמין. כדי לא לבזבז זמן מעבד יקר, מערכת ההפעלה מעבירה אותו למצב Blocked (חסום) ומקצה את המעבד לתהליך אחר שנמצא במצב Ready. רק לאחר סיום פעולת ה-I/O, התהליך יחזור למצב Ready."}, "difficulty_estimation": "Easy", "_source_file": "0001__Processes__MultipleChoice__Easy.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:02:44"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "Process States"], "content": {"text": "כאשר תהליך מבצע קריאת מערכת הממתינה לקלט מהמשתמש (כמו קריאה מהמקלדת), לאיזה מצב (State) הוא יעבור בדרך כלל?", "code_snippet": null, "options": ["א. Running", "ב. Ready", "ג. Blocked / Waiting", "ד. Terminated"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "כאשר תהליך נדרש להמתין לאירוע חיצוני (כמו קלט/פלט), הוא אינו יכול להמשיך בביצוע הפקודות שלו על המעבד. לכן, מערכת ההפעלה מעבירה אותו למצב Blocked (חום/המתנה) ומשחררת את המעבד לטובת תהליכים אחרים. רק לאחר שהקלט יתקבל, התהליך יחזור למצב Ready."}, "difficulty_estimation": "Easy", "_source_file": "0002__Processes__MultipleChoice__Easy.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:02:52"}, {"id": 1, "type": "MultipleChoice", "topic": ["Processes"], "content": {"text": "כאשר תהליך מבצע קריאת מערכת לביצוע פעולת קלט/פלט (I/O) וממתין לסיומה, לאיזה מצב (State) הוא יעבור?", "code_snippet": null, "options": ["א. Ready (מוכן)", "ב. Blocked / Waiting (חסום / ממתין)", "ג. Running (רץ)", "ד. Terminated (סיים)"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "כאשר תהליך מבצע פעולה הדורשת המתנה לאירוע חיצוני (כמו קלט/פלט), הוא אינו יכול לנצל את המעבד ולכן עובר למצב Blocked (חסום). לאחר סיום הפעולה והגעת הנתונים, הוא יעבור למצב Ready כדי להמתין לתורו לרוץ שוב על המעבד."}, "difficulty_estimation": "Easy", "_source_file": "0003__Processes__MultipleChoice__Easy.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:03:07"}, {"id": 1, "type": "MultipleChoice", "topic": ["Processes"], "content": {"text": "מה קורה למצב התהליך (Process State) כאשר הוא מבצע קריאת מערכת חוסמת (Blocking I/O), כמו קריאה מקובץ מהדיסק שטרם נטען?", "code_snippet": null, "options": ["א. התהליך עובר למצב Ready ומחכה בתור למעבד.", "ב. התהליך נשאר במצב Running ומבצע Busy Waiting עד שהנתונים מגיעים.", "ג. התהליך עובר למצב Blocked (או Waiting) עד לסיום פעולת ה-I/O.", "ד. התהליך עובר למצב Terminated ומערכת ההפעלה סוגרת אותו עקב שגיאה."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "כאשר תהליך מבצע פעולת I/O חוסמת, הוא אינו יכול להמשיך בביצוע הקוד שלו עד שהנתונים מוכנים. כדי לא לבזבז זמן מעבד יקר, מערכת ההפעלה מעבירה את התהליך למצב Blocked ומוציאה אותו מהמעבד. רק כאשר פעולת ה-I/O מסתיימת, התהליך יועבר חזרה למצב Ready."}, "difficulty_estimation": "Easy", "_source_file": "0004__Processes__MultipleChoice__Easy.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:03:25"}, {"id": 1, "type": "MultipleChoice", "topic": ["Processes", "System Calls"], "content": {"text": "מה קורה לתהליך אב הקורא למערכת הקריאה wait() כאשר תהליך הבן שלו עדיין פעיל?", "code_snippet": null, "options": ["א. תהליך האב ממשיך בביצוע הקוד שלו כרגיל ובמקביל לבן.", "ב. תהליך האב עובר למצב 'חסום' (Blocked/Waiting) עד אשר אחד מצאצאיו יסיים את ריצתו.", "ג. תהליך האב נמחק מהטבלה של מערכת ההפעלה.", "ד. תהליך הבן הופך להיות תהליך יתום (Orphan)."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "מערכת הקריאה wait() נועדה לסנכרון בין תהליכים. כאשר תהליך אב קורא לה, הוא מושהה על ידי מערכת ההפעלה (עובר למצב Blocked) עד שאחד מתהליכי הבן שלו מסיים את ריצתו (מבצע exit), ורק אז האב חוזר למצב Ready."}, "difficulty_estimation": "Easy", "_source_file": "0005__Processes__MultipleChoice__Easy.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:09:11"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "System Calls"], "content": {"text": "מה יהיה הפלט של הקוד הבא, בהנחה שכל קריאות המערכת מצליחות?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n        printf(\"%d \", x);\n    } else {\n        wait(NULL);\n        x -= 5;\n        printf(\"%d \", x);\n    }\n    return 0;\n}", "options": ["א. 15 5", "ב. 15 15", "ג. 5 5", "ד. 5 15", "ה. הפלט אינו דטרמיניסטי ותלוי בתזמון המעבד."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א. 15 5", "explanation": "לאחר הקריאה ל-fork, נוצר תהליך בן המקבל עותק נפרד של מרחב הכתובות. בתהליך הבן, fork מחזירה 0, לכן הוא נכנס לבלוק ה-if, מעדכן את ה-x המקומי שלו ל-15 ומדפיס אותו. בתהליך האב, fork מחזירה את ה-PID של הבן (ערך חיובי), ולכן הוא עובר לבלוק ה-else. האב מבצע wait(NULL) ולכן ממתין לסיום הבן לפני שהוא ממשיך בביצוע. לאחר שהבן מסיים, האב מפחית 5 מה-x שלו (שנשאר בערך 10 במקור כי הזיכרון נפרד) ומדפיס 5. לכן הפלט יהיה 15 ולאחר מכן 5."}, "difficulty_estimation": "Medium", "_source_file": "0005__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:03:40"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "System Calls"], "content": {"text": "מהו הערך המוחזר מהקריאה למערכת fork() בתהליך האב (parent process), בהנחה שהפעולה הצליחה?", "code_snippet": null, "options": ["א. 0", "ב. ה-PID (מזהה התהליך) של תהליך הבן שנוצר", "ג. ה-PID של תהליך האב עצמו", "ד. ערך בוליאני true (1)", "ה. הקריאה אינה מחזירה ערך בתהליך האב"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "לאחר קריאה מוצלחת ל-fork(), המערכת מחזירה את ה-PID של הבן החדש לתהליך האב, ומחזירה 0 לתהליך הבן. ערך שלילי מוחזר רק במקרה של שגיאה."}, "difficulty_estimation": "Easy", "_source_file": "0006__Processes__MultipleChoice__Easy.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:09:20"}, {"id": 1, "type": "MultipleChoice", "topic": ["Processes", "System Calls"], "content": {"text": "מה קורה כאשר תהליך קורא לקריאת המערכת fork() במערכת הפעלה מסוג Unix/Linux?", "code_snippet": null, "options": ["א. נוצר תהליך חדש (תהליך בן) שהוא עותק כמעט זהה של תהליך האב.", "ב. התהליך הנוכחי נעצר ומתחלף בקוד של תוכנית חדשה לגמרי.", "ג. נוצר חוט (Thread) חדש בתוך אותו מרחב כתובות של התהליך הקיים.", "ד. המערכת מבצעת מעבר למצב המתנה (Waiting) עד לסיום כל תהליכי הרקע."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "קריאת המערכת fork() יוצרת תהליך חדש על ידי שכפול התהליך הקורא. התהליך החדש (הבן) מקבל עותק של מרחב הכתובות, משתנים וקובצי הקלט/פלט של האב, אך הוא פועל כתהליך נפרד עם מזהה תהליך (PID) ייחודי."}, "difficulty_estimation": "Easy", "_source_file": "0007__Processes__MultipleChoice__Easy.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:09:28"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "Process States"], "content": {"text": "מהו המצב (State) של תהליך שממתין לסיום פעולת קלט/פלט (I/O) לפני שיוכל להמשיך בריצתו?", "code_snippet": null, "options": ["א. Running (ריצה)", "ב. Ready (מוכן)", "ג. Blocked/Waiting (חסום/ממתין)", "ד. Terminated (סיום)", "ה. Zombie (זומבי)"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "כאשר תהליך מבצע קריאת מערכת לקלט/פלט, הוא אינו יכול להמשיך בביצועו עד שהנתונים מוכנים או הפעולה הושלמה. לכן, מערכת ההפעלה מעבירה אותו למצב חסום (Blocked) ומוציאה אותו מתור הריצה כדי לאפשר לתהליכים אחרים להשתמש במעבד. רק לאחר קבלת פסיקה מהחומרה שהפעולה הסתיימה, התהליך יעבור למצב Ready ויוכל להיבחר שוב על ידי ה-Scheduler."}, "difficulty_estimation": "Easy", "_source_file": "0008__Processes__MultipleChoice__Easy.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:09:39"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "System Calls"], "content": {"text": "כמה פעמים תודפס המחרוזת \"Hello\" כתוצאה מהרצת הקוד הבא? הנח שכל הקריאות ל-fork מצליחות.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    if (fork() == 0) {\n        fork();\n        printf(\"Hello\\n\");\n    } else {\n        wait(NULL);\n    }\n    return 0;\n}", "options": ["1", "2", "3", "4", "0"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "2", "explanation": "התהליך המקורי (האב) מבצע fork. תהליך האב מקבל ערך חיובי (PID של הבן) ונכנס לבלוק ה-else, שם הוא מבצע wait וממתין לסיום בנו. תהליך הבן מקבל 0 ונכנס לבלוק ה-if. בתוך ה-if, תהליך הבן מבצע fork נוסף, מה שיוצר תהליך נכד. גם הבן וגם הנכד ממשיכים לשורת ה-printf ומדפיסים \"Hello\". סה\"כ ההדפסה מתבצעת פעמיים."}, "difficulty_estimation": "Medium", "_source_file": "0009__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:09:47"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "נתון קטע הקוד הבא בשפת C. מהו הפלט הצפוי של התוכנית בהנחה שכל קריאות המערכת מצליחות?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n        printf(\"%d \", x);\n    } else {\n        wait(NULL);\n        x -= 3;\n        printf(\"%d \", x);\n    }\n    return 0;\n}", "options": ["א. 15 12", "ב. 15 7", "ג. 7 15", "ד. 12 15", "ה. הפלט אינו קבוע ותלוי בתזמון המעבד."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב. 15 7", "explanation": "לאחר קריאת המערכת fork, נוצר תהליך בן המקבל עותק נפרד של מרחב הכתובות של האב, כולל המשתנה x. בתהליך הבן (שבו fork מחזיר 0), הערך של x הופך ל-15 והוא מודפס. בתהליך האב, נעשה שימוש ב-wait(NULL) שממתין לסיום הבן. לאחר מכן האב מחסיר 3 מהערך המקורי של x (שהיה 10 במרחב הכתובות שלו) ומדפיס 7. מכיוון שהאב מחכה לבן, הפלט תמיד יהיה 15 ולאחר מכן 7."}, "difficulty_estimation": "Medium", "_source_file": "0010__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:09:57"}, {"id": 1, "type": "MultipleChoice", "topic": ["Processes", "System Calls"], "content": {"text": "נתון קטע הקוד הבא בשפת C. נניח שכל קריאות המערכת מצליחות. מה נכון לומר לגבי ה-PID (Process Identifier) ומרחב הכתובות (Address Space) של התהליך המריץ את התוכנית \"ls\", בהשוואה לתהליך הבן שנוצר על ידי קריאת ה-fork המופיעה בקוד?", "code_snippet": "pid_t pid = fork();\nif (pid == 0) {\n    char *args[] = {\"ls\", \"-l\", NULL};\n    execvp(args[0], args);\n    exit(0);\n} else {\n    wait(NULL);\n}", "options": ["א. ה-PID משתנה ומרחב הכתובות משתנה.", "ב. ה-PID נשאר זהה ומרחב הכתובות נשאר זהה.", "ג. ה-PID משתנה אך מרחב הכתובות נשאר זהה.", "ד. ה-PID נשאר זהה אך מרחב הכתובות מוחלף בתוכנית החדשה.", "ה. לא ניתן לדעת, הדבר תלוי במתזמן (Scheduler)."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד. ה-PID נשאר זהה אך מרחב הכתובות מוחלף בתוכנית החדשה.", "explanation": "הקריאה למשפחת פונקציות exec (כמו execvp) מחליפה את מרחב הכתובות של התהליך הנוכחי (קוד, נתונים, מחסנית) בתוכנית חדשה. עם זאת, התהליך עצמו נשאר אותו תהליך במערכת ההפעלה, ולכן הוא שומר על ה-PID המקורי שלו שניתן לו בעת ה-fork."}, "difficulty_estimation": "Medium", "_source_file": "0011__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:10:11"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "System Calls"], "content": {"text": "נתון קטע הקוד הבא בשפת C. מה יהיה הפלט הצפוי של התוכנית בהנחה שכל קריאות המערכת מצליחות?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    if (fork() == 0) {\n        execlp(\"/bin/echo\", \"echo\", \"Hello\", NULL);\n        printf(\"World\\n\");\n    } else {\n        wait(NULL);\n        printf(\"Goodbye\\n\");\n    }\n    return 0;\n}", "options": ["א. Hello ולאחר מכן World ולאחר מכן Goodbye", "ב. Hello ולאחר מכן Goodbye", "ג. World ולאחר מכן Goodbye", "ד. Goodbye ולאחר מכן Hello", "ה. Hello בלבד"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב. Hello ולאחר מכן Goodbye", "explanation": "קריאת המערכת execlp מחליפה את דמות התהליך (Process Image) בתוכנית חדשה. לכן, הקוד שמופיע לאחר הקריאה ל-execlp בתהליך הבן לא יבוצע לעולם (אלא אם הקריאה נכשלה). תהליך האב ממתין לסיום הבן בעזרת wait ולכן ידפיס Goodbye רק לאחר שהבן סיים להדפיס Hello."}, "difficulty_estimation": "Medium", "_source_file": "0012__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:10:32"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "Fork"], "content": {"text": "מה יהיה הפלט של הקוד הבא (בהנחה שכל קריאות המערכת מצליחות והפלט מודפס למסך באופן מיידי)?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n        if (fork() == 0) {\n            printf(\"%d \", x);\n        } else {\n            wait(NULL);\n            printf(\"%d \", x);\n        }\n    } else {\n        wait(NULL);\n        printf(\"%d \", x);\n    }\n    return 0;\n}", "options": ["א. 10 15 15", "ב. 15 15 10", "ג. 15 20 10", "ד. 15 10 10", "ה. 15 15 15"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב. 15 15 10", "explanation": "התהליך הראשי מתחיל עם x=10. הוא מבצע fork. בתהליך הבן, x הופך ל-15. הבן מבצע fork נוסף ליצירת נכד. הנכד יורש את x=15 ומדפיס אותו. הבן מחכה לנכד (wait) ואז מדפיס את ה-x שלו (שהוא 15). לבסוף, תהליך האב המקורי, שחיכה לסיום הבן, מדפיס את ה-x שלו. מכיוון ש-fork יוצר העתק נפרד של מרחב הכתובות, השינויים בבן ובנכד לא השפיעו על ה-x של האב, ולכן הוא מדפיס 10."}, "difficulty_estimation": "Medium", "_source_file": "0013__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:10:47"}, {"id": 101, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בקריאת המערכת fork. מה יהיה הפלט של התוכנית (בהנחה שכל הקריאות ל-fork ו-wait מצליחות)?", "code_snippet": "int main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n        if (fork() == 0) {\n            x += 5;\n            printf(\"%d\", x);\n        } else {\n            wait(NULL);\n        }\n    } else {\n        wait(NULL);\n        x -= 5;\n        printf(\"%d\", x);\n    }\n    return 0;\n}", "options": ["א. 205", "ב. 2015", "ג. 1510", "ד. 2010", "ה. 155"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "א. 205", "explanation": "לאחר ביצוע fork, נוצר עותק של התהליך עם מרחב כתובות נפרד (Copy-on-Write). בתהליך הבן הראשון, x הופך ל-15. לאחר מכן הוא מבצע fork נוסף, ובתהליך הנכד x הופך ל-20 ומודפס. בתהליך האב המקורי, x נשאר 10 (כי הוא לא מושפע מהשינויים בבנים), ולאחר ה-wait הוא מופחת ב-5 ומודפס הערך 5. כיוון שהאב והבן ממתינים לסיום הצאצאים שלהם, ההדפסה של ה-20 תתבצע לפני ה-5."}, "difficulty_estimation": "Medium", "_source_file": "0014__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:10:58"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "מה יהיה הפלט של תוכנית ה-C הבאה? הניחו שכל קריאות המערכת מצליחות.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint x = 10;\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        x += 5;\n        return 0;\n    } else {\n        wait(NULL);\n        x -= 2;\n        printf(\"%d\", x);\n    }\n    return 0;\n}", "options": ["א. 8", "ב. 13", "ג. 10", "ד. 15", "ה. אף אחת מהתשובות אינה נכונה"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "א. 8", "explanation": "קריאת המערכת fork יוצרת תהליך חדש עם מרחב כתובות נפרד (Copy-on-Write). למרות שהתהליך הבן משנה את ערכו של x (מעלה ל-15), השינוי מתבצע על העתק מקומי בזיכרון של הבן ואינו משפיע על המשתנה x בתהליך האב. תהליך האב ממתין לסיום הבן באמצעות wait, ולאחר מכן מבצע x -= 2 על הערך המקורי שנותר אצלו (10). לכן הפלט יהיה 8."}, "difficulty_estimation": "Medium", "_source_file": "0015__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:11:21"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "מה יהיה הפלט של הקוד הבא (בהנחה שכל קריאות המערכת מצליחות)?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n        printf(\"%d \", x);\n    } else {\n        wait(NULL);\n        x -= 3;\n        printf(\"%d \", x);\n    }\n    return 0;\n}", "options": ["א. 15 12", "ב. 15 7", "ג. 7 15", "ד. 12 15", "ה. התוצאה אינה דטרמיניסטית ותלויה במתזמן."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב. 15 7", "explanation": "לאחר הקריאה ל-fork, נוצרים שני תהליכים נפרדים עם מרחבי כתובות נפרדים. שינוי משתנה בתהליך הבן אינו משפיע על המשתנה בתהליך האב. תהליך הבן מעדכן את x ל-15 ומדפיס. תהליך האב מחכה לסיום הבן באמצעות wait, ולכן הבן תמיד ידפיס ראשון. לאחר מכן האב מעדכן את ה-x המקומי שלו (שערכו נותר 10) ל-7 ומדפיס."}, "difficulty_estimation": "Medium", "_source_file": "0016__Processes__MultipleChoice__Medium.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:11:30"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "fork", "wait", "Copy-on-Write"], "content": {"text": "נתון קוד ה-C הבא. בהנחה שכל הקריאות ל-fork() מצליחות ושהמערכת מדפיסה את הפלט למסך, מהם הערכים שיודפסו על ידי כל התהליכים שנוצרו (בסדר כלשהו)?", "code_snippet": "int main() {\n    int x = 0;\n    for (int i = 0; i < 3; i++) {\n        if (fork() == 0) {\n            x++;\n        } else {\n            x--;\n            wait(NULL);\n            break;\n        }\n    }\n    printf(\"%d \", x);\n    return 0;\n}", "options": ["-1 0 1 3", "0 1 2 3", "-1 -1 -1 3", "-1 0 1 2", "אף אחת מהתשובות אינה נכונה"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "-1 0 1 3", "explanation": "הקוד מבצע לולאה שבה בכל שלב נוצר תהליך ילד חדש. האב (התהליך שקיבל ערך חיובי מ-fork) מחסיר 1 מהמשתנה המקומי x שלו, ממתין לסיום הילד שלו (wait), ויוצא מהלולאה (break). הילד (שקיבל 0 מ-fork) מוסיף 1 ל-x שלו וממשיך לאיטרציה הבאה של הלולאה.\n1. תהליך מקורי P0 (עם x=0): ב-i=0 יוצר את P1. ב-P0 ה-x הופך ל-1-, הוא עוצר ומדפיס 1-.\n2. תהליך P1 (הילד של P0, התחיל עם x=1): ב-i=1 יוצר את P2. ב-P1 ה-x הופך ל-0 (פחות 1), הוא עוצר ומדפיס 0.\n3. תהליך P2 (הילד של P1, התחיל עם x=2): ב-i=2 יוצר את P3. ב-P2 ה-x הופך ל-1 (פחות 1), הוא עוצר ומדפיס 1.\n4. תהליך P3 (הילד של P2, התחיל עם x=3): מסיים את הלולאה (i=3) ומדפיס 3.\nהערכים המודפסים הם 1-, 0, 1, 3. בשל ה-wait, הסדר יהיה הפוך (3, 1, 0, 1-) אך השאלה ביקשה את הערכים בסדר כלשהו."}, "difficulty_estimation": "Hard", "_source_file": "0017__Processes__MultipleChoice__Hard.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:11:57"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "fork", "waitpid", "Memory Management"], "content": {"text": "בהנחה שכל הקריאות למערכת (fork, waitpid) מצליחות, מה יהיה הפלט של קוד ה-C הבא?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    int x = 10;\n    pid_t pid = fork();\n    if (pid == 0) {\n        x += 5;\n        pid_t pid2 = fork();\n        if (pid2 == 0) {\n            x += 5;\n            exit(x);\n        }\n        int status;\n        waitpid(pid2, &status, 0);\n        if (WIFEXITED(status)) {\n            x += WEXITSTATUS(status);\n        }\n        printf(\"%d\", x);\n    } else {\n        wait(NULL);\n    }\n    return 0;\n}", "options": ["א. 15", "ב. 20", "ג. 30", "ד. 35", "ה. 40"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "הסבר: 1. האב המקורי יוצר תהליך בן (C1). לכל אחד מהם מרחב זיכרון נפרד. 2. בתוך C1, המשתנה x מעודכן ל-15. 3. C1 יוצר תהליך נכד (G1). ל-G1 עותק נפרד של הזיכרון שבו x הוא 15. 4. G1 מעדכן את x ל-20 ומסיים עם exit(20). 5. C1 ממתין ל-G1 ובעזרת המאקרו WEXITSTATUS שולף את קוד החזרה (20). 6. C1 מוסיף את הערך שחזר (20) ל-x המקומי שלו (15), ולכן x ב-C1 הופך ל-35. 7. C1 מדפיס את הערך 35. האב המקורי רק מבצע wait ולכן לא מדפיס דבר."}, "difficulty_estimation": "Hard", "_source_file": "0018__Processes__MultipleChoice__Hard.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:12:18"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "fork", "exec", "Process Image"], "content": {"text": "נתון קוד ה-C הבא. בהנחה שכל הקריאות למערכת מצליחות וכל הקבצים קיימים, מה יהיה הפלט של התוכנית?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    printf(\"1\\n\");\n    if (fork() == 0) {\n        printf(\"2\\n\");\n        execlp(\"/bin/echo\", \"echo\", \"3\", NULL);\n        printf(\"4\\n\");\n    } else {\n        wait(NULL);\n        printf(\"5\\n\");\n    }\n    return 0;\n}", "options": ["1, 2, 3, 4, 5", "1, 2, 3, 5", "1, 2, 4, 5", "1, 3, 2, 5", "הקוד יגרום לשגיאת זמן ריצה (Runtime Error)"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "1, 2, 3, 5", "explanation": "התהליך הראשי מתחיל ומדפיס '1'. לאחר מכן מתבצע fork. בתהליך הבן, מודפס '2' ואז מתבצעת הקריאה ל-execlp. פקודה זו מחליפה את תמונת הזיכרון של התהליך הנוכחי בתוכנית החדשה (echo). לכן, הקוד שמופיע לאחר ה-exec (הדפסת '4') לעולם לא יתבצע אם ה-exec הצליח. התוכנית echo מדפיסה '3' ומסתיימת. תהליך האב ממתין לסיום הבן באמצעות wait, ורק לאחר מכן מדפיס '5'. לכן הפלט יהיה 1, 2, 3, 5."}, "difficulty_estimation": "Hard", "_source_file": "0019__Processes__MultipleChoice__Hard.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:12:41"}, {"id": 1, "type": "MultipleChoice", "topic": ["Processes", "fork", "wait", "Zombie Processes", "Orphan Processes"], "content": {"text": "נתון קטע הקוד הבא בשפת C המורץ על מערכת Linux. נניח שכל הקריאות ל-fork מצליחות, ה-PID של התהליך המקורי הוא 100, וה-PID של תהליך ה-init במערכת הוא 1. מה יודפס על ידי ה-Grandchild (הנכד), ומה יהיה מצבו של תהליך הבן (Child 1) ברגע שה-Grandchild מדפיס את הפלט?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) { // Child 1\n        if (fork() == 0) { // Grandchild\n            sleep(2);\n            printf(\"%d\", getppid());\n            exit(0);\n        }\n        exit(0);\n    }\n    wait(NULL);\n    sleep(5);\n    return 0;\n}", "options": ["א. יודפס 100, ותהליך Child 1 יהיה במצב Zombie.", "ב. יודפס 1, ותהליך Child 1 יהיה במצב Zombie.", "ג. יודפס 1, ותהליך Child 1 לא יהיה קיים במערכת (נוקה).", "ד. יודפס 100, ותהליך Child 1 לא יהיה קיים במערכת (נוקה).", "ה. יודפס ה-PID של ה-Grandchild, ו-Child 1 יהיה במצב Running."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "כאשר Child 1 מבצע exit, הוא הופך ל-Zombie. התהליך המקורי (Parent) קורא ל-wait(NULL), פעולה זו 'אוספת' את הסטטוס של Child 1 ומנקה אותו מטבלת התהליכים (Reaping), לכן הוא אינו קיים יותר במערכת. ה-Grandchild הופך ליתום (Orphan) כיוון שאביו (Child 1) סיים את ריצתו. במערכות Linux, תהליך יתום מאומץ על ידי תהליך ה-init (או subreaper), שכתובתו היא 1. לכן, getppid() יחזיר 1."}, "difficulty_estimation": "Hard", "_source_file": "0020__Processes__MultipleChoice__Hard.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:12:58"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "fork", "Zombie Processes", "Orphan Processes"], "content": {"text": "נתון קטע הקוד הבא בשפת C. נניח שכל הקריאות ל-fork מצליחות, ושהמערכת משתמשת בתהליך ה-init (PID 1) כמאמץ ברירת מחדל לתהליכים יתומים. מה יהיה מצב התהליכים במערכת כעבור 5 שניות מתחילת ריצת התוכנית?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        // Child process\n        if (fork() > 0) {\n            // Child creates a Grandchild and exits immediately\n            _exit(0);\n        }\n        // Grandchild process continues\n        sleep(100);\n    } else {\n        // Parent process\n        // Parent does not call wait() yet\n        sleep(100);\n    }\n    return 0;\n}", "options": ["א. התהליך הנכד (Grandchild) יהיה במצב Zombie והתהליך הבן (Child) יהיה במצב Running.", "ב. התהליך הבן (Child) יהיה במצב Zombie והתהליך הנכד (Grandchild) יאומץ על ידי ה-init (או reaper process).", "ג. התהליך הבן (Child) ינוקה מהמערכת באופן מיידי כי הוא קרא ל-_exit, והנכד ימשיך לרוץ תחת האב המקורי.", "ד. כל התהליכים יסיימו את ריצתם כיוון שהבן (שהוא ההורה של הנכד) סיים את ריצתו."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "לאחר ה-fork הראשון נוצר תהליך הבן. הבן מבצע fork נוסף ויוצר את הנכד, ואז קורא מיד ל-_exit ומסיים. מכיוון שהאב המקורי עדיין רץ (ב-sleep) ולא קרא ל-wait(), הבן הופך ל-Zombie (תהליך שסיים אך רשומתו נשארת בטבלת התהליכים). הנכד הופך ליתום (Orphan) כי אביו (הבן) מת, ולכן הוא מאומץ על ידי ה-init process."}, "difficulty_estimation": "Hard", "_source_file": "0021__Processes__MultipleChoice__Hard.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:13:14"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "fork", "Address Space", "wait"], "content": {"text": "נתון קטע הקוד הבא בשפת C. מה יהיה סכום כל המספרים שיודפסו למסך (Standard Output) בהנחה שכל הקריאות ל-fork ו-wait מצליחות ואין בעיות זיכרון?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 2;\n    if (fork() == 0) {\n        x = x * 2;\n        if (fork() == 0) {\n            x = x + 1;\n            printf(\"%d\\n\", x);\n        } else {\n            wait(NULL);\n            x = x - 1;\n            printf(\"%d\\n\", x);\n        }\n    } else {\n        wait(NULL);\n        x = x + 2;\n        printf(\"%d\\n\", x);\n    }\n    return 0;\n}", "options": ["12", "10", "14", "9", "התוצאה אינה דטרמיניסטית ותלויה בסדר התזמון של המעבד"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "12", "explanation": "במערכת הפעלה, פקודת fork יוצרת תהליך בן עם מרחב כתובות נפרד המהווה העתק של תהליך האב. ננתח את זרימת התוכנית: 1. תהליך האב המקורי (P) מתחיל עם x=2. 2. P יוצר את C1. בתוך C1, המשתנה x מוכפל ב-2 (x=4). 3. C1 יוצר את GC (הנכד). בתוך GC, המשתנה x (שהועתק מ-C1 כ-4) גדל ב-1 (x=5) ומודפס המספר 5. 4. C1 ממתין לסיום GC, ואז מחסיר 1 מה-x שלו (4-1=3) ומדפיס 3. 5. P ממתין לסיום C1, ואז מוסיף 2 ל-x שלו (2+2=4) ומדפיס 4. סכום כל ההדפסות: 5+3+4=12. כיוון שמרחבי הכתובות מופרדים (Copy-on-Write), השינויים ב-x בכל תהליך אינם משפיעים על האחרים."}, "difficulty_estimation": "Hard", "_source_file": "0022__Processes__MultipleChoice__Hard.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:13:46"}, {"id": 10, "type": "MultipleChoice", "topic": ["Processes", "Fork", "Memory Space", "Wait"], "content": {"text": "מה יהיה הפלט של הקוד הבא בשפת C, בהנחה שכל הקריאות למערכת מצליחות ושסדר ההדפסה נקבע על פי ה-wait (כלומר, תהליך אב תמיד ידפיס אחרי שתהליך הבן שלו סיים)?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int val = 5;\n    if (fork() == 0) {\n        val += 10;\n        if (fork() == 0) {\n            val *= 2;\n            printf(\"%d \", val);\n        } else {\n            wait(NULL);\n            val -= 5;\n            printf(\"%d \", val);\n        }\n    } else {\n        wait(NULL);\n        val += 1;\n        printf(\"%d \", val);\n    }\n    return 0;\n}", "options": ["א. 30 10 6", "ב. 30 25 6", "ג. 15 10 6", "ד. 30 10 16", "ה. אף אחת מהתשובות אינה נכונה."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "בתהליך המקורי (P1) המשתנה val שווה 5. לאחר ה-fork הראשון, נוצר תהליך בן (P2) שמקבל עותק של val עם הערך 5. P2 מעדכן את val שלו ל-15 (5+10). לאחר מכן P2 מבצע fork נוסף ויוצר את P3. P3 מקבל עותק של val מ-P2, כלומר 15, מכפיל ב-2 ומדפיס 30. P2 ממתין ל-P3, לאחר מכן מחסיר 5 מה-val שלו (שהיה 15) ומדפיס 10. לבסוף, P1 שהמתין ל-P2, מעדכן את ה-val המקורי שלו (5) ב-1 ומדפיס 6. כיוון שכל תהליך פועל במרחב כתובות נפרד, השינויים במשתנה val אינם משותפים בין התהליכים."}, "difficulty_estimation": "Hard", "_source_file": "0023__Processes__MultipleChoice__Hard.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:14:03"}, {"id": 1, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "File Descriptors"], "content": {"text": "נתון קטע הקוד הבא המבוצע במערכת הפעלה Unix. נניח שכל קריאות המערכת מצליחות והקובץ test.txt נפתח כקובץ ריק (גודל 0). מה יהיה תוכן הקובץ בסיום ריצת התוכנית?", "code_snippet": "#include <fcntl.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    int fd = open(\"test.txt\", O_RDWR | O_CREAT | O_TRUNC, 0644);\n    write(fd, \"OS\", 2);\n    if (fork() == 0) {\n        write(fd, \"IS\", 2);\n        exit(0);\n    } else {\n        wait(NULL);\n        write(fd, \"FUN\", 3);\n    }\n    close(fd);\n    return 0;\n}", "options": ["א. OSISFUN", "ב. OSIS", "ג. OSFUN", "ד. OS"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "לאחר ביצוע קריאת המערכת fork(), תהליך הבן מקבל עותק של טבלת מתארי הקבצים (File Descriptor Table) של האב. עם זאת, מתארי הקבצים בשני התהליכים מצביעים לאותה כניסה בטבלת הקבצים הפתוחים של מערכת ההפעלה (System-wide Open File Table). כניסה זו מנהלת את ה-File Offset עבור הקובץ הפתוח. כיוון שהאופסט משותף, כאשר הבן כותב את המחרוזת 'IS', הוא מקדם את האופסט מ-2 ל-4. כיוון שהאב ממתין לסיום הבן (בעזרת wait), הוא יבצע את הכתיבה של 'FUN' רק לאחר מכן, והיא תתחיל מהאופסט המעודכן (4). לכן התוצאה היא OSISFUN."}, "difficulty_estimation": "Hard", "_source_file": "0024__Processes__MultipleChoice__Hard.json", "_topic_hint": "Processes", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:14:38"}, {"id": 1, "type": "Open", "topic": ["Processes"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בקריאות מערכת מסוג fork. כמה פעמים תודפס המחרוזת \"Hello\" במהלך הרצה תקינה של התוכנית? הסבירו את תשובתכם על ידי מעקב אחר יצירת התהליכים.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    fork();\n    if (fork() == 0) {\n        fork();\n    }\n    printf(\"Hello\\n\");\n    return 0;\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "המחרוזת \"Hello\" תודפס 6 פעמים. \nמעקב אחר יצירת התהליכים:\n1. התוכנית מתחילה עם תהליך אב יחיד (P1).\n2. לאחר ה-fork() הראשון, נוצר תהליך בן (P2). כעת ישנם 2 תהליכים במערכת.\n3. שני התהליכים (P1 ו-P2) מגיעים לשורת ה-if ומבצעים fork() נוסף. נוצרים שני תהליכים חדשים: P3 (הבן של P1) ו-P4 (הבן של P2). כעת ישנם 4 תהליכים במערכת.\n4. תנאי ה-if בודק האם הערך המוחזר מפעולת ה-fork הוא 0. תנאי זה מתקיים אך ורק עבור תהליכי הבן שזה עתה נוצרו (P3 ו-P4).\n5. בתוך בלוק ה-if, התהליכים P3 ו-P4 מבצעים fork() נוסף, מה שיוצר שני תהליכים חדשים נוספים (P5 ו-P6). כעת ישנם סה\"כ 6 תהליכים במערכת.\n6. כל 6 התהליכים הקיימים (P1, P2, P3, P4, P5, P6) ממשיכים בביצוע הקוד ומגיעים לשורת ה-printf. לכן, המחרוזת תודפס 6 פעמים."}, "difficulty_estimation": "Easy", "_source_file": "0025__Processes__Open__Easy.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:14:55"}, {"id": 8, "type": "Open", "topic": ["Processes", "fork"], "content": {"text": "כמה תהליכים נוצרים בסך הכל (כולל תהליך האב המקורי) במהלך הרצת הקוד הבא? יש לפרט את שלבי ההיווצרות של התהליכים.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nint main() {\n    fork();\n    pid_t pid = fork();\n    if (pid > 0) {\n        fork();\n    }\n    printf(\"Process\\n\");\n    return 0;\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "להלן שלבי היווצרות התהליכים:\n1. בתחילה קיים תהליך אחד (נסמנו P1).\n2. לאחר פקודת ה-fork() הראשונה, נוצר תהליך בן (P2). כעת יש במערכת 2 תהליכים.\n3. לאחר פקודת ה-fork() השנייה, כל אחד משני התהליכים הקיימים (P1 ו-P2) מתפצל פעם נוספת. נוצרים שני תהליכים חדשים (P3 ו-P4). כעת יש במערכת 4 תהליכים.\n4. המשתנה pid מכיל את ערך ההחזר של ה-fork השני. בתהליכי האב של הפיצול השני (P1 ו-P2) הערך יהיה גדול מ-0 (ה-PID של הבן), ובתהליכי הבן החדשים (P3 ו-P4) הערך יהיה 0.\n5. פקודת ה-if מתבצעת רק עבור תהליכים בהם pid > 0, כלומר רק P1 ו-P2 מבצעים את ה-fork() השלישי.\n6. ה-fork השלישי יוצר עוד שני תהליכים (P5 ו-P6).\n7. לסיכום: 1 (התחלתי) + 1 (ב-fork הראשון) + 2 (ב-fork השני) + 2 (ב-fork השלישי בתוך ה-if) = 6 תהליכים סך הכל."}, "difficulty_estimation": "Easy", "_source_file": "0026__Processes__Open__Easy.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:15:08"}, {"id": 1, "type": "Open", "topic": ["Processes", "fork"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בקריאת המערכת fork(). כמה תהליכים בסך הכל (כולל תהליך האב המקורי) ייווצרו במהלך ריצת התוכנית? הניחו שכל הקריאות ל-fork() מצליחות. יש להסביר את שלבי ההיווצרות.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    fork();\n    if (fork() == 0) {\n        fork();\n    }\n    return 0;\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "במהלך ריצת התוכנית ייווצרו בסך הכל 6 תהליכים (כולל האב המקורי). להלן הפירוט:\n1. התוכנית מתחילה עם תהליך אחד (P1).\n2. הקריאה הראשונה ל-fork() יוצרת תהליך בן (P2). כעת ישנם 2 תהליכים.\n3. לאחר מכן, שני התהליכים (P1 ו-P2) מגיעים לשורת ה-if ומבצעים fork() נוסף. \n   - P1 יוצר את P3 (עבור P3 הערך המוחזר הוא 0, עבור P1 הערך הוא ה-PID של P3).\n   - P2 יוצר את P4 (עבור P4 הערך המוחזר הוא 0, עבור P2 הערך הוא ה-PID של P4).\n   כעת ישנם 4 תהליכים.\n4. תנאי ה-if בודק האם הערך המוחזר מ-fork הוא 0. תנאי זה מתקיים רק עבור תהליכי הבן החדשים שנוצרו בשלב הקודם (P3 ו-P4).\n5. בתוך בלוק ה-if, שני התהליכים הללו (P3 ו-P4) קוראים ל-fork() פעם שלישית:\n   - P3 יוצר את P5.\n   - P4 יוצר את P6.\n6. סך כל התהליכים במערכת: P1, P2, P3, P4, P5, P6 (סה\"כ 6)."}, "difficulty_estimation": "Easy", "_source_file": "0027__Processes__Open__Easy.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:15:23"}, {"id": 1, "type": "Open", "topic": ["Processes", "Memory Management", "Fork"], "content": {"text": "נתון קוד ה-C הבא המשתמש בקריאת המערכת fork. מה יהיה הפלט של התוכנית (הניחו שכל קריאות המערכת מצליחות)? הסבירו האם השינוי במשתנה x בתהליך הבן משפיע על ערכו בתהליך האב.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    pid_t pid = fork();\n\n    if (pid == 0) {\n        // תהליך הבן\n        x = x + 5;\n        printf(\"Child: x = %d\\n\", x);\n    } else {\n        // תהליך האב\n        wait(NULL);\n        x = x - 5;\n        printf(\"Parent: x = %d\\n\", x);\n    }\n    return 0;\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפלט של התוכנית יהיה:\nChild: x = 15\nParent: x = 5\n\nהסבר: קריאת המערכת fork יוצרת תהליך חדש (בן) המהווה העתק של תהליך האב. למרות שהבן יורש את ערכי המשתנים של האב ברגע הפיצול, לכל תהליך יש מרחב כתובות (Address Space) נפרד ומבודד בזיכרון. לכן, כל שינוי שמבצע תהליך הבן במשתנה x מתבצע בזיכרון הפרטי שלו ואינו משפיע על ערכו של x במרחב הזיכרון של תהליך האב. תהליך האב ממתין לסיום הבן באמצעות wait, ולאחר מכן מדפיס את ערכו של x המקורי (10) פחות 5."}, "difficulty_estimation": "Easy", "_source_file": "0028__Processes__Open__Easy.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:15:41"}, {"id": 1, "type": "Open", "topic": ["Processes", "fork"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בקריאת המערכת fork(). הנח שכל הקריאות ל-fork() מצליחות ושאין שגיאות בזמן הריצה.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    fork();\n    if (fork() == 0) {\n        fork();\n    }\n    printf(\"Done\\n\");\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "כמה תהליכים סך הכל ייווצרו במהלך ריצת התוכנית (כולל התהליך הראשי)?", "code_snippet": null, "options": null}, {"id": "1.2", "text": "כמה פעמים תודפס המחרוזת \"Done\" למסך? נמק את תשובתך.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: סך הכל ייווצרו 6 תהליכים.\nניתוח שלבי היצירה:\n1. ה-fork() הראשון מפצל את התהליך המקורי (P) לשני תהליכים: P ו-C1.\n2. ה-fork() השני מתבצע על ידי שני התהליכים הקיימים (P ו-C1). P יוצר את C2, ו-C1 יוצר את C3. כעת ישנם 4 תהליכים במערכת.\n3. התנאי (fork() == 0) מתקיים רק עבור הילדים שנוצרו ב-fork השני (C2 ו-C3). לכן רק הם נכנסים לתוך בלוק ה-if.\n4. בתוך ה-if, התהליך C2 מבצע fork() ויוצר את C4. התהליך C3 מבצע fork() ויוצר את C5.\n5. סך התהליכים: P, C1, C2, C3, C4, C5 - סה\"כ 6 תהליכים.\n\n1.2: המחרוזת תודפס 6 פעמים.\nהסבר: כל תהליך שנוצר במהלך ריצת התוכנית ממשיך בביצוע הקוד עד סוף פונקציית ה-main. מכיוון שפקודת ה-printf נמצאת מחוץ לבלוק ה-if (אחריו), כל אחד מ-6 התהליכים שנוצרו יגיע לשורה זו וידפיס את המחרוזת פעם אחת."}, "difficulty_estimation": "Easy", "_source_file": "0029__Processes__Open__Easy.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:16:00"}, {"id": 1, "type": "Open", "topic": ["Processes", "fork"], "content": {"text": "כמה תהליכים ייווצרו בסך הכל (כולל התהליך הראשי) כתוצאה מהרצת הקוד הבא? פרטו את החישוב והסבירו בקצרה כיצד הגעתם לתוצאה.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    fork();\n    fork();\n    fork();\n    printf(\"Hello\\n\");\n    return 0;\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "בכל קריאה לפקודת fork(), כל תהליך קיים במערכת שמריץ את השורה הזו מתפצל לשני תהליכים: תהליך האב המקורי ותהליך בן חדש. שני התהליכים ממשיכים את הריצה מאותה נקודה בקוד. \nהחישוב הוא כדלקמן:\n1. התחלה: תהליך 1 (הראשי).\n2. לאחר ה-fork הראשון: התהליך הראשי יוצר בן, סה\"כ 2 תהליכים.\n3. לאחר ה-fork השני: כל אחד מ-2 התהליכים הקיימים יוצר בן, סה\"כ 4 תהליכים.\n4. לאחר ה-fork השלישי: כל אחד מ-4 התהליכים הקיימים יוצר בן, סה\"כ 8 תהליכים.\nבאופן כללי, עבור n קריאות עוקבות ל-fork(), מספר התהליכים הכולל יהיה 2 בחזקת n. במקרה זה 2^3 = 8."}, "difficulty_estimation": "Easy", "_source_file": "0030__Processes__Open__Easy.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:16:09"}, {"id": 1, "type": "Open", "topic": ["Processes", "fork"], "content": {"text": "כמה תהליכים נוצרים בסך הכל (כולל תהליך האב המקורי) במהלך ריצת הקוד הבא? הסבירו את תשובתכם.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    fork();\n    fork();\n    fork();\n    return 0;\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "כל קריאה לפקודת fork() יוצרת תהליך בן חדש שהוא העתק של התהליך הקורא. \n1. בתחילה קיים תהליך אחד (האב).\n2. לאחר ה-fork הראשון, ישנם 2 תהליכים (האב והבן הראשון).\n3. לאחר ה-fork השני, כל אחד מ-2 התהליכים הקיימים מבצע fork, ולכן נוצרים 2 תהליכים נוספים, סה\"כ 4 תהליכים.\n4. לאחר ה-fork השלישי, כל אחד מ-4 התהליכים הקיימים מבצע fork, ולכן נוצרים 4 תהליכים נוספים, סה\"כ 8 תהליכים.\nבאופן כללי, עבור n קריאות עוקבות ל-fork, מספר התהליכים יהיה 2 בחזקת n."}, "difficulty_estimation": "Easy", "_source_file": "0031__Processes__Open__Easy.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:16:17"}, {"id": 10, "type": "Open", "topic": ["Processes"], "content": {"text": "נתון קטע הקוד הבא בשפת C. בהנחה שכל הקריאות למערכת מצליחות, כמה תהליכים סה\"כ ירוצו במהלך ביצוע התוכנית (כולל תהליך האב המקורי)? יש לפרט את שלבי היצירה של התהליכים.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    fork();\n    if (fork() == 0) {\n        fork();\n    }\n    return 0;\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "שלבי יצירת התהליכים הם כדלקמן:\n1. בתחילה קיים תהליך אחד (נסמנו P1).\n2. לאחר ביצוע ה-fork() הראשון בשורה 5, נוצר תהליך בן (P2). כעת ישנם 2 תהליכים במערכת.\n3. בשורה 6, שני התהליכים (P1 ו-P2) מבצעים את הקריאה fork() בתוך תנאי ה-if:\n   - P1 יוצר תהליך בן חדש (P3). עבור P3 הפונקציה מחזירה 0, ולכן הוא נכנס לבלוק ה-if.\n   - P2 יוצר תהליך בן חדש (P4). עבור P4 הפונקציה מחזירה 0, ולכן הוא נכנס לבלוק ה-if.\n   - עבור P1 ו-P2, הפונקציה מחזירה ערך שונה מ-0 (ה-PID של הבנים שלהם), ולכן הם אינם נכנסים לבלוק ה-if.\n4. בתוך בלוק ה-if (שורה 7), התהליכים P3 ו-P4 מבצעים fork() נוסף:\n   - P3 יוצר תהליך בן חדש (P5).\n   - P4 יוצר תהליך בן חדש (P6).\n5. לסיכום, התהליכים שהורצו הם: P1 (המקורי), P2 (נוצר ב-fork הראשון), P3 ו-P4 (נוצרו ב-fork השני), P5 ו-P6 (נוצרו ב-fork השלישי).\nסה\"כ: 6 תהליכים."}, "difficulty_estimation": "Easy", "_source_file": "0032__Processes__Open__Easy.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:16:39"}, {"id": 1, "type": "Open", "topic": ["Processes", "fork", "Memory Isolation"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בקריאה למערכת fork. הניחו שכל הקריאות למערכת מצליחות ושאין תהליכי זומבי הממתינים במערכת.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nint main() {\n    int x = 5;\n    if (fork() == 0) {\n        x += 10;\n        if (fork() == 0) {\n            x += 10;\n        }\n    } else {\n        x -= 5;\n        fork();\n    }\n    printf(\"%d\\n\", x);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "כמה תהליכים נוצרו סך הכל במהלך ריצת התוכנית (כולל התהליך הראשי)? הציגו את עץ התהליכים שנוצר.", "code_snippet": null, "options": null}, {"id": "1.2", "text": "מהם הערכים השונים שיודפסו למסך? הסבירו עבור כל ערך איזה תהליך מדפיס אותו וכיצד הגיע לערך זה.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "האם שינוי הערך של x בתהליך אחד משפיע על הערך של x בתהליך אחר? הסבירו מדוע, תוך התייחסות למנגנון ניהול הזיכרון של תהליכים במערכת ההפעלה.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: סך הכל נוצרו 4 תהליכים. התהליך הראשי (P0) יוצר תהליך בן (P1). P1 יוצר תהליך נכד (P2). לאחר מכן, התהליך הראשי (P0) יוצר תהליך בן נוסף (P3). עץ התהליכים: P0 הוא השורש, בניו הם P1 ו-P3, ו-P2 הוא הבן של P1.\n\n1.2: הערכים שיודפסו הם 25, 15, 0, 0 (הסדר עשוי להשתנות בהתאם לתזמון):\n- תהליך P2 (הנכד): נכנס לבלוק ה-if הראשון של אביו (x=15) ולבלוק ה-if השני שלו עצמו (x=25) ומדפיס 25.\n- תהליך P1 (הבן הראשון): נכנס לבלוק ה-if הראשון (x=15), מסיים את ה-if הפנימי ומדפיס 15.\n- תהליך P0 (האב): נכנס לבלוק ה-else, מעדכן ל-x=0, מבצע fork ומדפיס 0.\n- תהליך P3 (הבן השני): נוצר בתוך ה-else של P0, יורש את הערך x=0 ומדפיס 0.\n\n1.3: לא, שינוי הערך אינו משפיע. לכל תהליך יש מרחב כתובות וירטואלי נפרד (Address Space). בעת ביצוע fork, מערכת ההפעלה יוצרת העתק של מרחב הכתובות עבור הבן. למרות שהתהליכים משתמשים באותה כתובת וירטואלית עבור x, הן ממופות למסגרות שונות בזיכרון הפיזי (או משוכפלות בעת כתיבה במנגנון Copy-on-Write), ולכן השינויים מבודדים."}, "difficulty_estimation": "Medium", "_source_file": "0033__Processes__Open__Medium.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:17:00"}, {"id": 7, "type": "Open", "topic": ["Processes", "fork", "Memory Isolation"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בקריאת המערכת fork. הניחו שכל הקריאות ל-fork מצליחות ושהפלט מודפס למסך באופן מיידי. הניחו כי פקודת ה-wait(NULL) גורמת לתהליך האב להמתין לסיום ביצועו של תהליך הבן הישיר שלו.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n        if (fork() == 0) {\n            x += 5;\n            printf(\"%d\\n\", x);\n        } else {\n            wait(NULL);\n            x -= 2;\n            printf(\"%d\\n\", x);\n        }\n    } else {\n        wait(NULL);\n        x -= 5;\n        printf(\"%d\\n\", x);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "כמה תהליכים נוצרו בסך הכל במהלך ריצת התוכנית (כולל התהליך הראשי)?", "code_snippet": null, "options": null}, {"id": "7.2", "text": "מה יהיו הערכים שיודפסו למסך ובאיזה סדר? נמקו את תשובתכם.", "code_snippet": null, "options": null}, {"id": "7.3", "text": "האם שינוי המשתנה x בתהליך הבן משפיע על ערכו של x בתהליך האב? הסבירו מדוע על סמך מנגנוני ניהול זיכרון בסיסיים של תהליכים.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: נוצרו 3 תהליכים בסך הכל. התהליך הראשי (P1) קרא ל-fork ויצר את P2. תהליך P2 קרא ל-fork פנימי ויצר את P3.\n\n7.2: הערכים שיודפסו הם 20, לאחר מכן 13, ולבסוף 5. \nהסבר: \n- תהליך P3 (הנכד) מקבל x=15 מ-P2, מוסיף 5 ומדפיס 20.\n- תהליך P2 (הבן) ממתין ל-P3, לאחר מכן מחסיר 2 מה-x שלו (שהיה 15) ומדפיס 13.\n- תהליך P1 (האב) ממתין ל-P2, לאחר מכן מחסיר 5 מה-x שלו (שהיה 10) ומדפיס 5.\nהסדר מובטח בזכות קריאות ה-wait.\n\n7.3: לא, השינוי אינו משפיע. בעת ביצוע fork, מערכת ההפעלה יוצרת העתק של מרחב הכתובות של האב עבור הבן. למרות שבתחילה הנתונים זהים, לכל תהליך יש זיכרון וירטואלי נפרד. בזכות מנגנון Copy-on-Write, ברגע שתהליך מנסה לשנות משתנה, נוצר עותק פיזי נפרד עבורו, ולכן שינויים בתהליך אחד אינם נראים בתהליך אחר."}, "difficulty_estimation": "Medium", "_source_file": "0034__Processes__Open__Medium.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:17:15"}, {"id": 7, "type": "Open", "topic": ["Processes", "Process Creation", "fork"], "content": {"text": "לפניכם קוד בשפת C המשתמש בקריאות המערכת fork ו-wait. הניחו שכל קריאות המערכת מצליחות ושהתהליכים מתזמנים בצורה כזו שכל תהליך אב ממתין לסיום ילדיו לפני הדפסה.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    pid_t pid1, pid2;\n\n    pid1 = fork();\n    if (pid1 == 0) {\n        x += 5;\n        pid2 = fork();\n        if (pid2 == 0) {\n            x += 5;\n            printf(\"C2: x=%d\\n\", x);\n        } else {\n            wait(NULL);\n            printf(\"C1: x=%d\\n\", x);\n        }\n    } else {\n        wait(NULL);\n        printf(\"P: x=%d\\n\", x);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "כמה תהליכים נוצרו בסך הכל במהלך ריצת התוכנית, כולל התהליך הראשי?", "code_snippet": null, "options": null}, {"id": "7.2", "text": "מה יהיה הפלט של התוכנית? יש לכתוב את השורות לפי סדר הדפסתן.", "code_snippet": null, "options": null}, {"id": "7.3", "text": "הסבירו מדוע השינויים במשתנה x בתהליכי הבנים אינם משתקפים בערכו של x בתהליך האב (P).", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: נוצרו 3 תהליכים בסך הכל. התהליך הראשי (P) מבצע fork ויוצר את C1. התהליך C1 מבצע fork נוסף ויוצר את C2.\n\n7.2: הפלט יהיה:\nC2: x=20\nC1: x=15\nP: x=10\nהסבר: C2 יורש מ-C1 את x=15 ומוסיף 5. C1 מוסיף 5 ל-10 המקורי. האב P נשאר עם 10. בגלל קריאות ה-wait, הסדר מובטח מהנכד לסבא.\n\n7.3: כאשר מתבצע fork, נוצר עותק של מרחב הכתובות של תהליך האב עבור הבן. למרות שהם חולקים קוד, לכל תהליך יש מחסנית (stack) וסגמנט נתונים (data segment) נפרדים משלו. מנגנון Copy-on-Write מוודא שברגע שתהליך מנסה לשנות משתנה, נוצר עותק פיזי נפרד בזיכרון, ולכן שינוי ב-x בתהליך אחד לא ישפיע על האחרים."}, "difficulty_estimation": "Medium", "_source_file": "0035__Processes__Open__Medium.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:17:26"}, {"id": 7, "type": "Open", "topic": ["Processes", "fork", "Process Lifecycle"], "content": {"text": "נתון קוד בשפת C המשתמש בקריאת המערכת fork. הניחו שכל הקריאות ל-fork מצליחות.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n        if (fork() == 0) {\n            x += 5;\n            printf(\"C2: x = %d\\n\", x);\n        } else {\n            wait(NULL);\n            printf(\"C1: x = %d\\n\", x);\n        }\n    } else {\n        wait(NULL);\n        x -= 5;\n        printf(\"P: x = %d\\n\", x);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "כמה תהליכים נוצרים סה\"כ במהלך ריצת התוכנית (כולל התהליך הראשי)? תארו את עץ התהליכים שנוצר.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "מה יהיה הפלט של התוכנית? הסבירו מדוע השינויים במשתנה x בכל תהליך אינם משפיעים על ערכו בתהליכים האחרים.", "code_snippet": null, "options": null}, {"id": "7.3", "text": "הגדירו מהו תהליך \"זומבי\" (Zombie Process). האם במהלך ריצת קוד זה (כפי שהוא כתוב) אחד התהליכים הופך לזומבי לפרק זמן מסוים? הסבירו.", "code_snippet": null, "options": null}, {"id": "7.4", "text": "מה יקרה אם נסיר את כל קריאות ה-wait מהקוד? התייחסו בפרט למושג \"תהליך יתום\" (Orphan Process).", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: נוצרים 3 תהליכים בסך הכל. התהליך הראשי (P) קורא ל-fork ויוצר את תהליך הבן הראשון (C1). תהליך C1 קורא ל-fork ויוצר את תהליך הנכד (C2). המבנה הוא שרשרת: P -> C1 -> C2.\n\n7.2: הפלט יהיה:\nC2: x = 20\nC1: x = 15\nP: x = 5\nהסבר: כאשר מתבצע fork, נוצר עותק של מרחב הכתובות של תהליך האב עבור הבן. למרות שבתחילה הם חולקים דפים פיזיים (Copy-on-Write), לוגית לכל תהליך יש משתנה x משלו בכתובת וירטואלית זהה אך בזיכרון פיזי נפרד. לכן, שינוי של x ב-C2 לא משפיע על C1, ושינוי ב-C1 לא משפיע על P.\n\n7.3: תהליך זומבי הוא תהליך שסיים את ביצועו (קרא ל-exit) אך עדיין קיימת עבורו רשומה בטבלת התהליכים של מערכת ההפעלה, כיוון שהאב טרם קרא ל-wait כדי לאסוף את סטטוס הסיום שלו. בקוד זה, C2 יהיה זומבי מרגע סיומו ועד ש-C1 יסיים את ה-wait, וכנ\"ל לגבי C1 מול P.\n\n7.4: ללא wait, תהליכי הבנים עלולים להפוך ליתומים אם האב יסיים לפניהם. תהליך יתום הוא תהליך שאביו הסתיים, ובמצב זה מערכת ההפעלה מאמצת אותו (בדרך כלל ע\"י תהליך ה-init/systemd ש-PID שלו הוא 1) כדי להבטיח שמישהו יבצע עליו wait בסיום."}, "difficulty_estimation": "Medium", "_source_file": "0036__Processes__Open__Medium.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:17:40"}, {"id": 7, "type": "Open", "topic": ["Processes", "System Calls", "fork"], "content": {"text": "לפניכם קוד בשפת C המשתמש בקריאות המערכת fork ו-wait. הניחו שכל קריאות המערכת מצליחות.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    for (int i = 0; i < 3; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            printf(\"Child %d\\n\", i);\n            if (i % 2 == 0) {\n                fork();\n            }\n            _exit(0);\n        }\n    }\n    while(wait(NULL) > 0);\n    printf(\"Parent done\\n\");\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "כמה תהליכים בסך הכל ייווצרו במהלך ריצת התוכנית (כולל התהליך הראשי)? הסבירו את החישוב.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "מה יקרה אם נחליף את הקריאה ל-`_exit(0)` בפקודת `break`? כיצד זה ישפיע על מספר התהליכים הנוצרים?", "code_snippet": null, "options": null}, {"id": "7.3", "text": "הסבירו בקצרה את ההבדל בין `exit()` לבין `_exit()`. מדוע בקוד זה נעשה שימוש ב-`_exit()` בתוך תהליך הבן?", "code_snippet": null, "options": null}, {"id": "7.4", "text": "אם נסיר את שורת הקוד `while(wait(NULL) > 0);`, מה עלול לקרות לתהליכי הבן בסיום ריצתם כל עוד התהליך האב עדיין רץ? הגדירו את המושג המתאים.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: סך הכל ייווצרו 6 תהליכים. פירוט: התהליך הראשי (1) מריץ לולאה 3 פעמים. באיטרציה i=0 הוא יוצר בן (C1), והבן יוצר נכד (C1_1) כי 0 זוגי. באיטרציה i=1 הוא יוצר בן (C2), והוא לא יוצר נכד כי 1 אינו זוגי. באיטרציה i=2 הוא יוצר בן (C3), והוא יוצר נכד (C3_1) כי 2 זוגי. סה\"כ: 1 (אב) + 3 (בנים) + 2 (נכדים) = 6.\n\n7.2: אם נחליף ב-break, תהליכי הבנים והנכדים לא יסיימו את ריצתם מיד אלא יצאו מהלולאה וימשיכו לשורת ה-wait. במקרה זה, מספר התהליכים שייווצרו לא ישתנה (עדיין 6), מכיוון שכל תהליך שנוצר יוצא מהלולאה ולא ממשיך לאיטרציות הבאות של האב.\n\n7.3: הפונקציה exit() היא פונקציית ספרייה המבצעת ניקוי (cleanup) הכולל ריקון חוצצים (buffers) של stdio לפני סיום התהליך, בעוד _exit() היא קריאת מערכת שמסיימת את התהליך מיד ללא ניקוי חוצצים. בבנים משתמשים לעיתים ב-_exit כדי למנוע מצב שבו חוצצים שהועתקו מהאב ירוקנו פעמיים (גם ע\"י הבן וגם ע\"י האב), מה שעלול להוביל לכפילות בפלט.\n\n7.4: ללא ה-wait, תהליכי הבן יהפכו לתהליכי 'זומבי' (Zombie Processes). זהו מצב שבו התהליך סיים את ביצועו אך עדיין קיימת רשומה עבורו בטבלת התהליכים של מערכת ההפעלה, כדי לאפשר לאב לקרוא את קוד היציאה שלו."}, "difficulty_estimation": "Medium", "_source_file": "0037__Processes__Open__Medium.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:17:57"}, {"id": 1, "type": "Open", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "נתון קוד בשפת C המשתמש בקריאות המערכת fork ו-wait. הנח שכל קריאות המערכת מצליחות ומתבצעות ללא שגיאות. ענו על הסעיפים הבאים בהסתמך על הקוד.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n        if (fork() == 0) {\n            x += 5;\n            printf(\"%d\\n\", x);\n        } else {\n            wait(NULL);\n            x -= 2;\n            printf(\"%d\\n\", x);\n        }\n    } else {\n        wait(NULL);\n        printf(\"%d\\n\", x);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "כמה תהליכים נוצרו בסך הכל במהלך הרצת התוכנית (כולל תהליך האב המקורי)?", "code_snippet": null, "options": null}, {"id": "1.2", "text": "מה יהיה הפלט של התוכנית? יש לציין את הערכים המודפסים לפי סדר הדפסתם ולהסביר את החישוב עבור כל אחד.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "האם המשתנה x משותף בין התהליכים השונים? הסבירו כיצד מנגנון ה-Copy-on-Write (CoW) בא לידי ביטוי במקרה זה.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: נוצרו 3 תהליכים בסך הכל. תהליך האב המקורי (P1), תהליך הבן הראשון (P2) שנוצר ב-fork הראשון, ותהליך הנכד (P3) שנוצר ב-fork השני בתוך הבלוק של הבן.\n\n1.2: הפלט יהיה:\n20\n13\n10\nהסבר: \n- P3 (הנכד): יורש x=15 מ-P2, מוסיף 5 ומדפיס 20.\n- P2 (הבן): מחכה ל-P3 שיסיים, לאחר מכן מחסיר 2 מה-x שלו (שהיה 15) ומדפיס 13.\n- P1 (האב): מחכה ל-P2 שיסיים, מדפיס את ה-x שלו שנשאר 10 ללא שינוי.\nהסדר מובטח עקב קריאות ה-wait.\n\n1.3: לא, המשתנה אינו משותף. כל תהליך מקבל מרחב כתובות וירטואלי נפרד. מנגנון Copy-on-Write גורם לכך שכל עוד התהליכים רק קוראים מהזיכרון, הם חולקים את אותם דפים פיזיים. ברגע שתהליך מבצע כתיבה (כמו x += 5), מערכת ההפעלה יוצרת עותק פיזי נפרד של הדף עבור אותו תהליך, כך שהשינוי אינו משפיע על תהליך האב או תהליכים מקבילים אחרים."}, "difficulty_estimation": "Medium", "_source_file": "0038__Processes__Open__Medium.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:18:11"}, {"id": 1, "type": "Open", "topic": ["Processes", "Fork", "Address Space"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בקריאת המערכת fork(). הניחו כי כל הקריאות למערכת מצליחות וכי הפלט נכתב למסך באופן מיידי (ללא buffering).", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    pid_t pid1 = fork();\n\n    if (pid1 == 0) {\n        x += 5;\n        pid_t pid2 = fork();\n        if (pid2 == 0) {\n            x *= 2;\n            printf(\"A: x=%d\\n\", x);\n        } else {\n            wait(NULL);\n            x -= 2;\n            printf(\"B: x=%d\\n\", x);\n        }\n    } else {\n        wait(NULL);\n        x += 1;\n        printf(\"C: x=%d\\n\", x);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "כמה תהליכים נוצרו בסך הכל במהלך ריצת התוכנית (כולל התהליך הראשי)? ציירו את עץ התהליכים.", "code_snippet": null, "options": null}, {"id": "1.2", "text": "מה יהיה הפלט של התוכנית? האם סדר ההדפסות מובטח? הסבירו.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "האם שינוי המשתנה x בתהליך אחד משפיע על ערכו בתהליך אחר? הסבירו מדוע על סמך מנגנון הזיכרון של תהליכים.", "code_snippet": null, "options": null}, {"id": "1.4", "text": "מה יקרה אם נסיר את כל קריאות ה-wait(NULL) מהקוד? האם ערכי ה-x המודפסים ישתנו? האם סדר ההדפסה ישתנה?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: נוצרו 3 תהליכים בסך הכל. התהליך הראשי (P1) יוצר בן (P2), והבן (P2) יוצר נכד (P3). עץ התהליכים הוא ליניארי: P1 -> P2 -> P3.\n\n1.2: הפלט יהיה:\nA: x=30\nB: x=13\nC: x=11\nסדר ההדפסות מובטח בגלל קריאות ה-wait. תהליך P2 מחכה ל-P3 (לכן A לפני B), ותהליך P1 מחכה ל-P2 (לכן B לפני C).\n\n1.3: לא. בעת ביצוע fork, התהליך הבן מקבל העתק של מרחב הכתובות של האב (Copy-on-Write). לכן, לכל תהליך יש עותק פרטי משלו של המשתנה x בזיכרון שלו, ושינויים בו אינם משפיעים על תהליכים אחרים.\n\n1.4: ערכי ה-x המודפסים לא ישתנו, כי המרחבים עדיין מופרדים. עם זאת, סדר ההדפסה לא יהיה מובטח יותר ויהיה תלוי במתזמן (Scheduler), שכן התהליכים ירוצו במקביל ללא סנכרון."}, "difficulty_estimation": "Medium", "_source_file": "0039__Processes__Open__Medium.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:18:27"}, {"id": 1, "type": "Open", "topic": ["Processes", "Fork", "Address Space"], "content": {"text": "נתונה תוכנית בשפת C המשתמשת בקריאת המערכת fork. הניחו כי כל הקריאות למערכת מצליחות וכי התהליכים מסתיימים כסדרם (אין תהליכי זומבי או יתומים במהלך הריצה שימנעו את ההדפסות).", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    pid_t p1 = fork();\n    if (p1 == 0) {\n        x += 5;\n        pid_t p2 = fork();\n        if (p2 == 0) {\n            x += 5;\n            printf(\"Child-Child: x = %d\\n\", x);\n        } else {\n            wait(NULL);\n            printf(\"Child: x = %d\\n\", x);\n        }\n    } else {\n        wait(NULL);\n        x -= 5;\n        printf(\"Parent: x = %d\\n\", x);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "מה יהיה פלט התוכנית? יש להסביר את סדר ההדפסות ואת הערך של x בכל הדפסה.", "code_snippet": null, "options": null}, {"id": "1.2", "text": "כמה תהליכים נוצרו בסך הכל במהלך ריצת התוכנית (כולל התהליך הראשי)?", "code_snippet": null, "options": null}, {"id": "1.3", "text": "האם שינוי הערך של x בתהליך הבן משפיע על ערכו של x בתהליך האב? הסבר מדוע בהתבסס על ניהול הזיכרון של תהליכים.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: פלט התוכנית יהיה:\nChild-Child: x = 20\nChild: x = 15\nParent: x = 5\nהסבר: התהליך הראשי (P1) מפצל את P2. ב-P2 המשתנה x הופך ל-15. P2 מפצל את P3. ב-P3 המשתנה x הופך ל-20 ומודפס. בגלל פקודות ה-wait, P3 מסיים ומדפיס ראשון, אחריו P2 מדפיס (x=15) ואז P1 מבצע x-=5 (מתוך ה-10 המקורי שלו) ומדפיס (x=5).\n\n1.2: נוצרו 3 תהליכים בסך הכל: התהליך המקורי (P1), הבן שלו (P2), והנכד (P3 - הבן של P2).\n\n1.3: לא, השינוי אינו משפיע. בעת ביצוע fork(), מערכת ההפעלה יוצרת עותק של מרחב הכתובות (Address Space) של תהליך האב עבור תהליך הבן. למרות שהם משתמשים באותן כתובות וירטואליות, הן ממופות למסגרות פיזיות שונות בזיכרון (או משתמשות במנגנון Copy-on-Write שיוצר עותק פיזי רק בעת כתיבה). לכן, לכל תהליך יש עותק פרטי משלו של המשתנה x."}, "difficulty_estimation": "Medium", "_source_file": "0040__Processes__Open__Medium.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:18:46"}, {"id": 10, "type": "Open", "topic": ["Processes", "Fork", "Short-circuit evaluation", "Process Tree", "Synchronization"], "content": {"text": "נתון קוד ה-C הבא המשתמש בקריאות מערכת לניהול תהליכים. הניחו שכל הקריאות ל-fork מצליחות, שהמערכת אינה מוגבלת במשאבים, ושאין אופטימיזציות קומפילציה המשנות את לוגיקת הקריאות. ענו על הסעיפים הבאים תוך פירוט מלא של עץ התהליכים והלוגיקה.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n\nint main() {\n    pid_t pid;\n    if (fork() == 0) {\n        // Child block\n        if (fork() || fork()) {\n            fork();\n        }\n    } else {\n        // Parent block\n        wait(NULL);\n        printf(\"Parent Done\\n\");\n    }\n    printf(\"Process %d exiting\\n\", getpid());\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה תהליכים נוצרים בסך הכל במהלך הרצת התוכנית (כולל התהליך המקורי)? פרטו את שלבי היצירה.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "כמה פעמים תודפס המחרוזת 'Process %d exiting' (כאשר %d הוא ה-PID) וכמה פעמים תודפס המחרוזת 'Parent Done'?", "code_snippet": null, "options": null}, {"id": "10.3", "text": "האם מובטח שההדפסה 'Parent Done' תהיה האחרונה שתופיע על המסך? נמקו את תשובתכם על בסיס מנגנון ה-wait.", "code_snippet": null, "options": null}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: ניתוח עץ התהליכים:\n- התהליך המקורי (P0) מבצע fork ראשון. נוצר P1 (הבן של P0).\n- P0 נכנס לבלוק ה-else ומבצע wait.\n- P1 נכנס לבלוק ה-if הראשון ומבצע fork (השני בתוכנית). נוצר P2 (הבן של P1).\n- בתוך ה-if הפנימי (fork() || fork()):\n  א. עבור P1: ה-fork מחזיר ערך חיובי (ה-PID של P2), ולכן בשל short-circuit evaluation של אופרטור ה-OR (||), ה-fork השני בביטוי לא מתבצע. P1 נכנס לתוך ה-if ומבצע fork נוסף (יצירת P4).\n  ב. עבור P2: ה-fork מחזיר 0, ולכן הוא חייב לבצע את החלק השני של ה-OR. הוא מבצע fork (השלישי בתוכנית) ויוצר את P3. עבור P2, תוצאת ה-OR היא אמת (0 || PID_P3), ולכן הוא נכנס לתוך ה-if ומבצע fork נוסף (יצירת P5).\n  ג. עבור P3: הוא נוצר מה-fork השני בביטוי ה-OR. הוא מקבל 0. תוצאת ה-OR עבורו היא (0 || 0) כלומר שקר, ולכן הוא לא נכנס לתוך ה-if.\nסך התהליכים: P0, P1, P2, P3, P4, P5 - סה\"כ 6 תהליכים.\n\n10.2: \n- המחרוזת 'Process %d exiting' מודפסת על ידי כל תהליך שמסיים את הריצה שלו מחוץ למבנה ה-if/else. מכיוון שיש 6 תהליכים וכולם מגיעים לשורה זו, היא תודפס 6 פעמים.\n- המחרוזת 'Parent Done' מודפסת רק בבלוק ה-else של ה-fork הראשון. רק תהליך P0 (האב המקורי) נכנס לבלוק זה, ולכן היא תודפס פעם אחת בלבד.\n\n10.3: \nלא, זה לא מובטח. הקריאה wait(NULL) ב-P0 גורמת לו להמתין לסיום של *אחד* מילדיו הישירים. ל-P0 יש רק ילד ישיר אחד והוא P1. ברגע ש-P1 מסיים (exit), P0 משתחרר מה-wait וממשיך להדפסה. עם זאת, P1 עצמו לא קורא ל-wait עבור הילדים שלו (P2, P4). לכן, ייתכן ש-P1 יסיים את ריצתו והדפסתו בזמן שילדיו (ונכדיו P3, P5) עדיין רצים. במצב כזה, P0 ידפיס 'Parent Done' ו-'Process P0 exiting' בזמן שתהליכים אחרים עדיין פעילים ברקע (תהליכים אלו יהפכו ליתומים - orphans)."}, "difficulty_estimation": "Hard", "_source_file": "0041__Processes__Open__Hard.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:19:18"}, {"id": 10, "type": "Open", "topic": ["Processes", "Fork", "Process Tree"], "content": {"text": "נתון הקוד הבא בשפת C. הניחו כי כל קריאות המערכת מצליחות, וכי הפלט מודפס לטרמינל ללא השהיות (buffering) משמעותיות שמשנות את סדר הלוגיקה (פרט לסדר הסטנדרטי של תזמון תהליכים).", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    int i;\n    for (i = 0; i < 3; i++) {\n        if (fork() == 0) {\n            if (i % 2 == 0) {\n                fork();\n                printf(\"A\\n\");\n            } else {\n                printf(\"B\\n\");\n                exit(0);\n            }\n        }\n    }\n    while(wait(NULL) > 0);\n    printf(\"C\\n\");\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה פעמים יודפס התו 'A' במהלך ריצת התוכנית? פרטו את החישוב.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "כמה פעמים יודפס התו 'B' במהלך ריצת התוכנית? פרטו את החישוב.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "כמה פעמים יודפס התו 'C' במהלך ריצת התוכנית? פרטו את החישוב.", "code_snippet": null, "options": null}, {"id": "10.4", "text": "מהו מספר התהליכים הכולל שנוצרו במערכת (כולל תהליך האב המקורי)?", "code_snippet": null, "options": null}], "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "ננתח את הלולאה לפי איטרציות:\n1. איטרציה i=0:\n- תהליך האב (P) יוצר בן (C1).\n- C1 נכנס לתנאי (i%2 == 0), מבצע fork נוסף ויוצר את C1a.\n- גם C1 וגם C1a מדפיסים 'A' וממשיכים לאיטרציה הבאה (i=1).\n- סה\"כ הדפסות 'A': 2.\n- תהליכים פעילים שממשיכים ל-i=1: P, C1, C1a.\n\n2. איטרציה i=1:\n- כל אחד מהתהליכים הפעילים (P, C1, C1a) מבצע fork.\n- נוצרים 3 בנים חדשים. עבורם i=1, לכן i%2 != 0.\n- כל אחד מ-3 הבנים הללו מדפיס 'B' ומבצע exit(0).\n- סה\"כ הדפסות 'B': 3.\n- תהליכים פעילים שממשיכים ל-i=2: P, C1, C1a.\n\n3. איטרציה i=2:\n- כל אחד מהתהליכים הפעילים (P, C1, C1a) מבצע fork.\n- נוצרים 3 בנים חדשים (C2, C3, C4). עבורם i=2, לכן i%2 == 0.\n- כל אחד מהם (C2, C3, C4) מבצע fork נוסף (יוצרים את C2a, C3a, C4a).\n- כל ה-6 הללו (הבנים והנכדים של איטרציה זו) מדפיסים 'A'.\n- סה\"כ הדפסות 'A' באיטרציה זו: 6.\n- תהליכים פעילים שמסיימים את הלולאה: P, C1, C1a, C2, C2a, C3, C3a, C4, C4a (סה\"כ 9 תהליכים).\n\n4. סיום (הדפסת 'C'):\n- כל תהליך שמסיים את הלולאה ומגיע לשורת ה-wait מדפיס 'C' פעם אחת לאחר שכל בניו הסתיימו.\n- ישנם 9 תהליכים כאלו.\n\nסיכום:\n- כמות 'A': 2 (מאיטרציה 0) + 6 (מאיטרציה 2) = 8.\n- כמות 'B': 3 (מאיטרציה 1).\n- כמות 'C': 9.\n- סה\"כ תהליכים: תהליך מקורי (1) + בנים מאיטרציה 0 (2) + בנים מאיטרציה 1 (3) + בנים מאיטרציה 2 (6) = 12."}, "difficulty_estimation": "Hard", "_source_file": "0042__Processes__Open__Hard.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:19:41"}, {"id": 10, "type": "Open", "topic": ["Processes", "Fork", "Wait", "Process Tree"], "content": {"text": "נתון הקוד הבא בשפת C. הנח שכל הקריאות למערכת מצליחות, שההדפסות מתבצעות ללא buffering (כלומר יוצאות מיד למסך), ושאין השהיות חיצוניות. ענה על הסעיפים הבאים:\n1. כמה פעמים תודפס האות 'A' וכמה פעמים תודפס האות 'B' על המסך?\n2. תאר את עץ התהליכים שנוצר. עבור כל תהליך, ציין אילו אותיות הוא מדפיס ובאיזה שלב.\n3. האם ייתכן מצב שבו האות 'B' מודפסת לפני כל מופע כלשהו של האות 'A'? נמק את תשובתך על סמך מנגנון הסנכרון בקוד.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int i, status;\n    pid_t pid;\n    for (i = 0; i < 2; i++) {\n        pid = fork();\n        if (pid == 0) {\n            // Child process\n            if (i == 0) {\n                fork();\n            }\n            printf(\"A\");\n        } else {\n            // Parent process\n            waitpid(pid, &status, 0);\n            printf(\"B\");\n        }\n    }\n    return 0;\n}", "options": null}, "sub_questions": null, "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "ניתוח הריצה:\n1. איטרציה i=0:\n- תהליך האב המקורי (P1) מבצע fork ויוצר את P2. \n- P1 נכנס ל-else ומחכה ל-P2 (באמצעות waitpid).\n- P2 (הבן) נכנס ל-if (pid == 0). כיוון ש-i=0, הוא מבצע fork נוסף ויוצר את P3.\n- P2 מדפיס 'A'.\n- P3 (הנכד) נוצר בתוך הבלוק של i=0 ומדפיס 'A'.\n\n2. איטרציה i=1:\n- P2 ו-P3 ממשיכים לאיטרציה הבאה. \n- P2 מבצע fork ויוצר את P4. P2 מחכה ל-P4 ומדפיס 'B'.\n- P4 (הנין) מדפיס 'A' (הוא לא עושה fork כי i=1) ומסיים.\n- P3 מבצע fork ויוצר את P5. P3 מחכה ל-P5 ומדפיס 'B'.\n- P5 (הנין) מדפיס 'A' ומסיים.\n- לאחר ש-P2 מסיים את i=1 ויוצא, P1 (שחיכה לו) מדפיס 'B' וממשיך ל-i=1.\n- P1 (ב-i=1) מבצע fork ויוצר את P6. P1 מחכה ל-P6 ומדפיס 'B'.\n- P6 מדפיס 'A' ומסיים.\n\nסיכום הדפסות:\n- האות 'A' מודפסת ע\"י: P2(i=0), P3(i=0), P4(i=1), P5(i=1), P6(i=1). סה\"כ 5 פעמים.\n- האות 'B' מודפסת ע\"י: P2(i=1), P3(i=1), P1(i=0), P1(i=1). סה\"כ 4 פעמים.\n\nתשובה לסעיף 3:\nלא, לא ייתכן ש-'B' תודפס לפני כל 'A'. בקוד קיים שימוש ב-waitpid המאלץ את האב לחכות לסיום הילד שלו לפני הדפסת 'B'. לדוגמה, P2 ו-P3 מדפיסים 'A' מיד בתחילת הריצה (i=0) עוד לפני שהם יכולים להגיע לשלב ההדפסה של 'B' או לפני ש-P1 יכול להשתחרר מה-wait שלו. כיוון ש-P2 חייב להדפיס 'A' ב-i=0 לפני שהוא בכלל מגיע ל-i=1 או מסיים, ו-P1 מחכה ל-P2, ה-'A' של P2 תמיד תופיע לפני ה-'B' של P1."}, "difficulty_estimation": "Hard", "_source_file": "0043__Processes__Open__Hard.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:20:21"}, {"id": 10, "type": "Open", "topic": ["Processes", "Fork", "Wait", "Process Hierarchy"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בקריאות המערכת fork ו-wait. עליכם לנתח את פעולת התוכנית ולענות על הסעיפים הבאים. הניחו כי כל הקריאות ל-fork מצליחות וכי אין בעיות זיכרון או משאבים. יש לפרט ולנמק את כל שלבי החישוב.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int val = 5;\n    for (int i = 0; i < 2; i++) {\n        if (fork() == 0) {\n            val += 2;\n            if (fork() > 0) {\n                val *= 2;\n                wait(NULL);\n            }\n        } else {\n            wait(NULL);\n            val -= 1;\n        }\n    }\n    printf(\"%d\\n\", val);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה תהליכים סה\"כ (כולל תהליך האב המקורי) ייווצרו במהלך הרצת התוכנית? הציגו את עץ התהליכים (ניתן להשתמש בשמות כמו P0, P1 וכו' כדי לסמן את התהליכים).", "code_snippet": null, "options": null}, {"id": "10.2", "text": "מהם הערכים שיודפסו למסך? יש לציין איזה ערך הודפס על ידי כל תהליך שזיהיתם בסעיף הקודם (לדוגמה: 'תהליך P0 הדפיס X').", "code_snippet": null, "options": null}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "ניתוח עץ התהליכים:\n1. התחלה: תהליך P0 עם val=5.\n2. איטרציה i=0:\n   - P0 מבצע fork ויוצר את P1. P0 נכנס ל-else, מחכה ל-P1 ומבצע val -= 1 (val=4).\n   - P1 (בן) מבצע val += 2 (val=7). אז P1 מבצע fork נוסף ויוצר את P2. \n   - ב-P1 (אב של P2), התנאי fork()>0 מתקיים: val *= 2 (val=14), מחכה ל-P2.\n   - ב-P2 (בן של P1), התנאי fork()>0 לא מתקיים. P2 ממשיך עם val=7.\nכעת יש 3 תהליכים (P0, P1, P2) שממשיכים לאיטרציה i=1.\n\n3. איטרציה i=1:\n   - כל אחד מ-3 התהליכים משכפל את המבנה של האיטרציה הקודמת:\n   - P0 (val=4) יוצר את P3. P3 יוצר את P4. P0 מחכה ל-P3 ומבצע val -= 1 (val=3).\n   - P3 (בן של P0) מבצע val=4+2=6, יוצר את P4, הופך ל-val=12 ומחכה ל-P4. P4 נשאר val=6.\n   - P1 (val=14) יוצר את P5. P5 יוצר את P6. P1 מחכה ל-P5 ומבצע val -= 1 (val=13).\n   - P5 (בן של P1) מבצע val=14+2=16, יוצר את P6, הופך ל-val=32 ומחכה ל-P6. P6 נשאר val=16.\n   - P2 (val=7) יוצר את P7. P7 יוצר את P8. P2 מחכה ל-P7 ומבצע val -= 1 (val=6).\n   - P7 (בן של P2) מבצע val=7+2=9, יוצר את P8, הופך ל-val=18 ומחכה ל-P8. P8 נשאר val=9.\n\nסיכום:\n10.1: סה\"כ נוצרו 9 תהליכים.\n10.2: הערכים המודפסים הם:\n- P0 מדפיס 3\n- P1 מדפיס 13\n- P2 מדפיס 6\n- P3 מדפיס 12\n- P4 מדפיס 6\n- P5 מדפיס 32\n- P6 מדפיס 16\n- P7 מדפיס 18\n- P8 מדפיס 9"}, "difficulty_estimation": "Hard", "_source_file": "0044__Processes__Open__Hard.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:21:00"}, {"id": 101, "type": "Open", "topic": ["Processes", "Pipes", "Fork", "IPC"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בקריאות מערכת לניהול תהליכים ותקשורת ביניהם. הניחו כי כל קריאות המערכת (fork, pipe, write, read, wait) מצליחות ומתבצעות ללא שגיאות. ענו על הסעיפים הבאים תוך פירוט הנימוקים.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int fd[2];\n    pipe(fd);\n    pid_t p1 = fork();\n\n    if (p1 == 0) {\n        // Child 1 (C1)\n        close(fd[0]);\n        pid_t g1 = fork();\n        if (g1 == 0) {\n            // Grandchild (G)\n            int val = 15;\n            write(fd[1], &val, sizeof(val));\n            printf(\"G\");\n            return 0;\n        }\n        wait(NULL);\n        int val = 25;\n        write(fd[1], &val, sizeof(val));\n        printf(\"C1\");\n        close(fd[1]);\n        return 0;\n    } else {\n        // Parent (P)\n        pid_t p2 = fork();\n        if (p2 == 0) {\n            // Child 2 (C2)\n            close(fd[1]);\n            int res, sum = 0;\n            while(read(fd[0], &res, sizeof(res)) > 0) {\n                sum += res;\n            }\n            printf(\"%d\", sum);\n            close(fd[0]);\n            return 0;\n        }\n        close(fd[0]);\n        close(fd[1]);\n        wait(NULL);\n        wait(NULL);\n        printf(\"P\");\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "101.1", "text": "מה יהיה הפלט המדויק של התוכנית? הסבירו את סדר ההדפסה ואת החישוב שהוביל לתוצאה.", "code_snippet": null, "options": null}, {"id": "101.2", "text": "כמה תהליכים נוצרו בסך הכל במהלך הרצת התוכנית (כולל תהליך האב המקורי)?", "code_snippet": null, "options": null}, {"id": "101.3", "text": "מה יקרה לפלט התוכנית אם נסיר את השורה (close(fd[1] בתהליך האב (השורה שנמצאת תחת הבלוק של ה-Parent)? נמקו.", "code_snippet": null, "options": null}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "101.1: הפלט יהיה GC140P. הסבר: תהליך C1 יוצר את G. תהליך G כותב 15 לצינור, מדפיס G ומסתיים. C1 ממתין ל-G (באמצעות wait), ואז כותב 25 לצינור, מדפיס C1 ומסתיים. תהליך C2 קורא מהצינור בלולאה. הוא יקרא את 15 ואז את 25. הלולאה תסתיים רק כאשר כל קצוות הכתיבה של הצינור ייסגרו. קצוות הכתיבה נמצאים אצל G (נסגר בסיום), C1 (נסגר במפורש ובסיום), והאב P. כיוון ש-P סוגר את fd[1] מיד לאחר ה-fork השני, ברגע ש-C1 מסתיים, אין יותר כותבים פתוחים ו-read יחזיר 0. לכן C2 ידפיס את הסכום 40. האב P ממתין לשני ילדיו ומדפיס P בסוף.\n\n101.2: נוצרו 4 תהליכים: האב המקורי (P), הבן הראשון (C1), הנכד (G), והבן השני (C2).\n\n101.3: אם האב לא יסגור את fd[1], התוכנית תיתקע (Deadlock/Hang). תהליך C2 יישאר חסום בקריאת ה-read בתוך הלולאה, כיוון שקיים עדיין קצה כתיבה פתוח (אצל האב P), ולכן מערכת ההפעלה לא תשלח סיגנל EOF (ערך חזרה 0 מ-read). כתוצאה מכך C2 לא ידפיס את הסכום ולא יסתיים, והאב P ימתין לו לנצח ב-wait."}, "difficulty_estimation": "Hard", "_source_file": "0045__Processes__Open__Hard.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:21:22"}, {"id": 10, "type": "Open", "topic": ["Processes", "System Calls", "Memory Isolation"], "content": {"text": "לפניכם קוד בשפת C המשתמש בקריאות המערכת fork ו-waitpid. עליכם לנתח את פעולת הקוד ולענות על הסעיפים הבאים. הניחו שכל קריאות המערכת מצליחות ושאין השהיות חיצוניות מלבד אלו המשתמעות מהקוד. יש לפרט ולנמק את שלבי החישוב.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    int x = 10;\n    for (int i = 0; i < 2; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            x -= 2;\n            if (fork() == 0) {\n                x += 5;\n                printf(\"A: %d\\n\", x);\n                exit(0);\n            }\n            x++;\n            printf(\"B: %d\\n\", x);\n            exit(0);\n        } else {\n            waitpid(pid, NULL, 0);\n            x /= 2;\n        }\n    }\n    printf(\"C: %d\\n\", x);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה תהליכים נוצרו בסך הכל במהלך הרצת התוכנית (כולל תהליך האב המקורי)?", "code_snippet": null, "options": null}, {"id": "10.2", "text": "מהו הפלט של התוכנית? במידה וסדר ההדפסה אינו דטרמיניסטי, ציינו אילו שורות יכולות להתחלף ביניהן והסבירו מדוע.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "כיצד היה משתנה ערכו של x המודפס בשורה המתחילה באות C, לו היינו מחליפים את השורה x /= 2; בשורה x = x - i;?", "code_snippet": null, "options": null}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "ניתוח הקוד:\n1. סעיף 10.1: האב מבצע לולאה בת 2 איטרציות. בכל איטרציה הוא קורא ל-fork (יצירת ילד) ומחכה לו שיסתיים. כל ילד בתורו קורא ל-fork נוסף (יצירת נכד). \nאיטרציה i=0: אב -> ילד 1 -> נכד 1 (סה\"כ 3 תהליכים עד כה).\nאיטרציה i=1: אב -> ילד 2 -> נכד 2 (עוד 2 תהליכים).\nסה\"כ נוצרו 5 תהליכים.\n\n2. סעיף 10.2: \n- איטרציה i=0: האב מתחיל עם x=10. הילד יורש x=10, מחסיר 2 (x=8). הנכד יורש מהילד x=8, מוסיף 5 ומדפיס A: 13. הילד מוסיף 1 ומדפיס B: 9. האב מחכה לילד ומבצע x=10/2=5.\n- איטרציה i=1: האב כעת עם x=5. הילד השני יורש x=5, מחסיר 2 (x=3). הנכד השני יורש x=3, מוסיף 5 ומדפיס A: 8. הילד השני מוסיף 1 ומדפיס B: 4. האב מחכה לילד ומבצע x=5/2=2 (חלוקת שלמים).\n- סיום: האב מדפיס C: 2.\nסדר ההדפסה: בתוך כל איטרציה, הסדר בין A ל-B אינו דטרמיניסטי כי הילד והנכד רצים במקביל ואין wait ביניהם. אך כל איטרציה חייבת להסתיים לפני שהבאה מתחילה בגלל ה-waitpid של האב. לכן A:13 ו-B:9 יופיעו לפני A:8 ו-B:4.\n\n3. סעיף 10.3: \n- ב-i=0: האב יבצע x = 10 - 0 = 10.\n- ב-i=1: האב יבצע x = 10 - 1 = 9.\nלכן הפלט בשורה C יהיה 9."}, "difficulty_estimation": "Hard", "_source_file": "0046__Processes__Open__Hard.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:21:51"}, {"id": 1, "type": "Open", "topic": ["Processes", "Fork", "Wait", "Orphan Processes"], "content": {"text": "נתון קטע הקוד הבא בשפת C. הנח שכל קריאות המערכת מצליחות, שהתהליכים רצים על מעבד יחיד, ושהפלט של הפונקציה printf נכתב ל-stdout בצורה אטומית (כלומר, לא ייתכן ערבוב תווים בתוך מחרוזת אחת מהדפסות שונות). ענה על הסעיפים הבאים:", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    for (int i = 0; i < 2; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            printf(\"C%d \", i);\n            if (i == 0) {\n                if (fork() == 0) {\n                    printf(\"G \");\n                    return 0;\n                }\n                printf(\"G \");\n            }\n            return 0;\n        } else {\n            printf(\"P%d \", i);\n            wait(NULL);\n        }\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "כמה תהליכים נוצרו סך הכל במהלך ריצת התוכנית (כולל התהליך המקורי)? פרטו אילו תהליכים נוצרו ובאיזה שלב.", "code_snippet": null, "options": null}, {"id": "1.2", "text": "שרטטו את עץ התהליכים (Process Tree) שנוצר במהלך הריצה.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "האם ייתכן שיתקבל הפלט הבא: 'P0 C0 G P1 C1 G '? נמקו את תשובתכם תוך התייחסות למנגנון ה-wait ולתהליכים יתומים (orphans).", "code_snippet": null, "options": null}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. נוצרו סה\"כ 4 תהליכים: התהליך המקורי (P), הבן הראשון (C0) שנוצר ב-i=0, הבן השני (C1) שנוצר ב-i=1, והנכד (G) שנוצר על ידי C0.\n2. עץ התהליכים: P הוא השורש. ל-P יש שני בנים ישירים: C0 ו-C1. ל-C0 יש בן אחד: G. חשוב לציין ש-C1 נוצר רק לאחר ש-C0 הסתיים, כיוון ש-P מבצע wait(NULL) בכל איטרציה ומחכה לסיום הבן הנוכחי לפני המעבר לאיטרציה הבאה.\n3. כן, הפלט ייתכן. הסבר: באיטרציה i=0, האב P יוצר את C0 ומחכה לו. C0 מדפיס 'C0', יוצר את G, ומדפיס 'G'. ברגע ש-C0 מסיים (return 0), האב P משתחרר מה-wait וממשיך לאיטרציה i=1. ב-i=1, האב מדפיס 'P1' ויוצר את C1 שמדפיס 'C1'. התהליך G הוא נכד של P ובן של C0. מכיוון ש-C0 לא ביצע wait(NULL) עבור G, התהליך G הופך ליתום (Orphan) וממשיך לרוץ במקביל לאב P. לכן, ה-'G' השני (שהודפס על ידי הנכד) יכול להופיע בכל שלב לאחר ה-fork בתוך C0, ובפרט בסוף הפלט לאחר ש-P ו-C1 כבר סיימו את פעולתם."}, "difficulty_estimation": "Hard", "_source_file": "0047__Processes__Open__Hard.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:22:29"}, {"id": 10, "type": "Open", "topic": ["Processes", "Signals", "Fork"], "content": {"text": "לפניכם קוד בשפת C המשתמש בקריאות מערכת לניהול תהליכים וסיגנלים. הניחו שכל הקריאות למערכת מצליחות, שאין עומס חריג על המערכת, וכי פקודת sleep אכן גורמת לתהליך להמתין כנדרש. שימו לב כי סיגנלים עשויים לקטוע קריאות מערכת חוסמות (כמו sleep).", "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <signal.h>\n\nint g_var = 1;\n\nvoid signal_handler(int sig) {\n    if (sig == SIGUSR1) g_var += 3;\n    else if (sig == SIGCHLD) g_var *= 2;\n}\n\nint main() {\n    signal(SIGUSR1, signal_handler);\n    signal(SIGCHLD, signal_handler);\n\n    pid_t p = fork();\n    if (p == 0) { // Child process\n        g_var += 5;\n        if (fork() == 0) { // Grandchild process\n            g_var += 10;\n            kill(getppid(), SIGUSR1);\n            exit(0);\n        }\n        wait(NULL);\n        printf(\"C: %d\\n\", g_var);\n        exit(0);\n    }\n\n    sleep(5);\n    printf(\"P: %d\\n\", g_var);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "מה יהיה הפלט של התוכנית? יש לכתוב את השורות בסדר הופעתן.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "הסבירו בפירוט את השתלשלות האירועים: מדוע כל ערך הודפס כפי שהודפס? התייחסו למרחבי הכתובות, לטיפול בסיגנלים ולסנכרון בין התהליכים.", "code_snippet": null, "options": null}], "points": 15, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הסבר השלבים:\n1. תהליך האב מתחיל עם g_var = 1 ורושם מטפלים לסיגנלים SIGUSR1 ו-SIGCHLD.\n2. האב מבצע fork. נוצר בן (C) עם עותק נפרד של g_var = 1.\n3. הבן מעדכן את g_var שלו ל-6 (1+5).\n4. הבן מבצע fork. נוצר נכד (GC) עם עותק נפרד של g_var = 6.\n5. הנכד מעדכן את g_var שלו ל-16 (6+10) ושולח סיגנל SIGUSR1 לאביו (הבן) באמצעות kill(getppid(), ...).\n6. הבן מקבל את הסיגנל SIGUSR1. המטפל שלו רץ ומעדכן את g_var של הבן ל-9 (6+3).\n7. הנכד מסיים (exit). סיום הנכד שולח סיגנל SIGCHLD לאביו (הבן).\n8. הבן מקבל SIGCHLD. המטפל שלו רץ ומכפיל את g_var שלו: 9 * 2 = 18.\n9. הבן משלים את ה-wait, מדפיס 'C: 18' ומסיים.\n10. סיום הבן שולח סיגנל SIGCHLD לאב.\n11. האב, שהיה ב-sleep, מתעורר עקב קבלת הסיגנל. המטפל של האב רץ ומכפיל את g_var שלו: 1 * 2 = 2.\n12. האב ממשיך להדפסה ומדפיס 'P: 2'.\n\nהפלט הצפוי:\nC: 18\nP: 2"}, "difficulty_estimation": "Hard", "_source_file": "0048__Processes__Open__Hard.json", "_topic_hint": "Processes", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:23:25"}, {"id": 5, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה. כמה פעמים תודפס המחרוזת \"Hello\"?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    if (fork() == 0) {\n        fork();\n        printf(\"Hello\\n\");\n    }\n    return 0;\n}", "options": ["א. 1", "ב. 2", "ג. 3", "ד. 4"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "התהליך הראשי (האב) מבצע fork() ראשון. תהליך האב מקבל מהקריאה את ה-PID של הבן (ערך חיובי), ולכן התנאי fork() == 0 אינו מתקיים עבורו והוא מדלג על הבלוק. תהליך הבן מקבל מהקריאה את הערך 0, ולכן הוא נכנס לתוך בלוק ה-if. בתוך הבלוק, תהליך הבן מבצע fork() נוסף, מה שיוצר תהליך חדש (נכד). בשלב זה, גם הבן וגם הנכד נמצאים בתוך הבלוק וממשיכים לביצוע פקודת ה-printf. לכן, המחרוזת תודפס פעמיים (פעם אחת על ידי הבן ופעם אחת על ידי הנכד)."}, "difficulty_estimation": "Easy", "_source_file": "0049__Processes__CodeAnalysis__Easy.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:23:43"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה. כמה פעמים תודפס המחרוזת \"Hello\" למסך? הניחו שכל קריאות המערכת מצליחות.", "code_snippet": "int main() {\n    for (int i = 0; i < 2; i++) {\n        fork();\n    }\n    printf(\"Hello\\n\");\n    return 0;\n}", "options": ["א. 2", "ב. 3", "ג. 4", "ד. 6", "ה. 8"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "בכל איטרציה של הלולאה, כל תהליך קיים מבצע fork() ובכך מכפיל את מספר התהליכים. בתחילה יש תהליך אחד (התהליך הראשי). לאחר האיטרציה הראשונה (i=0) ישנם 2 תהליכים. לאחר האיטרציה השנייה (i=1), כל אחד משני התהליכים הקיימים מבצע fork(), ולכן נוצרים 2 תהליכים נוספים, מה שמביא אותנו ל-4 תהליכים בסך הכל. כל אחד מארבעת התהליכים הללו ממשיך לשורת ה-printf ומדפיס את המחרוזת פעם אחת."}, "difficulty_estimation": "Easy", "_source_file": "0050__Processes__CodeAnalysis__Easy.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:23:52"}, {"id": 5, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה. מה יהיה הפלט של התוכנית? (הנח שכל קריאות המערכת מצליחות, ואין חשיבות לסדר ההדפסה בין התהליכים השונים).", "code_snippet": "int main() {\n    int x = 10;\n    if (fork() == 0) {\n        x += 5;\n    } else {\n        x -= 5;\n    }\n    printf(\"%d \", x);\n    return 0;\n}", "options": ["א. 15 5", "ב. 15", "ג. 5", "ד. 10 10", "ה. 15 10"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "קריאת המערכת fork() יוצרת תהליך בן חדש המהווה העתק של תהליך האב. בתהליך הבן, הערך המוחזר מ-fork() הוא 0, ולכן הוא נכנס לבלוק ה-if ומעדכן את x ל-15. בתהליך האב, הערך המוחזר הוא ה-PID של הבן (גדול מ-0), ולכן הוא נכנס לבלוק ה-else ומעדכן את x ל-5. כיוון שלכל תהליך מרחב זיכרון נפרד, כל אחד מהם מדפיס את הערך המקומי שלו, ומתקבלים שני המספרים 15 ו-5."}, "difficulty_estimation": "Easy", "_source_file": "0051__Processes__CodeAnalysis__Easy.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:24:03"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה. כמה פעמים תודפס המחרוזת \"OS\" למסך? הניחו שכל קריאות המערכת מצליחות וכי הפלט מרוקן (flushed) מיד לאחר ההדפסה.", "code_snippet": "int main() {\n    for (int i = 0; i < 2; i++) {\n        fork();\n    }\n    printf(\"OS\\n\");\n    return 0;\n}", "options": ["א. 2", "ב. 3", "ג. 4", "ד. 6", "ה. 8"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "התוכנית מבצעת לולאה בת שתי איטרציות. בתחילה קיים תהליך אחד. באיטרציה הראשונה (i=0), התהליך מבצע fork ונוצר תהליך בן, כך שישנם 2 תהליכים. באיטרציה השנייה (i=1), כל אחד משני התהליכים הקיימים מבצע fork בעצמו, מה שיוצר שני תהליכים חדשים נוספים. סה\"כ בסיום הלולאה קיימים 4 תהליכים (2^2). כל אחד מארבעת התהליכים הללו ממשיך לשורת ההדפסה ומדפיס \"OS\" פעם אחת, ולכן המחרוזת תודפס 4 פעמים."}, "difficulty_estimation": "Easy", "_source_file": "0052__Processes__CodeAnalysis__Easy.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:24:16"}, {"id": 5, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "כמה פעמים תודפס המילה 'Hello' במהלך הרצת הקוד הבא? הניחו שכל הקריאות למערכת מצליחות.", "code_snippet": "int main() {\n    fork();\n    if (fork() == 0) {\n        fork();\n    }\n    printf(\"Hello\\n\");\n    return 0;\n}", "options": ["א. 3", "ב. 4", "ג. 6", "ד. 8", "ה. 5"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "לאחר ה-fork הראשון ישנם 2 תהליכים. בשורה השנייה, כל אחד מהם מבצע fork נוסף, מה שיוצר 2 תהליכים נוספים (סה\"כ 4 תהליכים בשלב זה). מתוך הארבעה, רק 2 התהליכים שהם 'בנים' של ה-fork השני (אלו שקיבלו את הערך 0) נכנסים לתוך בלוק ה-if ומבצעים fork שלישי. ה-fork השלישי יוצר 2 תהליכים נוספים. לסיכום: 4 תהליכים קיימים לפני ה-if, ועוד 2 נוצרים בתוכו, סה\"כ 6 תהליכים שכל אחד מהם מגיע לשורת ההדפסה."}, "difficulty_estimation": "Easy", "_source_file": "0053__Processes__CodeAnalysis__Easy.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:24:26"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה בשפת C. כמה פעמים תודפס המילה 'OS' במהלך ריצת התוכנית?\nהניחו כי כל קריאות המערכת מצליחות, וכי כל הדפסה מתבצעת מיד ללא חוצץ (buffer).", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    for (int i = 0; i < 2; i++) {\n        fork();\n        printf(\"OS\\n\");\n    }\n    return 0;\n}", "options": ["א. 2", "ב. 4", "ג. 6", "ד. 8", "ה. 16"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "באיטרציה הראשונה של הלולאה (i=0), מתבצעת קריאת fork אחת שיוצרת תהליך בן. בשלב זה ישנם 2 תהליכים (האב המקורי והבן החדש), וכל אחד מהם מדפיס את המילה 'OS' פעם אחת (סה\"כ 2 הדפסות). באיטרציה השנייה (i=1), כל אחד משני התהליכים הקיימים מבצע fork בעצמו, מה שיוצר 2 תהליכים נוספים (סה\"כ 4 תהליכים רצים כעת). כל ארבעת התהליכים הללו מבצעים את פקודת ההדפסה של האיטרציה השנייה (סה\"כ 4 הדפסות נוספות). לכן, סך כל הפעמים שהמילה תודפס הוא 2 + 4 = 6."}, "difficulty_estimation": "Easy", "_source_file": "0054__Processes__CodeAnalysis__Easy.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:24:52"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה. כמה פעמים יודפס התו 'X' למסך? הניחו שכל קריאות המערכת מצליחות ותהליכים אינם נכשלים.", "code_snippet": "int main() {\n    if (fork() == 0) {\n        fork();\n        printf(\"X\\n\");\n    }\n    return 0;\n}", "options": ["א. 1", "ב. 2", "ג. 3", "ד. 4", "ה. 0"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "התהליך הראשי (האב) מבצע fork. תהליך האב מקבל ערך הגדול מ-0 ולכן אינו נכנס לבלוק ה-if. תהליך הבן מקבל את הערך 0 ונכנס לבלוק ה-if. בתוך הבלוק, תהליך הבן מבצע fork נוסף, מה שיוצר תהליך חדש (הנכד של התהליך המקורי). כעת, גם תהליך הבן וגם תהליך הנכד נמצאים בתוך הבלוק וממשיכים לשורת ההדפסה. לכן, התו 'X' יודפס פעמיים בסך הכל."}, "difficulty_estimation": "Easy", "_source_file": "0055__Processes__CodeAnalysis__Easy.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:25:05"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה. כמה פעמים יודפס המחרוזת \"OS\" במהלך הרצת התוכנית? הניחו שכל קריאות המערכת מצליחות.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    fork();\n    if (fork() == 0) {\n        fork();\n    }\n    printf(\"OS\\n\");\n    return 0;\n}", "options": ["א. 2", "ב. 4", "ג. 5", "ד. 6", "ה. 8"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "נבצע מעקב אחר יצירת התהליכים:\n1. התהליך המקורי (P1) מבצע את ה-fork הראשון. נוצר תהליך בן (P2). כעת יש 2 תהליכים.\n2. שני התהליכים (P1, P2) מגיעים לשורת ה-if ומבצעים fork נוסף:\n   - P1 יוצר את P3. ב-P1 ה-fork מחזיר PID חיובי (דילוג על ה-if). ב-P3 ה-fork מחזיר 0 (כניסה ל-if).\n   - P2 יוצר את P4. ב-P2 ה-fork מחזיר PID חיובי (דילוג על ה-if). ב-P4 ה-fork מחזיר 0 (כניסה ל-if).\n3. התהליכים שנכנסו ל-if (הם P3 ו-P4) מבצעים fork שלישי:\n   - P3 יוצר את P5.\n   - P4 יוצר את P6.\n4. כל התהליכים שנוצרו ולא הסתיימו מגיעים לשורת ההדפסה. התהליכים הם: P1, P2, P3, P4, P5, P6. סה\"כ 6 תהליכים, ולכן המחרוזת תודפס 6 פעמים."}, "difficulty_estimation": "Easy", "_source_file": "0056__Processes__CodeAnalysis__Easy.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:25:25"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה בשפת C. מה יהיה הפלט של התוכנית? הניחו שכל קריאות המערכת מצליחות, וכי הפלט מודפס ברצף ללא רווחים או ירידות שורה.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 0;\n    for (int i = 0; i < 3; i++) {\n        if (fork() == 0) {\n            x++;\n        } else {\n            x--;\n            wait(NULL);\n            break;\n        }\n    }\n    printf(\"%d\", x);\n    return 0;\n}", "options": ["א. 3210", "ב. 310-1", "ג. -1013", "ד. 0", "ה. אף אחת מהתשובות אינה נכונה"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "נעקוב אחר יצירת התהליכים: התהליך הראשי (P0) מתחיל עם x=0. באיטרציה הראשונה (i=0) הוא יוצר בן (P1). P0 מבצע x-- (הופך ל-1-) ומחכה ל-P1. P1 מבצע x++ (הופך ל-1) וממשיך לאיטרציה הבאה. באיטרציה i=1, P1 יוצר בן (P2). P1 מבצע x-- (הופך ל-0) ומחכה ל-P2. P2 מבצע x++ (הופך ל-2) וממשיך לאיטרציה הבאה. באיטרציה i=2, P2 יוצר בן (P3). P2 מבצע x-- (הופך ל-1) ומחכה ל-P3. P3 מבצע x++ (הופך ל-3) ומסיים את הלולאה. P3 הוא הראשון שמגיע להדפסה ומדפיס 3. לאחר מכן P2 מסיים את ה-wait ומדפיס 1. לאחר מכן P1 מסיים את ה-wait ומדפיס 0. לבסוף P0 מסיים את ה-wait ומדפיס 1-. לכן הפלט הוא 310-1."}, "difficulty_estimation": "Medium", "_source_file": "0057__Processes__CodeAnalysis__Medium.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:25:42"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Address Space"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו כי כל קריאות המערכת מצליחות, וכי הפונקציה wait(NULL) גורמת לתהליך האב להמתין עד לסיום ביצועו של תהליך בן אחד. מה יהיה הפלט המדויק של התוכנית?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint counter = 0;\n\nint main() {\n    for (int i = 0; i < 2; i++) {\n        if (fork() == 0) {\n            counter++;\n            printf(\"%d\", counter);\n        } else {\n            wait(NULL);\n            counter--;\n            printf(\"%d\", counter);\n        }\n    }\n    return 0;\n}", "options": ["א. 120-10-2", "ב. 1100-1-2", "ג. 120-1-20", "ד. 1210-1-2", "ה. אף אחת מהתשובות אינה נכונה"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "נעקוב אחר ביצוע התהליכים: 1. תהליך האב המקורי (P1) עם counter=0 ו-i=0 מבצע fork. P1 נכנס ל-wait. 2. הבן (P2) עם i=0 מקדם את counter ל-1 ומדפיס '1'. 3. P2 ממשיך ל-i=1 ומבצע fork. P2 נכנס ל-wait. 4. הבן של P2 (נקרא לו P3) עם i=1 מקדם את ה-counter שלו (שהיה 1) ל-2 ומדפיס '2'. P3 מסיים. 5. P2 משתחרר מה-wait, מקטין את ה-counter שלו ל-0 ומדפיס '0'. P2 מסיים. 6. P1 משתחרר מה-wait (של P2), מקטין את ה-counter שלו ל-1- ומדפיס '1-'. 7. P1 ממשיך ל-i=1 ומבצע fork. P1 נכנס ל-wait. 8. הבן החדש (P4) עם i=1 מקדם את ה-counter שלו (שהיה 1-) ל-0 ומדפיס '0'. P4 מסיים. 9. P1 משתחרר מה-wait, מקטין את ה-counter ל-2- ומדפיס '2-'. סה\"כ הפלט: 120-10-2."}, "difficulty_estimation": "Medium", "_source_file": "0058__Processes__CodeAnalysis__Medium.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:25:58"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו שכל קריאות המערכת מצליחות, שהתהליכים רצים לפי סדר הקריאה ל-wait, ושהפלט מודפס למסך ללא השהיה (buffering). מה יהיה הפלט של התוכנית?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint x = 10;\n\nint main() {\n    for (int i = 0; i < 2; i++) {\n        if (fork() == 0) {\n            x += 5;\n            printf(\"%d \", x);\n            return 0;\n        } else {\n            wait(NULL);\n            x += 2;\n        }\n    }\n    printf(\"%d\", x);\n    return 0;\n}", "options": ["א. 15 15 10", "ב. 15 17 14", "ג. 15 22 24", "ד. 15 17 12", "ה. אף אחת מהתשובות אינה נכונה"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "באיטרציה הראשונה (i=0), האב יוצר בן. הבן מקבל עותק של x=10, מבצע x += 5 ומדפיס 15. האב ממתין לסיום הבן (wait) ואז מבצע x += 2, כך שערך x אצלו הופך ל-12. באיטרציה השנייה (i=1), האב יוצר בן נוסף. הבן השני יורש את ערך ה-x הנוכחי של האב (12), מבצע x += 5 ומדפיס 17. האב שוב ממתין ואז מבצע x += 2, כך שערך x אצלו הופך ל-14. בסיום הלולאה, האב מדפיס את ערך ה-x שלו (14). מכיוון שכל תהליך מקבל עותק נפרד של הזיכרון (Copy-on-Write), השינויים של הבנים לא משפיעים על האב ולהיפך, מלבד הירושה ברגע ה-fork. לכן הפלט הכולל הוא 15 17 14."}, "difficulty_estimation": "Medium", "_source_file": "0059__Processes__CodeAnalysis__Medium.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:26:24"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Processes"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו שכל קריאות המערכת מצליחות, ושלא פועלים במערכת תהליכים נוספים פרט לאלו שנוצרים בקוד. תזכורת: כל הדפסה לפלט הסטנדרטי מתבצעת מיד, ללא חוצץ (buffer) הדפסה. איזה מהפלטים הבאים אינו אפשרי?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    if (fork() == 0) {\n        fork();\n        printf(\"1\");\n    } else {\n        wait(NULL);\n        printf(\"2\");\n    }\n    return 0;\n}", "options": ["א. 112", "ב. 121", "ג. 211", "ד. כל הפלטים המוצגים אפשריים"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "התהליך הראשי (האב) מבצע fork ויוצר את תהליך הבן (C1). לאחר מכן האב קורא ל-wait, מה שאומר שהוא ימתין עד ש-C1 יסיים את ריצתו לפני שידפיס '2'. תהליך C1 בעצמו מבצע fork ויוצר תהליך נכד (G1). גם C1 וגם G1 מדפיסים '1'. כיוון ש-C1 חייב להדפיס '1' לפני שהוא מסיים את ריצתו, והאב מדפיס '2' רק לאחר סיום C1, הרי שלפחות תו '1' אחד חייב להופיע לפני התו '2' בפלט. לכן הפלט '211' אינו אפשרי (הנכד G1 יכול להדפיס '1' אחרי ה-'2' של האב אם C1 סיים לפניו, אך הבן C1 עצמו חייב להדפיס '1' לפני ה-'2')."}, "difficulty_estimation": "Medium", "_source_file": "0060__Processes__CodeAnalysis__Medium.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:26:59"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתון קטע הקוד הבא בשפת C. הניחו כי כל קריאות המערכת מצליחות, וכי הפלט מודפס ישירות למסך ללא שימוש ב-buffer פנימי. מה יהיו הערכים המודפסים על המסך בסיום ריצת התוכנית (הסדר אינו מחייב)?", "code_snippet": "int main() {\n    int x = 0;\n    for (int i = 0; i < 2; i++) {\n        if (fork() == 0) {\n            x += 2;\n        } else {\n            x += 1;\n            wait(NULL);\n        }\n    }\n    printf(\"%d \", x);\n    return 0;\n}", "options": ["א. 2 3 3 4", "ב. 1 2 3 4", "ג. 2 2 4 4", "ד. 0 1 2 3", "ה. אף אחת מהתשובות אינה נכונה"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "נעקוב אחר פיצול התהליכים וערך המשתנה x (הנמצא במרחב הכתובות הנפרד של כל תהליך):\n1. התהליך המקורי (P0) מתחיל עם x=0.\n2. איטרציה ראשונה (i=0): P0 מבצע fork. נוצר בן P1. בבן (P1) התנאי מתקיים ו-x גדל ל-2. באב (P0) התנאי לא מתקיים, x גדל ל-1 והוא ממתין לבנו.\n3. איטרציה שנייה (i=1):\n   - תהליך P1 (שבו x=2) מבצע fork ויוצר את P3. ב-P3 (הבן החדש) x=2+2=4. ב-P1 (האב של P3) x=2+1=3.\n   - לאחר ש-P1 מסיים, P0 ממשיך לאיטרציה השנייה שלו. P0 (שבו x=1) מבצע fork ויוצר את P2. ב-P2 (הבן החדש) x=1+2=3. ב-P0 (האב) x=1+1=2.\n4. בסיום, כל ארבעת התהליכים שנוצרו (P0, P1, P2, P3) מדפיסים את ערך ה-x שלהם: 2, 3, 3, 4."}, "difficulty_estimation": "Medium", "_source_file": "0061__Processes__CodeAnalysis__Medium.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:27:20"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "נתונה התוכנית הבאה בשפת C. מה יהיה הפלט של התוכנית? הניחו שכל קריאות המערכת מצליחות ושהפלט מודפס מיד ללא חוצץ (buffering).", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint x = 5;\n\nint main() {\n    for (int i = 0; i < 2; i++) {\n        if (fork() == 0) {\n            x += 10;\n            printf(\"%d\", x);\n            return 0;\n        } else {\n            wait(NULL);\n            x -= 2;\n            printf(\"%d\", x);\n        }\n    }\n    return 0;\n}", "options": ["א. 153131", "ב. 1513131", "ג. 155133", "ד. 15151313", "ה. 151331"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "בכל איטרציה של הלולאה, תהליך האב יוצר תהליך בן ומחכה לסיומו בעזרת wait. כיוון שכל תהליך מקבל מרחב כתובות נפרד, השינויים במשתנה הגלובלי x בתוך הבן אינם משפיעים על האב, אך הבן יורש את הערך הנוכחי של x מהאב ברגע ה-fork. באיטרציה הראשונה (i=0): הבן מקבל x=5, מוסיף 10 ומדפיס 15. האב מחכה, מעדכן את ה-x שלו ל-3 (5-2) ומדפיס 3. באיטרציה השנייה (i=1): האב (שה-x שלו הוא 3) יוצר בן חדש. הבן יורש x=3, מוסיף 10 ומדפיס 13. האב מחכה, מעדכן את ה-x שלו ל-1 (3-2) ומדפיס 1. התוצאה המצטברת היא 153131."}, "difficulty_estimation": "Medium", "_source_file": "0062__Processes__CodeAnalysis__Medium.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:27:33"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Fork"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו כי כל קריאות המערכת מצליחות, וכי הפלט מודפס מיד למסך (ללא buffering). מה יהיה הפלט של התוכנית?", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    int x = 5;\n    for (int i = 0; i < 2; i++) {\n        if (fork() == 0) {\n            x += 10;\n            printf(\"%d\", x);\n            exit(0);\n        } else {\n            x += 2;\n            wait(NULL);\n        }\n    }\n    printf(\"%d\", x);\n    return 0;\n}", "options": ["א. 15159", "ב. 15179", "ג. 152535", "ד. 151719", "ה. 15177"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "בתחילת התוכנית x=5. באיטרציה הראשונה (i=0), מתבצע fork. הבן הראשון מקבל עותק של x=5, מעדכן אותו ל-15 (x += 10), מדפיס '15' ומסיים (exit). האב באותו זמן מעדכן את ה-x שלו ל-7 (x += 2) ומחכה לסיום הבן. באיטרציה השנייה (i=1), האב (שבו x=7) מבצע fork נוסף. הבן השני מקבל עותק של x=7, מעדכן אותו ל-17 (x += 10), מדפיס '17' ומסיים. האב מעדכן את ה-x שלו ל-9 (x += 2) ומחכה לסיום הבן. בסיום הלולאה, האב מדפיס את הערך הסופי של x שלו, שהוא 9. לכן הפלט המצטבר הוא 15179."}, "difficulty_estimation": "Medium", "_source_file": "0063__Processes__CodeAnalysis__Medium.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:27:45"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "נתונה התוכנית הבאה בשפת C. מה יהיה הפלט של התוכנית? הניחו שכל קריאות המערכת מצליחות, שההדפסות מתבצעות מיד ללא חוצץ (buffer), ושתהליך אב תמיד ממתין לסיום ילדיו לפני שהוא ממשיך בביצוע.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint val = 5;\n\nint main() {\n    pid_t pid;\n    pid = fork();\n    if (pid == 0) {\n        val += 15;\n        if (fork() == 0) {\n            val += 20;\n            printf(\"%d\", val);\n        } else {\n            wait(NULL);\n            printf(\"%d\", val);\n        }\n    } else {\n        wait(NULL);\n        val += 10;\n        printf(\"%d\", val);\n    }\n    return 0;\n}", "options": ["א. 402015", "ב. 404015", "ג. 402025", "ד. 404025", "ה. 204015"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "לאחר ה-fork הראשון, נוצר תהליך בן (C1) בו המשתנה הגלובלי val הוא 5. C1 מעדכן את val ל-20. לאחר מכן C1 מבצע fork נוסף ויוצר נכד (G1). ב-G1 המשתנה val מתחיל ב-20, מעודכן ל-40 ומודפס. כיוון שלכל תהליך מרחב זיכרון נפרד (Copy on Write), השינוי בנכד לא משפיע על C1. לכן, לאחר ה-wait ב-C1, הוא מדפיס את הערך שלו שהוא 20. תהליך האב המקורי המתין לסיום C1, ולאחר מכן הוסיף 10 לערך המקורי שלו (5) והדפיס 15. התוצאה המשורשרת היא 402015."}, "difficulty_estimation": "Medium", "_source_file": "0064__Processes__CodeAnalysis__Medium.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:27:56"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Processes", "fork", "wait", "Memory Isolation", "Concurrency"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו שכל קריאות המערכת מצליחות, ושאין תהליכים נוספים במערכת מלבד אלו שנוצרים על ידי התוכנית. הניחו כי המערכת אינה משתמשת בחוצצים (buffers) עבור הפלט.", "code_snippet": "1  #include <stdio.h>\n2  #include <unistd.h>\n3  #include <sys/wait.h>\n4  #include <stdlib.h>\n5\n6  int main() {\n7    int x = 1;\n8    pid_t p;\n9    for (int i = 0; i < 2; i++) {\n10     p = fork();\n11     if (p == 0) {\n12       x += 2;\n13       if (i == 1) {\n14         if (fork() == 0) {\n15           x *= 2;\n16           printf(\"C: %d\\n\", x);\n17           exit(0);\n18         }\n19         wait(NULL);\n20       }\n21       printf(\"B: %d\\n\", x);\n22       exit(0);\n23     } else {\n24       x += 1;\n25     }\n26   }\n27   while(wait(NULL) > 0);\n28   printf(\"A: %d\\n\", x);\n29   return 0;\n30 }", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה תהליכים נוצרו סה\"כ במהלך ריצת התוכנית (כולל התהליך הראשי)? הסבירו את תשובתכם בעזרת תיאור עץ התהליכים.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "ציינו את כל שורות הפלט של התוכנית. האם סדר ההדפסה של השורות קבוע? אם כן - מהו? אם לא - אילו אילוצים קיימים על סדר ההדפסה?", "code_snippet": null, "options": null}, {"id": "10.3", "text": "נניח שמוחקים את שורה 27 מהקוד (לולאת ה-wait). האם במצב זה ייתכן שהשורה \"A: 3\" תודפס לפני השורה \"B: 4\"? נמקו.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: נוצרו 4 תהליכים סה\"כ. התהליך הראשי (P0) מתחיל עם x=1. באיטרציה i=0 הוא יוצר את P1. באיטרציה i=1 הוא יוצר את P2. תהליך P2, כיוון שהוא בבן של האיטרציה השנייה (i=1), יוצר את P3 (נכד של P0).\n\n10.2: שורות הפלט הן: \"B: 3\", \"C: 8\", \"B: 4\", \"A: 3\".\nהסבר הערכים:\n- P1 (נוצר ב-i=0): יורש x=1, מבצע x+=2 ומדפיס \"B: 3\".\n- P0 (אחרי i=0): מבצע x+=1, כעת x=2.\n- P2 (נוצר ב-i=1): יורש x=2, מבצע x+=2, כעת x=4. כיוון ש-i=1, יוצר את P3.\n- P3 (נוצר בתוך P2): יורש x=4, מבצע x*=2, מדפיס \"C: 8\".\n- P2 מחכה ל-P3 (שורה 19) ואז מדפיס \"B: 4\".\n- P0 (אחרי i=1): מבצע x+=1, כעת x=3. מחכה לכל בניו (שורה 27) ומדפיס \"A: 3\".\nאילוצי סדר: \"C: 8\" חייב להופיע לפני \"B: 4\" בגלל ה-wait בשורה 19. \"A: 3\" חייב להופיע אחרון בגלל ה-wait בשורה 27. \"B: 3\" יכול להופיע בכל מקום לפני \"A: 3\".\n\n10.3: כן. אם נסיר את שורה 27, התהליך הראשי (P0) לא יחכה לסיום בניו (P1, P2). לאחר סיום הלולאה הוא יגיע מיד לשורה 28. ייתכן מצב שבו P0 יסיים את הריצה וידפיס \"A: 3\" בזמן ש-P2 עדיין ממתין ל-P3 או טרם הגיע לשורת ההדפסה שלו (מרוץ תהליכים)."}, "difficulty_estimation": "Hard", "_source_file": "0065__Processes__CodeAnalysis__Hard.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:28:19"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "Fork", "System Calls", "Concurrency"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הריצו את התוכנית, והתהליך שנוצר קיבל את מזהה התהליך (PID) שמספרו 100. \nיש להניח שכל קריאות המערכת שיכולות להצליח הצליחו, לא נוצרים תהליכים בקטעי קוד אחרים במערכת, וכל תהליך חדש מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.\nתזכורת: כל הדפסה לפלט הסטנדרטי מתבצעת מיד (ללא buffer).", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    pid_t root = getpid(); \n    if (fork() || fork()) {\n        if (!fork()) {\n            printf(\"A %d %d\\n\", getpid(), getppid());\n            exit(0);\n        }\n    } else {\n        if (fork() && fork()) {\n            printf(\"B %d %d\\n\", getpid(), getppid());\n        }\n    }\n\n    while(wait(NULL) > 0);\n\n    if (getpid() == root) {\n        printf(\"Root Done: %d\\n\", getpid());\n    }\n\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "כמה תהליכים נוצרו בתוכנית בסך הכל (כולל התהליך הראשי)? הציגו את עץ התהליכים שנוצר.", "code_snippet": null, "options": null}, {"id": "1.2", "text": "כתבו את כל שורות הפלט האפשריות של התוכנית (סדר השורות עשוי להשתנות, אך יש לציין את תוכן השורות במדויק).", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. ניתוח יצירת התהליכים:\n- תהליך 100 מבצע fork() ראשון (שורה 8). נוצר תהליך 101. עבור 100 הביטוי fork() הוא אמת (101), לכן בגלל אופרטור ה-|| הוא מדלג על ה-fork השני ונכנס לבלוק ה-if.\n- תהליך 101 קיבל 0 מה-fork הראשון, לכן הוא מבצע את ה-fork() השני בביטוי ה-||. נוצר תהליך 102. עבור 101 הביטוי השני הוא אמת (102), לכן הוא נכנס לבלוק ה-if. תהליך 102 קיבל 0 ב-fork השני, לכן הביטוי (0 || 0) הוא שקר והוא נכנס לבלוק ה-else.\n- בתוך ה-if (תהליכים 100 ו-101): שניהם מבצעים if(!fork()). תהליך 100 יוצר את 103. תהליך 103 מדפיס 'A 103 100' ויוצא. תהליך 101 יוצר את 104. תהליך 104 מדפיס 'A 104 101' ויוצא.\n- בתוך ה-else (תהליך 102): מבצע fork() && fork(). תהליך 102 יוצר את 105. תהליך 105 מקבל 0 ומפסיק את ה-AND. תהליך 102 מקבל 105 וממשיך ל-fork() השני, בו הוא יוצר את 106. תהליך 102 מקבל 106 (אמת) ומדפיס 'B 102 101'. תהליך 106 מקבל 0 ולא מדפיס.\n- סה\"כ נוצרו 7 תהליכים (100, 101, 102, 103, 104, 105, 106).\n\n2. פלט התוכנית:\nהשורות הבאות יודפסו (הסדר בין השלוש הראשונות עשוי להשתנות, האחרונה תמיד בסוף):\nA 103 100\nA 104 101\nB 102 101\nRoot Done: 100"}, "difficulty_estimation": "Hard", "_source_file": "0066__Processes__CodeAnalysis__Hard.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:28:46"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Memory Management", "Concurrency"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו שכל קריאות המערכת מצליחות, שתהליכים אינם נוצרים מחוץ לקוד המוצג, ושתזמון התהליכים (Scheduling) אינו ידוע מראש. הנחה נוספת: הפונקציה fflush(stdout) מבטיחה שהפלט נשלח למסך באופן מיידי.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    int x = 10;\n    for (int i = 0; i < 2; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            x += 5;\n            if (i == 0) {\n                if (fork() == 0) {\n                    x += 10;\n                }\n                x *= 2;\n            }\n            printf(\"%d:%d \", i, x);\n            fflush(stdout);\n            exit(0);\n        } else {\n            x -= 2;\n            waitpid(pid, NULL, 0);\n        }\n    }\n    printf(\"Done:%d\\n\", x);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה תהליכים נוצרו במהלך ריצת התוכנית (כולל התהליך המקורי)? ציירו את עץ התהליכים.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "האם ייתכן שהפלט \"0:50\" יופיע לאחר הפלט \"1:13\"? נמקו את תשובתכם על סמך מנגנון ה-wait בתוכנית.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "מהו הפלט המלא (או הפלטים האפשריים) של התוכנית? יש לפרט את החישוב עבור כל תהליך.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. נוצרו 4 תהליכים בסך הכל: התהליך הראשי (P1), הבן שלו מהאיטרציה הראשונה (P2), הנכד (P3 - הבן של P2), והבן של הראשי מהאיטרציה השנייה (P4).\n\n2. כן, ייתכן שהפלט '0:50' יופיע אחרי '1:13'. הסיבה היא שהתהליך הראשי (P1) מבצע waitpid(pid) רק עבור הבנים הישירים שלו (P2 ו-P4). P1 מחכה ש-P2 יסתיים לפני שהוא ממשיך לאיטרציה הבאה (i=1), אבל P2 עצמו לא מחכה לבן שלו (P3). לכן, ברגע ש-P2 מסיים ומדפיס, P1 יכול להמשיך, ליצור את P4 ולהדפיס '1:13', בזמן ש-P3 עדיין רץ או ממתין לתורו להדפיס.\n\n3. פירוט החישובים:\n- P1 (הראשי): מתחיל עם x=10. ב-i=0 מבצע x-=2 (x=8) ומחכה ל-P2. ב-i=1 מבצע x-=2 (x=6) ומחכה ל-P4. בסוף מדפיס 'Done:6'.\n- P2 (בן של P1, i=0): יורש x=10. מבצע x+=5 (x=15). יוצר את P3. מבצע x*=2 (x=30). מדפיס '0:30' ויוצא.\n- P3 (בן של P2): יורש x=15. מבצע x+=10 (x=25). מבצע x*=2 (x=50). מדפיס '0:50' ויוצא.\n- P4 (בן של P1, i=1): יורש x=8. מבצע x+=5 (x=13). מדפיס '1:13' ויוצא.\n\nסדר ההדפסות: '0:30' חייב להופיע לפני '1:13' (כי P1 מחכה ל-P2). '0:50' יכול להופיע בכל מקום לפני 'Done:6'. 'Done:6' תמיד אחרון.\nפלטים אפשריים לדוגמה: \n- 0:30 0:50 1:13 Done:6\n- 0:50 0:30 1:13 Done:6\n- 0:30 1:13 0:50 Done:6"}, "difficulty_estimation": "Hard", "_source_file": "0067__Processes__CodeAnalysis__Hard.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:29:22"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Fork", "Exec", "Concurrency"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו שכל קריאות המערכת מצליחות, שקריאת ה-exec מוצאת את הפקודה echo, ושכל הדפסה מתבצעת באופן מיידי ללא חוצץ (buffer). כמו כן, הניחו כי המערכת אינה יוצרת תהליכים נוספים פרט לאלו המצוינים בקוד.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    printf(\"A\");\n    fflush(stdout);\n    if (fork() && fork()) {\n        fork();\n    } else {\n        if (fork() == 0) {\n            execlp(\"echo\", \"echo\", \"B\", NULL);\n            printf(\"D\");\n            fflush(stdout);\n        }\n    }\n    printf(\"C\");\n    fflush(stdout);\n    while(wait(NULL) > 0);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה תהליכים נוצרו סה\"כ במהלך ריצת התוכנית (כולל התהליך הראשי)? הסבירו בעזרת פירוט שלבי הריצה או עץ תהליכים.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "האם הפלט \"ACCCBCB\" הוא פלט אפשרי עבור ריצה של תוכנית זו? נמקו.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "האם התו 'D' יודפס אי פעם? הסבירו מדוע.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. ניתוח תהליכים: \n- P0 (הראשי) מדפיס A.\n- P0 מבצע fork() ראשון ויוצר את P1. עבור P0 התוצאה אמת, לכן הוא ממשיך ל-fork() השני ויוצר את P2. התנאי (fork && fork) אמת עבור P0 ולכן הוא נכנס לבלוק ה-if ומבצע fork() שלישי ליצירת P3. גם P0 וגם P3 מדפיסים C.\n- P1 (נוצר ב-fork הראשון): עבורו ה-fork הראשון מחזיר 0. בשל אופרטור ה-&& מתבצע short-circuit ו-P1 עובר לבלוק ה-else. שם הוא מבצע fork() ויוצר את P4. P4 מבצע exec ומדפיס B. P1 ממשיך ומדפיס C.\n- P2 (נוצר ב-fork השני): עבורו ה-fork השני מחזיר 0. התנאי (אמת && 0) הוא שקר, לכן P2 עובר לבלוק ה-else. שם הוא מבצע fork() ויוצר את P5. P5 מבצע exec ומדפיס B. P2 ממשיך ומדפיס C.\nסה\"כ תהליכים: P0, P1, P2, P3, P4, P5 - סה\"כ 6 תהליכים.\n\n2. ניתוח פלט: \n- 'A' מודפס פעם אחת (P0).\n- 'C' מודפס 4 פעמים על ידי התהליכים P0, P3, P1, P2.\n- 'B' מודפס פעמיים על ידי התהליכים P4, P5 (באמצעות echo).\nהפלט \"ACCCBCB\" מכיל פעם אחת A, ארבע פעמים C ופעמיים B. כיוון שאין סדר מחייב בין התהליכים השונים (פרט לכך ש-A מודפס ראשון), פלט זה אפשרי.\n\n3. הדפסת 'D':\n- התו 'D' לא יודפס לעולם. התהליכים P4 ו-P5, שהם היחידים שמגיעים לשורה זו, מבצעים קריאת execlp לפני ההדפסה. קריאת exec מחליפה את מרחב הכתובות והקוד של התהליך בקוד של התוכנית echo, ולכן הפקודה printf(\"D\") שמופיעה אחרי ה-exec לא תתבצע לעולם (אלא אם ה-exec נכשל, אך הנחנו שהצליח)."}, "difficulty_estimation": "Hard", "_source_file": "0068__Processes__CodeAnalysis__Hard.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:30:04"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "fork", "exec", "Wait"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו כי המזהה (PID) של התהליך המריץ את הפונקציה main הוא 100. כל קריאת מערכת שמצליחה מחזירה ערך תקין (לפי התיעוד), ותהליכים חדשים מקבלים מזהה הגדול ב-1 מהמזהה האחרון שהוקצה במערכת. הניחו כי לא נוצרים תהליכים אחרים במערכת בזמן הריצה, וכי הפונקציה printf מדפיסה ישירות למסך ללא שימוש ב-buffer (כאילו בוצע fflush).", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    pid_t pid;\n    printf(\"P%d\\n\", getpid());\n    if (fork() == 0) {\n        if (fork() || fork()) {\n            printf(\"T%d\\n\", getpid());\n        }\n        exit(0);\n    }\n    pid = fork();\n    if (pid == 0) {\n        execlp(\"ls\", \"ls\", NULL);\n        printf(\"E%d\\n\", getpid());\n        exit(1);\n    }\n    waitpid(pid, NULL, 0);\n    printf(\"D%d\\n\", getpid());\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה תהליכים נוצרו בסך הכל במהלך ריצת התוכנית (כולל התהליך הראשי)? פרטו את ה-PID של כל אחד מהם ואת הקשר ביניהם (מי האבא של מי).", "code_snippet": null, "options": null}, {"id": "10.2", "text": "האם ייתכן מצב בו המחרוזת 'D100' תודפס לפני המחרוזת 'T101'? נמקו את תשובתכם.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "נניח כי הקריאה ל-execlp נכשלה (למשל, הקובץ ls לא נמצא). מה יהיו כל ההדפסות של התוכנית במקרה זה? (אין צורך לציין את סדר ההדפסות, אלא רק אילו מחרוזות יופיעו).", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. נוצרו 5 תהליכים בסך הכל:\n- תהליך 100: התהליך הראשי.\n- תהליך 101: נוצר על ידי 100 בשורה 9.\n- תהליך 102: נוצר על ידי 101 בשורה 10 (ב-fork הראשון).\n- תהליך 103: נוצר על ידי 102 בשורה 10 (ב-fork השני, מכיוון שה-fork הראשון החזיר 0 ל-102).\n- תהליך 104: נוצר על ידי 100 בשורה 15.\n\n2. כן, ייתכן. תהליך 100 מבצע waitpid עבור תהליך 104 בלבד. הוא אינו ממתין לסיום של תהליך 101 או צאצאיו (102, 103). לכן, אם תהליך 104 יסיים את פעולתו (ה-ls יסתיים) ותהליך 100 ימשיך להדפסה בשורה 22 לפני שתהליך 101 יספיק להגיע להדפסה בשורה 11, 'D100' יודפס לפני 'T101'.\n\n3. אם execlp נכשל, התהליך (104) לא מוחלף וממשיך לשורה הבאה בקוד. ההדפסות שיופיעו הן:\n- P100 (מהתהליך הראשי בתחילת הריצה).\n- T101 (מתהליך 101, שעובר את תנאי ה-OR בגלל short-circuit).\n- T102 (מתהליך 102, שמבצע את ה-fork השני בתנאי ה-OR).\n- E104 (מתהליך 104, המדפיס הודעת שגיאה לאחר כישלון ה-exec).\n- D100 (מתהליך 100, לאחר שסיים להמתין ל-104)."}, "difficulty_estimation": "Hard", "_source_file": "0069__Processes__CodeAnalysis__Hard.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:30:46"}, {"id": 101, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Fork Logic", "Process Tree"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו כי כל קריאות המערכת מצליחות, וכי מזהה התהליך (PID) של התהליך המריץ את main הוא 1000. כל תהליך חדש שנוצר במערכת מקבל PID הגדול ב-1 מה-PID האחרון שניתן. הניחו כי אין תהליכים אחרים שנוצרים במערכת בזמן הריצה. ענו על הסעיפים הבאים.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    int x = 5;\n    pid_t p1, p2;\n\n    p1 = fork();\n    if (p1 > 0) {\n        // Parent block\n        x += 2;\n        if (fork() == 0) {\n            x *= 2;\n            printf(\"Node A: x=%d, PID=%d, PPID=%d\\n\", x, getpid(), getppid());\n            exit(0);\n        }\n        wait(NULL);\n    } else if (p1 == 0) {\n        // Child block\n        x -= 2;\n        p2 = fork();\n        if (p2 > 0) {\n            wait(NULL);\n            x += 10;\n        } else {\n            x += 5;\n            printf(\"Node B: x=%d, PID=%d, PPID=%d\\n\", x, getpid(), getppid());\n            exit(0);\n        }\n        printf(\"Node C: x=%d, PID=%d, PPID=%d\\n\", x, getpid(), getppid());\n        exit(0);\n    }\n\n    wait(NULL);\n    printf(\"Node D: x=%d, PID=%d\\n\", x, getpid());\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "101.1", "text": "ציירו את עץ התהליכים שנוצר במהלך ריצת התוכנית. עבור כל תהליך בעץ ציינו את ה-PID שלו ואת ה-PPID שלו.", "code_snippet": null, "options": null}, {"id": "101.2", "text": "מהו הפלט המלא של התוכנית? במידה וישנם מספר פלטים אפשריים בשל חוסר דטרמיניזם בתזמון, ציינו את כולם או הסבירו את סדר ההדפסה.", "code_snippet": null, "options": null}, {"id": "101.3", "text": "כמה פעמים תודפס המילה \"Node\" בסך הכל?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "ניתוח זרימת התוכנית:\n1. תהליך 1000 (P1000) מבצע fork ראשון. נוצר תהליך 1001.\n2. P1000 (הורה): x הופך ל-7. הוא מבצע fork נוסף ויוצר את 1002. \n   - תהליך 1002 (בן של 1000): x הופך ל-14 (7*2). מדפיס 'Node A: x=14, PID=1002, PPID=1000' ויוצא.\n   - P1000 מחכה ל-1002, ואז מחכה ל-1001 (בסוף), ומדפיס 'Node D: x=7, PID=1000'.\n3. תהליך 1001 (בן של 1000): x הופך ל-3. הוא מבצע fork ויוצר את 1003.\n   - תהליך 1003 (בן של 1001): x הופך ל-8 (3+5). מדפיס 'Node B: x=8, PID=1003, PPID=1001' ויוצא.\n   - תהליך 1001 מחכה ל-1003, מעדכן את x ל-13 (3+10), מדפיס 'Node C: x=13, PID=1001, PPID=1000' ויוצא.\n\nסדר הדפסה אפשרי:\nהסדר בין Node A לבין Node B/C תלוי במתזמן, אך Node D תמיד יהיה אחרון עבור P1000. Node C חייב לבוא אחרי Node B. Node A חייב לבוא לפני Node D.\nפלט לדוגמה:\nNode B: x=8, PID=1003, PPID=1001\nNode C: x=13, PID=1001, PPID=1000\nNode A: x=14, PID=1002, PPID=1000\nNode D: x=7, PID=1000\n\nסה\"כ הדפסות של Node: 4 פעמים."}, "difficulty_estimation": "Hard", "_source_file": "0070__Processes__CodeAnalysis__Hard.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:31:06"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Buffering", "Fork"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו שכל קריאות המערכת מצליחות, ושכל תהליך שנוצר מסיים את ריצתו כראוי.\nתזכורת: פונקציית printf משתמשת בחוצץ (buffer) עבור הפלט הסטנדרטי. במידה ואין תו ירידת שורה (\\n), החוצץ מועבר בשלמותו לתהליכי בנים בעת ביצוע fork ומתרוקן רק בסיום התהליך או בעת קריאה ל-fflush.", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    printf(\"Start\");\n    if (fork() || fork()) {\n        if (!fork()) {\n            printf(\"1\");\n            exit(0);\n        }\n    } else {\n        printf(\"2\");\n    }\n    while(wait(NULL) > 0);\n    printf(\"End\");\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "כמה תהליכים סה\"כ נוצרו במהלך ריצת התוכנית (כולל התהליך הראשי)?", "code_snippet": null, "options": null}, {"id": "1.2", "text": "רשמו פלט אפשרי אחד של התוכנית והסבירו כיצד מנגנון ה-buffering משפיע על הופעת המילה \"Start\" בפלט.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "כיצד ישתנה מספר הפעמים שהמילה \"Start\" מופיעה בפלט אם נוסיף n\\ לאחר המילה \"Start\" בשורה 7?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: נוצרו 5 תהליכים סה\"כ. תהליך האב P0 יוצר את P1 ב-fork הראשון. P0 נכנס ל-if (בגלל short-circuit). P1 ממשיך ל-fork השני ויוצר את P2. P1 נכנס ל-if ו-P2 נכנס ל-else. בתוך ה-if, תהליך P0 יוצר את P3 ותהליך P1 יוצר את P4.\n\n1.2: פלט אפשרי: Start1Start1Start2EndStartEndStartEnd (הסדר בין התהליכים יכול להשתנות). הסבר: המילה Start נכנסת ל-buffer של P0. כיוון שאין n\\, היא לא מודפסת מיד. כל תהליך שנוצר ב-fork יורש את תוכן ה-buffer. לכן, כל אחד מ-5 התהליכים מחזיק ב-Start ב-buffer שלו ומדפיס אותו בסיום או בתוספת לפלט אחר. P3 ו-P4 מדפיסים Start1, תהליך P2 מדפיס Start2End, ותהליכים P0 ו-P1 מדפיסים StartEnd.\n\n1.3: אם נוסיף n\\, ה-buffer יתרוקן מיד בשורה 7. לכן המילה Start תודפס פעם אחת בלבד על ידי P0 לפני ה-fork הראשון, והבנים יירשו buffer ריק. המילה Start תופיע פעם אחת בלבד בכל הפלט."}, "difficulty_estimation": "Hard", "_source_file": "0071__Processes__CodeAnalysis__Hard.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:31:33"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "fork", "Short-circuit Evaluation"], "content": {"text": "נתונה התוכנית הבאה בשפת C. הניחו שכל קריאות המערכת מצליחות, אין תהליכים נוספים במערכת שמשפיעים על הריצה, וכל הדפסה מתבצעת באופן מיידי ללא חוצץ (buffer).", "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 0;\n    if (fork() || fork()) {\n        x++;\n        if (!fork()) {\n            x += 2;\n        }\n    } else {\n        x--;\n    }\n    while(wait(NULL) > 0);\n    printf(\"%d \", x);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "כמה תהליכים נוצרו בסך הכל במהלך ריצת התוכנית (כולל התהליך הראשי)? הציגו את עץ התהליכים.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "מהם כל הערכים האפשריים שיוצגו כפלט של התוכנית? הסבירו אילו תהליכים מדפיסים אילו ערכים.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "נניח ונחליף את האופרטור || בשורה 6 באופרטור &&. כמה תהליכים ייווצרו כעת במערכת (כולל התהליך הראשי)?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. סך הכל נוצרו 5 תהליכים:\n- תהליך אב (P1) מבצע fork ראשון. הוא מקבל ערך חיובי ולכן בגלל short-circuit של || הוא לא מבצע את ה-fork השני ונכנס לבלוק ה-if.\n- הבן הראשון (P2) מקבל 0 מה-fork הראשון, ולכן חייב לבצע את ה-fork השני. הוא יוצר את P3.\n- P2 מקבל ערך חיובי מה-fork השני ונכנס לבלוק ה-if.\n- P3 מקבל 0 מה-fork השני ונכנס לבלוק ה-else.\n- בתוך בלוק ה-if, תהליכים P1 ו-P2 מבצעים fork נוסף (P4 ו-P5 בהתאמה). סך הכל 5 תהליכים.\n\n2. הערכים המודפסים הם 1, 1, 3, 3, 1-:\n- P1 ו-P2: מקדמים את x ל-1. ב-fork הפנימי האבא (P1/P2) מקבל PID ולכן ה-if הפנימי לא מתקיים עבורו. הם מדפיסים 1.\n- P4 ו-P5 (הבנים של ה-fork הפנימי): יורשים x=1, נכנסים ל-if הפנימי ומבצעים x += 2. הם מדפיסים 3.\n- P3: נכנס ל-else ומבצע x--. הוא מדפיס 1-.\n\n3. אם נחליף ל-&&, ייווצרו 4 תהליכים:\n- P1 מבצע fork ראשון (P2). P1 ממשיך ל-fork שני (P3). P2 נכשל בתנאי (קיבל 0) ועובר ל-else.\n- P1 מצליח בשני ה-forks ונכנס ל-if. P3 נכשל בתנאי (קיבל 0 ב-fork השני) ועובר ל-else.\n- בתוך ה-if, רק P1 מבצע fork נוסף (P4).\n- סך הכל: P1, P2, P3, P4."}, "difficulty_estimation": "Hard", "_source_file": "0072__Processes__CodeAnalysis__Hard.json", "_topic_hint": "Processes", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:31:51"}, {"id": 5, "type": "MultipleChoice", "topic": ["Threads", "Memory Management"], "content": {"text": "איזה מהמשאבים הבאים משותף (shared) לכל החוטים (threads) השייכים לאותו תהליך?", "code_snippet": null, "options": ["א. המחסנית (Stack)", "ב. משתנים גלובליים ומרחב הכתובות (Global Variables / Address Space)", "ג. אוגרי המעבד (CPU Registers)", "ד. מונה התוכנית (Program Counter)"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "חוטים בתוך אותו תהליך חולקים את אותו מרחב כתובות, הכולל את קטע הנתונים (משתנים גלובליים) והערימה (Heap). לעומת זאת, לכל חוט יש מחסנית (Stack), אוגרים ומונה תוכנית (PC) משלו, המהווים את ההקשר (Context) הייחודי שלו."}, "difficulty_estimation": "Easy", "_source_file": "0073__Threads__MultipleChoice__Easy.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:31:58"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Memory Management"], "content": {"text": "איזה מבין המשאבים הבאים משותף לכל החוטים (threads) השייכים לאותו תהליך?", "code_snippet": null, "options": ["א. מחסנית (Stack)", "ב. מונה התוכנית (Program Counter)", "ג. משתנים גלובליים ומרחב הכתובות", "ד. קובץ האוגרים (Register set)"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "חוטים באותו תהליך חולקים את מרחב הכתובות של התהליך, הכולל את קטע הקוד (Code segment) ואת קטע הנתונים (Data segment) שבו נמצאים המשתנים הגלובליים. לעומת זאת, לכל חוט יש הקשר הרצה (execution context) ייחודי הכולל מחסנית משלו, מונה תוכנית משלו וסט אוגרים משלו."}, "difficulty_estimation": "Easy", "_source_file": "0074__Threads__MultipleChoice__Easy.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:32:09"}, {"id": 5, "type": "MultipleChoice", "topic": ["Threads", "Memory Management"], "content": {"text": "איזה מהמשאבים הבאים משותף (Shared) לכל החוטים (threads) השייכים לאותו תהליך?", "code_snippet": null, "options": ["א. המחסנית (Stack)", "ב. אוגרי המעבד (Registers)", "ג. מונה הפקודות (Program Counter)", "ד. מרחב הכתובות הגלובלי והערימה (Heap)", "ה. אף אחת מהתשובות אינה נכונה"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "חוטים (threads) בתוך אותו תהליך חולקים את מרחב הכתובות של התהליך, הכולל את קטע הקוד, המשתנים הגלובליים והערימה (Heap). לעומת זאת, לכל חוט יש משאבים פרטיים משלו ההכרחיים לניהול זרימת הריצה העצמאית שלו: מחסנית (Stack) עבור משתנים לוקאליים וקריאות לפונקציות, אוגרים (Registers) ומונה פקודות (PC)."}, "difficulty_estimation": "Easy", "_source_file": "0075__Threads__MultipleChoice__Easy.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:32:18"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Memory Management"], "content": {"text": "איזה מהמשאבים הבאים משותף (Shared) בדרך כלל בין חוטים (threads) שונים השייכים לאותו תהליך?", "code_snippet": null, "options": ["א. מחסנית (Stack)", "ב. אוגרי המעבד (Registers)", "ג. מרחב הכתובות (Address Space) ומשתנים גלובליים", "ד. מונה הפקודות (Program Counter)", "ה. אף אחת מהתשובות אינה נכונה"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "חוטים השייכים לאותו תהליך חולקים את מרחב הכתובות של התהליך, הכולל את קטע הקוד (Code), המשתנים הגלובליים (Data) והערימה (Heap). לעומת זאת, לכל חוט יש הקשר ריצה (Execution Context) נפרד הכולל מחסנית משלו, אוגרים משלו ומונה פקודות (PC) משלו כדי לאפשר הרצה עצמאית."}, "difficulty_estimation": "Easy", "_source_file": "0076__Threads__MultipleChoice__Easy.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:32:26"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Memory Management"], "content": {"text": "מה מהבאים משותף לכל החוטים (threads) השייכים לאותו תהליך?", "code_snippet": null, "options": ["א. המחסנית (Stack)", "ב. אוגרי המעבד (Registers)", "ג. מונה הפקודות (Program Counter)", "ד. מרחב הכתובות ומשתנים גלובליים", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "חוטים באותו תהליך חולקים את מרחב הכתובות, קוד, נתונים (משתנים גלובליים) ומשאבי מערכת כמו קבצים פתוחים. לעומת זאת, לכל חוט יש הקשר ריצה פרטי הכולל מחסנית, אוגרים ומונה פקודות (PC) משלו."}, "difficulty_estimation": "Easy", "_source_file": "0077__Threads__MultipleChoice__Easy.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:32:34"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Memory Management"], "content": {"text": "בהינתן קוד C המשתמש בספריית pthreads, איזה מהמשתנים הבאים משותף (shared) ונגיש גם לחוט החישוב הראשי (main thread) וגם לחוט החדש שנוצר?", "code_snippet": "int x = 10;\n\nvoid* my_func(void* arg) {\n    int y = 20;\n    x++;\n    return NULL;\n}\n\nint main() {\n    pthread_t tid;\n    pthread_create(&tid, NULL, my_func, NULL);\n    // ... code ...\n    return 0;\n}", "options": ["א. המשתנה x בלבד", "ב. המשתנה y בלבד", "ג. גם x וגם y", "ד. אף אחד מהמשתנים אינו משותף"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "המשתנה x הוא משתנה גלובלי, ולכן הוא נמצא במקטע הנתונים (Data Segment) המשותף לכל החוטים (threads) באותו תהליך. לעומת זאת, המשתנה y הוא משתנה מקומי המוגדר בתוך פונקציית החוט, ולכן הוא מוקצה על המחסנית (Stack) הפרטית של החוט ואינו משותף לחוטים אחרים."}, "difficulty_estimation": "Easy", "_source_file": "0078__Threads__MultipleChoice__Easy.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:32:47"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Memory Management"], "content": {"text": "כאשר מספר חוטים (threads) רצים בתוך אותו תהליך (process), מה מהבאים משותף לכל החוטים?", "code_snippet": null, "options": ["א. המחסנית (Stack) הפרטית של כל חוט.", "ב. ערימת הזיכרון (Heap) והמשתנים הגלובליים.", "ג. אוגרי המעבד (Registers).", "ד. מונה התוכנית (Program Counter)."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "בתוך תהליך, כל החוטים חולקים את אותו מרחב כתובות, הכולל את ה-Heap והמשתנים הגלובליים. לעומת זאת, לכל חוט יש Stack, Registers ו-Program Counter משלו כדי לאפשר הרצה עצמאית של קוד."}, "difficulty_estimation": "Easy", "_source_file": "0079__Threads__MultipleChoice__Easy.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:32:53"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Memory Management"], "content": {"text": "איזה מהמשאבים הבאים **אינו** משותף בין חוטי חישוב (threads) השייכים לאותו תהליך?", "code_snippet": null, "options": ["א. משתנים גלובליים (Global variables)", "ב. זיכרון הערימה (Heap memory)", "ג. קוד התוכנית (Code segment)", "ד. המחסנית (Stack)", "ה. כל התשובות האחרות משותפות בין חוטי החישוב"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "לכל חוט חישוב (thread) יש מחסנית (Stack) פרטית משלו וסט רגיסטרים משלו (כולל Program Counter), זאת על מנת לאפשר לכל חוט לנהל את זרימת הפונקציות והמשתנים המקומיים שלו באופן עצמאי. לעומת זאת, חוטי חישוב באותו תהליך חולקים את מרחב הכתובות הכולל את קטע הקוד, הנתונים הגלובליים והערימה."}, "difficulty_estimation": "Easy", "_source_file": "0080__Threads__MultipleChoice__Easy.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:33:00"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Race Conditions"], "content": {"text": "נתונה התוכנית הבאה בשפת C המשתמשת בספריית pthreads. התוכנית יוצרת 10 חוטים (threads), כאשר כל חוט מבצע לולאה המקדמת משתנה גלובלי משותף counter ב-1, כמיליון פעמים. בסיום ריצת כל החוטים, התוכנית מדפיסה את ערכו של counter. מה ניתן לומר על פלט התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\n\nvoid* thread_func(void* arg) {\n    for (int i = 0; i < 1000000; i++) {\n        counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[10];\n    for (int i = 0; i < 10; i++) {\n        pthread_create(&threads[i], NULL, thread_func, NULL);\n    }\n    for (int i = 0; i < 10; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    printf(\"%d\\n\", counter);\n    return 0;\n}", "options": ["א. התוכנית תמיד תדפיס 10,000,000.", "ב. התוכנית תדפיס ערך קטן מ-10,000,000 או שווה לו, בשל היעדר סנכרון (Race Condition).", "ג. התוכנית תגרום לשגיאת הרצה (Segmentation Fault) כיוון שחוטים שונים ניגשים לאותו זיכרון בו-זמנית.", "ד. התוכנית תמיד תדפיס 1,000,000 כי המשתנה counter הוא מקומי לכל חוט (Thread Local Storage).", "ה. התוכנית לא תתקמפל כי לא ניתן להשתמש במשתנה גלובלי משותף בתוך פונקציית חוט ללא מילת המפתח volatile."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "הפעולה ++counter ברמת שפת C אינה פעולה אטומית (Atomic Operation). ברמת האסמבלי, היא מורכבת בדרך כלל משלוש פקודות: קריאת הערך מהזיכרון לרגיסטר, הוספת 1 לרגיסטר, וכתיבת הערך חזרה לזיכרון. ללא שימוש במנגנוני סנכרון כמו Mutex, ייתכן מצב שבו שני חוטים קוראים את אותו הערך לפני שאחד מהם הספיק לעדכן אותו (Context Switch ביניהם), מה שמוביל לאובדן עדכונים ולערך סופי נמוך מהצפוי (Race Condition). תיאורטית הערך יכול להיות 10,000,000 אם לא התרחש שום מירוץ, אך במערכת מרובת ליבות זה כמעט בלתי אפשרי."}, "difficulty_estimation": "Medium", "_source_file": "0081__Threads__MultipleChoice__Medium.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:33:15"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Memory Layout"], "content": {"text": "נתון הקוד הבא בשפת C, המריץ שני חוטים (threads) המבצעים את אותה הפונקציה. בהנחה שהמערכת מריצה את החוטים במקביל על מעבד מרובה ליבות וללא סנכרון חיצוני, איזו מהטענות הבאות היא הנכונה ביותר לגבי תוצאת ההרצה?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint shared_var = 0;\n\nvoid* increment_task(void* arg) {\n    static int func_static = 0;\n    for (int i = 0; i < 100; i++) {\n        shared_var++;\n        func_static++;\n    }\n    return (void*)(long)func_static;\n}\n\nint main() {\n    pthread_t t1, t2;\n    void *res1, *res2;\n    pthread_create(&t1, NULL, increment_task, NULL);\n    pthread_create(&t2, NULL, increment_task, NULL);\n    pthread_join(t1, &res1);\n    pthread_join(t2, &res2);\n    printf(\"%d, %ld, %ld\\n\", shared_var, (long)res1, (long)res2);\n    return 0;\n}", "options": ["א. הערך של shared_var יהיה בדיוק 200, וערכי ההחזר res1 ו-res2 יהיו 100 ו-200 (בסדר כלשהו).", "ב. הערך של shared_var עשוי להיות קטן מ-200 עקב Race Condition, אך המשתנה func_static הוא מקומי לכל חוט ולכן ערכי ההחזר יהיו תמיד 100.", "ג. המשתנה func_static משותף לשני החוטים, ולכן גם shared_var וגם ערכי ההחזר res1 ו-res2 עשויים להיות מושפעים מ-Race Condition.", "ד. הקוד יגרום לשגיאת הרצה (Runtime Error) כיוון ששני חוטים מנסים לגשת למשתנה static בו-זמנית.", "ה. המשתנה func_static מאותחל מחדש ל-0 בכל פעם שחוט חדש מתחיל את הפונקציה, לכן התוצאה הסופית של shared_var תהיה 200."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "במשתני static המוגדרים בתוך פונקציה, בדומה למשתנים גלובליים, קיים רק עותק אחד בזיכרון המשותף לכל החוטים באותו תהליך (הם מאוחסנים ב-Data Segment). מכיוון ששני החוטים מקדמים את shared_var ואת func_static ללא מנגנון סנכרון (כמו Mutex), שניהם חשופים לבעיית מרוץ (Race Condition). לכן, לא ניתן להבטיח ש-shared_var יגיע ל-200, וערכי ההחזר (שמייצגים את מצב func_static ברגע סיום החוט) אינם מובטחים להיות 100 או 200."}, "difficulty_estimation": "Medium", "_source_file": "0082__Threads__MultipleChoice__Medium.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:33:32"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Race Conditions"], "content": {"text": "בקטע הקוד הבא ב-C, מתכנת מנסה ליצור 5 חוטים (threads) שכל אחד מהם ידפיס את המספר הסידורי שבו הוא נוצר (0 עד 4). מה ניתן לומר על פלט התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_func(void* arg) {\n    int id = *(int*)arg;\n    printf(\"%d \", id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    for (int i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": ["א. התוכנית תמיד תדפיס את המספרים 0, 1, 2, 3, 4 לפי הסדר.", "ב. התוכנית תדפיס את המספרים 0, 1, 2, 3, 4 בסדר כלשהו (פרמוטציה), וכל מספר יופיע בדיוק פעם אחת.", "ג. ייתכן שחלק מהערכים יודפסו מספר פעמים וערכים אחרים לא יודפסו כלל, שכן כל החוטים ניגשים לאותה כתובת זיכרון של המשתנה i.", "ד. התוכנית תמיד תדפיס '5 5 5 5 5' כיוון שהלולאה ב-main מסתיימת תמיד לפני שהחוטים מתחילים לרוץ.", "ה. תתרחש שגיאת הידור (Compilation Error) כי לא ניתן להעביר מצביע למשתנה מקומי i לפונקציית החוט."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "הבעיה בקוד היא העברת הכתובת של המשתנה הלוקאלי i (באמצעות i&) לכל החוטים. כל החוטים מקבלים מצביע לאותו מיקום בזיכרון. כיוון שה-main thread ממשיך לקדם את i בלולאה בזמן שהחוטים נוצרים ומתחילים את ריצתם, נוצר Race Condition: עד שחוט מסוים ניגש לזיכרון כדי לקרוא את הערך של id, הערך של i כבר עשוי להשתנות על ידי ה-main thread. לכן, ייתכן שחוטים שונים יקראו את אותו הערך (למשל, כולם יקראו 5 אם הלולאה הסתיימה מהר), וערכים מסוימים לא יודפסו כלל."}, "difficulty_estimation": "Medium", "_source_file": "0083__Threads__MultipleChoice__Medium.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:33:47"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Memory Management"], "content": {"text": "נתונה תוכנית C המשתמשת בספריית pthreads ליצירת 5 חוטים (threads). המטרה היא שכל חוט ידפיס את המספר הסידורי שלו (0 עד 4). מה מהבאים מתאר נכונה את התנהגות התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_func(void* arg) {\n    int val = *((int*)arg);\n    printf(\"%d \", val);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    for (int i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": ["א. התוכנית תמיד תדפיס את המספרים 0 עד 4 בסדר עולה (0 1 2 3 4).", "ב. התוכנית תמיד תדפיס את המספרים 0 עד 4, אך הסדר עשוי להשתנות בהתאם לתזמון.", "ג. התוכנית עלולה להדפיס מספרים שאינם בטווח 0-5 עקב גישה לזיכרון שאינו מאותחל.", "ד. התוכנית עלולה להדפיס את אותו מספר מספר פעמים (למשל 5 5 5 5 5), כיוון שכל החוטים ניגשים לאותה כתובת זיכרון שערכה משתנה בחוט הראשי.", "ה. התוכנית לא תתקמפל כי לא ניתן להעביר מצביע למשתנה מקומי (i) כארגומנט לחוט."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "הבעיה בתוכנית היא Race Condition על המשתנה i. הפונקציה pthread_create מקבלת מצביע לכתובת הזיכרון של i. כיוון שהחוט הראשי ממשיך לרוץ ולעדכן את i בלולאה, וכל החוטים שנוצרו ניגשים לאותה כתובת זיכרון, ייתכן שעד שחוט מסוים יתחיל לרוץ ויבצע את ה-dereference למצביע, הערך של i כבר השתנה ע\"י החוט הראשי (למשל ל-5 בסיום הלולאה). לכן, ייתכן שיוצגו ערכים כפולים או ערכים שאינם תואמים את הציפייה המקורית."}, "difficulty_estimation": "Medium", "_source_file": "0084__Threads__MultipleChoice__Medium.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:34:04"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Memory Management"], "content": {"text": "נתון קוד ה-C הבא המשתמש בספריית pthreads. מה מהבאים מתאר נכונה את הפלט הצפוי של התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_func(void* arg) {\n    int* id = (int*)arg;\n    printf(\"%d \", *id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    for (int i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": ["א. התוכנית תמיד תדפיס את המספרים 0 עד 4 בסדר עולה (0 1 2 3 4).", "ב. התוכנית תמיד תדפיס את המספרים 0 עד 4 בסדר כלשהו.", "ג. התוכנית תמיד תדפיס את המספר 5 חמש פעמים.", "ד. התוכנית עלולה להדפיס מספרים בטווח 0-5, כאשר ייתכן שמספר מסוים יודפס יותר מפעם אחת.", "ה. תתרחש שגיאת הידור (Compilation Error) כי לא ניתן להעביר כתובת של משתנה מקומי לפונקציית החוט."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "הבעיה בקוד היא שכל החוטים (threads) מקבלים מצביע לאותו מיקום בזיכרון - המשתנה המקומי i שנמצא על המחסנית של פונקציית main. כיוון שהחוטים רצים במקביל ללולאת היצירה, ייתכן שערכו של i ישתנה על ידי ה-main thread לפני שחוט מסוים יספיק לקרוא אותו ולהדפיסו. בסיום הלולאה הראשונה i מגיע לערך 5. לכן, הפלט תלוי בתזמון (Race Condition): ייתכן שחלק מהחוטים ידפיסו ערכים ישנים של i, חלק ידפיסו את הערך הנוכחי, וחלק ידפיסו 5 אם הם ירוצו רק לאחר שהלולאה הסתיימה."}, "difficulty_estimation": "Medium", "_source_file": "0085__Threads__MultipleChoice__Medium.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:34:22"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Pthreads", "Race Conditions"], "content": {"text": "לפניך קוד בשפת C המשתמש בספריית pthreads ליצירת 5 חוטים (threads). מה מהבאים מתאר נכונה את ההתנהגות הצפויה של התוכנית בעת הרצתה?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_func(void* arg) {\n    int val = *(int*)arg;\n    printf(\"%d \", val);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    for (int i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": ["א. התוכנית תדפיס תמיד את המספרים 0 1 2 3 4 בסדר זה בדיוק.", "ב. התוכנית תדפיס תמיד את המספרים 0 עד 4, אך בסדר שאינו ידוע מראש (פרמוטציה של המספרים).", "ג. ייתכן שחלק מהמספרים יודפסו יותר מפעם אחת, חלק לא יודפסו כלל, וייתכן אף שהמספר 5 יודפס.", "ד. התוכנית תגרום לשגיאת גישה לזיכרון (Segmentation Fault) כיוון שהמשתנה i הוא מקומי לפונקציית main.", "ה. התוכנית לא תעבור קומפילציה כיוון שלא ניתן להעביר את הכתובת של i כארגומנט מסוג void*."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "הבעיה בקוד היא מרוץ תהליכים (Race Condition) על המשתנה i. כל חמשת החוטים מקבלים את אותה הכתובת בזיכרון (הכתובת של המשתנה i ב-stack של main). מכיוון שחוט ה-main ממשיך לקדם את i בלולאה בזמן שהחוטים החדשים נוצרים ומתחילים לרוץ, ייתכן שחוט מסוים יקרא את הערך של i רק אחרי שהוא כבר קודם מספר פעמים על ידי ה-main. לכן, ייתכן ששני חוטים יקראו את אותו ערך, או שחוט יקרא את הערך 5 (תנאי העצירה של הלולאה) לפני שהתוכנית תסתיים. הפלט אינו דטרמיניסטי ותלוי בתזמון המעבד."}, "difficulty_estimation": "Medium", "_source_file": "0086__Threads__MultipleChoice__Medium.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:34:35"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Race Condition"], "content": {"text": "נתון הקוד הבא הכתוב בשפת C ומשתמש בספריית pthreads. מה מהבאים מתאר נכונה את התנהגות התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint global_sum = 0;\n\nvoid* thread_func(void* arg) {\n    int val = *(int*)arg;\n    for (int i = 0; i < 1000; i++) {\n        global_sum += val;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[2];\n    for (int i = 1; i <= 2; i++) {\n        pthread_create(&threads[i-1], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 2; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    printf(\"%d\\n\", global_sum);\n    return 0;\n}", "options": ["א. התוכנית תמיד תדפיס 3000, מכיוון שהלולאה הראשונה רצה עבור i=1 ו-i=2.", "ב. התוכנית תדפיס ערך שבין 1000 ל-3000, אך הערך יהיה תמיד כפולה של 1000.", "ג. הפלט עשוי להיות שונה מ-3000 גם בשל Race Condition על global_sum וגם בשל העברת מצביע למשתנה הלוקאלי i שערכו משתנה ב-main.", "ד. התוכנית תגרום לשגיאת סגמנטציה (Segmentation Fault) כיוון שחוטי המשנה מנסים לגשת לזיכרון של המחסנית של חוט ה-main.", "ה. התוכנית תדפיס תמיד 3000, שכן pthread_join מבצע סנכרון (Memory Barrier) שמבטיח את תקינות הערך של global_sum."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "התשובה הנכונה היא ג'. ישנן שתי בעיות סנכרון עיקריות בקוד: 1. Race Condition על המשתנה הגלובלי: הפעולה global_sum += val אינה אטומית. כאשר שני חוטים מנסים לעדכן את המשתנה בו-זמנית, עדכונים עלולים ללכת לאיבוד. 2. Argument Race: הכתובת של המשתנה i מועברת לחוטים. כיוון ש-i משתנה בלולאה ב-main בזמן שהחוטים נוצרים, ייתכן שחוט יקרא את הערך של i מהזיכרון רק לאחר ש-main כבר קידם אותו (למשל ל-2 או ל-3), ולכן val בתוך החוט לא יהיה בהכרח הערך המיועד (1 או 2)."}, "difficulty_estimation": "Medium", "_source_file": "0087__Threads__MultipleChoice__Medium.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:34:56"}, {"id": 1, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Race Conditions"], "content": {"text": "לפניכם קוד בשפת C המשתמש בספריית pthreads. מה ניתן לומר על הפלט של התוכנית בהנחה שהקומפילציה והרצת התהליכונים הצליחו?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* task(void* arg) {\n    int* val = (int*)arg;\n    for (int i = 0; i < 100; i++) {\n        (*val)++;\n    }\n    return NULL;\n}\n\nint main() {\n    int shared_val = 0;\n    pthread_t threads[10];\n    for (int i = 0; i < 10; i++) {\n        pthread_create(&threads[i], NULL, task, &shared_val);\n    }\n    for (int i = 0; i < 10; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    printf(\"%d\", shared_val);\n    return 0;\n}", "options": ["א. הפלט יהיה תמיד 1000.", "ב. הפלט עשוי להיות קטן מ-1000 עקב מרוץ תהליכונים (Race Condition).", "ג. התוכנית תגרום לשגיאת פילוח (Segmentation Fault) בשל גישה מקבילית של תהליכונים שונים לאותו משתנה מקומי.", "ד. הפלט יהיה תמיד 100, כיוון שכל תהליכון מבצע בדיוק 100 איטרציות ודורס את תוצאות קודמיו.", "ה. הקוד לא יעבור קומפילציה כיוון שהפונקציה pthread_create דורשת העברת משתנה גלובלי בלבד כארגומנט."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "הפעולה ++(*val) אינה אטומית. היא מורכבת משלושה שלבים ברמת המכונה: טעינת הערך מהזיכרון לרגיסטר, קידום הערך ברגיסטר, וכתיבת הערך המעודכן חזרה לזיכרון. כאשר מספר תהליכונים ניגשים לאותו משתנה ללא סנכרון (כמו Mutex), תהליכון אחד עלול לקרוא ערך 'ישן' בזמן שתהליכון אחר מעדכן אותו, ובכך לגרום לאובדן עדכונים (Race Condition). לכן, התוצאה הסופית עשויה להיות נמוכה מ-1000. שימוש בכתובת של משתנה מקומי מתוך main הוא תקין במקרה זה כי main ממתינה לסיום התהליכונים בעזרת pthread_join לפני שהיא מסיימת את ריצתה ומפנה את המחסנית."}, "difficulty_estimation": "Medium", "_source_file": "0088__Threads__MultipleChoice__Medium.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:35:19"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Race Conditions", "Pthreads", "Memory Management"], "content": {"text": "נתון קוד ה-C הבא המשתמש בספריית pthreads. מה ניתן לומר על פלט התוכנית בסיום ריצתה?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint global_val = 0;\n\nvoid* thread_func(void* arg) {\n    int thread_id = *(int*)arg;\n    global_val += thread_id;\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[3];\n    for (int i = 1; i <= 3; i++) {\n        pthread_create(&threads[i-1], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 3; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    printf(\"%d\\n\", global_val);\n    return 0;\n}", "options": ["א. הפלט יהיה תמיד 6 (הסכום של 1, 2 ו-3).", "ב. הפלט יהיה תמיד 12 (הערך 4 כפול 3 שרשורים).", "ג. הפלט אינו דטרמיניסטי; הוא עשוי להשתנות בין הרצות שונות עקב גישה לאותה כתובת זיכרון ותחרות על משתנה גלובלי.", "ד. התוכנית תגרום לשגיאת זמן ריצה (Runtime Error) כיוון שלא ניתן לגשת למשתנה מקומי של main מתוך שרשור.", "ה. הפלט יהיה תמיד 0 כיוון שהשינויים בשרשורים מתבצעים על עותק מקומי של global_val."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "התשובה הנכונה היא ג'. קיימות כאן שתי בעיות קריטיות: 1. ה-Main thread מעביר לכל השרשורים מצביע (&i) לאותו מיקום בזיכרון שבו נמצא משתנה הלולאה. כיוון שהלולאה ממשיכה לרוץ במקביל להיווצרות השרשורים, עד שהשרשור יבצע dereference למצביע, הערך של i עשוי להשתנות (למשל ל-4). 2. קיימת תחרות (Race Condition) על המשתנה הגלובלי global_val; פעולת ה-increment (+=) אינה אטומית ברמת ה-CPU, וללא שימוש ב-Mutex, עדכונים של שרשורים שונים עלולים 'לדרוס' זה את זה."}, "difficulty_estimation": "Hard", "_source_file": "0089__Threads__MultipleChoice__Hard.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:35:34"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Processes", "Synchronization", "fork"], "content": {"text": "נתון תהליך המריץ שני חוטים (Threads) של POSIX. חוט א' נועל Mutex גלובלי ומתחיל בביצוע חישוב ארוך. בזמן שחוט א' מחזיק בנעילה, חוט ב' מבצע קריאה למערכת (system call) מסוג fork(). איזו מהטענות הבאות מתארת נכונה את מצב התהליך הבן שנוצר?", "code_snippet": null, "options": ["א. בתהליך הבן ייווצרו שני חוטים המקבילים לחוטים בתהליך האב, וחוט א' בבן ימשיך להחזיק ב-Mutex.", "ב. בתהליך הבן יהיה קיים רק חוט אחד (העתק של חוט ב'), וה-Mutex יופיע במצב 'נעול' ללא חוט שיכול לשחרר אותו.", "ג. מערכת ההפעלה מזהה שה-Mutex נעול על ידי חוט שלא הועתק לבן, ולכן היא משחררת את ה-Mutex באופן אוטומטי בתהליך הבן.", "ד. הקריאה ל-fork() תחסום את חוט ב' עד שחוט א' ישחרר את ה-Mutex, כדי למנוע חוסר עקביות בזיכרון.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "לפי תקן POSIX, כאשר תהליך מרובה חוטים מבצע fork(), רק החוט שקרא ל-fork() מועתק לתהליך הבן. שאר החוטים אינם קיימים בבן. עם זאת, מרחב הכתובות מועתק כפי שהוא (במנגנון Copy-on-Write), כולל מצבם של אובייקטי סנכרון בזיכרון. לכן, אם Mutex היה נעול באב על ידי חוט שלא הועתק לבן, הוא יישאר נעול בבן לנצח (מצב של Deadlock פוטנציאלי), שכן החוט האחראי לשחרורו אינו קיים בבן."}, "difficulty_estimation": "Hard", "_source_file": "0090__Threads__MultipleChoice__Hard.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:35:58"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Processes", "fork", "Synchronization"], "content": {"text": "נתון תהליך המכיל שלושה חוטים (threads) הפועלים במקביל במרחב המשתמש (POSIX threads). חוט א' נועל Mutex גלובלי ומתחיל בביצוע חישוב ארוך. לפני שחוט א' מספיק לשחרר את הנעילה, חוט ב' מבצע קריאה למערכת מסוג fork(). איזה מההיגדים הבאים מתאר בצורה המדויקת ביותר את מצב התהליך הבן (Child Process) שנוצר מיד לאחר הקריאה?", "code_snippet": null, "options": ["א. בתהליך הבן ייווצרו שלושה חוטים המקבילים לאלו שבמקור, וחוט א' בבן ימשיך להחזיק ב-Mutex.", "ב. בתהליך הבן ייווצר רק חוט אחד (העתק של חוט ב'), וה-Mutex יהיה במצב נעול (locked) מבלי שיהיה חוט קיים שיוכל לשחררו.", "ג. בתהליך הבן ייווצר רק חוט אחד (העתק של חוט ב'), ומערכת ההפעלה תזהה שהחוט שנעל את ה-Mutex אינו קיים ותשחרר את הנעילה אוטומטית.", "ד. הקריאה ל-fork() תיחסם על ידי מערכת ההפעלה עד שכל ה-Mutexes במרחב הכתובות ישוחררו על ידי החוטים המחזיקים בהם.", "ה. בתהליך הבן ייווצר רק חוט אחד (העתק של חוט ב'), וכל ה-Mutexes בזיכרון של הבן יאותחלו למצב פתוח (unlocked) כברירת מחדל."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "לפי תקן POSIX, כאשר תהליך מרובה חוטים קורא ל-fork(), רק החוט שביצע את הקריאה מועתק לתהליך הבן. שאר החוטים אינם קיימים בבן. עם זאת, מרחב הכתובות מועתק במלואו, כולל המצב של משתנים גלובליים ואובייקטי סנכרון (כמו Mutexes). מכיוון שה-Mutex הועתק כשהוא במצב 'נעול' והחוט שאמור לשחרר אותו (חוט א') לא הועתק לבן, ה-Mutex יישאר נעול לצמיתות בתוך התהליך הבן. מצב זה נחשב למסוכן ועלול להוביל ל-Deadlock בתהליך הבן."}, "difficulty_estimation": "Hard", "_source_file": "0091__Threads__MultipleChoice__Hard.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:36:13"}, {"id": 101, "type": "MultipleChoice", "topic": ["Threads", "Memory Management", "Pthreads", "Stack vs Heap"], "content": {"text": "שקלו את קטע הקוד הבא הכתוב בשפת C והמשתמש בספריית pthreads. נניח שהקריאה ל-pthread_create מצליחה והמערכת היא מערכת Linux סטנדרטית. מהי הקביעה המדויקת ביותר לגבי הרצת התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n\nvoid* task(void* arg) {\n    int* p = (int*)arg;\n    sleep(1);\n    printf(\"%d\\n\", *p);\n    return NULL;\n}\n\nvoid start_work() {\n    pthread_t t;\n    int local_val = 42;\n    pthread_create(&t, NULL, task, &local_val);\n    // No pthread_join here\n}\n\nint main() {\n    start_work();\n    sleep(2);\n    return 0;\n}", "options": ["א. יודפס תמיד הערך 42, מכיוון שחוטים חולקים את אותו מרחב כתובות והזיכרון נשאר תקף כל עוד התהליך רץ.", "ב. תתרחש בהכרח שגיאת Segmentation Fault מיד עם הניסיון לגשת למשתנה p, כיוון שלכל חוט יש מחסנית נפרדת וגישה למחסנית של חוט אחר חסומה על ידי ה-MMU.", "ג. התנהגות התוכנית אינה מוגדרת (Undefined Behavior). ייתכן שיודפס 42, ייתכן שיודפס ערך זבל, וייתכן שתתרחש שגיאת זיכרון.", "ד. התוכנית לא תעבור קומפילציה כיוון שלא ניתן להעביר כתובת של משתנה מקומי (Local Variable) כארגומנט לפונקציית החוט.", "ה. התוכנית תסתיים מיד לאחר הקריאה ל-start_work מבלי להדפיס דבר, כיוון שסיום הפונקציה שיוצרת את החוט גורר את סיום החוט עצמו."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "הסבר: למרות שכל החוטים בתהליך חולקים את אותו מרחב כתובות וירטואלי, לכל חוט יש מחסנית (Stack) פרטית משלו. המשתנה local_val מוקצה על המחסנית של החוט הראשי בזמן ביצוע הפונקציה start_work. ברגע שפונקציה זו מסתיימת, מסגרת המחסנית (Stack Frame) שלה משתחררת וניתן להשתמש בה לקריאות עתידיות. החוט החדש מנסה לגשת לכתובת הזיכרון הזו (Dangling Pointer) לאחר שהפונקציה שיצרה אותו כבר חזרה. כיוון שהתהליך עדיין רץ (בגלל ה-sleep ב-main), הגישה לזיכרון לא תמיד תגרום ל-Segfault (כי הדף בזיכרון עדיין שייך לתהליך), אך התוכן בכתובת זו עלול להשתנות או להיות לא תקף, מה שמוביל להתנהגות לא מוגדרת."}, "difficulty_estimation": "Hard", "_source_file": "0092__Threads__MultipleChoice__Hard.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:36:31"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Process Management", "fork", "Synchronization"], "content": {"text": "נתון תהליך מרובה חוטים (Multi-threaded process) המשתמש ב-Mutex גלובלי לצורך סנכרון. אחד מהחוטים (שאינו חוט ה-Main) מבצע קריאה לפונקציה fork() כפי שמתואר בקוד מטה. נניח כי בזמן הקריאה ל-fork(), חוט אחר בתהליך האב (שאינו החוט הקורא ל-fork) מחזיק במנעול ה-lock. מה יקרה בנקודה המסומנת ב-Line X בתוך תהליך הבן?", "code_snippet": "void* thread_func(void* arg) {\n    if (fork() == 0) {\n        // Child process\n        pthread_mutex_lock(&lock); // Line X\n        printf(\"Child acquired lock\\n\");\n        pthread_mutex_unlock(&lock);\n        exit(0);\n    }\n    return NULL;\n}", "options": ["א. תהליך הבן יצליח לתפוס את המנעול מכיוון שכל המנעולים משתחררים אוטומטית בעת fork().", "ב. תהליך הבן יכיל את כל החוטים שהיו באב, ולכן החוט שהחזיק במנעול באב ישחרר אותו גם בבן.", "ג. תהליך הבן ייתקע בקיפאון (Deadlock) ב-Line X, שכן המנעול מועתק במצב 'תפוס' אך החוט שאמור לשחרר אותו אינו קיים בבן.", "ד. תהליך הבן יקרוס (Segmentation Fault) בגישה למנעול שנתפס על ידי חוט שכבר לא קיים.", "ה. מערכת ההפעלה תזהה את המצב ותעביר את הבעלות על המנעול לחוט היחיד שקיים בבן."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "לפי תקן POSIX, כאשר תהליך מרובה חוטים מבצע fork(), רק החוט שקרא ל-fork() משוכפל בתהליך הבן. שאר החוטים של האב אינם קיימים בבן. עם זאת, מצב הזיכרון (כולל מצב ה-Mutexes) מועתק כפי שהוא (Copy-on-Write). אם חוט אחר באב החזיק במנעול בזמן ה-fork, המנעול יופיע כתפוס בזיכרון של הבן. מכיוון שהחוט שהחזיק במנעול לא קיים בבן כדי לשחרר אותו, כל ניסיון של החוט היחיד בבן לתפוס את המנעול יוביל ל-Deadlock."}, "difficulty_estimation": "Hard", "_source_file": "0093__Threads__MultipleChoice__Hard.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:36:56"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Race Conditions"], "content": {"text": "נתון קטע הקוד הבא בשפת C המשתמש בספריית pthreads. מה מהבאים מתאר נכונה את התנהגות התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n\nvoid* thread_func(void* arg) {\n    int id = *(int*)arg;\n    printf(\"%d \", id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    for (int i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": ["א. התוכנית תדפיס תמיד את המספרים 0 עד 4 בסדר כלשהו, כאשר כל מספר מופיע בדיוק פעם אחת.", "ב. ייתכן מצב בו יודפס המספר 5, או שמספר מסוים בטווח 0-4 יודפס יותר מפעם אחת.", "ג. השימוש ב-pthread_join מבטיח שכל thread יסיים את ריצתו לפני שהלולאה הבאה של ה-main תתחיל, ולכן הפלט יהיה 0 1 2 3 4.", "ד. התוכנית תגרום לשגיאת זמן ריצה (Runtime Error) כיוון שכל ה-threads מנסים לגשת לאותו זיכרון במקביל."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "הבעיה בקוד היא Race Condition על המשתנה i. כל ה-threads מקבלים את אותה הכתובת בזיכרון (&i). בזמן ש-thread מסוים מתעורר וניגש לכתובת הזו כדי לקרוא את הערך (dereference), ה-main thread עשוי כבר לקדם את i בתוך הלולאה. יתרה מכך, i מגיע לערך 5 כדי לצאת מהלולאה הראשונה, ולכן ייתכן שחלק מה-threads (או כולם) יקראו את הערך 5 מהכתובת המשותפת לפני שהם מספיקים להדפיס."}, "difficulty_estimation": "Hard", "_source_file": "0094__Threads__MultipleChoice__Hard.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:37:14"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Memory Visibility", "Optimization", "Pthreads"], "content": {"text": "במערכת המשתמשת ב-POSIX Threads (Pthreads), נתון הקוד הבא בשפת C. מהי הטענה המדויקת ביותר לגבי התנהגות התוכנית בעת הרצה על מעבד מרובה ליבות (Multi-core) עם רמת אופטימיזציה גבוהה (למשל O3-)?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* thread_func(void* arg) {\n    int* p = (int*)arg;\n    while (*p == 0); // Wait for flag to change\n    printf(\"Value changed!\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t t1;\n    int flag = 0;\n    pthread_create(&t1, NULL, thread_func, &flag);\n    \n    // Simulate some work\n    for (volatile int i = 0; i < 1000000; i++);\n    \n    flag = 1;\n    pthread_join(t1, NULL);\n    return 0;\n}", "options": ["א. התוכנית תקינה לחלוטין ותדפיס תמיד את ההודעה, שכן חוטים חולקים את אותו מרחב כתובות והשינוי ב-flag ייראה מיד לחוט t1.", "ב. התוכנית עלולה להיכנס ללולאה אינסופית בגלל אופטימיזציות קומפיילר, שכן ללא סנכרון או שימוש ב-volatile, החוט t1 עשוי לטעון את הערך של flag לרגיסטר פעם אחת בלבד ולא לבדוק שוב את הזיכרון.", "ג. תתרחש שגיאת Segmentation Fault כיוון שחוט t1 מנסה לגשת למחסנית (Stack) של החוט הראשי, דבר שאינו מותר במודל של Kernel-level threads.", "ד. הקריאה ל-pthread_join תגרום ל-Deadlock כיוון שהיא חוסמת את החוט הראשי מלערוך את המשתנה flag.", "ה. התוכנית לא תתקמפל כיוון שלא ניתן להעביר כתובת של משתנה מקומי (flag) כארגומנט לפונקציה pthread_create."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "במרחב כתובות משותף, חוטים אכן יכולים לגשת לאותם משתנים (כולל משתנים על מחסנית של חוט אחר כל עוד הוא חי). עם זאת, ללא מנגנוני סנכרון (כמו Mutex) או הגדרת המשתנה כ-volatile, הקומפיילר עשוי להניח שערכו של flag אינו משתנה בתוך הלולאה בחוט t1 (כי אין שום קריאה לפונקציה או כתיבה למשתנה בתוך הלולאה). לכן, הקומפיילר עשוי לבצע אופטימיזציה שבה הערך נטען לרגיסטר פעם אחת בלבד לפני הלולאה. במצב כזה, השינוי שביצע החוט הראשי בזיכרון לא יורגש בתוך הלולאה והחוט ייתקע בלולאה אינסופית."}, "difficulty_estimation": "Hard", "_source_file": "0095__Threads__MultipleChoice__Hard.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:37:47"}, {"id": 10, "type": "MultipleChoice", "topic": ["Threads", "Process Management", "POSIX"], "content": {"text": "נתון קוד C המשתמש בספריית Pthreads. תהליך מסוים יוצר שני תהליכונים (Threads) בנוסף לתהליכון הראשי (Main thread). אחד מהתהליכונים החדשים שנוצרו מבצע קריאה למערכת (System Call) מסוג fork(). איזה מההיגדים הבאים מתאר נכונה את מצב התהליך הבן שנוצר מיד לאחר הקריאה?", "code_snippet": "void* thread_func(void* arg) {\n    pid_t pid = fork();\n    if (pid == 0) {\n        // מה קיים כאן בתוך התהליך הבן?\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, thread_func, NULL);\n    pthread_create(&t2, NULL, some_other_func, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    return 0;\n}", "options": ["א. התהליך הבן יכיל העתק של כל התהליכונים שהיו קיימים בתהליך האב (סה\"כ 3 תהליכונים).", "ב. התהליך הבן יכיל רק תהליכון אחד, שהוא העתק של התהליכון שביצע את הקריאה ל-fork.", "ג. התהליך הבן יכיל רק את התהליכון הראשי (Main thread), וכל שאר התהליכונים יופסקו.", "ד. הפעולה אינה מוגדרת (Undefined behavior) ותלויה במימוש הספציפי של ה-Scheduler של מערכת ההפעלה."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "לפי תקן POSIX, כאשר תהליך מרובה תהליכונים קורא ל-fork, התהליך הבן שנוצר הוא העתק של תהליך האב מבחינת מרחב הכתובות (Address Space), אך הוא מכיל רק תהליכון אחד בלבד - התהליכון שביצע את הקריאה ל-fork. שאר התהליכונים שהיו קיימים באב אינם נוצרים בבן. זוהי נקודה קריטית כי אם התהליכונים האחרים החזיקו במנעולים (Mutexes) ברגע הקריאה, המנעולים יופיעו כתפוסים בבן אך התהליכון שאמור לשחרר אותם לא קיים שם, מה שעלול להוביל ל-Deadlock."}, "difficulty_estimation": "Hard", "_source_file": "0096__Threads__MultipleChoice__Hard.json", "_topic_hint": "Threads", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:38:08"}, {"id": 10, "type": "Open", "topic": ["Threads", "User-level threads", "Kernel-level threads"], "content": {"text": "במערכת הפעלה מסוימת, תהליך מכיל שלושה חוטים (threads). אחד החוטים מבצע קריאת מערכת חוסמת (blocking system call) לקלט מהמקלדת, כפי שמתואר בקטע הקוד הבא. הסבירו מה יקרה לשני החוטים האחרים באותו תהליך בשני המקרים המפורטים מטה:", "code_snippet": "void* thread_work(void* arg) {\n    char buffer[1024];\n    // הקריאה הבאה חוסמת את החוט עד לקבלת קלט\n    read(STDIN_FILENO, buffer, sizeof(buffer));\n    printf(\"Input received!\\n\");\n    return NULL;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "החוטים ממומשים כחוטים ברמת המשתמש (User-level threads) במודל Many-to-One.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "החוטים ממומשים כחוטים ברמת הגרעין (Kernel-level threads) במודל One-to-One.", "code_snippet": null, "options": null}], "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1. במודל Many-to-One (User-level threads), מערכת ההפעלה (הגרעין) אינה מודעת לקיומם של החוטים ורואה רק תהליך אחד. כאשר חוט אחד מבצע קריאת מערכת חוסמת, הגרעין מעביר את כל התהליך למצב 'ממתין' (Waiting/Blocked). כתוצאה מכך, כל שאר החוטים בתהליך ייחסמו ולא יוכלו להמשיך בביצועם עד שהקריאה תסתיים.\n\n10.2. במודל One-to-One (Kernel-level threads), כל חוט משתמש ממופה לחוט נפרד בתוך הגרעין. במקרה זה, הגרעין מנהל את התזמון של כל חוט בנפרד. לכן, אם חוט אחד נחסם בגלל קריאת מערכת, הגרעין יכול להמשיך לתזמן ולהריץ את שני החוטים האחרים של אותו תהליך ללא הפרעה."}, "difficulty_estimation": "Easy", "_source_file": "0097__Threads__Open__Easy.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:38:19"}, {"id": 10, "type": "Open", "topic": ["Threads", "Concurrency", "Race Conditions"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. התוכנית יוצרת שני חוטים (threads) המריצים את הפונקציה `increment` שמקדמת משתנה גלובלי משותף.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\n\nvoid* increment(void* arg) {\n    for (int i = 0; i < 100; i++) {\n        counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, increment, NULL);\n    pthread_create(&t2, NULL, increment, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\\n\", counter);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "מהו הערך המקסימלי האפשרי שיודפס על ידי התוכנית? נמקו בקצרה.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "האם ייתכן שהתוכנית תדפיס ערך הנמוך מ-200? אם כן, הסבירו באיזה מצב זה עלול לקרות. אם לא, הסבירו מדוע.", "code_snippet": null, "options": null}], "points": 15, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1. הערך המקסימלי הוא 200. כל אחד משני החוטים מבצע 100 איטרציות שבהן הוא מקדם את המשתנה הגלובלי counter. במקרה שבו אין חפיפה בין הפעולות (למשל ריצה סדרתית מלאה של חוט אחד ואז השני), כל הקידומים יישמרו.\n10.2. כן, ייתכן ערך נמוך מ-200 בשל מצב מרוץ (Race Condition). הפעולה ++counter אינה אטומית (היא מורכבת מקריאת הערך מהזיכרון, הוספת 1 ברגיסטר, וכתיבה חזרה לזיכרון). אם שני חוטים קוראים את הערך בו-זמנית (למשל 50), שניהם יקדמו אותו ל-51 ויכתבו את אותה התוצאה לזיכרון, מה שיוביל לאובדן של אחד הקידומים."}, "difficulty_estimation": "Easy", "_source_file": "0098__Threads__Open__Easy.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:38:32"}, {"id": 7, "type": "Open", "topic": ["Threads"], "content": {"text": "נתון קטע הקוד הבא בשפת C המשתמש בספריית pthreads. מה יהיה הפלט של התוכנית? הסבר את תשובתך תוך התייחסות למרחב הכתובות המשותף בין חוטים (threads).", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint global_var = 10;\n\nvoid* thread_func(void* arg) {\n    global_var += 5;\n    return NULL;\n}\n\nint main() {\n    pthread_t tid;\n    pthread_create(&tid, NULL, thread_func, NULL);\n    pthread_join(tid, NULL);\n    printf(\"%d\\n\", global_var);\n    return 0;\n}", "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפלט יהיה 15. חוטים (threads) ששייכים לאותו תהליך חולקים את אותו מרחב כתובות, ובפרט את מקטע הנתונים (Data Segment) שבו נמצאים משתנים גלובליים. לכן, כאשר ה-thread שנוצר מעדכן את המשתנה global_var, השינוי משתקף גם ב-thread הראשי (main). הפעולה pthread_join מבטיחה שה-thread הראשי ימתין לסיום ביצוע ה-thread החדש לפני שידפיס את הערך."}, "difficulty_estimation": "Easy", "_source_file": "0099__Threads__Open__Easy.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:38:47"}, {"id": 7, "type": "Open", "topic": ["Threads", "Concurrency", "Memory Management"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. התוכנית מגדירה משתנה גלובלי ומבצעת פעולות עדכון מתוך שני חוטים שונים.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\n\nvoid* increment_task(void* arg) {\n    for (int i = 0; i < 100; i++) {\n        counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n\n    pthread_create(&t1, NULL, increment_task, NULL);\n    pthread_create(&t2, NULL, increment_task, NULL);\n\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n\n    printf(\"%d\\n\", counter);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "בהנחה שהריצה מתבצעת באופן תקין וללא הפרעות של מרוץ תהליכים (race conditions), מה יהיה הפלט המודפס למסך?", "code_snippet": null, "options": null}, {"id": "7.2", "text": "הסבר מדוע חוטים (threads) מסוגלים לעדכן את המשתנה counter בצורה כזו, וכיצד התנהגות זו הייתה משתנה אילו היינו משתמשים בתהליכים (processes) ע\"י fork במקום חוטים?", "code_snippet": null, "options": null}], "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1. הפלט יהיה 200. כל אחד משני החוטים מבצע 100 איטרציות של קידום המשתנה counter ב-1.\n7.2. חוטים (threads) השייכים לאותו תהליך חולקים את אותו מרחב כתובות (Address Space), ולכן משתנים גלובליים (הנמצאים במקטע הנתונים) הם משותפים לכולם. אילו היינו משתמשים ב-fork, היה נוצר תהליך בן עם עותק נפרד של מרחב הכתובות (Copy-on-write). במקרה כזה, קידום המשתנה בתהליך הבן לא היה משפיע על המשתנה בתהליך האב, והאב היה מדפיס 0."}, "difficulty_estimation": "Easy", "_source_file": "0100__Threads__Open__Easy.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:39:01"}, {"id": 7, "type": "Open", "topic": ["Threads", "Concurrency", "Memory Management"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. מה יהיה הפלט המודפס למסך בסיום ריצת התוכנית? הסבירו את תשובתכם תוך התייחסות לאופן שבו חוטים (threads) חולקים זיכרון.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint shared_val = 100;\n\nvoid* thread_work(void* arg) {\n    shared_val += 50;\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n\n    pthread_create(&t1, NULL, thread_work, NULL);\n    pthread_join(t1, NULL);\n\n    pthread_create(&t2, NULL, thread_work, NULL);\n    pthread_join(t2, NULL);\n\n    printf(\"%d\\n\", shared_val);\n    return 0;\n}", "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפלט יהיה 200. ההסבר לכך טמון בעובדה שחוטים (Threads) השייכים לאותו תהליך חולקים את אותו מרחב כתובות (Address Space), ובפרט את מקטע הנתונים הגלובליים. המשתנה shared_val הוא גלובלי, ולכן כל שינוי שמבצע חוט אחד נראה באופן מיידי לחוטים האחרים. בתוכנית זו: 1. הערך ההתחלתי הוא 100. 2. החוט הראשון (t1) מוסיף 50, והערך הופך ל-150. 3. הפונקציה pthread_join מבטיחה שהחוט הראשון יסיים לפני שהחוט השני יתחיל. 4. החוט השני (t2) מוסיף 50 נוספים לערך הקיים (150), ולכן התוצאה הסופית היא 200."}, "difficulty_estimation": "Easy", "_source_file": "0101__Threads__Open__Easy.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:39:12"}, {"id": 7, "type": "Open", "topic": ["Threads"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. מהן האפשרויות השונות לפלט התוכנית? הסבר/י מדוע ייתכנו מספר אפשרויות והאם קיימת הבטחה לגבי סדר ההדפסה של האותיות A ו-B.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nvoid* thread_func(void* arg) {\n    printf(\"B\");\n    return NULL;\n}\n\nint main() {\n    pthread_t t;\n    pthread_create(&t, NULL, thread_func, NULL);\n    printf(\"A\");\n    pthread_join(t, NULL);\n    return 0;\n}", "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפלט של התוכנית יכול להיות 'AB' או 'BA'. הסיבה לכך היא שברגע שמתבצעת הקריאה ל-pthread_create, נוצר חוט (thread) חדש שמתחיל לרוץ במקביל לחוט הראשי. התזמון (scheduling) של החוטים על ידי מערכת ההפעלה אינו דטרמיניסטי, ולכן אין לדעת מי יבצע את פקודת ה-printf שלו קודם: החוט הראשי שממשיך מיד לאחר הקריאה ל-create, או החוט החדש שנוצר. פקודת ה-pthread_join מבטיחה שהחוט הראשי ימתין לסיום החוט החדש לפני שהתוכנית כולה תסתיים, אך מכיוון שהיא ממוקמת אחרי ה-printf של ה-main, היא אינה משפיעה על סדר ההדפסה היחסי בין A ל-B."}, "difficulty_estimation": "Easy", "_source_file": "0102__Threads__Open__Easy.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:39:27"}, {"id": 10, "type": "Open", "topic": ["Threads", "Shared Memory", "Pthreads"], "content": {"text": "נתון קטע הקוד הבא בשפת C המשתמש בספריית pthreads. הניחו כי כל הקריאות למערכת (system calls) מצליחות וכי התזמון מתבצע כך שהחוט החדש מסיים את ריצתו לפני שהחוט הראשי ממשיך לאחר ה-join. מה יהיה הפלט של התוכנית? הסבירו בקצרה מדוע.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint x = 10;\n\nvoid* thread_func(void* arg) {\n    x += 5;\n    printf(\"Thread: x = %d\\n\", x);\n    return NULL;\n}\n\nint main() {\n    pthread_t tid;\n    pthread_create(&tid, NULL, thread_func, NULL);\n    pthread_join(tid, NULL);\n    x += 2;\n    printf(\"Main: x = %d\\n\", x);\n    return 0;\n}", "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפלט הצפוי הוא:\nThread: x = 15\nMain: x = 17\nהסבר: חוטים (threads) בתוך אותו תהליך חולקים את אותו מרחב כתובות, ולכן המשתנה הגלובלי x משותף לחוט הראשי ולחוט שנוצר. החוט הראשי קורא ל-pthread_join, מה שגורם לו להמתין עד שהחוט החדש יסיים את ביצועו. בתוך thread_func, הערך של x עולה מ-10 ל-15 ומודפס. לאחר סיום החוט, החוט הראשי ממשיך, מוסיף 2 לערך המעודכן (15+2=17) ומדפיס את התוצאה."}, "difficulty_estimation": "Easy", "_source_file": "0103__Threads__Open__Easy.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:39:38"}, {"id": 7, "type": "Open", "topic": ["Threads", "Concurrency", "Race Conditions"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. התוכנית יוצרת שני חוטים (threads) שכל אחד מהם מעלה את הערך של משתנה גלובלי משותף counter בתוך לולאה 10,000 פעמים.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint counter = 0;\n\nvoid* increment(void* arg) {\n    for (int i = 0; i < 10000; i++) {\n        counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, increment, NULL);\n    pthread_create(&t2, NULL, increment, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"Final counter: %d\\n\", counter);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "מהי התוצאה המקסימלית האפשרית של המשתנה counter בסיום ריצת התוכנית?", "code_snippet": null, "options": null}, {"id": "7.2", "text": "האם מובטח שהפלט של התוכנית יהיה תמיד התוצאה המקסימלית? הסבירו מדוע, והשתמשו במושג \"מרוץ תהליכים\" (Race Condition) בהסברכם.", "code_snippet": null, "options": null}], "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1. התוצאה המקסימלית היא 20,000 (כל אחד משני החוטים מבצע 10,000 פעולות הגדלה).\n7.2. לא, לא מובטח שהפלט יהיה 20,000. הסיבה לכך היא קיום של מרוץ תהליכים (Race Condition). הפעולה ++counter אינה פעולה אטומית (Atomic) ברמת המעבד; היא מורכבת משלושה שלבים: קריאת הערך מהזיכרון לרגיסטר, הוספת 1 ברגיסטר, וכתיבת הערך חזרה לזיכרון. אם מתבצע context switch בין חוטים באמצע שלבים אלו, חוט אחד עלול לקרוא ערך ישן ולדרוס עדכון של חוט אחר, מה שיוביל לכך שחלק מההגדלות יאבדו והתוצאה הסופית תהיה קטנה מ-20,000."}, "difficulty_estimation": "Easy", "_source_file": "0104__Threads__Open__Easy.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:39:57"}, {"id": 7, "type": "Open", "topic": ["Threads", "Concurrency", "Race Conditions", "Memory Layout"], "content": {"text": "לפניכם קוד בשפת C המשתמש בחוטים (Threads). הניחו שהקוד רץ על מערכת מרובת ליבות וכי אין מנגנוני סנכרון נוספים מעבר למה שמופיע בקוד.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint counter = 0;\n\nvoid* worker(void* arg) {\n    int* local_ptr = (int*)arg;\n    for (int i = 0; i < 100; i++) {\n        counter++;\n        (*local_ptr)++;\n    }\n    return NULL;\n}\n\nint main() {\n    int shared_val = 0;\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, worker, &shared_val);\n    pthread_create(&t2, NULL, worker, &shared_val);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"counter: %d, shared_val: %d\\n\", counter, shared_val);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "מהם הערכים המינימליים והמקסימליים האפשריים שיוצגו עבור counter ו-shared_val בסיום התוכנית? הסבירו בקצרה מדוע.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "הסבירו את ההבדל במיקום בזיכרון בין counter ל-shared_val. האם הבדל זה משנה את רגישות המשתנה shared_val למצבי מרוץ (Race Conditions)?", "code_snippet": null, "options": null}, {"id": "7.3", "text": "כיצד שימוש ב-pthread_mutex_t יכול לפתור את הבעיה? הציגו את השינוי הנדרש בקוד ה-worker בלבד (הניחו כי המיוטקס כבר אותחל גלובלית בשם lock).", "code_snippet": null, "options": null}], "points": 15, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1. המקסימום עבור שניהם הוא 200 (במקרה של ריצה סדרתית או תזמון מושלם). המינימום הוא 2 (במקרה של Race Condition שבו כל חוט קורא את הערך 0, מקדם ל-1 וכותב, ואז התהליך חוזר על עצמו כך שכל חוט דורס את עבודת השני פרט לפעם אחת). הערכים נובעים מכך שפעולת הקידום אינה אטומית (Load, Increment, Store).\n\n7.2. המשתנה counter הוא גלובלי ולכן נמצא ב-Data Segment. המשתנה shared_val הוכרז ב-main ולכן נמצא על המחסנית (Stack) של חוט ה-main. למרות זאת, כיוון שכתובתו הועברה כארגומנט לחוטים האחרים, לכולם יש גישה לאותו מרחב זיכרון. לכן, shared_val חשוף ל-Race Condition בדיוק כמו counter.\n\n7.3. יש לנעול את המיוטקס לפני הגישה למשתנים המשותפים ולשחרר אחרי:\nvoid* worker(void* arg) {\n    int* local_ptr = (int*)arg;\n    for (int i = 0; i < 100; i++) {\n        pthread_mutex_lock(&lock);\n        counter++;\n        (*local_ptr)++;\n        pthread_mutex_unlock(&lock);\n    }\n    return NULL;\n}"}, "difficulty_estimation": "Medium", "_source_file": "0105__Threads__Open__Medium.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:40:14"}, {"id": 7, "type": "Open", "topic": ["Threads", "Concurrency", "Memory Layout", "Process vs Thread"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. הניחו כי כל הקריאות למערכת מצליחות וכי התוכנית רצה על מערכת עם מעבד מרובה ליבות.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint global_var = 0;\n\nvoid* thread_func(void* arg) {\n    int local_var = 0;\n    for (int i = 0; i < 1000; i++) {\n        global_var++;\n        local_var++;\n    }\n    printf(\"%d \", local_var);\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, thread_func, NULL);\n    pthread_create(&t2, NULL, thread_func, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\\n\", global_var);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "מה יהיו הערכים שיודפסו עבור המשתנה local_var על ידי שני החוטים? נמקו.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "מהו טווח הערכים האפשרי שיודפס עבור המשתנה global_var בפקודת ה-printf האחרונה ב-main? הסבירו מדוע.", "code_snippet": null, "options": null}, {"id": "7.3", "text": "נניח ונחליף את יצירת החוטים (pthread_create) ביצירת תהליכים על ידי fork, ואת ה-pthread_join בפקודת wait. כיצד ישתנה הפלט עבור global_var בסוף הריצה של תהליך האב?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: כל חוט ידפיס 1000. הסבר: המשתנה local_var הוא משתנה מקומי המוקצה על המחסנית (stack). לכל חוט (Thread) יש מחסנית נפרדת משלו, ולכן כל חוט מעדכן עותק פרטי שלו שאינו מושפע מהחוט השני.\n\n7.2: טווח הערכים הוא [1000, 2000]. הסבר: המשתנה global_var נמצא במקטע הנתונים המשותף לכל החוטים באותו תהליך. מכיוון שאין סנכרון (כמו Mutex) על הגישה למשתנה, נוצר מצב מרוץ (Race Condition). בפעולת הקידום (global_var++), חוט אחד עלול לקרוא את הערך, ובזמן שהוא מחשב את התוצאה, החוט השני יקרא את אותו ערך ישן, מה שיגרום לעדכון של אחד מהם 'להידרס'. המינימום הוא 1000 (במקרה שחוט אחד תמיד דורס את השני) והמקסימום הוא 2000 (במקרה שלא היו התנגשויות כלל).\n\n7.3: הפלט עבור global_var בתהליך האב יהיה 0. הסבר: כאשר משתמשים ב-fork, נוצר תהליך חדש עם מרחב כתובות נפרד. למרות שבתחילה הזיכרון מועתק (או משתמש ב-Copy-on-Write), שינויים שמבצע תהליך הבן על משתנה גלובלי אינם משפיעים על המשתנה בזיכרון של תהליך האב. מכיוון שתהליך האב עצמו לא שינה את global_var ב-main, הערך יישאר 0."}, "difficulty_estimation": "Medium", "_source_file": "0106__Threads__Open__Medium.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:40:30"}, {"id": 10, "type": "Open", "topic": ["Threads", "User-level threads", "Kernel-level threads", "Concurrency", "Race Conditions"], "content": {"text": "השאלה הבאה עוסקת בניהול חוטים (threads) במערכות הפעלה ובבעיות סנכרון הנובעות מריצה מקבילית.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "10.1", "text": "נניח תהליך המשתמש בחוטים ברמת המשתמש (User-level threads) במודל Many-to-One. אחד החוטים מבצע קריאת מערכת חוסמת (blocking system call) לקלט מהמקלדת. הסבירו מה יקרה לשאר החוטים באותו תהליך ומדוע. האם המצב היה שונה אילו המערכת הייתה משתמשת בחוטים ברמת הגרעין (Kernel-level threads) במודל One-to-One?", "code_snippet": null, "options": null}, {"id": "10.2", "text": "נתון קטע הקוד הבא המורץ על ידי שני חוטים (Thread A ו-Thread B) החולקים את אותו מרחב כתובות. המשתנה counter הוא גלובלי ומאותחל ל-0. מהו הערך המינימלי האפשרי של counter לאחר ששני החוטים מסיימים את ריצתם? הסבירו בקצרה כיצד ניתן להגיע לערך זה.", "code_snippet": "void* increment(void* arg) {\n    for (int i = 0; i < 100; i++) {\n        int temp = counter;\n        counter = temp + 1;\n    }\n    return NULL;\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: במודל Many-to-One (חוטים ברמת המשתמש), הגרעין אינו מכיר את החוטים הבודדים ומתייחס לכל התהליך כיחידת תזמון אחת. לכן, כאשר חוט אחד מבצע קריאת מערכת חוסמת, כל התהליך נכנס למצב 'חסום' (Blocked), וכל שאר החוטים בתהליך לא יוכלו לרוץ עד שהקריאה תסתיים. במודל One-to-One (חוטים ברמת הגרעין), כל חוט ממופה לישות תזמון עצמאית בגרעין, ולכן חסימה של חוט אחד אינה מונעת מהגרעין להמשיך לתזמן חוטים אחרים של אותו תהליך.\n\n10.2: הערך המינימלי הוא 2. הסבר: מצב זה קורה עקב Race Condition. נניח שחוט א' קורא את counter=0 לתוך temp ומופסק מיד. חוט ב' רץ 99 פעמים ומסיים (counter=99). כעת חוט א' חוזר, מבצע counter = 0 + 1 ומעדכן את counter ל-1. כעת חוט ב' מתחיל את האיטרציה ה-100 שלו, קורא counter=1 לתוך ה-temp שלו ומופסק. חוט א' ממשיך ורץ את כל 99 האיטרציות הנותרות שלו ומסיים (נניח שעדכן את counter ל-100). לבסוף, חוט ב' חוזר לביצוע האיטרציה האחרונה שלו, מבצע counter = 1 + 1 ודורס את הערך ל-2."}, "difficulty_estimation": "Medium", "_source_file": "0107__Threads__Open__Medium.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:40:52"}, {"id": 7, "type": "Open", "topic": ["Threads", "Concurrency", "User-level vs Kernel-level Threads"], "content": {"text": "נניח מערכת הפעלה התומכת בשני מודלים שונים לניהול חוטים (Threads): מודל Many-to-One (חוטים ברמת המשתמש) ומודל One-to-One (חוטים ברמת הליבה). תהליך מסוים יוצר 4 חוטים. חוט מספר 1 מבצע קריאת מערכת חוסמת (Blocking System Call) לקריאת נתונים מהדיסק, בעוד ששאר החוטים (2, 3, ו-4) מבצעים חישובים מתמטיים.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\n\nvoid* worker(void* arg) {\n    for (int i = 0; i < 1000000; i++) {\n        counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, worker, NULL);\n    pthread_create(&t2, NULL, worker, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"Final counter: %d\\n\", counter);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "תאר מה יקרה לחוטים 2, 3 ו-4 בזמן שחוט 1 ממתין לדיסק בכל אחד מהמודלים (Many-to-One ו-One-to-One).", "code_snippet": null, "options": null}, {"id": "7.2", "text": "התייחס לקוד ה-C המצורף. מהי הבעיה הלוגית בקוד זה, ומה יהיה הפלט הצפוי של התוכנית (האם תמיד יודפס 2,000,000)? הסבר מדוע.", "code_snippet": null, "options": null}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: במודל Many-to-One, כל החוטים של התהליך ממופים לישות תזמון אחת בליבה. לכן, כאשר חוט 1 מבצע קריאה חוסמת, הליבה חוסמת את התהליך כולו, וחוטים 2, 3 ו-4 לא יוכלו לרוץ עד שהקריאה תסתיים. במודל One-to-One, כל חוט ממופה לישות תזמון נפרדת בליבה. לכן, רק חוט 1 ייחסם, וחוטים 2, 3 ו-4 יוכלו להמשיך לרוץ במקביל על מעבדים אחרים או בתורות תזמון נפרדים.\n\n7.2: הבעיה בקוד היא מרוץ תהליכים (Race Condition) על המשתנה הגלובלי counter. הפעולה ++counter אינה אטומית (היא מורכבת מקריאה, הוספה וכתיבה). מאחר ששני החוטים ניגשים ומשנים את אותו משתנה ללא סנכרון (למשל ללא Mutex), ייתכן שחוט אחד יקרא ערך ישן לפני שהשני הספיק לעדכן אותו. לכן, הפלט כמעט תמיד יהיה קטן מ-2,000,000, והוא אינו דטרמיניסטי."}, "difficulty_estimation": "Medium", "_source_file": "0108__Threads__Open__Medium.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:41:05"}, {"id": 10, "type": "Open", "topic": ["Threads", "User-level Threads", "Kernel-level Threads", "Blocking I/O"], "content": {"text": "שקלו מערכת המריצה תהליך עם שלושה חוטים (Threads) המבצעים את הפעולות המתוארות בקוד הבא. נניח שחוט 2 מבצע קריאה חוסמת (blocking read) מקובץ גדול הנמצא על הדיסק.", "code_snippet": "void* thread_1_work(void* arg) { \n    while(1) { /* Compute intensive math */ } \n}\n\nvoid* thread_2_work(void* arg) { \n    int fd = open(\"large_file.dat\", O_RDONLY);\n    read(fd, buffer, 1000000); // Blocking I/O call\n    close(fd);\n}\n\nvoid* thread_3_work(void* arg) { \n    printf(\"Status: Working...\\n\"); \n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "במידה והספרייה לניהול חוטים ממומשת במודל Many-to-One (User-level threads), האם חוט 1 יוכל להמשיך בחישוביו בזמן שחוט 2 ממתין לנתונים מהדיסק? נמקו.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "במידה והמערכת משתמשת במודל One-to-One (Kernel-level threads), מה יהיה מצבם של חוט 1 וחוט 3 בזמן שחוט 2 חסום?", "code_snippet": null, "options": null}, {"id": "10.3", "text": "ציינו יתרון אחד של מודל Many-to-One על פני מודל One-to-One, למרות המגבלה שהוצגה בסעיפים הקודמים.", "code_snippet": null, "options": null}], "points": 15, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: לא, חוט 1 לא יוכל להמשיך לרוץ. במודל Many-to-One, מערכת ההפעלה אינה מודעת לקיום החוטים בתוך התהליך ורואה רק ישות תזמון אחת. כאשר חוט 2 מבצע קריאה חוסמת, הוא מבצע קריאת מערכת (system call) שגורמת לכל התהליך להיכנס למצב Waiting עד לסיום פעולת ה-I/O.\n\n10.2: במודל One-to-One, כל חוט משתמש בישות תזמון נפרדת של הקרנל. לכן, כאשר חוט 2 נחסם על פעולת I/O, רק הוא עובר למצב Waiting. חוט 1 יכול להמשיך לרוץ על המעבד (מצב Running) וחוט 3 יכול להיות מתוזמן להדפסה (מצב Ready/Running).\n\n10.3: יתרון מרכזי של Many-to-One הוא היעילות בניהול החוטים. יצירת חוט, החלפת הקשר (context switch) בין חוטים וסנכרון ביניהם מתבצעים במרחב המשתמש (User-space) ללא צורך במעבר למצב קרנל (trap/kernel mode), מה שהופך את הפעולות הללו למהירות משמעותית בהשוואה לניהול חוטים על ידי הקרנל."}, "difficulty_estimation": "Medium", "_source_file": "0109__Threads__Open__Medium.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:41:17"}, {"id": 7, "type": "Open", "topic": ["Threads", "Concurrency", "Memory Management"], "content": {"text": "לפניך קוד בשפת C המשתמש בספריית pthreads. מטרת התוכנית היא ליצור 5 חוטים (threads), כאשר כל חוט מקבל את המזהה שלו (מספר בין 0 ל-4) ומדפיס אותו.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define NUM_THREADS 5\n\nvoid* thread_func(void* arg) {\n    int id = *((int*)arg);\n    printf(\"Thread ID: %d\\n\", id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    for (int i = 0; i < NUM_THREADS; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < NUM_THREADS; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "הסבר מדוע הקוד לעיל אינו תקין ועלול להדפיס פלט שאינו מכיל את כל המספרים 0 עד 4 (למשל, הדפסה של המספר 5 מספר פעמים).", "code_snippet": null, "options": null}, {"id": "7.2", "text": "הצע שתי דרכים שונות לתיקון הבעיה: אחת המשתמשת בהקצאה דינמית (malloc) ואחת המשתמשת בהעברת ערך ישירות דרך המצביע (Casting), מבלי להשתמש במנגנוני סנכרון כמו Mutex.", "code_snippet": null, "options": null}], "points": 15, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: הבעיה היא Race Condition על המשתנה i. כל החוטים מקבלים מצביע לאותה כתובת זיכרון (&i) הנמצאת במחסנית (stack) של פונקציית ה-main. מכיוון שהחוטים רצים במקביל ללולאת ה-for ב-main, ייתכן שעד שחוט מסוים ניגש לזיכרון כדי לקרוא את הערך, הלולאה כבר התקדמה והערך של i השתנה (או אפילו הגיע ל-5, התנאי לעצירת הלולאה).\n\n7.2: דרך א': הקצאה דינמית - בתוך הלולאה נקצה זיכרון עם malloc עבור כל מספר, נשמור בו את i ונעביר את המצביע ל-malloc. החוט יבצע free בסיום. דרך ב': העברת ערך ב-Casting - נמיר את הערך של i לטיפוס void* ונשלח אותו כארגומנט (למשל pthread_create(..., (void*)(long)i)). בתוך החוט נבצע המרה הפוכה מ-void* חזרה ל-int. בצורה זו כל חוט מקבל עותק של הערך בתוך ה-argument pointer עצמו ולא מצביע לכתובת משותפת."}, "difficulty_estimation": "Medium", "_source_file": "0110__Threads__Open__Medium.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:41:35"}, {"id": 10, "type": "Open", "topic": ["Threads", "Concurrency", "Memory Management"], "content": {"text": "סטודנט כתב תוכנית ב-C המשתמשת בחוטים (threads) כדי להדפיס את המזהה של כל חוט. הקוד נראה כך:", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* print_id(void* arg) {\n    int id = *((int*)arg);\n    printf(\"My ID is: %d\\n\", id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[4];\n    for (int i = 0; i < 4; i++) {\n        pthread_create(&threads[i], NULL, print_id, &i);\n    }\n    for (int i = 0; i < 4; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "הסטודנט הריץ את התוכנית וקיבל את הפלט הבא: \nMy ID is: 1\nMy ID is: 2\nMy ID is: 4\nMy ID is: 4\nהסבירו מדוע התוכנית לא הדפיסה את המספרים 0 עד 3 בסדר כלשהו, ומהי הבעיה בגישה לזיכרון בקוד זה.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "הציעו שתי דרכים שונות לתיקון הבעיה (שינוי הקוד כך שכל חוט ידפיס בוודאות מזהה ייחודי מ-0 עד 3), והסבירו את היתרון/חיסרון של כל אחת.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "אם נזיז את הקריאה ל-pthread_join אל תוך הלולאה הראשונה (מיד לאחר ה-pthread_create), האם הבעיה תיפתר? מה תהיה ההשפעה על זמן הריצה הכולל של התוכנית?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: הבעיה היא race condition על המשתנה i. הסטודנט מעביר לכל חוט מצביע לאותו מיקום בזיכרון (הכתובת של i במחסנית של main). בזמן שהחוטים נוצרים ומתחילים לרוץ, הלולאה ב-main ממשיכה להתקדם ולשנות את הערך של i. לכן, חוט עשוי לקרוא את הערך של i לאחר שהוא כבר גדל. בדוגמה, חוטים מסוימים קראו את אותו ערך, וערך 0 לא נקרא בכלל כי הלולאה התקדמה לפני שהחוט הראשון הספיק לקרוא מהזיכרון.\n\n10.2: דרך א: העברת הערך עצמו על ידי casting. במקום &i, נעביר (void*)(long)i. בחוט נבצע casting חזרה ל-int. יתרון: אין צורך בניהול זיכרון נוסף. חיסרון: מסתמך על כך שגודל מצביע גדול או שווה לגודל int.\nדרך ב: הקצאת מערך של מזהים או הקצאה דינמית (malloc) לכל חוט בנפרד. יתרון: בטוח וגנרי לכל סוג מידע. חיסרון: דורש ניהול זיכרון (שחרור).\n\n10.3: כן, הבעיה תיפתר כי ה-main thread ימתין לסיום כל חוט לפני שיקדם את i באיטרציה הבאה. עם זאת, התוכנית תהפוך לסדרתית לחלוטין (Sequential) ולא יהיה כל ניצול של מקביליות, מה שיבטל את המטרה של שימוש בחוטים."}, "difficulty_estimation": "Medium", "_source_file": "0111__Threads__Open__Medium.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:41:49"}, {"id": 7, "type": "Open", "topic": ["Threads", "User-level threads", "Kernel-level threads", "Concurrency"], "content": {"text": "סטודנט פיתח דפדפן אינטרנט פשוט המשתמש בספריית חוטים (threads) ברמת המשתמש (User-level threads) במימוש של Many-to-One (כלומר, כל חוטי המשתמש ממופים לחוט ליבה יחיד).", "code_snippet": null, "options": null}, "sub_questions": [{"id": "7.1", "text": "מה יקרה כאשר אחד החוטים בדפדפן מבצע קריאת מערכת חוסמת (Blocking system call), כמו למשל קריאת נתונים מהרשת? הסבירו את ההשפעה על שאר החוטים בתהליך.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "כיצד המעבר למודל של חוטי ליבה (Kernel-level threads) במודל One-to-One עשוי לשפר את ביצועי הדפדפן במקרה של פעולות קלט/פלט (I/O)?", "code_snippet": null, "options": null}, {"id": "7.3", "text": "נתון קטע הקוד הבא המשתמש ב-POSIX Threads. מה יהיה הפלט של התוכנית? הסבירו בקצרה את הקשר למרחב הכתובות של חוטים.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint global_val = 20;\n\nvoid* increment_func(void* arg) {\n    global_val += 10;\n    return NULL;\n}\n\nint main() {\n    pthread_t t1;\n    pthread_create(&t1, NULL, increment_func, NULL);\n    pthread_join(t1, NULL);\n    printf(\"Final value: %d\\n\", global_val);\n    return 0;\n}", "options": null}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: במודל Many-to-One, מערכת ההפעלה רואה רק את תהליך הליבה היחיד. כאשר חוט משתמש מבצע קריאת מערכת חוסמת, הליבה מעבירה את כל התהליך למצב המתנה (Waiting/Blocked). כתוצאה מכך, כל שאר החוטים באותו תהליך ייחסמו ולא יוכלו לרוץ, גם אם הם מוכנים לביצוע פעולות חישוב.\n\n7.2: במודל One-to-One, כל חוט משתמש ממופה לחוט ליבה נפרד. אם חוט אחד מבצע קריאת מערכת חוסמת, הליבה חוסמת רק את חוט הליבה הספציפי הזה. המתזמן (Scheduler) של מערכת ההפעלה יכול להמשיך להריץ חוטים אחרים של אותו תהליך על מעבדים פנויים, מה שמאפשר מקביליות אמיתית ושיפור ביצועים.\n\n7.3: הפלט יהיה: Final value: 30. הסיבה היא שחוטים (Threads) בתוך אותו תהליך חולקים את אותו מרחב כתובות, ובפרט הם חולקים את סגמנט הנתונים (Data segment) שבו נמצאים משתנים גלובליים. לכן, השינוי שביצע חוט t1 במשתנה global_val נראה מיד לחוט הראשי (main thread) לאחר סיום הריצה (pthread_join)."}, "difficulty_estimation": "Medium", "_source_file": "0112__Threads__Open__Medium.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:42:02"}, {"id": 10, "type": "Open", "topic": ["Threads", "Synchronization", "Condition Variables", "Deadlock"], "content": {"text": "במערכת הפעלה נתונה, ממומש מנגנון לניהול משאבים משותפים (Tokens). המנגנון מאפשר לתהליכונים לבקש מספר מסוים של אסימונים ולשחרר אותם בסיום השימוש. להלן קוד ה-C המממש את המנגנון באמצעות Pthreads:", "code_snippet": "#include <pthread.h>\n\nint available_tokens = 5;\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t c = PTHREAD_COND_INITIALIZER;\n\nvoid request_tokens(int n) {\n    pthread_mutex_lock(&m);\n    while (available_tokens < n) {\n        pthread_cond_wait(&c, &m);\n    }\n    available_tokens -= n;\n    pthread_mutex_unlock(&m);\n}\n\nvoid release_tokens(int n) {\n    pthread_mutex_lock(&m);\n    available_tokens += n;\n    pthread_cond_signal(&c);\n    pthread_mutex_unlock(&m);\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "הסבר מדוע השימוש ב-pthread_cond_signal בפונקציה release_tokens עלול להוביל למצב של Deadlock או הרעבה (Starvation) במערכת בה פועלים מספר תהליכונים המבקשים כמויות שונות של אסימונים. הדגם באמצעות תרחיש ספציפי.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "נניח שבתור למשתנה התנאי c ממתינים התהליכונים הבאים (לפי סדר הגעתם): T1 (מבקש 6 אסימונים), T2 (מבקש 2 אסימונים). כרגע available_tokens = 1. תהליכון T3 קורא ל-release_tokens(2). תאר את השתלשלות האירועים אם המימוש של pthread_cond_signal מעיר את התהליכון הראשון בתור (FIFO).", "code_snippet": null, "options": null}, {"id": "10.3", "text": "הצע שינוי מינימלי לקוד (שורת קוד אחת) שיפתור את הבעיה שהוצגה בסעיף 10.1, והסבר מדוע פתרון זה יעיל אך עלול להיות יקר מבחינת ביצועים.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: הבעיה נובעת מכך ש-pthread_cond_signal מעיר תהליכון אחד בלבד מהתור. אם התהליכון שהתעורר דורש יותר אסימונים ממה שיש כרגע ב-available_tokens, הוא יחזור לישון בתוך ה-while. הבעיה היא שהאות (signal) 'אבד' - ייתכן שישנם תהליכונים אחרים בתור שדרישתם קטנה יותר ויכלו להמשיך בריצה עם כמות האסימונים הנוכחית, אך הם לא התעוררו. אם כל התהליכונים שמשחררים אסימונים מסתמכים על signal בודד, המערכת עלולה להיתקע (Deadlock) למרות שיש מספיק משאבים.\n\n10.2: תרחיש: 1. available_tokens = 1. תהליכונים T1(6) ו-T2(2) ישנים בתור c. \n2. T3 משחרר 2 אסימונים: available_tokens מעודכן ל-3.\n3. T3 מבצע signal. לפי FIFO, התהליכון T1 מתעורר.\n4. T1 בודק את התנאי: 3 < 6, לכן הוא מבצע שוב wait וחוזר לישון.\n5. המשתנה available_tokens נשאר 3, אך T2 (שצריך רק 2) נשאר לישון כי אף אחד לא העיר אותו. המערכת במצב של Deadlock אם אין תהליכונים נוספים שיבצעו release.\n\n10.3: הפתרון הוא החלפת pthread_cond_signal(&c) ב-pthread_cond_broadcast(&c). פעולה זו תעיר את כל התהליכונים הממתינים. כל אחד מהם יבדוק את התנאי שלו בתורו (תחת הגנת המוטקס). מי שדרישתו נענית ימשיך, ומי שלא יחזור לישון. זה פותר את הבעיה כי מובטח שכל מי שיכול להתקדם יתעורר. החיסרון (Performance Overhead) הוא 'בעיית העדר' (Thundering Herd) - התעוררות המונית של תהליכונים שרובם יחזרו לישון מיד, מה שגורם להקשרים מיותרים (Context Switches) ותחרות על המוטקס."}, "difficulty_estimation": "Hard", "_source_file": "0113__Threads__Open__Hard.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:42:24"}, {"id": 10, "type": "Open", "topic": ["Threads", "Process Management", "Synchronization"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. התוכנית מבצעת יצירת חוט (thread) ולאחר מכן מבצעת fork(). הנח כי כל הקריאות למערכת מצליחות וכי התזמון מתבצע בדיוק כפי שמתואר בהערות (ה-sleep מבטיח סדר פעולות מסוים).", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\nint shared_data = 0;\n\nvoid* thread_work(void* arg) {\n    pthread_mutex_lock(&lock);\n    shared_data++;\n    sleep(5); // מחזיק את המנעול לזמן ממושך\n    pthread_mutex_unlock(&lock);\n    return NULL;\n}\n\nint main() {\n    pthread_t t1;\n    pthread_create(&t1, NULL, thread_work, NULL);\n    \n    sleep(1); // מבטיח ש-t1 יספיק לנעול את המוטקס\n\n    if (fork() == 0) {\n        // תהליך הבן\n        printf(\"Child process started...\\n\");\n        pthread_mutex_lock(&lock);\n        printf(\"Child: shared_data = %d\\n\", shared_data);\n        pthread_mutex_unlock(&lock);\n        return 0;\n    }\n\n    wait(NULL);\n    pthread_join(t1, NULL);\n    printf(\"Parent finished.\\n\");\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "האם תהליך הבן יצליח להדפיס את השורה \"Child: shared_data = 1\"? נמק את תשובתך תוך התייחסות למצב החוטים והמנעולים לאחר פעולת ה-fork().", "code_snippet": null, "options": null}, {"id": "10.2", "text": "כיצד ניתן להשתמש בפונקציה pthread_atfork() כדי לפתור את הבעיה שנוצרה? הסבר מה תפקיד כל אחד משלושת ה-handlers (prepare, parent, child).", "code_snippet": null, "options": null}, {"id": "10.3", "text": "נניח והמערכת הייתה משתמשת במודל Many-to-One (User-Level Threads) עבור ספריית ה-pthreads. כיצד הקריאה ל-sleep(5) בתוך thread_work הייתה משפיעה על ביצוע ה-fork() ב-main? הסבר.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: לא, תהליך הבן ייכנס למצב של Deadlock. כאשר מתבצע fork() בתהליך מרובה חוטים, רק החוט שקרא ל-fork() משוכפל לתהליך הבן. עם זאת, כל מצב הזיכרון (כולל המוטקסים) מועתק כפי שהוא. מכיוון שחוט t1 נעל את המוטקס לפני ה-fork, המוטקס בבן מועתק כשהוא במצב 'נעול'. מאחר וחוט t1 לא קיים בתהליך הבן, אין מי שישחרר את המנעול, והקריאה ל-pthread_mutex_lock בבן תחסום לעד.\n\n10.2: הפונקציה pthread_atfork(prepare, parent, child) מאפשרת לרשום פונקציות טיפול שיופעלו סביב ה-fork:\n- prepare: מופעלת בתהליך האב לפני ה-fork. שם ננעל את כל המוטקסים הרלוונטיים.\n- parent: מופעלת בתהליך האב לאחר ה-fork. שם נשחרר את המוטקסים.\n- child: מופעלת בתהליך הבן לאחר ה-fork. שם נשחרר את המוטקסים בתוך הכתובת של הבן (כך שהם יהיו פתוחים לשימוש בבן).\n\n10.3: במודל Many-to-One, כל החוטים של תהליך מסוים ממופים לחוט קרנל יחיד. אם חוט משתמש מבצע קריאת מערכת חוסמת (כמו sleep), הקרנל חוסם את כל תהליך המשתמש. לכן, thread_work יגרום לכל תהליך האב להיחסם ל-5 שניות, וה-main לא יגיע לקריאה ל-fork עד ש-t1 יסיים את ה-sleep וישחרר את המנעול. במקרה כזה, הבעיה מהסעיף הראשון לא תתרחש כי המנעול יהיה משוחרר בזמן ה-fork."}, "difficulty_estimation": "Hard", "_source_file": "0114__Threads__Open__Hard.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:42:49"}, {"id": 1, "type": "Open", "topic": ["Threads", "Synchronization", "Read-Write Locks", "Starvation"], "content": {"text": "לפניך מימוש חלקי בשפת C למנגנון Read-Write Lock המשתמש ב-Mutex וב-Condition Variable. המטרה היא לאפשר למספר קוראים (Readers) לגשת למשאב בו-זמנית, אך לאפשר לכותב (Writer) אחד בלבד גישה בלעדית.\nענה על הסעיפים הבאים תוך פירוט והסבר.", "code_snippet": "typedef struct {\n    int readers;\n    int writer_active;\n    pthread_mutex_t lock;\n    pthread_cond_t cond;\n} rwlock_t;\n\nvoid read_lock(rwlock_t *rw) {\n    pthread_mutex_lock(&rw->lock);\n    while (rw->writer_active)\n        pthread_cond_wait(&rw->cond, &rw->lock);\n    rw->readers++;\n    pthread_mutex_unlock(&rw->lock);\n}\n\nvoid read_unlock(rwlock_t *rw) {\n    pthread_mutex_lock(&rw->lock);\n    rw->readers--;\n    if (rw->readers == 0)\n        pthread_cond_broadcast(&rw->cond);\n    pthread_mutex_unlock(&rw->lock);\n}\n\nvoid write_lock(rwlock_t *rw) {\n    pthread_mutex_lock(&rw->lock);\n    while (rw->writer_active || rw->readers > 0)\n        pthread_cond_wait(&rw->cond, &rw->lock);\n    rw->writer_active = 1;\n    pthread_mutex_unlock(&rw->lock);\n}\n\nvoid write_unlock(rwlock_t *rw) {\n    pthread_mutex_lock(&rw->lock);\n    rw->writer_active = 0;\n    pthread_cond_broadcast(&rw->cond);\n    pthread_mutex_unlock(&rw->lock);\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "האם המימוש הנתון סובל מבעיית הרעבה (Starvation)? אם כן, איזה סוג תהליכונים (קוראים או כותבים) עלול לסבול מהרעבה ובאילו תנאים?", "code_snippet": null, "options": null}, {"id": "1.2", "text": "מדוע נעשה שימוש בלולאת while סביב הקריאה ל-pthread_cond_wait ולא בפקודת if? הסבר מה עלול לקרות אם נחליף את ה-while ב-if.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "נניח שהמערכת פועלת במודל תהליכונים Many-to-One (כלומר, כל תהליכוני המשתמש ממופים לתהליכון קרנל יחיד). תהליכון קורא מחזיק ב-lock ומבצע קריאת מערכת חוסמת (Blocking I/O) כגון read() מדיסק. כיצד הדבר ישפיע על תהליכון כותב הממתין ב-write_lock?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: כן, המימוש סובל מהרעבת כותבים (Writer Starvation). ב-read_lock, קורא חדש נחסם רק אם יש כותב פעיל (writer_active). אם יש קוראים פעילים וכותב ממתין ב-write_lock, קוראים חדשים שיגיעו יצליחו להעלות את rw->readers ולהיכנס למשאב, כי writer_active עדיין 0. אם זרם הקוראים הוא רציף, מספר הקוראים לעולם לא ירד ל-0, והכותב ימתין לנצח.\n\n1.2: השימוש ב-while הכרחי בגלל שתי סיבות: א. Spurious Wakeups - תהליכון עלול להתעורר מה-Condition Variable גם ללא שליחת סיגנל מפורש. ב. Mesa Semantics - ברגע שתהליכון מתעורר ומנסה לנעול את המוטקס מחדש, תהליכון אחר עלול 'להשתחל' ולשנות את התנאי (למשל, כותב אחר תפס את המשאב). לכן, יש לבדוק את התנאי שוב מיד עם החזרה מההמתנה.\n\n1.3: במודל Many-to-One, הקרנל אינו מודע לקיום תהליכוני המשתמש ורואה רק את תהליך ה-LWP היחיד. כאשר תהליכון משתמש מבצע קריאת מערכת חוסמת, כל התהליך (על כל תהליכוניו) נחסם ע\"י הקרנל. לכן, הכותב הממתין לא יוכל לקבל זמן מעבד אפילו אם הקורא סיים את פעולת ה-I/O, עד שהקרנל לא יחזיר את התהליך כולו למצב Ready."}, "difficulty_estimation": "Hard", "_source_file": "0115__Threads__Open__Hard.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:43:16"}, {"id": 10, "type": "Open", "topic": ["Threads", "Process Management", "Synchronization", "Deadlock"], "content": {"text": "במערכות הפעלה מודרניות, השילוב בין יצירת תהליכים (fork) לבין שימוש בחוטים (threads) עשוי להוביל למצבים מורכבים ובעייתיים. לפניכם קוד C המדגים סיטואציה כזו. הניחו כי כל הקריאות למערכת מצליחות וכי התזמון מתבצע בדיוק כפי שמתואר בהערות (sleep).", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid* thread_A(void* arg) {\n    pthread_mutex_lock(&lock);\n    printf(\"Thread A: Locked mutex, performing long task...\\n\");\n    sleep(10); \n    pthread_mutex_unlock(&lock);\n    return NULL;\n}\n\nvoid* thread_B(void* arg) {\n    sleep(1); // הבטחה שחוט א' יתפוס את המנעול קודם\n    printf(\"Thread B: Forking now...\\n\");\n    pid_t pid = fork();\n    \n    if (pid == 0) {\n        // תהליך הבן\n        printf(\"Child process: Attempting to lock mutex...\\n\");\n        pthread_mutex_lock(&lock);\n        printf(\"Child process: Success! Locked!\\n\");\n        pthread_mutex_unlock(&lock);\n    } else {\n        // תהליך האב\n        wait(NULL);\n        printf(\"Parent process: Child finished.\\n\");\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, thread_A, NULL);\n    pthread_create(&t2, NULL, thread_B, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "האם תהליך הבן יצליח להדפיס את השורה \"Child process: Success! Locked!\"? נמקו את תשובתכם תוך התייחסות למה שקורה לחוטים (Threads) ולמבני הנתונים בזיכרון בזמן ביצוע fork().", "code_snippet": null, "options": null}, {"id": "10.2", "text": "כיצד מנגנון ה-Copy-on-Write (COW) משפיע על מצב המנעול (mutex) בזיכרון של תהליך הבן ברגע ה-fork?", "code_snippet": null, "options": null}, {"id": "10.3", "text": "הציעו פתרון המשתמש בפונקציה pthread_atfork. הסבירו מה תפקידן של שלוש פונקציות ה-callback (prepare, parent, child) וכיצד הן מונעות את הבעיה שהתגלתה בסעיף 10.1.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: לא, תהליך הבן ייכנס למצב של Deadlock (קיפאון). כאשר מתבצע fork() בתהליך מרובה חוטים, רק החוט שקרא ל-fork() משוכפל בתהליך הבן. כל שאר החוטים (במקרה זה Thread A) אינם קיימים בבן. מכיוון ש-Thread A החזיק במנעול בזמן ה-fork, המנעול מועתק לבן כשהוא במצב 'תפוס' (Locked). מכיוון ש-Thread A לא קיים בבן כדי לשחרר את המנעול, החוט היחיד בבן ימתין לנצח.\n\n10.2: מנגנון ה-COW מבטיח שכל מרחב הכתובות, כולל מצב המנעול בזיכרון, יועתק לוגית לבן. בזיכרון הפיזי, עד שלא יבוצע שינוי, הבן והאב חולקים את אותם דפים. לכן, ביט ה-lock בתוך מבנה הנתונים של ה-mutex יועתק כשהוא דלוק (1). העובדה שמדובר בעותק נפרד (בסופו של דבר) לא עוזרת כאן, כי המצב הפנימי של האובייקט מעיד על כך שהוא תפוס על ידי ישות שאינה קיימת בבן.\n\n10.3: הפונקציה pthread_atfork מאפשרת לרשום פונקציות שירוצו בנקודות זמן קריטיות סביב ה-fork:\n1. prepare: רצה באב לפני ה-fork. עליה לנעול את המנעול (pthread_mutex_lock) כדי להבטיח מצב עקבי.\n2. parent: רצה באב אחרי ה-fork. עליה לשחרר את המנעול (pthread_mutex_unlock).\n3. child: רצה בבן אחרי ה-fork. עליה לשחרר את המנעול או לאתחל אותו מחדש. \nבצורה זו, מובטח שבזמן השכפול המנעול מוחזק ע\"י החוט המבצע, ולכן בבן הוא 'ישתחרר' בצורה מסודרת ע\"י פונקציית ה-child."}, "difficulty_estimation": "Hard", "_source_file": "0116__Threads__Open__Hard.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:43:37"}, {"id": 1, "type": "Open", "topic": ["Threads", "Synchronization", "Process Management", "Deadlock"], "content": {"text": "נתון קטע הקוד הבא בשפת C המשתמש בספריית pthreads ובפקודת המערכת fork. הנח כי התוכנית רצה על מערכת Linux מודרנית וכי כל הקריאות למערכת (pthread_create, fork) מצליחות. ענה על הסעיפים הבאים תוך פירוט ונימוק מלא.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\nint counter = 100;\n\nvoid* thread_work(void* arg) {\n    pthread_mutex_lock(&lock);\n    counter += 50;\n    sleep(20); // Hold the lock for a long time\n    pthread_mutex_unlock(&lock);\n    return NULL;\n}\n\nint main() {\n    pthread_t t1;\n    pthread_create(&t1, NULL, thread_work, NULL);\n    \n    sleep(2); // Ensure thread_work starts and acquires the lock\n    \n    pid_t pid = fork();\n    if (pid == 0) {\n        // Child process\n        printf(\"Child: Attempting to lock...\\n\");\n        pthread_mutex_lock(&lock);\n        counter += 10;\n        printf(\"Child counter: %d\\n\", counter);\n        pthread_mutex_unlock(&lock);\n    } else {\n        // Parent process\n        wait(NULL);\n        printf(\"Parent counter: %d\\n\", counter);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "כמה תהליכים וכמה חוטים (threads) סה\"כ יהיו קיימים במערכת מיד לאחר ביצוע שורת ה-fork? פרט כמה בכל תהליך.", "code_snippet": null, "options": null}, {"id": "1.2", "text": "האם תהליך הבן יצליח להדפיס את השורה \"Child counter: ...\"? הסבר את המנגנון הגורם לכך/מונע זאת.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "נניח שהורדנו את השורה (pthread_mutex_lock(&lock)) ואת ה-unlock מתהליך הבן. מה יהיה הפלט של תהליך האב ומה יהיה הפלט של תהליך הבן? התייחס למנגנון ה-Copy-on-Write.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: לאחר ה-fork יהיו 2 תהליכים. בתהליך האב יהיו 2 חוטים (החוט הראשי והחוט t1 שנוצר). בתהליך הבן יהיה חוט אחד בלבד. זאת מכיוון שעל פי תקן POSIX, כאשר תהליך מרובה חוטים מבצע fork, רק החוט שקרא ל-fork משוכפל לתהליך הבן. שאר החוטים אינם קיימים בבן.\n\n1.2: לא, תהליך הבן לא ידפיס את השורה. הוא ייכנס למצב של Deadlock. הסיבה היא שה-mutex משוכפל כחלק ממרחב הזיכרון של התהליך. מכיוון שבאב החוט t1 החזיק בנעילה בזמן ה-fork, ה-mutex משוכפל לבן כשהוא במצב 'נעול'. אולם, החוט שהחזיק בנעילה (t1) לא קיים בתהליך הבן, ולכן אין אף חוט שיכול לשחרר את הנעילה. החוט היחיד בבן ימתין לנצח ב-pthread_mutex_lock.\n\n1.3: אם נסיר את הנעילה בבן, הבן ידפיס: 'Child counter: 160' (הוא יורש את ה-counter מהאב אחרי ש-t1 כבר הוסיף 50, ואז מוסיף 10 משלו). האב ידפיס: 'Parent counter: 150'. למרות שהמשתנה גלובלי, fork יוצר מרחב כתובות נפרד. בתחילה שני התהליכים מצביעים לאותם דפים פיזיים (Copy-on-Write), אך ברגע שהבן מבצע כתיבה (counter += 10), נוצר עותק פרטי של הדף עבורו, ולכן השינוי בבן לא משפיע על האב."}, "difficulty_estimation": "Hard", "_source_file": "0117__Threads__Open__Hard.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:43:55"}, {"id": 1, "type": "Open", "topic": ["Threads", "Synchronization", "Mutex", "Condition Variables"], "content": {"text": "לפניכם קוד בשפת C המשתמש בספריית pthreads לניהול סנכרון בין תהליכונים. במערכת קיימים שני סוגי תהליכונים: 'Increasers' המעלים מונה משותף, ו-'Checkers' הממתינים שהמונה יגיע לערך סף N ואז מפחיתים ממנו. הנח כי כל הקריאות לפונקציות pthreads מצליחות ושאין בעיות זיכרון.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 5\nint counter = 0;\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\nvoid* increaser(void* arg) {\n    for(int i = 0; i < 1000; i++) {\n        pthread_mutex_lock(&lock);\n        counter++;\n        if (counter >= N) {\n            pthread_cond_broadcast(&cond);\n        }\n        pthread_mutex_unlock(&lock);\n    }\n    return NULL;\n}\n\nvoid* checker(void* arg) {\n    pthread_mutex_lock(&lock);\n    while (counter < N) {\n        pthread_cond_wait(&cond, &lock);\n    }\n    counter -= N;\n    pthread_mutex_unlock(&lock);\n    return NULL;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "מה יהיה הערך הסופי של המשתנה הגלובלי `counter` אם נריץ 10 תהליכוני `increaser` ו-2 תהליכוני `checker`, בהנחה שכל התהליכונים סיימו את ביצועם? פרטו את החישוב.", "code_snippet": null, "options": null}, {"id": "1.2", "text": "מדוע נעשה שימוש בלולאת `while` בשורה `while (counter < N)` בתוך פונקציית ה-`checker`? תארו תרחיש ספציפי (interleaving) שבו החלפת ה-`while` ב-`if` תוביל למצב שבו `counter` יהיה שלילי.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "נניח שהחלפנו את `pthread_cond_broadcast` ב-`pthread_cond_signal`. האם ייתכן מצב שבו תהליכון `checker` ימתין לנצח (Deadlock/Starvation) למרות שהתנאי `counter >= N` התקיים בשלב כלשהו? הסבירו.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: כל תהליכון increaser מבצע 1000 הגדלות. ישנם 10 תהליכונים כאלו, לכן סה\"כ יתבצעו 10,000 הגדלות (10 * 1000). כל תהליכון checker מבצע הפחתה אחת של הערך N (שהוא 5). ישנם 2 תהליכונים כאלו, לכן סה\"כ יופחתו 10 (2 * 5). הערך הסופי יהיה: 10,000 - 10 = 9,990.\n\n1.2: השימוש ב-while הכרחי בגלל Mesa Semantics. תרחיש שבו if יכשל: נניח ש-counter=4. שני תהליכוני checker (נקרא להם C1 ו-C2) נכנסים להמתנה ב-cond_wait. תהליכון increaser מעלה את המונה ל-5 וקורא ל-broadcast. שני ה-checkers מתעוררים ומנסים להשיג את ה-mutex. C1 משיג את ה-mutex ראשון, בודק את התנאי (שכבר נבדק לפני ה-wait), מפחית 5 מהמונה (counter=0) ומשחרר את ה-mutex. כעת C2 משיג את ה-mutex. אם היה נעשה שימוש ב-if, הוא היה ממשיך ישר להפחתה ומחסיר 5 מ-0, מה שמוביל ל-counter=-5. שימוש ב-while מכריח את C2 לבדוק שוב את התנאי, לגלות שהוא שוב קטן מ-N ולחזור להמתין.\n\n1.3: כן. במצב שבו יש מספר checkers הממתינים, signal מעיר רק תהליכון אחד. אם התהליכון שהתעורר לא מצליח לסיים את עבודתו (למשל, אם התנאי השתנה שוב לפני שהשיג את ה-lock) או אם ישנם מספר checkers שצריכים להתעורר כדי לצרוך את המשאבים שהצטברו (למשל counter=10), שימוש ב-signal עלול להשאיר checkers אחרים ישנים לנצח למרות שהמשאב זמין. עם זאת, בקוד הספציפי הזה, הבעיה העיקרית ב-signal היא אובדן הודעות (Lost Wakeups) אם ה-signal נשלח כשאין אף אחד שממתין, אך כאן ה-broadcast מבטיח שכל מי שצריך להתעורר יתעורר."}, "difficulty_estimation": "Hard", "_source_file": "0118__Threads__Open__Hard.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:44:21"}, {"id": 7, "type": "Open", "topic": ["Threads", "Process Management", "Synchronization", "Deadlock"], "content": {"text": "נתון קוד בשפת C המשתמש בספריית pthreads. התוכנית מדגימה אינטראקציה בין חוטים (threads) לבין יצירת תהליך חדש באמצעות fork. עליכם לנתח את התנהגות המערכת ולענות על השאלות הבאות. הניחו כי כל הקריאות למערכת מצליחות וכי התזמון מתבצע בדיוק כפי שמתואר ב-sleep.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint counter = 0;\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid* thread_func(void* arg) {\n    pthread_mutex_lock(&lock);\n    counter++;\n    sleep(10); // מדמה עבודה ממושכת תחת נעילה\n    pthread_mutex_unlock(&lock);\n    return NULL;\n}\n\nint main() {\n    pthread_t t1;\n    pthread_create(&t1, NULL, thread_func, NULL);\n    sleep(1); // מבטיח שהחוט t1 התחיל ונעל את המוטקס\n\n    int pid = fork();\n    if (pid == 0) {\n        // תהליך הבן\n        printf(\"Child: Attempting to lock...\\n\");\n        pthread_mutex_lock(&lock);\n        printf(\"Child: Counter is %d\\n\", counter);\n        pthread_mutex_unlock(&lock);\n        return 0;\n    } else {\n        // תהליך האב\n        wait(NULL);\n        printf(\"Parent: Finished\\n\");\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "האם תהליך הבן ידפיס את השורה \"Child: Counter is 1\"? נמקו את תשובתכם תוך התייחסות למצב ה-Mutex ולמבנה התהליך בבן.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "מה יקרה לתהליך האב במקרה זה? האם הוא יגיע להדפסה \"Parent: Finished\"?", "code_snippet": null, "options": null}, {"id": "7.3", "text": "כיצד שימוש בפונקציה pthread_atfork יכול לפתור את הבעיה? הסבירו את תפקיד שלושת ה-callbacks שהיא מקבלת.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: לא, תהליך הבן לא ידפיס את השורה. ב-POSIX, כאשר תהליך המכיל מספר חוטים מבצע fork, רק החוט שקרא ל-fork משוכפל לתהליך הבן. החוט thread_func שביצע את הנעילה אינו קיים בבן. עם זאת, ה-fork מעתיק את כל מרחב הכתובות כפי שהוא, כולל את מצב ה-Mutex. מכיוון שהמוטקס היה נעול באב ברגע ה-fork, הוא מועתק כשהוא במצב 'נעול' לבן. כיוון שהחוט היחיד שיכול לשחרר את הנעילה (thread_func) לא קיים בבן, הבן ייכנס למצב של Deadlock בניסיון לנעול את המוטקס.\n\n7.2: תהליך האב לא יסיים את ריצתו. האב קורא ל-wait(NULL) וממתין לסיום תהליך הבן. מכיוון שתהליך הבן תקוע ב-Deadlock ולעולם לא יסתיים, האב יישאר במצב המתנה (Blocked) לנצח.\n\n7.3: הפונקציה pthread_atfork מאפשרת לרשום handlers שירוצו בנקודות זמן קריטיות סביב ה-fork: \n1. prepare: רץ באב לפני ה-fork. שם ננעל את כל המוטקסים כדי להבטיח מצב עקבי.\n2. parent: רץ באב מיד אחרי ה-fork. שם נשחרר את המוטקסים.\n3. child: רץ בבן מיד אחרי ה-fork. שם נשחרר (re-initialize/unlock) את המוטקסים כדי שהבן יתחיל עם מוטקסים פתוחים ויוכל להשתמש בהם."}, "difficulty_estimation": "Hard", "_source_file": "0119__Threads__Open__Hard.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:44:44"}, {"id": 1, "type": "Open", "topic": ["Threads", "Synchronization", "Race Conditions", "Pthreads"], "content": {"text": "לפניכם מימוש בשפת C של מנגנון 'מחסום' (Barrier) המיועד לשימוש על ידי N תהליכונים (Threads). המטרה היא שכל תהליכון ימתין בנקודת המחסום עד שכל ה-N תהליכונים יגיעו אליה, ורק אז כולם ימשיכו בביצוע. המתכנת מעוניין שהמחסום יהיה 'רב-פעמי' (Reusable), כלומר שניתן יהיה להשתמש בו בלולאה.", "code_snippet": "int count = 0;\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cv = PTHREAD_COND_INITIALIZER;\n\nvoid barrier_wait(int N) {\n    pthread_mutex_lock(&m);\n    count++;\n    if (count == N) {\n        count = 0;\n        pthread_cond_broadcast(&cv);\n    } else {\n        pthread_cond_wait(&cv, &m);\n    }\n    pthread_mutex_unlock(&m);\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "נניח שהתהליכונים מריצים את הפונקציה הבאה: \nvoid* worker(void* arg) {\n    for(int i=0; i<100; i++) {\n        // Do some work\n        barrier_wait(N);\n    }\n    return NULL;\n}\nהסבירו מדוע המימוש הנתון של barrier_wait אינו תקין עבור שימוש חוזר (reusable barrier) ועלול לגרום לקיפאון (Deadlock) או להתנהגות לא צפויה.", "code_snippet": null, "options": null}, {"id": "1.2", "text": "כיצד תופעת ה-Spurious Wakeup משפיעה על הקוד הנתון? הציעו תיקון לקוד הקיים (ברמת הלוגיקה) שפותר גם את בעיית ה-Spurious Wakeup וגם את בעיית השימוש החוזר.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "6.1: הבעיה המרכזית במימוש היא ה-Race Condition שנוצר בין איטרציות שונות של הלולאה. כאשר התהליכון ה-N מגיע, הוא מאפס את count ל-0 ומבצע broadcast. תהליכון 'מהיר' עשוי להתעורר, לסיים את barrier_wait, לבצע את העבודה של האיטרציה הבאה ולקרוא שוב ל-barrier_wait לפני שתהליכון 'איטי' מהאיטרציה הקודמת בכלל הצליח להתעורר או לצאת מהפונקציה. התהליכון המהיר יקדם את count ל-1, בעוד שתהליכונים אחרים עדיין שייכים ל'סיבוב' הקודם. במצב קיצוני, תהליכון מהיר יכול להשלים סיבוב שלם ולגרום ל-broadcast נוסף בזמן שתהליכונים מהסיבוב הקודם עדיין מחכים, מה שיגרום לערבוב של תהליכונים מאיטרציות שונות וסיכוי גבוה לקיפאון (Deadlock) כי ה-count לא ישקף נכונה את מספר המחכים לסיבוב הנוכחי.\n\n6.2: Spurious Wakeup היא תופעה בה תהליכון מתעורר מ-pthread_cond_wait ללא קבלת סיגנל. בקוד הנתון, אם תהליכון מתעורר בטעות לפני ש-count == N, הוא ימשיך לביצוע (Phase 2) למרות ששאר התהליכונים טרם הגיעו. הפתרון המקובל הוא עטיפת ה-wait בלולאת while. \nכדי לפתור את שתי הבעיות (כולל ה-reusable barrier), ניתן להשתמש בטכניקה של 'דורות' (Generations) או Sense-Reversing Barrier. בשיטה זו, מחזיקים משתנה נוסף המייצג את הדור הנוכחי. תהליכון מחכה עד שהדור משתנה: \nvoid barrier_wait(int N) {\n    pthread_mutex_lock(&m);\n    int my_gen = generation;\n    count++;\n    if (count == N) {\n        count = 0;\n        generation++;\n        pthread_cond_broadcast(&cv);\n    } else {\n        while (my_gen == generation)\n            pthread_cond_wait(&cv, &m);\n    }\n    pthread_mutex_unlock(&m);\n}\nכך, גם אם תהליכון מהיר נכנס שוב, הוא יגדיל את count עבור הדור הבא, בעוד שהתהליכונים האיטיים מחכים לשינוי ב-generation."}, "difficulty_estimation": "Hard", "_source_file": "0120__Threads__Open__Hard.json", "_topic_hint": "Threads", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:45:03"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Condition"], "content": {"text": "לפניכם קוד בשפת C המשתמש בספריית pthreads. נניח שכל הקריאות למערכת מצליחות והתוכנית רצה על מערכת עם מעבד מרובה ליבות. מה ניתן לומר על הפלט של התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint count = 0;\n\nvoid* task(void* arg) {\n    for (int i = 0; i < 1000; i++) {\n        count++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, task, NULL);\n    pthread_create(&t2, NULL, task, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\", count);\n    return 0;\n}", "options": ["הפלט יהיה תמיד 1000.", "הפלט יהיה תמיד 2000.", "הפלט יהיה בטווח [2, 2000] ולא ניתן לחיזוי מראש.", "התוכנית לא תעבור קומפילציה כי count הוא משתנה גלובלי."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "הפלט יהיה בטווח [2, 2000] ולא ניתן לחיזוי מראש.", "explanation": "הקוד מדגים מצב מרוץ (Race Condition). הפעולה ++count אינה פעולה אטומית (Atomic Operation) ברמת שפת המכונה; היא מורכבת משלושה שלבים: קריאת הערך מהזיכרון לרגיסטר, הוספת 1, וכתיבת הערך חזרה לזיכרון. מכיוון ששני החוטים (Threads) ניגשים לאותו משתנה גלובלי ומשנים אותו ללא מנגנון סנכרון (כמו Mutex), חוט אחד עלול לקרוא ערך ישן בזמן שהחוט השני מעדכן אותו, ובכך 'לדרוס' את העדכון של החוט השני. לכן, התוצאה הסופית אינה דטרמיניסטית ויכולה להיות כל ערך בין 2 ל-2000 (במקרים קיצוניים של תזמון)."}, "difficulty_estimation": "Easy", "_source_file": "0121__Threads__CodeAnalysis__Easy.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:45:20"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Threads", "Pthreads", "Shared Memory"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. מה יהיה הפלט של התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint shared_val = 5;\n\nvoid* thread_func(void* arg) {\n    int val = *((int*)arg);\n    shared_val += val;\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    int a = 10, b = 20;\n\n    pthread_create(&t1, NULL, thread_func, &a);\n    pthread_join(t1, NULL);\n\n    pthread_create(&t2, NULL, thread_func, &b);\n    pthread_join(t2, NULL);\n\n    printf(\"%d\", shared_val);\n    return 0;\n}", "options": ["5", "15", "25", "35"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "35", "explanation": "התוכנית מתחילה עם משתנה גלובלי shared_val שערכו 5. בשלב הראשון נוצר חוט t1 שמקבל את הערך 10 ומוסיף אותו ל-shared_val. מכיוון שמתבצע pthread_join מיד לאחר מכן, תהליך ה-main עוצר ומחכה ש-t1 יסיים. לאחר ש-t1 מסיים, ערכו של shared_val הוא 15. רק אז נוצר חוט t2 שמקבל את הערך 20 ומוסיף אותו ל-shared_val. שוב מתבצע join ולכן ה-main מחכה ל-t2. בסיום, shared_val שווה ל-35 והוא מודפס למסך. מכיוון שהצטרפות החוטים (join) נעשית באופן סדרתי, אין כאן מצב מרוץ (Race Condition) והתוצאה דטרמיניסטית."}, "difficulty_estimation": "Easy", "_source_file": "0122__Threads__CodeAnalysis__Easy.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:45:35"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Pthreads"], "content": {"text": "מה יהיה הפלט של התוכנית הבאה המשתמשת בספריית pthreads? הניחו כי כל הקריאות לספרייה מצליחות.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 5;\n\nvoid* task(void* arg) {\n    counter += 10;\n    return NULL;\n}\n\nint main() {\n    pthread_t t1;\n    pthread_create(&t1, NULL, task, NULL);\n    pthread_join(t1, NULL);\n    printf(\"%d\", counter);\n    return 0;\n}", "options": ["5", "10", "15", "ערך לא ידוע עקב Race Condition"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "15", "explanation": "התוכנית יוצרת חוט (Thread) חדש שמבצע את הפונקציה task. פונקציה זו מוסיפה 10 למשתנה הגלובלי counter, שערכו ההתחלתי הוא 5. מכיוון שהתהליך הראשי קורא ל-pthread_join, הוא ממתין לסיום הביצוע של חוט t1 לפני שהוא ממשיך לשורת ההדפסה. לכן, מובטח כי הפעולה בחוט תסתיים לפני ה-printf, והתוצאה תהיה 15. אין כאן Race Condition על אף הגישה למשתנה משותף, כיוון שה-join מסנכרן את סדר הפעולות."}, "difficulty_estimation": "Easy", "_source_file": "0123__Threads__CodeAnalysis__Easy.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:45:45"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Shared Memory"], "content": {"text": "נתון קטע הקוד הבא בשפת C המשתמש בספריית pthreads. מה יהיה הפלט של התוכנית בהנחה שכל הקריאות למערכת מצליחות?", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint x = 10;\n\nvoid* thread_func(void* arg) {\n    x += 5;\n    return NULL;\n}\n\nint main() {\n    pthread_t t;\n    pthread_create(&t, NULL, thread_func, NULL);\n    pthread_join(t, NULL);\n    printf(\"%d\", x);\n    return 0;\n}", "options": ["5", "10", "15", "0"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "15", "explanation": "התוכנית מגדירה משתנה גלובלי x המאותחל ל-10. חוטים (threads) באותו תהליך חולקים את אותו מרחב כתובות, ולכן לחוט החדש שנוצר יש גישה ישירה למשתנה x. הפונקציה thread_func מוסיפה 5 לערך של x. הפונקציה pthread_join גורמת לחוט הראשי (main) להמתין עד שהחוט החדש יסיים את פעולתו לפני שהוא ממשיך לשורת ההדפסה. לכן, בזמן הקריאה ל-printf, הערך של x כבר עודכן ל-15."}, "difficulty_estimation": "Easy", "_source_file": "0124__Threads__CodeAnalysis__Easy.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:46:05"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. מה יהיה הפלט של התוכנית בהנחה שכל קריאות המערכת מצליחות?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint x = 10;\n\nvoid* my_thread(void* arg) {\n    x = x * 2;\n    return NULL;\n}\n\nint main() {\n    pthread_t t;\n    pthread_create(&t, NULL, my_thread, NULL);\n    pthread_join(t, NULL);\n    printf(\"%d\", x);\n    return 0;\n}", "options": ["10", "20", "0", "הפלט אינו קבוע"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "20", "explanation": "התוכנית מגדירה משתנה גלובלי x המשותף לכל החוטים בתהליך. חוט חדש נוצר ומבצע הכפלה של x ב-2. הפונקציה pthread_join גורמת לחוט הראשי (main) להמתין עד לסיום ביצועו של החוט החדש. לכן, ההדפסה תתבצע רק לאחר ש-x עודכן ל-20."}, "difficulty_estimation": "Easy", "_source_file": "0125__Threads__CodeAnalysis__Easy.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:46:16"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Shared Memory"], "content": {"text": "מה יהיה הפלט של התוכנית הבאה המשתמשת בחוטים (threads)? הניחו שכל הקריאות למערכת מצליחות.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 10;\n\nvoid* func(void* arg) {\n    counter += 5;\n    return NULL;\n}\n\nint main() {\n    pthread_t t1;\n    pthread_create(&t1, NULL, func, NULL);\n    pthread_join(t1, NULL);\n    printf(\"%d\", counter);\n    return 0;\n}", "options": ["5", "10", "15", "הפלט אינו קבוע"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "15", "explanation": "התוכנית מגדירה משתנה גלובלי בשם counter עם ערך התחלתי 10. בתוך ה-main נוצר חוט (thread) חדש המריץ את הפונקציה func, אשר מוסיפה 5 למשתנה הגלובלי. מכיוון שהתהליך הראשי קורא ל-pthread_join, הוא ממתין עד לסיום ביצוע החוט t1 לפני שהוא ממשיך לשורת ההדפסה. לכן, מובטח שהשינוי למשתנה counter יתבצע לפני ההדפסה, והתוצאה תהיה 15."}, "difficulty_estimation": "Easy", "_source_file": "0126__Threads__CodeAnalysis__Easy.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:46:26"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Conditions"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. מהם הערכים האפשריים שיכולים להיות מודפסים ע\"י פקודת ה-printf בסיום ריצת התוכנית?", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint counter = 0;\n\nvoid* thread_func(void* arg) {\n    int temp = counter;\n    counter = temp + 1;\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, thread_func, NULL);\n    pthread_create(&t2, NULL, thread_func, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\", counter);\n    return 0;\n}", "options": ["0", "1", "2", "1 או 2"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "1 או 2", "explanation": "הקוד יוצר שני חוטים (threads) הניגשים לאותו משתנה גלובלי (counter) ללא שימוש במנגנוני סנכרון כמו Mutex. במצב שבו החוטים רצים אחד אחרי השני באופן מלא, הערך הסופי יהיה 2. אולם, ייתכן מצב של Race Condition שבו שני החוטים קוראים את הערך ההתחלתי 0 לתוך המשתנה המקומי temp, שניהם מחשבים temp + 1 = 1, ושניהם כותבים את הערך 1 חזרה למשתנה הגלובלי. במקרה כזה, אחת מההגדלות תאבד והפלט יהיה 1."}, "difficulty_estimation": "Easy", "_source_file": "0127__Threads__CodeAnalysis__Easy.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:46:49"}, {"id": 101, "type": "CodeAnalysis", "topic": ["Threads", "Shared Memory"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. מה יהיה הפלט של התוכנית בהנחה שכל קריאות המערכת מצליחות?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint global_var = 20;\n\nvoid* thread_routine(void* arg) {\n    global_var += 30;\n    return NULL;\n}\n\nint main() {\n    pthread_t tid;\n    if (pthread_create(&tid, NULL, thread_routine, NULL) != 0) {\n        return 1;\n    }\n    pthread_join(tid, NULL);\n    printf(\"%d\", global_var);\n    return 0;\n}", "options": ["20", "30", "50", "הפלט אינו דטרמיניסטי"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "50", "explanation": "בניגוד לתהליכים הנוצרים על ידי fork, חוטים (threads) בתוך אותו תהליך חולקים את אותו מרחב כתובות, ובפרט את המשתנים הגלובליים. החוט שנוצר ב-pthread_create ניגש למשתנה global_var ומעדכן אותו ל-50 (20+30). מכיוון שהחוט הראשי קורא ל-pthread_join, הוא ממתין לסיום ביצוע החוט השני לפני שהוא ממשיך להדפסה, ולכן יודפס הערך המעודכן 50."}, "difficulty_estimation": "Easy", "_source_file": "0128__Threads__CodeAnalysis__Easy.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:47:04"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Memory Sharing", "Pthreads"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. מה מהבאים מתאר נכונה את הפלטים האפשריים של התוכנית? הניחו כי כל הקריאות למערכת מצליחות.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n\nvoid* print_val(void* arg) {\n    int val = *((int*)arg);\n    printf(\"%d\", val);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[3];\n    for (int i = 0; i < 3; i++) {\n        pthread_create(&threads[i], NULL, print_val, &i);\n    }\n    for (int i = 0; i < 3; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": ["א. הפלט תמיד יהיה 012 (בסדר כלשהו).", "ב. הפלט תמיד יהיה 333.", "ג. ייתכנו פלטים כמו 123, 333, או 023.", "ד. התוכנית תדפיס תמיד 000 כיוון שזה הערך ההתחלתי של i."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "הבעיה המרכזית בקוד היא שכל שלושת החוטים (threads) מקבלים כארגומנט את הכתובת של אותו משתנה מקומי i (כלומר &i). כיוון שהחוטים רצים במקביל ללולאת ה-main, הערך בכתובת זו עשוי להשתנות על ידי לולאת ה-for בטרם החוט הספיק לקרוא אותו. בסיום הלולאה הראשונה, ערכו של i הוא 3. לכן, כל חוט עשוי לקרוא כל ערך ש-i קיבל במהלך הריצה (0, 1, 2) או את הערך הסופי (3), תלוי בתזמון (scheduling) של החוטים ביחס ללולאה ב-main. לכן פלטים המכילים 3 או חזרות על מספרים הם אפשריים בהחלט."}, "difficulty_estimation": "Medium", "_source_file": "0129__Threads__CodeAnalysis__Medium.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:47:17"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Race Conditions", "Concurrency"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. בתוכנית זו, שני חוטים ניגשים למשתנה גלובלי משותף x ומעדכנים אותו ללא שימוש במנגנוני סנכרון (כגון Mutex). מהו הערך המינימלי האפשרי שיודפס על המסך בסיום ריצת התוכנית? הניחו שפעולת העדכון x = x + y מורכבת משלושה שלבים: קריאת הערך של x מהזיכרון לאוגר, הוספת y לאוגר, וכתיבת הערך מהאוגר חזרה לזיכרון.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint x = 10;\n\nvoid* thread_func(void* arg) {\n    int y = *(int*)arg;\n    x = x + y;\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    int val1 = 5, val2 = 10;\n    pthread_create(&t1, NULL, thread_func, &val1);\n    pthread_create(&t2, NULL, thread_func, &val2);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\\n\", x);\n    return 0;\n}", "options": ["א. 10", "ב. 15", "ג. 20", "ד. 25"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "הערך ההתחלתי של x הוא 10. חוט t1 אמור להוסיף 5 (סך הכל 15) וחוט t2 אמור להוסיף 10 (סך הכל 20). ללא סנכרון, תיתכן תחרות (Race Condition). הערך המינימלי מתקבל בתרחיש הבא: 1. חוט t1 קורא את הערך x=10 לתוך אוגר מקומי. 2. מתבצעת החלפת הקשר (Context Switch) וחוט t2 רץ במלואו: הוא קורא 10, מוסיף 10 וכותב 20 ל-x. 3. חוט t1 ממשיך מהנקודה שעצר: באוגר שלו עדיין שמור הערך 10, הוא מוסיף לו 5 וכותב את התוצאה 15 לתוך x. פעולה זו דורסת את העדכון של חוט t2. לכן, הערך המינימלי האפשרי הוא 15."}, "difficulty_estimation": "Medium", "_source_file": "0130__Threads__CodeAnalysis__Medium.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:47:49"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Pthreads", "Race Conditions", "Memory Sharing"], "content": {"text": "לפניכם קוד בשפת C המשתמש בספריית pthreads. התוכנית יוצרת שלושה חוטים (threads), כאשר כל חוט אמור להדפיס את אינדקס הלולאה שבו הוא נוצר. מה ניתן לומר על הפלט של התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nvoid* print_id(void* arg) {\n    int id = *(int*)arg;\n    printf(\"%d \", id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[3];\n    for (int i = 0; i < 3; i++) {\n        pthread_create(&threads[i], NULL, print_id, &i);\n    }\n    for (int i = 0; i < 3; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": ["א. הפלט יהיה תמיד 0 1 2 בסדר כלשהו.", "ב. הפלט יהיה תמיד 0 1 2 בסדר עולה.", "ג. ייתכן שהפלט יכיל ערכים כפולים (למשל 1 1 2) או את הערך 3.", "ד. הקוד לא יתקמפל עקב ניסיון להעביר מצביע למשתנה מקומי.", "ה. הפלט יהיה תמיד 3 3 3."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "הבעיה בקוד נובעת מכך שכל החוטים מקבלים כארגומנט את אותה הכתובת בזיכרון - הכתובת של המשתנה i שנמצא במחסנית של פונקציית ה-main. מכיוון שהחוטים רצים במקביל לחוט הראשי שמקדם את i, נוצר מצב של מרוץ (Race Condition). עד שחוט מסוים מספיק לבצע את ה-dereference למצביע שקיבל, ערכו של i ב-main כבר עשוי להשתנות. במקרה קיצון, אם ה-main מסיים את הלולאה לפני שמי מהחוטים התחיל לפעול, כולם עשויים להדפיס 3 (הערך שבו i עוצר את הלולאה). לכן, ייתכנו כפילויות וערכים מחוץ לטווח המקורי 0-2."}, "difficulty_estimation": "Medium", "_source_file": "0131__Threads__CodeAnalysis__Medium.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:48:15"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Pthreads", "Concurrency", "Race Conditions"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. מה ניתן לומר על הפלט של התוכנית בהרצה טיפוסית במערכת מרובת ליבות?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n\nvoid* thread_func(void* arg) {\n    int id = *(int*)arg;\n    printf(\"%d \", id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[4];\n    for (int i = 0; i < 4; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 4; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": ["א. הפלט יהיה תמיד 0 1 2 3 (בסדר כלשהו).", "ב. הפלט יהיה תמיד 4 4 4 4.", "ג. הפלט עשוי להכיל ספרות בין 0 ל-4, כאשר ייתכן שספרה מסוימת תודפס יותר מפעם אחת וספרה אחרת לא תודפס כלל.", "ד. התוכנית תגרום לשגיאת סגמנטציה (Segmentation Fault) כיוון שכל החוטים ניגשים לאותו משתנה i."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "הבעיה המרכזית בקוד היא העברת הכתובת של משתנה הלולאה i לכל החוטים. כיוון שכל החוטים חולקים את אותו מרחב כתובות, כל חוט מקבל מצביע לאותו מיקום בזיכרון (המחסנית של main). בזמן שחוט אחד נוצר ומתחיל את ריצתו, הלולאה ב-main ממשיכה לרוץ ומעדכנת את הערך של i. כתוצאה מכך, עד שחוט מסוים ניגש לזיכרון כדי לקרוא את הערך של id, הערך של i עשוי להשתנות. ייתכן שחוט יקרא את הערך 1, 2, 3 או אפילו 4 (אם הלולאה הסתיימה לפני שהחוט ניגש לזיכרון). לכן, הפלט אינו צפוי ויכול לכלול חזרות על מספרים."}, "difficulty_estimation": "Medium", "_source_file": "0132__Threads__CodeAnalysis__Medium.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:48:30"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Pthreads", "Concurrency"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. בהנחה שכל הקריאות למערכת מצליחות, וכי פעולת הקידום (count++) מתבצעת באופן אטומי (כלומר, אין איבוד עדכונים עקב Race Condition), מה יהיה הפלט של התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint count = 0;\n\nvoid* increment(void* arg) {\n    int limit = *(int*)arg;\n    for (int i = 0; i < limit; i++) {\n        count++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2, t3;\n    int val1 = 10, val2 = 20, val3 = 30;\n\n    pthread_create(&t1, NULL, increment, &val1);\n    pthread_join(t1, NULL);\n\n    pthread_create(&t2, NULL, increment, &val2);\n    pthread_create(&t3, NULL, increment, &val3);\n\n    pthread_join(t2, NULL);\n    pthread_join(t3, NULL);\n\n    printf(\"%d\", count);\n    return 0;\n}", "options": ["א. 30", "ב. 50", "ג. 60", "ד. 10", "ה. התוצאה אינה קבועה"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "התוכנית מתחילה בביצוע ה-main. החוט הראשון (t1) נוצר עם הערך 10. פקודת ה-pthread_join(t1) גורמת לתהליך הראשי להמתין עד ש-t1 יסיים. בשלב זה count שווה ל-10. לאחר מכן, נוצרים שני חוטים נוספים (t2 ו-t3) כמעט במקביל. t2 מבצע 20 איטרציות ו-t3 מבצע 30 איטרציות. מכיוון שצוין בשאלה שיש להניח שאין Race Condition (פעולות אטומיות), הערך הסופי של count יהיה סכום כל ההוספות שבוצעו על ידי כל החוטים: 10 (מ-t1) + 20 (מ-t2) + 30 (מ-t3) = 60."}, "difficulty_estimation": "Medium", "_source_file": "0133__Threads__CodeAnalysis__Medium.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:48:46"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Pthreads", "Race Conditions", "Shared Memory"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. התוכנית יוצרת שלושה חוטים (threads), כאשר כל אחד מהם אמור להדפיס את המספר שקיבל כארגומנט ולעדכן מונה גלובלי. מה ניתן לומר על פלט התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\n\nvoid* task(void* arg) {\n    int id = *(int*)arg;\n    printf(\"%d\", id);\n    counter++;\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[3];\n    for (int i = 0; i < 3; i++) {\n        pthread_create(&threads[i], NULL, task, &i);\n    }\n    for (int i = 0; i < 3; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    printf(\" C%d\", counter);\n    return 0;\n}", "options": ["א. הפלט תמיד יהיה הצירוף '012 C3' בסדר כלשהו של הספרות.", "ב. הפלט יהיה תמיד '333 C3'.", "ג. ייתכן שהפלט יכיל את הספרה 3, וייתכן שספרות מסוימות יופיעו יותר מפעם אחת (למשל '133 C2').", "ד. התוכנית תמיד תדפיס '012 C0' כי המונה לא מתעדכן בחוט הראשי.", "ה. תתרחש שגיאת סגמנטציה כיוון שהגישה לכתובת של i אינה מותרת מהחוטים."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "הקוד מדגים שתי בעיות סנכרון נפוצות: 1. העברת מצביע למשתנה מקומי (i) שערכו משתנה בחוט אחר. כל החוטים מקבלים את אותה כתובת בזיכרון. כיוון שהחוט הראשי ממשיך לרוץ ולקדם את i, בזמן שהחוטים החדשים ניגשים לכתובת זו, הערך בה עשוי להיות כל אחד מערכי הלולאה או ערך הסיום (3). לכן ייתכנו כפילויות או הופעה של הספרה 3. 2. קיימת תחרות (Race Condition) על המשתנה הגלובלי counter. הפעולה ++ אינה אטומית, ולכן אם שני חוטים ינסו לעדכן אותו בו-זמנית, ייתכן שעדכון אחד ידרס והערך הסופי יהיה קטן מ-3."}, "difficulty_estimation": "Medium", "_source_file": "0134__Threads__CodeAnalysis__Medium.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:49:10"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Race Conditions", "Concurrency", "Pthreads"], "content": {"text": "לפניך קטע קוד בשפת C המשתמש בספריית pthreads. התוכנית יוצרת שני חוטים (threads) המבצעים כל אחד 100 איטרציות של קידום משתנה גלובלי משותף `counter`. מהו הערך המינימלי האפשרי שיודפס על ידי הפקודה `printf` בסיום ריצת התוכנית?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\n\nvoid* func(void* arg) {\n    for (int i = 0; i < 100; i++) {\n        int temp = counter;\n        counter = temp + 1;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, func, NULL);\n    pthread_create(&t2, NULL, func, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\\n\", counter);\n    return 0;\n}", "options": ["א. 1", "ב. 2", "ג. 100", "ד. 200"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "הפעולה counter = temp + 1 אינה אטומית, ולכן נוצר מרוץ תהליכים (Race Condition). הערך המינימלי האפשרי עבור שני חוטים המבצעים N קידומים כל אחד הוא 2. \nתרחיש לדוגמה המביא לערך 2: \n1. חוט א' קורא את הערך 0 לתוך temp ונרדם.\n2. חוט ב' רץ 99 איטרציות מלאות, ומעדכן את counter ל-99.\n3. חוט א' מתעורר, מחשב 0+1 וכותב ל-counter את הערך 1 (בכך הוא דורס את ה-99 של חוט ב').\n4. חוט ב' מתחיל את האיטרציה ה-100 שלו, קורא את הערך 1 לתוך temp ונרדם.\n5. חוט א' מתעורר ומבצע את כל 99 האיטרציות הנותרות שלו עד הסוף. הערך ב-counter יהיה כעת 100.\n6. חוט ב' מתעורר מהאיטרציה האחרונה שלו, מחשב 1+1 וכותב ל-counter את הערך 2 (בכך הוא דורס את ה-100 של חוט א')."}, "difficulty_estimation": "Medium", "_source_file": "0135__Threads__CodeAnalysis__Medium.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:49:26"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Conditions", "Synchronization"], "content": {"text": "נתון קטע הקוד הבא בשפת C המשתמש בספריית pthreads. מה מהבאים נכון לגבי הפלט המודפס למסך? הניחו שכל הקריאות ל-pthread_create מצליחות ושהתהליכון הראשי (main) ממתין לסיום כל החוטים לפני ההדפסה.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint total = 0;\n\nvoid* task(void* arg) {\n    int val = *(int*)arg;\n    total += val;\n    return NULL;\n}\n\nint main() {\n    pthread_t t[2];\n    int i;\n    for (i = 1; i <= 2; i++) {\n        pthread_create(&t[i-1], NULL, task, &i);\n    }\n    for (int j = 0; j < 2; j++) {\n        pthread_join(t[j], NULL);\n    }\n    printf(\"%d\", total);\n    return 0;\n}", "options": ["א. הפלט יהיה תמיד 3", "ב. הפלט יהיה תמיד 6", "ג. הפלט יכול להיות כל מספר שלם בין 1 ל-6", "ד. הפלט יהיה תמיד 0", "ה. לא ניתן לדעת, התוכנית תמיד תסתיים בשגיאת סגמנטציה (Segmentation Fault)"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "הפלט אינו קבוע עקב שתי בעיות סנכרון מרכזיות: 1. העברת משתנה לפי כתובת (Pass by Reference): החוטים מקבלים את הכתובת של משתנה הלולאה i. מכיוון שהם רצים במקביל ללולאה, הערך בכתובת זו עשוי להשתנות לפני שהם קוראים אותו. הערכים האפשריים שחוט יכול לקרוא הם 1, 2, או 3 (הערך של i לאחר סיום הלולאה). 2. מרוץ תהליכונים (Race Condition): הפעולה total += val אינה אטומית (היא מורכבת מקריאה, הוספה וכתיבה). חוט אחד יכול לקרוא את הערך הישן של total, ובזמן שהוא מחשב את הסכום, חוט אחר יעדכן את total, כך שהעדכון של החוט הראשון ידרוס את השני. השילוב של שתי הבעיות מאפשר לקבל כל ערך שלם בטווח 1 עד 6. לדוגמה: אם שני החוטים קראו את הערך i=1 ושניהם קראו total=0, שניהם יכתבו 1 לתוך total והפלט יהיה 1. אם שניהם קראו i=3 ורצו בזה אחר זה, הפלט יהיה 6."}, "difficulty_estimation": "Medium", "_source_file": "0136__Threads__CodeAnalysis__Medium.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:49:56"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Race Conditions", "Pthreads", "Memory Management"], "content": {"text": "לפניכם קוד בשפת C המשתמש בספריית pthreads. הניחו כי כל קריאות המערכת מצליחות, כי התוכנית רצה על מערכת עם מעבד יחיד (Single Core), וכי ה-Scheduler יכול להחליף בין חוטים בכל רגע (Preemptive).", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint global_counter = 0;\n\nvoid* thread_func(void* arg) {\n    int* id_ptr = (int*)arg;\n    int my_id = *id_ptr;\n    int temp = global_counter;\n    usleep(10); // Force potential context switch\n    global_counter = temp + my_id;\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[3];\n    int i;\n    for (i = 0; i < 3; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int j = 0; j < 3; j++) {\n        pthread_join(threads[j], NULL);\n    }\n    printf(\"%d\\n\", global_counter);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "מהו הטווח (מינימום ומקסימום) של הערכים האפשריים שיודפסו על ידי התוכנית? נמקו והדגימו תרחיש קצר עבור כל קצה.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "נניח שנוסיף מנעול (Mutex) סביב הקטע הקריטי בתוך thread_func (שורות 10-12). האם הפלט יהיה בהכרח 3 (0+1+2)? הסבירו.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "הציעו דרך לתקן את הקריאה ל-pthread_create ואת הגישה בתוך thread_func כך שכל חוט יקבל בוודאות את ערך ה-i המקורי שלו (0, 1, או 2) ללא שימוש בהקצאת זיכרון דינמי (malloc).", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. מקסימום: 9. המשתנה i ב-main משותף לכל החוטים דרך הכתובת שלו. עד שהחוטים מספיקים לקרוא את הערך בשורה 9, הלולאה ב-main עשויה להסתיים וערכו של i יהיה 3. אם כל חוט קרא 3 וביצע את העדכון באופן סדרתי (ללא דריסת ערכים), נקבל 3+3+3=9. מינימום: 0. ייתכן שחוט אחד קרא i=0 ושמר temp=0. בזמן שהוא ב-usleep, חוטים אחרים רצו ועדכנו את global_counter לערך כלשהו (למשל 6). כשהחוט הראשון מתעורר, הוא מבצע 0+0 וכותב 0 לתוך global_counter, ובכך דורס את העדכונים האחרים.\n2. לא. המנעול יפתור את ה-Race Condition על global_counter (העדכונים יהיו אטומיים), אך הוא לא פותר את הבעיה שכל החוטים ניגשים לאותה כתובת זיכרון (&i). עדיין ייתכן שכל החוטים יקראו את הערך 3 מהכתובת המשותפת, ולכן הפלט יהיה 9 (אך לא תהיה דריסת זיכרון באמצע).\n3. ניתן להעביר את הערך של i ישירות כארגומנט (Casting) במקום את הכתובת שלו. ב-main: pthread_create(&threads[i], NULL, thread_func, (void*)(long)i); ובפונקציית החוט: int my_id = (int)(long)arg;"}, "difficulty_estimation": "Hard", "_source_file": "0137__Threads__CodeAnalysis__Hard.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:50:24"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Synchronization", "Race Conditions", "Pthreads"], "content": {"text": "לפניך קוד בשפת C המשתמש בספריית Pthreads. הנח כי כל הקריאות למערכת מצליחות וכי התוכנית רצה על מערכת מרובת ליבות. ענה על הסעיפים הבאים:", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\n\nvoid* thread_func(void* arg) {\n    int val = *((int*)arg);\n    for (int i = 0; i < 100; i++) {\n        counter++;\n    }\n    printf(\"%d \", val);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    for (int i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    printf(\"\\nCounter: %d\\n\", counter);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "זהה שתי בעיות סנכרון/לוגיקה בקוד לעיל הקשורות לעבודה עם חוטים.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "מהו הטווח האפשרי של הערך המודפס עבור המשתנה counter? הסבר בקצרה את הגבול התחתון.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "האם ייתכן שהפלט של התוכנית יכלול את הספרה 5? אם כן, הסבר באילו תנאים. אם לא, הסבר מדוע.", "code_snippet": null, "options": null}], "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. הבעיות הן: א) Race Condition על המשתנה הגלובלי counter כיוון שפעולת ה-increment אינה אטומית. ב) Data Race על המשתנה i - כל החוטים מקבלים מצביע לאותה כתובת זיכרון שערכה משתנה על ידי ה-main thread בזמן שהם מנסים לקרוא ממנה.\n2. הטווח הוא [100, 500]. הגבול התחתון הוא 100: זה קורה למשל אם חוט אחד קורא את הערך 0, מושהה, ובינתיים שאר החוטים מסיימים את עבודתם ומעדכנים את counter ל-400. כאשר החוט הראשון חוזר לפעול, הוא מחזיק בערך המקומי שקרא (0), מקדם אותו וכותב חזרה לזיכרון, ובכך דורס את כל העדכונים הקודמים.\n3. כן, ייתכן שהערך 5 יודפס. הלולאה ב-main רצה מ-0 עד 4. בסיום האיטרציה האחרונה, i מקודם ל-5 והתנאי i < 5 נכשל. אם חוט שנוצר באיטרציה כלשהי ניגש לכתובת arg (שהיא הכתובת של i) רק לאחר שה-main thread סיים את הלולאה, הוא יקרא את הערך 5 וידפיס אותו."}, "difficulty_estimation": "Hard", "_source_file": "0138__Threads__CodeAnalysis__Hard.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:50:45"}, {"id": 101, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Conditions", "Pthreads"], "content": {"text": "לפניכם קוד הכתוב בשפת C המשתמש בספריית pthreads. נניח כי כל הקריאות למערכת מצליחות, וכי התוכנית רצה על מערכת המאפשרת פרה-אמפציה (preemption) בכל עת.\n\n1. מהו הטווח האפשרי (מינימום ומקסימום) של הערך המודפס עבור המשתנה counter בסוף התוכנית? הסבירו.\n2. מהן הספרות האפשריות שיכולות להיות מודפסות על ידי פקודת ה-printf בתוך הפונקציה worker? האם הספרה '3' יכולה להופיע? הסבירו.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\n\nvoid* worker(void* arg) {\n    int val = *(int*)arg;\n    int local = counter;\n    local++;\n    counter = local;\n    printf(\"%d\", val);\n    return NULL;\n}\n\nint main() {\n    pthread_t t[3];\n    for (int i = 0; i < 3; i++) {\n        pthread_create(&t[i], NULL, worker, &i);\n    }\n    for (int i = 0; i < 3; i++) {\n        pthread_join(t[i], NULL);\n    }\n    printf(\" Final: %d\\n\", counter);\n    return 0;\n}", "options": null}, "sub_questions": null, "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. טווח הערכים של counter: המינימום הוא 1 והמקסימום הוא 3. המקסימום (3) מתקבל אם החוטים רצים באופן סדרתי או ללא התערבות בקריאה/כתיבה של counter. המינימום (1) מתקבל במצב של Race Condition: כל שלושת החוטים קוראים את הערך ההתחלתי (0) לתוך המשתנה המקומי local, מקדמים אותו ל-1, ואז כותבים כולם 1 חזרה ל-counter.\n\n2. הספרות האפשריות ב-worker: הספרות הן 0, 1, 2, וגם 3. הסיבה לכך היא שהכתובת של i מועברת לכל החוטים (&i). מכיוון ש-i הוא משתנה מקומי ב-main שמשתנה בלולאה, קיים מרוץ (Race Condition) על ערכו. אם חוט מסוים ניגש לכתובת הזיכרון של i רק לאחר שהלולאה ב-main התקדמה או הסתיימה, הוא יראה את הערך המעודכן. מכיוון שהלולאה רצה עד ש-i שווה ל-3, ייתכן שחוט יקרא את הערך 3 מהכתובת לפני ש-main יצא מהלולאה או בזמן ההמתנה ב-join."}, "difficulty_estimation": "Hard", "_source_file": "0139__Threads__CodeAnalysis__Hard.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:51:02"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Conditions", "Memory Management"], "content": {"text": "עיינו בקוד ה-C הבא המשתמש ב-POSIX Threads. התוכנית רצה על מערכת מרובת ליבות. הניחו שכל קריאות המערכת מצליחות ושספריית הסטנדרט מוגדרת ללא Buffering (כלומר printf מדפיס מיד).", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint g = 0;\n\nvoid* task(void* arg) {\n    int val = *(int*)arg;\n    g = g + 1;\n    printf(\"%d \", val);\n    return NULL;\n}\n\nint main() {\n    pthread_t t[3];\n    for (int i = 0; i < 3; i++) {\n        pthread_create(&t[i], NULL, task, &i);\n    }\n    for (int i = 0; i < 3; i++) {\n        pthread_join(t[i], NULL);\n    }\n    printf(\"! %d\", g);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "מהם הערכים האפשריים שיכולים להיות מודפסים עבור המשתנה val על ידי כל אחד מהחוטים? הסבירו האם הערך 3 יכול להופיע בפלט.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "מהו הטווח האפשרי של ערכים עבור המשתנה g בהדפסה האחרונה (אחרי הסימן '!')? נמקו.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "כיצד ניתן לשנות את שורת הקריאה ל-pthread_create ואת השורה הראשונה בפונקציה task כך שכל חוט ידפיס בוודאות ערך ייחודי (0, 1, 2) ללא שימוש במנגנוני סנכרון (כגון Mutex)?", "code_snippet": null, "options": null}], "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. הערכים האפשריים עבור val הם {0, 1, 2, 3}. הסיבה לכך היא שכל החוטים מקבלים את הכתובת של אותו משתנה מקומי i מהמחסנית של main. כיוון שאין סנכרון, חוט עשוי לקרוא את הערך של i רק לאחר שהחוט הראשי כבר קידם אותו בלולאה. הערך 3 אפשרי בהחלט: אם חוט מסוים מתחיל לבצע את הפונקציה task רק לאחר שהלולאה הראשונה ב-main הסתיימה, הוא יקרא את הערך הנוכחי של i בכתובת שקיבל, שהוא 3 (ערך היציאה מהלולאה).\n\n2. הטווח עבור g הוא [1, 3]. הפעולה g = g + 1 אינה אטומית (מורכבת מקריאה, הוספה וכתיבה). במערכת מרובת ליבות, ייתכן שכל שלושת החוטים יקראו את הערך 0 בו-זמנית, יוסיפו 1 ויכתבו כולם 1 חזרה לזיכרון (Race Condition). במקרה האופטימלי שבו אין התנגשות, כל חוט יקדם את g בתורו והתוצאה תהיה 3.\n\n3. כדי להבטיח שכל חוט יקבל עותק ייחודי של הערך i ללא תלות בשינויים העתידיים של המשתנה ב-main, ניתן להעביר את הערך עצמו באמצעות Casting לטיפוס void* (בהנחה שגודל מצביע מאפשר זאת): \nב-main: pthread_create(&t[i], NULL, task, (void*)(long)i);\nב-task: int val = (int)(long)arg;"}, "difficulty_estimation": "Hard", "_source_file": "0140__Threads__CodeAnalysis__Hard.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:51:27"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Conditions", "Pthreads"], "content": {"text": "לפניך קטע קוד ב-C המשתמש בספריית pthreads. מטרת התוכנית היא ליצור 5 חוטים (threads), כך שכל חוט ידפיס מזהה ייחודי (0 עד 4) שהועבר לו בזמן היצירה. הנח כי כל הקריאות ל-pthread_create ו-pthread_join מצליחות.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define NUM_THREADS 5\n\nvoid* thread_func(void* arg) {\n    int id = *((int*)arg);\n    printf(\"%d \", id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    for (int i = 0; i < NUM_THREADS; i++) {\n        pthread_create(&threads[i], NULL, thread_func, &i);\n    }\n    for (int i = 0; i < NUM_THREADS; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "האם הפלט של התוכנית יהיה בהכרח פרמוטציה של המספרים {0, 1, 2, 3, 4}? הסבירו מדוע.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "האם ייתכן מצב בו אחד החוטים ידפיס את הערך 5? נמקו.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "הציעו שינוי מינימלי לקוד (שורות בודדות) שיבטיח שכל חוט ידפיס מזהה ייחודי בין 0 ל-NUM_THREADS-1.", "code_snippet": null, "options": null}], "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. לא, הפלט לא יהיה בהכרח פרמוטציה של 0-4. הבעיה היא שכל החוטים מקבלים את הכתובת של אותו משתנה מקומי i. מכיוון שהחוטים רצים במקביל ללולאת ה-main, ייתכן שערך המשתנה i ישתנה ב-main לפני שחוט מסוים יספיק לקרוא אותו ב-thread_func. זהו Race Condition על המשתנה i.\n2. כן, ייתכן בהחלט. אם לולאת היצירה (הלולאה הראשונה) מסתיימת לפני שאחד החוטים ניגש לזיכרון של i, הערך של i יהיה 5 (תנאי העצירה של הלולאה), וזה מה שהחוט ידפיס.\n3. ישנן שתי דרכים נפוצות לתיקון: א. הקצאת מערך של מזהים (למשל int ids[NUM_THREADS]) והעברת הכתובת של המקום ה-i במערך לכל חוט. ב. העברת הערך של i ישירות על ידי Casting ל-(void*) ב-pthread_create וביצוע Casting חזרה ל-int בתוך ה-thread_func (עובד כי גודל void* בדרך כלל גדול או שווה ל-int)."}, "difficulty_estimation": "Hard", "_source_file": "0141__Threads__CodeAnalysis__Hard.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:51:41"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Conditions"], "content": {"text": "נתון קטע הקוד הבא בשפת C. שני חוטים (Threads) נוצרים ומריצים את הפונקציה worker במקביל על מעבד יחיד. המשתנה x הוא גלובלי ומאותחל ל-0. מהו הערך המקסימלי והערך המינימלי האפשריים של x עם סיום ריצת התוכנית? הסבירו את תשובתכם ותארו את סדר הפעולות (interleaving) המוביל לערכים אלו.", "code_snippet": "int x = 0;\n\nvoid* worker(void* arg) {\n    for (int i = 0; i < 100; i++) {\n        int temp = x;\n        temp = temp + 1;\n        x = temp;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, worker, NULL);\n    pthread_create(&t2, NULL, worker, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\", x);\n    return 0;\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "ערך מקסימלי: 200. מתקבל כאשר שני החוטים רצים באופן סדרתי (אחד אחרי השני), כך שכל פעולת קידום מתבצעת על הערך המעודכן ביותר.\nערך מינימלי: 2. תרחיש המביא לתוצאה זו:\n1. חוט א' קורא x=0 עבור האיטרציה הראשונה שלו (i=0) ונעצר.\n2. חוט ב' רץ 99 איטרציות מלאות (i=0 עד i=98), ומעדכן את x ל-99.\n3. חוט א' ממשיך וכותב x=1 (הערך שקרא 0 פלוס 1).\n4. חוט ב' קורא את הערך x=1 עבור האיטרציה האחרונה שלו (i=99) ונעצר.\n5. חוט א' רץ ומסיים את כל 99 האיטרציות הנותרות שלו (מ-i=1 עד i=99), ומעדכן את x ל-100.\n6. חוט ב' ממשיך את האיטרציה האחרונה שלו, מחשב 1+1 וכותב x=2."}, "difficulty_estimation": "Hard", "_source_file": "0142__Threads__CodeAnalysis__Hard.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:52:20"}, {"id": 101, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Conditions", "Synchronization", "Pthreads"], "content": {"text": "לפניכם קוד בשפת C המשתמש בחוטים (Threads). הניחו כי כל קריאות המערכת מצליחות וכי התוכנית רצה על מערכת מרובת ליבות המאפשרת הרצה מקבילית אמיתית.", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint total = 0;\npthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;\n\nvoid* worker(void* arg) {\n    int id = *(int*)arg;\n    for (int i = 0; i < 100; i++) {\n        if (id % 2 == 0) {\n            total++;\n        } else {\n            pthread_mutex_lock(&mtx);\n            total++;\n            pthread_mutex_unlock(&mtx);\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[4];\n    for (int i = 0; i < 4; i++) {\n        pthread_create(&threads[i], NULL, worker, &i);\n    }\n    for (int i = 0; i < 4; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    printf(\"%d\\n\", total);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "101.1", "text": "מהו הערך המקסימלי האפשרי שהתוכנית יכולה להדפיס? הסבירו בקצרה.", "code_snippet": null, "options": null}, {"id": "101.2", "text": "האם פלט התוכנית דטרמיניסטי (כלומר, האם תמיד יודפס אותו ערך)? אם לא, ציינו את שתי הסיבות המרכזיות לכך שערכו של total עשוי להשתנות בין הרצות שונות.", "code_snippet": null, "options": null}, {"id": "101.3", "text": "נניח ושינינו את שורת יצירת החוט ל-pthread_create(&threads[i], NULL, worker, (void*)(long)i); ואת קריאת ה-id ל-int id = (int)(long)arg;. האם כעת הפלט יהיה דטרמיניסטי ושווה ל-400? נמקו.", "code_snippet": null, "options": null}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. הערך המקסימלי הוא 400. ישנם 4 חוטים וכל אחד מבצע 100 איטרציות של קידום המשתנה total. בתרחיש אידיאלי ללא איבוד עדכונים, הסכום יגיע ל-400.\n2. הפלט אינו דטרמיניסטי משתי סיבות עיקריות:\nא) מרוץ תהליכים על המשתנה i: כל החוטים מקבלים את הכתובת של i בזיכרון של פונקציית main. עד שחוט מתחיל לרוץ וקורא את הערך מהכתובת, הערך של i עשוי להשתנות על ידי הלולאה ב-main (למשל, כל החוטים עשויים לקרוא את הערך 4).\nב) מרוץ תהליכים על total: בתוך פונקציית worker, אם ה-id שנקרא הוא זוגי, הגישה ל-total מתבצעת ללא הגנת Mutex. מכיוון שמספר חוטים יכולים לגשת למשתנה בו-זמנית, עדכונים עלולים ללכת לאיבוד (Lost Update).\n3. לא. למרות שתיקון זה מבטיח שכל חוט יקבל ID ייחודי (0, 1, 2, 3), חוטים 0 ו-2 עדיין יזהו את עצמם כזוגיים (id % 2 == 0) וינסו לקדם את total ללא שימוש במנעול. כתוצאה מכך, עדיין קיים מרוץ תהליכים בין חוט 0 לחוט 2 (ובין שניהם לחוטים האי-זוגיים שמשתמשים במנעול אך לא מונעים מהזוגיים לגשת), ולכן הפלט עדיין לא יהיה דטרמיניסטי ועלול להיות נמוך מ-400."}, "difficulty_estimation": "Hard", "_source_file": "0143__Threads__CodeAnalysis__Hard.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:52:41"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Race Conditions", "Synchronization"], "content": {"text": "לפניכם תוכנית בשפת C המשתמשת בספריית pthreads. המשתנה g הוא משתנה גלובלי המשותף לכל החוטים ומאותחל ל-0. הניחו כי המערכת משתמשת במעבד יחיד וכי אלגוריתם התזמון הוא Preemptive (ניתן להחליף בין חוטים בכל נקודת זמן, כולל באמצע פעולות אריתמטיות של קריאה וכתיבה לזיכרון). מהו הערך המינימלי והערך המקסימלי האפשריים של המשתנה g עם סיום ריצת התוכנית? נמקו את תשובתכם בעזרת תרחיש הרצה (interleaving) מתאים.", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint g = 0;\n\nvoid* child_func(void* arg) {\n    int temp = g;\n    g = temp + 1;\n    return NULL;\n}\n\nvoid* parent_func(void* arg) {\n    pthread_t tid;\n    int temp = g;\n    g = temp + 1;\n    pthread_create(&tid, NULL, child_func, NULL);\n    pthread_join(tid, NULL);\n    temp = g;\n    g = temp + 1;\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, parent_func, NULL);\n    pthread_create(&t2, NULL, parent_func, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\\n\", g);\n    return 0;\n}", "options": null}, "sub_questions": null, "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "ערך מקסימלי: 6. זהו המקרה שבו כל הפעולות מתבצעות באופן סדרתי ללא הפרעה. כל חוט אב (parent_func) מבצע 3 קידומים של g: אחד ישירות לפני יצירת הבן, אחד על ידי הבן (child_func), ואחד ישירות לאחר ה-join. כיוון שיש שני חוטי אב, מתבצעים 6 קידומים סה\"כ.\n\nערך מינימלי: 3. כדי להגיע למינימום, ננסה לגרום לאובדן עדכונים (lost updates). נניח שחוט אב T1 קורא g=0. אז חוט T2 רץ את כל המסלול שלו (3 קידומים) ומביא את g ל-3. כעת T1 חוזר ומבצע את הכתיבה שלו: g = 0 + 1 = 1. בשלב זה איבדנו את כל העדכונים של T2 והערך הוא 1. כעת T1 יוצר את חוט הבן שלו (C1). כיוון ש-C1 נוצר לאחר ש-T1 כבר כתב 1, C1 יקרא לפחות 1 ויעדכן ל-2. לאחר מכן T1 יבצע join ויקרא את הערך שכתב הבן (2) ויעדכן ל-3. \nלא ניתן להגיע לערך נמוך מ-3 (כמו 2) מכיוון שכל חוט אב מחולק לשני מקטעי קוד שביניהם יש נקודת סנכרון (join). הקידום האחרון של חוט אב תמיד יתבסס על הערך שנכתב על ידי הבן שלו, והבן תמיד יקרא ערך שנכתב לפחות על ידי הקידום הראשון של האב שלו."}, "difficulty_estimation": "Hard", "_source_file": "0144__Threads__CodeAnalysis__Hard.json", "_topic_hint": "Threads", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:53:50"}, {"id": 1, "type": "MultipleChoice", "topic": ["Synchronization", "Race Condition"], "content": {"text": "מהו מצב מרוץ (Race Condition) בהקשר של סנכרון בין תהליכים או חוטים (threads)?", "code_snippet": null, "options": ["א. מצב שבו שני תהליכים מנסים לגשת לאותו קובץ בדיסק בו-זמנית.", "ב. מצב שבו התוצאה הסופית של התוכנית תלויה בתזמון היחסי של ביצוע הפעולות על משאב משותף.", "ג. מצב שבו תהליך אחד נתקע בלולאה אינסופית ומונע מתהליכים אחרים להשתמש במעבד.", "ד. מצב שבו שני תהליכים מחכים זה לזה לצורך קבלת משאב ואינם יכולים להמשיך בביצועם.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. מצב מרוץ (Race Condition) מוגדר כמצב שבו מספר תהליכים או חוטים ניגשים ומשנים נתונים משותפים בו-זמנית, כך שהתוצאה הסופית של החישוב תלויה בסדר הגישה (התזמון) של הישויות השונות למשאב."}, "difficulty_estimation": "Easy", "_source_file": "0145__Synchronization__MultipleChoice__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:53:57"}, {"id": 1, "type": "MultipleChoice", "topic": ["Synchronization", "Critical Section"], "content": {"text": "מהו 'קטע קריטי' (Critical Section) בהקשר של סנכרון בין תהליכים או חוטים (threads)?", "code_snippet": null, "options": ["א. קטע קוד שחייב להתבצע בזמן הקצר ביותר האפשרי כדי לא לעכב את המערכת.", "ב. קטע קוד שבו מתבצעת גישה למשאב משותף, ושאסור ליותר מתהליך אחד לבצעו בו-זמנית.", "ג. קטע קוד שרק למערכת ההפעלה (Kernel) מותר להריץ.", "ד. קטע קוד שבו מתרחשת פסיקת שעון לצורך החלפת הקשר (Context Switch).", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "קטע קריטי הוא חלק בתוכנית שבו מתבצעת גישה למשאבים משותפים (כמו משתנים גלובליים, קבצים או חומרה). כדי למנוע מצבי מרוץ (Race Conditions), יש להבטיח 'מניעה הדדית' (Mutual Exclusion), כלומר שרק תהליך/חוט אחד ישהה בקטע הקריטי שלו בכל רגע נתון."}, "difficulty_estimation": "Easy", "_source_file": "0146__Synchronization__MultipleChoice__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:54:06"}, {"id": 5, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency"], "content": {"text": "מהו 'מצב מרוץ' (Race Condition) בהקשר של סנכרון תהליכים?", "code_snippet": null, "options": ["א. מצב שבו שני תהליכים או יותר ניגשים למשאב משותף והתוצאה הסופית תלויה בתזמון הביצוע של הפקודות.", "ב. מצב שבו תהליך אחד ממתין למשאב שמוחזק על ידי תהליך אחר, שממתין למשאב של הראשון.", "ג. מצב שבו תהליך בעל עדיפות נמוכה אינו מצליח לקבל זמן מעבד בגלל תהליכים בעלי עדיפות גבוהה.", "ד. מצב שבו המעבד מבצע החלפת הקשר (context switch) בתדירות גבוהה מדי.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. מצב מרוץ מתרחש כאשר מספר חוטים או תהליכים מבצעים מניפולציה על נתונים משותפים במקביל, והתוצאה הסופית של החישוב תלויה בסדר שבו הגישות בוצעו בפועל. כדי למנוע זאת, יש להשתמש במנגנוני סנכרון כמו Mutex."}, "difficulty_estimation": "Easy", "_source_file": "0147__Synchronization__MultipleChoice__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:54:18"}, {"id": 5, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency"], "content": {"text": "מהו \"קטע קריטי\" (Critical Section) בהקשר של סנכרון בין תהליכים או חוטים (threads)?", "code_snippet": null, "options": ["א. חלק בקוד שבו מתבצעת גישה למשאבים משותפים ועלול להיווצר בו Race Condition.", "ב. קטע קוד במערכת ההפעלה שאחראי על ביצוע החלפת הקשר (Context Switch).", "ג. קוד שחייב לרוץ במצב פריבילגי (Kernel Mode) בלבד.", "ד. פונקציה שמבצעת הקצאת זיכרון דינמי עבור תהליך חדש.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. קטע קריטי הוא קטע קוד שבו מתבצעת גישה למשאב משותף (כגון משתנה גלובלי, קובץ או מבנה נתונים). כדי למנוע מצב של מרוץ (Race Condition), עלינו להבטיח שרק תהליך אחד נמצא בקטע הקריטי שלו בו-זמנית (Mutual Exclusion)."}, "difficulty_estimation": "Easy", "_source_file": "0148__Synchronization__MultipleChoice__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:54:25"}, {"id": 1, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency"], "content": {"text": "מהו 'קטע קריטי' (Critical Section) בהקשר של סנכרון בין תהליכים או חוטים (threads)?", "code_snippet": null, "options": ["א. קטע קוד שחייב להתבצע על ידי המעבד במהירות המרבית ללא השהיות.", "ב. קטע קוד שבו מתבצעת גישה למשאב משותף ושרק חוט/תהליך אחד יכול לבצע בו זמנית.", "ג. קטע קוד המכיל רק פקודות מערכת (System Calls) המיועדות לניהול זיכרון.", "ד. קטע קוד שבו המעבד מבצע פעולות קלט/פלט (I/O) בלבד.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. קטע קריטי הוא חלק בתוכנית שבו ניגשים למשאב משותף (כגון משתנה גלובלי). כדי למנוע מצבי מרוץ (Race Conditions), יש להשתמש במנגנוני סנכרון כדי להבטיח שרק תהליך/חוט אחד ישהה בקטע זה בכל זמן נתון (Mutual Exclusion)."}, "difficulty_estimation": "Easy", "_source_file": "0150__Synchronization__MultipleChoice__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:54:35"}, {"id": 1, "type": "MultipleChoice", "topic": ["Synchronization", "Critical Section"], "content": {"text": "מהו \"קטע קריטי\" (Critical Section) בהקשר של סנכרון בין תהליכים או חוטים (threads)?", "code_snippet": null, "options": ["א. קטע קוד שזמן הריצה שלו ארוך במיוחד ועלול לעכב את המערכת.", "ב. קטע קוד שבו מתבצעת גישה למשאב משותף ונדרש להבטיח שרק חוט אחד יבצע אותו בכל רגע נתון.", "ג. קטע קוד בתוך ליבת מערכת ההפעלה (kernel) שלא ניתן להפסיק את ריצתו על ידי פסיקה.", "ד. פונקציה שניתן לקרוא לה רק מתוך תהליך יחיד במהלך כל חיי התוכנית.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. קטע קריטי הוא קטע בתוכנית שבו מתבצעת גישה למשאבים משותפים (כגון משתנים גלובליים, מבני נתונים או קבצים). כדי למנוע מצבי מרוץ (race conditions), יש להשתמש במנגנוני סנכרון שיבטיחו מניעה הדדית (mutual exclusion), כך שרק חוט אחד יוכל לשהות בקטע הקריטי בכל זמן נתון."}, "difficulty_estimation": "Easy", "_source_file": "0152__Synchronization__MultipleChoice__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "MultipleChoice", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:54:46"}, {"id": 10, "type": "MultipleChoice", "topic": ["Synchronization", "Peterson's Algorithm", "Memory Barriers", "Concurrency"], "content": {"text": "נניח מימוש של אלגוריתם פיטרסון (Peterson's Algorithm) עבור שני תהליכים (P0 ו-P1) במערכת מודרנית שבה המעבד או הקומפיילר עשויים לבצע אופטימיזציות של Reordering (שינוי סדר פעולות) לפעולות קריאה וכתיבה לזיכרון. הקוד עבור P0 מוצג להלן. מהי הסכנה העיקרית בהרצת קוד זה ללא שימוש ב-Memory Barriers (מחסומי זיכרון) או במשתנים אטומיים?", "code_snippet": "flag[0] = true;\nturn = 1;\nwhile (flag[1] && turn == 1);\n// Critical Section\nflag[0] = false;", "options": ["א. לא קיימת סכנה, האלגוריתם הוכח מתמטית ולכן יעבוד תמיד ללא קשר לארכיטקטורת החומרה.", "ב. ייתכן מצב שבו שני התהליכים יכנסו לקטע הקריטי בו-זמנית (פגיעה ב-Mutual Exclusion).", "ג. המערכת תיכנס ל-Deadlock ודאי בכל פעם ששני התהליכים ינסו להיכנס לקטע הקריטי יחד.", "ד. התהליכים יסבלו מהרעבה (Starvation) כיוון ש-turn לעולם לא יתעדכן בזמן, אך ה-Mutual Exclusion יישמר."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "בארכיטקטורות מחשב מודרניות, המעבד או הקומפיילר עשויים לשנות את סדר פעולות הכתיבה והקריאה (Out-of-order execution) כדי לשפר ביצועים. ללא Memory Barriers, ייתכן שהכתיבה ל-flag[0] תתבצע בפועל (או תיראה לשאר הליבות) רק אחרי הקריאה של flag[1] בתוך הלולאה. במצב כזה, שני התהליכים עלולים לראות ש-flag של הצד השני הוא false בו-זמנית, ושניהם ייכנסו לקטע הקריטי יחד, מה שמפר את עקרון ה-Mutual Exclusion."}, "difficulty_estimation": "Hard", "_source_file": "0164__Synchronization__MultipleChoice__Hard.json", "_topic_hint": "Synchronization", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:55:22"}, {"id": 10, "type": "MultipleChoice", "topic": ["Synchronization", "Condition Variables", "Race Conditions", "Lost Wakeup"], "content": {"text": "נתון הקוד הבא המממש סנכרון פשוט בין שני תהליכונים (Threads). תהליכון א' ממתין שמשתנה גלובלי בשם ready יהפוך ל-1, ותהליכון ב' מעדכן את ערכו. המשתנים m (מסוג pthread_mutex_t) ו-c (מסוג pthread_cond_t) אותחלו כראוי. איזה מהמשפטים הבאים מתאר בצורה המדויקת ביותר את הבעיה הפוטנציאלית בקוד?", "code_snippet": "// Global variables\nint ready = 0;\npthread_mutex_t m;\npthread_cond_t c;\n\n// Thread A:\npthread_mutex_lock(&m);\nwhile (ready == 0) {\n    pthread_cond_wait(&c, &m);\n}\npthread_mutex_unlock(&m);\n\n// Thread B:\nready = 1;\npthread_cond_signal(&c);", "options": ["א. הקוד תקין לחלוטין; ביצוע pthread_cond_signal ללא נעילת המנעול הוא מותר ותקין תמיד.", "ב. תיתכן בעיית 'Lost Wakeup': תהליכון א' עלול לבדוק את התנאי, למצוא שהוא 0, אך לפני שיקרא ל-wait, תהליכון ב' יעדכן את המשתנה וישלח סיגנל שייאבד.", "ג. הקוד יגרום בהכרח ל-Deadlock כיוון שתהליכון ב' לא משחרר מנעול שלא נעל.", "ד. תהליכון א' עלול להיכנס ללולאה אינסופית בגלל Spurious Wakeup גם אם ready שונה ל-1.", "ה. תהליכון ב' יקרוס (Segmentation Fault) בזמן הקריאה ל-pthread_cond_signal כי המנעול m אינו מוחזק על ידו."]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "הבעיה היא היעדר סנכרון על המשתנה המשותף ready בתהליכון ב'. תרחיש אפשרי: תהליכון א' נועל את המנעול, בודק את ready ורואה שהוא 0. לפני ש-א' קורא ל-pthread_cond_wait (שמשחרר את המנעול אטומית), מתבצע context switch. תהליכון ב' מעדכן את ready ל-1 ושולח סיגנל. כיוון שאין אף תהליכון שממתין כרגע על c, הסיגנל הולך לאיבוד. כש-א' חוזר לפעול, הוא קורא ל-wait ונרדם לנצח, למרות ש-ready כבר 1. לכן חובה לעדכן את המשתנה ולשלוח את הסיגנל תחת הגנת המנעול."}, "difficulty_estimation": "Hard", "_source_file": "0168__Synchronization__MultipleChoice__Hard.json", "_topic_hint": "Synchronization", "_requested_type": "MultipleChoice", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:55:43"}, {"id": 10, "type": "Open", "topic": ["Synchronization", "Semaphores", "Threads"], "content": {"text": "לפניכם קטע קוד בשפת C המשתמש בשני חוטים (threads) לעדכון משתנה גלובלי משותף בשם counter. הסמפור s מאותחל לערך 1.", "code_snippet": "int counter = 0;\nsem_t s;\n\nvoid* increment(void* arg) {\n    for (int i = 0; i < 50; i++) {\n        sem_wait(&s);\n        counter++;\n        sem_post(&s);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    sem_init(&s, 0, 1);\n    pthread_create(&t1, NULL, increment, NULL);\n    pthread_create(&t2, NULL, increment, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\", counter);\n    return 0;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "מהו הערך שיודפס בסיום ריצת התוכנית? הסבירו בקצרה מדוע.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "נניח שמתכנת בטעות הסיר את השורה sem_post(&s); מתוך הלולאה. כיצד תשתנה התנהגות התוכנית?", "code_snippet": null, "options": null}], "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: הערך שיודפס הוא 100. כל אחד משני החוטים מבצע 50 איטרציות של הגדלת המשתנה counter. מכיוון שהגישה למשתנה המשותף מוגנת על ידי סמפור בינארי (המשמש כ-Mutex), לא יתרחשו מצבי מרוץ (Race Conditions) וכל העדכונים יישמרו.\n\n10.2: התוכנית תיכנס למצב של קיפאון (Deadlock/Hang). החוט הראשון שיצליח להיכנס לקטע הקריטי יבצע sem_wait ויוריד את ערך הסמפור ל-0. מכיוון שאין sem_post, ערך הסמפור לא יחזור ל-1 לעולם. לכן, באיטרציה השנייה שלו (או כאשר החוט השני ינסה להיכנס), הוא ייחסם ב-sem_wait לנצח."}, "difficulty_estimation": "Easy", "_source_file": "0169__Synchronization__Open__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:55:58"}, {"id": 1, "type": "Open", "topic": ["Synchronization", "Mutex", "Race Condition"], "content": {"text": "נתונים שני חוטים (Threads) המריצים את הפונקציה `increment_counter` במקביל. המשתנה `counter` הוא משתנה גלובלי המאותחל ל-0. הנח כי אין אופטימיזציות של הקומפיילר וכי הפעולות מבוצעות בדיוק כפי שהן כתובות.", "code_snippet": "int counter = 0;\n\nvoid* increment_counter(void* arg) {\n    for (int i = 0; i < 100; i++) {\n        int temp = counter;\n        temp = temp + 1;\n        counter = temp;\n    }\n    return NULL;\n}", "options": null}, "sub_questions": [{"id": "1.1", "text": "מהו השם של התופעה שעלולה לגרום לכך שהערך הסופי של המשתנה `counter` יהיה נמוך מ-200?", "code_snippet": null, "options": null}, {"id": "1.2", "text": "הציעו פתרון המשתמש ב-Mutex (מנעול) על מנת להבטיח שהערך הסופי של `counter` יהיה תמיד 200. יש לכתוב את קטע הקוד הרלוונטי.", "code_snippet": null, "options": null}], "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: התופעה נקראת 'מרוץ תהליכים' (Race Condition). היא מתרחשת כאשר מספר חוטים ניגשים למשאב משותף (במקרה זה המשתנה counter) ומבצעים עליו פעולות של קריאה וכתיבה ללא סנכרון, כך שהתוצאה הסופית תלויה בסדר התזמון של החוטים.\n\n1.2: כדי לפתור זאת, יש להשתמש ב-Mutex שיבטיח שרק חוט אחד נמצא ב'קטע הקריטי' (Critical Section) בכל זמן נתון. \nקוד מוצע:\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid* increment_counter(void* arg) {\n    for (int i = 0; i < 100; i++) {\n        pthread_mutex_lock(&lock);\n        int temp = counter;\n        temp = temp + 1;\n        counter = temp;\n        pthread_mutex_unlock(&lock);\n    }\n    return NULL;\n}"}, "difficulty_estimation": "Easy", "_source_file": "0171__Synchronization__Open__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "Open", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:56:17"}, {"id": 10, "type": "Open", "topic": ["Synchronization", "Semaphores", "Concurrency"], "content": {"text": "במערכת הפעלה נתונה, ישנו משאב משותף הנגיש לשני סוגי תהליכים: קוראים (Readers) וכותבים (Writers). עליכם לממש פתרון סנכרון בשפת C באמצעות סמפורים בלבד המקיים את התנאים הבאים:\n1. מספר הקוראים שיכולים לגשת למשאב בו-זמנית מוגבל לכל היותר ל-5.\n2. כותב יכול לגשת למשאב רק אם אין בו קוראים כלל.\n3. בזמן שכותב ניגש למשאב, אף קורא או כותב אחר לא יכול לגשת אליו (בלעדיות).\n4. מניעת הרעבה של כותבים: ברגע שכותב ממתין בתור, קוראים חדשים לא יורשו להיכנס למשאב עד שהכותב יסיים.", "code_snippet": "sem_t mutex;          // Protects read_count\nsem_t resource;       // Controls access to the resource\nsem_t read_limit;     // Limits number of concurrent readers\nsem_t service_queue;  // Prevents writer starvation\nint read_count = 0;\n\n// Initialize semaphores and implement reader() and writer()", "options": null}, "sub_questions": null, "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפתרון עושה שימוש בארבעה סמפורים:\n1. הסמפור service_queue (אותחל ל-1) משמש כ'שומר סף'. גם קוראים וגם כותבים חייבים לעבור דרכו. אם כותב ממתין עליו, קוראים חדשים ייחסמו, מה שמונע הרעבת כותבים.\n2. הסמפור read_limit (אותחל ל-5) מבטיח שלא יותר מ-5 קוראים ישהו במשאב בו-זמנית.\n3. הסמפור resource (אותחל ל-1) מבטיח בלעדיות לכותב. הקורא הראשון שנכנס נועל אותו, והקורא האחרון שיוצא משחרר אותו.\n4. הסמפור mutex (אותחל ל-1) מגן על המשתנה המשותף read_count.\n\nמימוש ה-Writer:\nsem_wait(&service_queue);\nsem_wait(&resource);\n// Writing...\nsem_post(&resource);\nsem_post(&service_queue);\n\nמימוש ה-Reader:\nsem_wait(&service_queue);\nsem_wait(&read_limit);\nsem_wait(&mutex);\nread_count++;\nif (read_count == 1) sem_wait(&resource);\nsem_post(&mutex);\nsem_post(&service_queue);\n\n// Reading...\n\nsem_wait(&mutex);\nread_count--;\nif (read_count == 0) sem_post(&resource);\nsem_post(&mutex);\nsem_post(&read_limit);"}, "difficulty_estimation": "Medium", "_source_file": "0182__Synchronization__Open__Medium.json", "_topic_hint": "Synchronization", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:56:53"}, {"id": 10, "type": "Open", "topic": ["Synchronization", "Semaphores", "Deadlocks"], "content": {"text": "נתונים שלושה חוטים (Threads) המבצעים לולאה אינסופית. המטרה היא להשתמש בסמפורים כדי לסנכרן ביניהם כך שהפלט יהיה תמיד ברצף ABCABC... (כלומר, A תמיד מודפס לפני B, ו-B תמיד לפני C). לפניכם קטעי הקוד של החוטים:", "code_snippet": "// Thread A\nwhile(1) {\n    sem_wait(&s1);\n    printf(\"A\");\n    sem_post(&s2);\n}\n\n// Thread B\nwhile(1) {\n    sem_wait(&s2);\n    printf(\"B\");\n    sem_post(&s3);\n}\n\n// Thread C\nwhile(1) {\n    sem_wait(&s3);\n    printf(\"C\");\n    sem_post(&s1);\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "מהם ערכי האתחול הנדרשים עבור הסמפורים s1, s2, s3 כדי להבטיח שההדפסה הראשונה תהיה 'A' והסדר יישמר לאורך זמן?", "code_snippet": null, "options": null}, {"id": "10.2", "text": "מה יקרה אם נאתחל את כל הסמפורים לערך 0? הסבירו בקצרה.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "נניח ואתחלנו את s1=1, s2=1, s3=1. האם הסדר ABC מובטח? אם לא, תנו דוגמה לפלט אפשרי אחר.", "code_snippet": null, "options": null}], "points": 15, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1. ערכי האתחול הנדרשים הם s1=1, s2=0, s3=0. אתחול s1 ל-1 מאפשר לחוט A להתחיל מיד. מכיוון ש-s2 ו-s3 הם 0, חוטים B ו-C ייחסמו ב-wait עד שחוט A יבצע post ל-s2, וחוט B יבצע post ל-s3 בהתאמה.\n\n10.2. אם כל הסמפורים יאותחלו ל-0, יתרחש מצב של Deadlock (קיפאון). כל אחד משלושת החוטים ינסה לבצע sem_wait על סמפור שערכו 0 וייחסם, ולא יהיה אף חוט שיבצע sem_post כדי לשחרר אותם.\n\n10.3. לא, הסדר אינו מובטח. אם כל הסמפורים מאותחלים ל-1, כל אחד מהחוטים יכול לעבור את ה-wait הראשון שלו ללא תלות באחרים. במצב כזה קיימת תחרות (Race Condition) על סדר ההדפסה שתלוי בתזמון של מערכת ההפעלה. פלט אפשרי אחר יכול להיות למשל BACBAC או CBA..."}, "difficulty_estimation": "Medium", "_source_file": "0184__Synchronization__Open__Medium.json", "_topic_hint": "Synchronization", "_requested_type": "Open", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 18:57:08"}, {"id": 10, "type": "Open", "topic": ["Synchronization", "Atomics", "Barriers", "Concurrency"], "content": {"text": "מחסום (Barrier) הוא אובייקט סנכרון המבטיח שכל N החוטים המשתתפים הגיעו לנקודה מסוימת לפני שמישהו מהם ממשיך בביצוע. מימוש נאיבי של מחסום המבוסס על מונה (Counter) ו-Mutex בלבד עלול להיכשל או לגרום לביצועים ירודים כאשר המחסום נמצא בשימוש חוזר (Reusable Barrier) בתוך לולאה. בשאלה זו נבחן את טכניקת ה-Sense Reversal המאפשרת מימוש יעיל ובטוח לשימוש חוזר ללא צורך ב-Locking כבד.", "code_snippet": "#include <stdatomic.h>\n\ntypedef struct {\n    atomic_int count;\n    atomic_int sense;\n    int N;\n} Barrier;\n\nvoid init(Barrier* b, int N) {\n    atomic_init(&b->count, N);\n    atomic_init(&b->sense, 0);\n    b->N = N;\n}\n\nvoid wait(Barrier* b) {\n    // Implementation required\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "הסבירו מדוע מימוש מחסום המבוסס על קידום מונה ובדיקת `if (count == N)` (ללא מנגנון נוסף) אינו בטיחותי לשימוש בתוך לולאה. תארו תרחיש (Race Condition) שבו חוט עלול להתקדם לשלב הבא באופן שגוי.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "השלימו את הקוד עבור הפונקציה `wait` המשתמשת בטכניקת ה-Sense Reversal. עליכם להשתמש בפעולות אטומיות בלבד (`atomic_load`, `atomic_store`, `atomic_fetch_sub`) ולהבטיח שהמחסום ניתן לשימוש חוזר אינסופי ללא אתחול חיצוני.", "code_snippet": "void wait(Barrier* b) {\n    // השלימו כאן\n}", "options": null}], "points": 15, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: במימוש נאיבי, החוט האחרון שמעלה את המונה ל-N משחרר את שאר החוטים. אם החוטים רצים בלולאה, חוט מהיר במיוחד עשוי לסיים את האיטרציה הנוכחית, להיכנס לאיטרציה הבאה ולהתחיל לשנות את המונה (למשל לאפס אותו או להעלות אותו שוב) לפני שחוטים איטיים יותר הספיקו אפילו לקרוא שהמונה הגיע ל-N. מצב זה יגרום לחוטים האיטיים להיתקע לנצח או לחוט המהיר 'לפרוץ' את המחסום בטרם עת.\n\n10.2: בטכניקת Sense Reversal, אנו משתמשים במשתנה 'sense' גלובלי ובמשתנה מקומי לכל חוט. חוט שנכנס למחסום מחשב מה צריך להיות ה-sense הבא (היפוך של הנוכחי). החוטים ממתינים עד שה-sense הגלובלי ישתנה לערך המבוקש. החוט האחרון שמגיע הוא זה שאחראי לאפס את המונה עבור הסבב הבא ולשנות את ה-sense הגלובלי, ובכך הוא משחרר את כולם.\n\nקוד המימוש:\nvoid wait(Barrier* b) {\n    static _Thread_local int local_sense = 0;\n    local_sense = !local_sense; // היפוך ה-sense המקומי לכל חוט\n    \n    if (atomic_fetch_sub(&b->count, 1) == 1) {\n        // החוט האחרון שהגיע\n        atomic_store(&b->count, b->N); // הכנה לסבב הבא\n        atomic_store(&b->sense, local_sense); // שחרור כל החוטים ע\"י שינוי ה-sense הגלובלי\n    } else {\n        // חוטים שאינם האחרונים מחכים לשינוי ה-sense\n        while (atomic_load(&b->sense) != local_sense) {\n            // Spinning\n        }\n    }\n}"}, "difficulty_estimation": "Hard", "_source_file": "0186__Synchronization__Open__Hard.json", "_topic_hint": "Synchronization", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:57:43"}, {"id": 10, "type": "Open", "topic": ["Synchronization", "Semaphores", "Mutexes", "Concurrency", "Starvation"], "content": {"text": "עליכם לממש מנגנון סנכרון עבור משאב משותף המוגבל ל-M משתמשים בו-זמנית. החוטים במערכת מחולקים לשני סוגים: A ו-B. המגבלות הן:\n1. סך כל החוטים (A ו-B יחד) המשתמשים במשאב לא יעלה על M.\n2. מספר החוטים מסוג A המשתמשים במשאב לא יעלה על K (כאשר K < M).\n3. מניעת הרעבה: אם יש חוטים מסוג B הממתינים בתור לכניסה, חוט חדש מסוג A יוכל להיכנס למשאב רק אם נמצאים בו כרגע פחות מ-K-1 חוטים מסוג A (כלומר, עליו להשאיר מקום פוטנציאלי לחוט מסוג B).\n\nעליכם להשתמש בטכניקת 'העברת המקל' (Pass the Baton) על מנת להבטיח את קיום התנאים ומניעת הרעבה, תוך שימוש בסמפורים ומוטקסים בלבד.", "code_snippet": "typedef struct {\n    int M, K;\n    int inA, inB;\n    int waitA, waitB;\n    sem_t lock;\n    sem_t semA;\n    sem_t semB;\n} ResourceControl;\n\nvoid init(ResourceControl *rc, int M, int K);\nvoid enter_A(ResourceControl *rc);\nvoid leave_A(ResourceControl *rc);\nvoid enter_B(ResourceControl *rc);\nvoid leave_B(ResourceControl *rc);", "options": null}, "sub_questions": [{"id": "10.1", "text": "ממשו את פונקציית האתחול init.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "ממשו את הפונקציות enter_A, leave_A, enter_B, leave_B. יש להשתמש בפונקציית עזר release_next המיישמת את לוגיקת העברת המקל.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפתרון משתמש בטכניקת Pass the Baton. הרעיון המרכזי הוא שחוט שנכנס או יוצא בודק אם יש חוטים אחרים שיכולים להיכנס. אם כן, הוא משחרר את הסמפור שלהם מבלי לשחרר את ה-mutex (החוט המשוחרר 'יורש' את ה-mutex). רק אם אין אף חוט שיכול להיכנס, ה-mutex משוחרר.\n\n10.1:\nvoid init(ResourceControl *rc, int M, int K) {\n    rc->M = M; rc->K = K;\n    rc->inA = 0; rc->inB = 0;\n    rc->waitA = 0; rc->waitB = 0;\n    sem_init(&rc->lock, 0, 1);\n    sem_init(&rc->semA, 0, 0);\n    sem_init(&rc->semB, 0, 0);\n}\n\n10.2:\nvoid release_next(ResourceControl *rc) {\n    if (rc->waitB > 0 && (rc->inA + rc->inB < rc->M)) {\n        rc->waitB--; rc->inB++;\n        sem_post(&rc->semB);\n    } else if (rc->waitA > 0 && (rc->inA + rc->inB < rc->M) && (rc->inA < rc->K) && !(rc->waitB > 0 && rc->inA == rc->K - 1)) {\n        rc->waitA--; rc->inA++;\n        sem_post(&rc->semA);\n    } else {\n        sem_post(&rc->lock);\n    }\n}\n\nvoid enter_A(ResourceControl *rc) {\n    sem_wait(&rc->lock);\n    if ((rc->inA + rc->inB < rc->M) && (rc->inA < rc->K) && !(rc->waitB > 0 && rc->inA == rc->K - 1)) {\n        rc->inA++;\n        release_next(rc);\n    } else {\n        rc->waitA++;\n        sem_post(&rc->lock);\n        sem_wait(&rc->semA);\n        release_next(rc);\n    }\n}\n\nvoid leave_A(ResourceControl *rc) {\n    sem_wait(&rc->lock);\n    rc->inA--;\n    release_next(rc);\n}\n\nvoid enter_B(ResourceControl *rc) {\n    sem_wait(&rc->lock);\n    if (rc->inA + rc->inB < rc->M) {\n        rc->inB++;\n        release_next(rc);\n    } else {\n        rc->waitB++;\n        sem_post(&rc->lock);\n        sem_wait(&rc->semB);\n        release_next(rc);\n    }\n}\n\nvoid leave_B(ResourceControl *rc) {\n    sem_wait(&rc->lock);\n    rc->inB--;\n    release_next(rc);\n}"}, "difficulty_estimation": "Hard", "_source_file": "0189__Synchronization__Open__Hard.json", "_topic_hint": "Synchronization", "_requested_type": "Open", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 18:58:21"}, {"id": 101, "type": "CodeAnalysis", "topic": ["Synchronization", "Mutex", "Threads", "Race Conditions"], "content": {"text": "לפניכם קוד בשפת C המשתמש בחוטים (threads) ובמנעול מסוג Mutex. מה יהיה הפלט של התוכנית בהנחה שכל קריאות המערכת מצליחות?", "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\npthread_mutex_t lock;\n\nvoid* increment_task(void* arg) {\n    for (int i = 0; i < 1000; i++) {\n        pthread_mutex_lock(&lock);\n        counter++;\n        pthread_mutex_unlock(&lock);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_mutex_init(&lock, NULL);\n    \n    pthread_create(&t1, NULL, increment_task, NULL);\n    pthread_create(&t2, NULL, increment_task, NULL);\n    \n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    \n    printf(\"%d\\n\", counter);\n    pthread_mutex_destroy(&lock);\n    return 0;\n}", "options": ["הפלט יהיה תמיד 1000", "הפלט יהיה תמיד 2000", "הפלט יהיה ערך אקראי בין 1000 ל-2000 עקב Race Condition", "התוכנית תיכנס למצב של Deadlock ולא תדפיס דבר"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "הפלט יהיה תמיד 2000", "explanation": "התוכנית יוצרת שני חוטים (threads), כאשר כל אחד מהם מבצע לולאה של 1000 איטרציות המקדמות משתנה גלובלי משותף (counter). מכיוון שפעולת הקידום (counter++) מוקפת בנעילה ושחרור של Mutex (pthread_mutex_lock ו-pthread_mutex_unlock), הקטע הקריטי מוגן. הגנה זו מבטיחה שרק חוט אחד יוכל לגשת למשתנה ולעדכן אותו בכל רגע נתון, ובכך נמנע מצב של Race Condition. לכן, כל 2000 הקידומים (1000 מכל חוט) יתבצעו בהצלחה והתוצאה הסופית תהיה תמיד 2000."}, "difficulty_estimation": "Easy", "_source_file": "0194__Synchronization__CodeAnalysis__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:58:44"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Synchronization", "Mutex", "Race Conditions"], "content": {"text": "לפניכם תוכנית בשפת C המשתמשת בשני חוטים (threads) ובסנכרון מסוג מוטקס (mutex) כדי לקדם מונה משותף. עיינו בקוד וענו על הסעיפים הבאים:", "code_snippet": "1  #include <pthread.h>\n2  #include <stdio.h>\n3  \n4  int counter = 0;\n5  pthread_mutex_t mtx;\n6  \n7  void* func(void* arg) {\n8      for (int i = 0; i < 1000; i++) {\n9          pthread_mutex_lock(&mtx);\n10         counter++;\n11         pthread_mutex_unlock(&mtx);\n12     }\n13     return NULL;\n14 }\n15 \n16 int main() {\n17     pthread_t t1, t2;\n18     pthread_mutex_init(&mtx, NULL);\n19     pthread_create(&t1, NULL, func, NULL);\n20     pthread_create(&t2, NULL, func, NULL);\n21     pthread_join(t1, NULL);\n22     pthread_join(t2, NULL);\n23     printf(\"counter = %d\\n\", counter);\n24     pthread_mutex_destroy(&mtx);\n25     return 0;\n26 }", "options": null}, "sub_questions": [{"id": "10.1", "text": "מהו הערך המדויק שיודפס על המסך בסיום ריצת התוכנית?", "code_snippet": null, "options": null}, {"id": "10.2", "text": "נניח כי מחקנו את שורות 9 ו-11 מהקוד (הקריאות ל-lock ול-unlock). מהו הערך המקסימלי שייתכן ויודפס כעת? האם מובטח שהערך יהיה זהה בכל הרצה? הסבירו בקצרה.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: הערך שיודפס הוא 2000. השימוש במוטקס מבטיח שרק חוט אחד יוכל לבצע את פעולת הקידום (שורה 10) בכל רגע נתון. מכיוון שכל אחד משני החוטים מבצע 1000 קידומים, והסנכרון מונע איבוד עדכונים, התוצאה הסופית היא 2000.\n\n10.2: הערך המקסימלי שייתכן ויודפס הוא 2000 (במקרה שבו התזמון במקרה מנע חפיפה בין החוטים). לא, הערך אינו מובטח להיות זהה בכל הרצה. ללא המוטקס, הפעולה counter++ אינה אטומית (היא מורכבת מקריאה, הוספה וכתיבה), ונוצר מצב מרוץ (Race Condition). חוטים עלולים לקרוא את אותו ערך ישן ולדרוס זה את העדכון של זה, מה שיוביל לערך סופי נמוך מ-2000 (הערך המינימלי התיאורטי הוא 2)."}, "difficulty_estimation": "Easy", "_source_file": "0196__Synchronization__CodeAnalysis__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:59:09"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Synchronization", "Mutex", "Race Conditions", "Threads"], "content": {"text": "נתון קוד ה-C הבא המשתמש בספריית pthreads. התוכנית מגדירה משתנה גלובלי counter ויוצרת שני חוטים המריצים את הפונקציה increment המקדמת את המונה 1000 פעמים.", "code_snippet": "1 #include <pthread.h>\n2 #include <stdio.h>\n3 \n4 int counter = 0;\n5 pthread_mutex_t lock;\n6 \n7 void* increment(void* arg) {\n8     for (int i = 0; i < 1000; i++) {\n9         pthread_mutex_lock(&lock);\n10        counter++;\n11        pthread_mutex_unlock(&lock);\n12    }\n13    return NULL;\n14 }\n15 \n16 int main() {\n17     pthread_t t1, t2;\n18     pthread_mutex_init(&lock, NULL);\n19     pthread_create(&t1, NULL, increment, NULL);\n20     pthread_create(&t2, NULL, increment, NULL);\n21     pthread_join(t1, NULL);\n22     pthread_join(t2, NULL);\n23     printf(\"%d\\n\", counter);\n24     return 0;\n25 }", "options": null}, "sub_questions": [{"id": "1.1", "text": "מה יהיה הערך המודפס של counter בסיום ריצת התוכנית כפי שהיא?", "code_snippet": null, "options": null}, {"id": "1.2", "text": "נניח שהסרנו את השורות המבצעות נעילה ושחרור של המיוטקס (שורות 9 ו-11). מהו הערך המקסימלי והערך המינימלי האפשריים של counter שיודפסו בסיום הריצה?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: הערך שיודפס הוא 2000. השימוש ב-Mutex בשורות 9 ו-11 מבטיח שרק חוט אחד יוכל לגשת למשתנה המשותף counter בכל רגע נתון. מכיוון שכל חוט מבצע 1000 קידומים, והקידומים מוגנים מפני מרוץ תהליכים, התוצאה הסופית היא 1000 + 1000 = 2000.\n\n1.2: הערך המקסימלי הוא 2000 (במקרה שבו התזמון במקרה מנע התנגשויות). הערך המינימלי הוא 2. הסבר לערך המינימלי: חוט א' קורא את הערך 0 ונעצר לפני הקידום. חוט ב' רץ 999 פעמים ומעדכן את המונה ל-999. חוט א' ממשיך, כותב 1 למונה, ואז קורא את הערך 1 עבור האיטרציה השנייה שלו ונעצר. חוט ב' ממשיך לאיטרציה האחרונה שלו, קורא את הערך 1, וממתין לפני הכתיבה. חוט א' רץ כעת את כל שאר 998 האיטרציות שלו ומסיים (הערך במונה כעת 999). לבסוף חוט ב' חוזר וכותב את הערך 2 (הערך 1 שקרא + 1) למונה."}, "difficulty_estimation": "Easy", "_source_file": "0198__Synchronization__CodeAnalysis__Easy.json", "_topic_hint": "Synchronization", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Easy", "_generated_at": "2026-02-07 18:59:40"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Threads"], "content": {"text": "לפניכם קטע קוד המשתמש בסמפורים לתיאום בין שני חוטים (threads). מה יהיה הפלט של התוכנית בהנחה שכל קריאות המערכת מצליחות והחוטים מסיימים את ריצתם כסדרם?", "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n\nsem_t s1, s2;\nint count = 0;\n\nvoid* threadA(void* arg) {\n    for(int i = 0; i < 2; i++) {\n        sem_wait(&s1);\n        printf(\"A\");\n        count++;\n        sem_post(&s2);\n    }\n    return NULL;\n}\n\nvoid* threadB(void* arg) {\n    for(int i = 0; i < 2; i++) {\n        sem_wait(&s2);\n        printf(\"B\");\n        count++;\n        sem_post(&s1);\n    }\n    return NULL;\n}\n\nint main() {\n    sem_init(&s1, 0, 1);\n    sem_init(&s2, 0, 0);\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, threadA, NULL);\n    pthread_create(&t2, NULL, threadB, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"%d\", count);\n    return 0;\n}", "options": ["א. ABAB4", "ב. BABA4", "ג. AABB4", "ד. התוכנית תיכנס למצב של Deadlock", "ה. ABAB2"]}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "הסמפור s1 מאותחל ל-1 והסמפור s2 מאותחל ל-0. חוט A הוא היחיד שיכול להתחיל את הלולאה שלו כי sem_wait(&s1) יצליח מיד. חוט A מדפיס 'A', מעלה את count ל-1, ומבצע sem_post(&s2). כעת הערך של s2 הוא 1, מה שמאפשר לחוט B לבצע sem_wait(&s2), להדפיס 'B', להעלות את count ל-2 ולבצע sem_post(&s1). הסמפורים יוצרים סנכרון מסוג 'פינג-פונג' בין החוטים. מכיוון שכל חוט רץ פעמיים, הפלט יהיה ABAB והערך הסופי של count יהיה 4."}, "difficulty_estimation": "Medium", "_source_file": "0204__Synchronization__CodeAnalysis__Medium.json", "_topic_hint": "Synchronization", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 19:00:02"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Threads"], "content": {"text": "נתונה התוכנית הבאה המשתמשת בסמפורים (Semaphores) לסנכרון בין שני תהליכונים. הניחו שכל הקריאות ל-pthread_create ו-sem_init מצליחות. מה יהיה הפלט של התוכנית?", "code_snippet": "sem_t sem1, sem2;\nint counter = 0;\n\nvoid* threadA(void* arg) {\n    for (int i = 0; i < 5; i++) {\n        sem_wait(&sem1);\n        counter++;\n        printf(\"A%d \", counter);\n        sem_post(&sem2);\n    }\n    return NULL;\n}\n\nvoid* threadB(void* arg) {\n    for (int i = 0; i < 5; i++) {\n        sem_wait(&sem2);\n        counter++;\n        printf(\"B%d \", counter);\n        sem_post(&sem1);\n    }\n    return NULL;\n}\n\nint main() {\n    sem_init(&sem1, 0, 1);\n    sem_init(&sem2, 0, 0);\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, threadA, NULL);\n    pthread_create(&t2, NULL, threadB, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    return 0;\n}", "options": ["א. A1 B2 A3 B4 A5 B6 A7 B8 A9 B10", "ב. A1 A2 A3 A4 A5 B1 B2 B3 B4 B5", "ג. התוכנית תבצע הדפסה אחת ותיכנס למבוי סתום (Deadlock).", "ד. B1 A2 B3 A4 B5 A6 B7 A8 B9 A10", "ה. הפלט אינו דטרמיניסטי ותלוי בסדר הרצת התהליכונים על ידי המעבד."]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "הסמפור sem1 מאותחל ל-1, מה שמאפשר לתהליכון A להיכנס לקטע הקריטי ראשון. הסמפור sem2 מאותחל ל-0, ולכן תהליכון B ייחסם בשורה sem_wait(&sem2) עד ש-A יבצע post ל-sem2. לאחר ש-A מעלה את המונה ל-1 ומדפיס 'A1 ', הוא מבצע post ל-sem2 שמשחרר את תהליכון B. כעת B מעלה את המונה ל-2, מדפיס 'B2 ' ומשחרר את A חזרה על ידי post ל-sem1. המבנה הזה יוצר סדר ריצה דטרמיניסטי שבו התהליכונים רצים לסירוגין, ולכן המונה גדל ב-1 בכל הדפסה והאותיות מתחלפות."}, "difficulty_estimation": "Medium", "_source_file": "0207__Synchronization__CodeAnalysis__Medium.json", "_topic_hint": "Synchronization", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Medium", "_generated_at": "2026-02-07 19:00:24"}, {"id": 10, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Barriers", "Race Conditions"], "content": {"text": "לפניכם קוד המממש מחסום (Barrier) עבור N חוטים (כאשר N > 1). המטרה היא להבטיח שכל N החוטים יסיימו את 'שלב א' (הקריאה ל-do_work_A) לפני שמישהו מהם יתחיל את 'שלב ב' (הקריאה ל-do_work_B). הקוד משתמש בטכניקה הנקראת Chained Signaling בתוך Turnstile כדי לאפשר לחוטים לעבור את המחסום בזה אחר זה. הניחו שכל קריאות המערכת מצליחות וכי do_work_A ו-do_work_B אינן כוללות סנכרון פנימי.", "code_snippet": "sem_t mutex;     // initialized to 1\nsem_t turnstile; // initialized to 0\nint count = 0;\n\nvoid barrier() {\n    // Arrival\n    sem_wait(&mutex);\n    count++;\n    if (count == N) {\n        sem_post(&turnstile);\n    }\n    sem_post(&mutex);\n\n    // The Turnstile\n    sem_wait(&turnstile);\n    sem_post(&turnstile);\n}\n\nvoid* worker(void* arg) {\n    while(1) {\n        do_work_A();\n        barrier();\n        do_work_B();\n        // Point X\n    }\n    return NULL;\n}", "options": null}, "sub_questions": [{"id": "10.1", "text": "הסבירו מדוע באיטרציה הראשונה של הלולאה, המחסום ימלא את תפקידו וכל החוטים ימתינו זה לזה.", "code_snippet": null, "options": null}, {"id": "10.2", "text": "האם המחסום הנתון הוא Reusable? כלומר, האם מובטח סנכרון תקין גם באיטרציה השנייה והלאה? אם כן - הסבירו מדוע. אם לא - תארו תרחיש (תזמון) שבו חוט מסוים מתחיל את 'שלב ב' של האיטרציה השנייה לפני שחוט אחר סיים את 'שלב א' של אותה איטרציה.", "code_snippet": null, "options": null}, {"id": "10.3", "text": "מהו הערך של הסמפור turnstile כאשר חוט כלשהו נמצא ב-'Point X' באיטרציה הראשונה? כיצד ניתן לתקן את הפונקציה barrier כך שתהיה בטוחה לשימוש חוזר (Reusable) מבלי להשתמש בסמפורים נוספים?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "10.1: באיטרציה הראשונה, turnstile מאותחל ל-0. N-1 החוטים הראשונים שיגיעו ל-barrier יגדילו את count אך לא ייכנסו ל-if, ולכן ייחסמו ב-sem_wait בשורה 13. החוט ה-N שיגיע יגדיל את count ל-N, יבצע sem_post ל-turnstile בשורה 9, וישחרר את החוט הראשון. החוט שישתחרר יבצע מיד sem_post בשורה 14 וישחרר את הבא בתור, וכך הלאה (שרשרת). לכן כולם יעברו רק אחרי שהאחרון הגיע.\n\n10.2: המחסום אינו Reusable. הבעיה היא שערך הסמפור turnstile נשאר 1 לאחר שהחוט האחרון עובר (הוא מבצע post בשורה 14 שאיש לא צורך). תרחיש שבירה: חוט T1 מסיים את barrier באיטרציה 1, מסיים את do_work_B במהירות, חוזר לתחילת הלולאה, מסיים את do_work_A של איטרציה 2 ומגיע שוב ל-barrier. מכיוון ש-turnstile הוא 1, T1 יבצע sem_wait ויעבור מיד לשלב ב' של איטרציה 2, למרות שחוטים אחרים אולי עדיין תקועים בשלב ב' של איטרציה 1 או בתחילת איטרציה 2.\n\n10.3: ערך הסמפור turnstile בנקודה X הוא 1. כדי לתקן את המחסום ולהופכו ל-Reusable, יש להוסיף שלב שני (Two-phase barrier) שבו נועלים את ה-turnstile בחזרה. בשיטה זו, לאחר שכל החוטים עברו את ה-turnstile הראשון, הם צריכים להמתין ב-turnstile שני שייפתח רק כאשר כולם סיימו לעבור את הראשון, והחוט האחרון שיעבור את השני יאפס את ה-count וינעל את ה-turnstile (יבצע wait מבלי לבצע post)."}, "difficulty_estimation": "Hard", "_source_file": "0209__Synchronization__CodeAnalysis__Hard.json", "_topic_hint": "Synchronization", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 19:01:07"}, {"id": 1, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Starvation", "Race Conditions"], "content": {"text": "לפניכם מימוש מוצע למנגנון Read-Write Lock המשתמש בסמפורים. המנגנון נועד לאפשר למספר קוראים (Readers) לקרוא מהמשאב בו-זמנית, אך להבטיח בלעדיות לכותב (Writer) יחיד. הנחו כי כל הסמפורים מאותחלים כראוי (mutex=1, writeBlock=1) וכי המשתנה readersCount מאותחל ל-0.", "code_snippet": "1  sem_t mutex;\n2  sem_t writeBlock;\n3  int readersCount = 0;\n4\n5  void startRead() {\n6    sem_wait(&mutex);\n7    readersCount++;\n8    if (readersCount == 1)\n9      sem_wait(&writeBlock);\n10   sem_post(&mutex);\n11 }\n12\n13 void endRead() {\n14   sem_wait(&mutex);\n15   readersCount--;\n16   if (readersCount == 0)\n17     sem_post(&writeBlock);\n18   sem_post(&mutex);\n19 }\n20\n21 void startWrite() {\n22   sem_wait(&writeBlock);\n23 }\n24\n25 void endWrite() {\n26   sem_post(&writeBlock);\n27 }", "options": null}, "sub_questions": [{"id": "1.1", "text": "האם המימוש הנוכחי עלול לגרום להרעבה (Starvation)? אם כן, של אילו חוטים (קוראים או כותבים) ובאילו תנאים?", "code_snippet": null, "options": null}, {"id": "1.2", "text": "נניח שקיימים שלושה חוטים: R1, R2 (קוראים) ו-W1 (כותב). הציגו סדר פעולות (Interleaving) שבו W1 מגיע בזמן ש-R1 נמצא בקטע הקריטי, אך R2 מצליח להיכנס לקטע הקריטי לפני ש-W1 מתחיל לכתוב.", "code_snippet": null, "options": null}, {"id": "1.3", "text": "מה יקרה אם נעביר את שורה 15 (הורדת המונה) אל מחוץ לבלוק הסנכרון, כלומר מיד אחרי שורה 18? הסבירו את ההשלכה על תקינות הקוד.", "code_snippet": null, "options": null}, {"id": "1.4", "text": "כדי למנוע הרעבת כותבים, מוצע להוסיף סמפור נוסף בשם readTry המאותחל ל-1. היכן יש להוסיף את הקריאות ל-sem_wait ו-sem_post של סמפור זה בפונקציות startRead ו-startWrite?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: המימוש עלול לגרום להרעבת כותבים (Writers). אם יש זרם קבוע של קוראים שנכנסים לקטע הקריטי (startRead) לפני שהקורא האחרון מסיים (endRead), המשתנה readersCount לעולם לא יגיע ל-0, ולכן הסמפור writeBlock לא ישוחרר לעולם עבור הכותב.\n\n1.2: תרחיש אפשרי: \nא. R1 מבצע startRead, נועל את mutex, מקדם ל-1, נועל את writeBlock ומשחרר את mutex.\nב. W1 מבצע startWrite ונעצר (blocked) ב-sem_wait על writeBlock.\nג. R2 מבצע startRead, נועל את mutex, מקדם ל-2. מכיוון ש-2 != 1, הוא מדלג על ה-wait ומשחרר את mutex.\nד. R2 נכנס לקטע הקריטי בזמן ש-W1 עדיין ממתין.\n\n1.3: העברת readersCount-- אל מחוץ ל-mutex תיצור מצב מרוץ (Race Condition). אם שני חוטים יבצעו endRead במקביל, הפעולה האריתמטית (שאינה אטומית) עלולה להסתיים בערך שגוי. בנוסף, הבדיקה if (readersCount == 0) עלולה להתבצע על ערך לא מעודכן, מה שיוביל לכך ש-writeBlock לא ישוחרר לעולם (Deadlock לכותבים) או ישוחרר פעמיים.\n\n1.4: הפתרון למניעת הרעבת כותבים:\nב-startRead: יש להוסיף sem_wait(&readTry) בשורה 5.5 (לפני ה-mutex) ו-sem_post(&readTry) בשורה 10.5 (אחרי שחרור ה-mutex).\nב-startWrite: יש להוסיף sem_wait(&readTry) לפני ה-wait על writeBlock, ו-sem_post(&readTry) מיד לאחר מכן (או בסוף הכתיבה). \nבצורה זו, כותב שמגיע יתפוס את readTry וימנע מקוראים חדשים להיכנס עד שיסיים."}, "difficulty_estimation": "Hard", "_source_file": "0212__Synchronization__CodeAnalysis__Hard.json", "_topic_hint": "Synchronization", "_requested_type": "CodeAnalysis", "_requested_difficulty": "Hard", "_generated_at": "2026-02-07 19:01:41"}]