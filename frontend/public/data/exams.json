[{"filename": "os20SA.json", "metadata": {"course_name": "Operating Systems", "year": "2020", "semester": "Summer", "moed": "Moed A", "exam_date": "23.09.2020", "source_file": "os20SA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Deadlocks", "Concurrency", "Processes"], "content": {"text": "אם יש הרעבה בהכרח יש גם קיפאון.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. תיתכן הרעבה ללא קיפאון, לדוגמה במנעול TAS תיתכן הרעבה אבל לא קיפאון."}, "difficulty_estimation": "Easy"}, {"id": 2, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling"], "content": {"text": "באלגוריתם תזמון Round Robin, זמן המחזור הוא אופטימלי.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. זמן המחזור של RR הוא גרוע, כפי שראינו בשיעור."}, "difficulty_estimation": "Easy"}, {"id": 3, "type": "MultipleChoice", "topic": ["Virtual Memory", "Paging", "Memory Management"], "content": {"text": "הגדלת ה-TLB יכולה להקטין את ה-hit ratio.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. לדוגמה עבור אלגוריתם FIFO זה אפשרי."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency", "Mutexes"], "content": {"text": "במחשב עם מעבד יחיד, תמיד נעדיף מנעול שלא מבצע spinning.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. אם חוט נכשל בתפיסת המנעול, אין טעם לבצע spinning כי אף חוט אחר לא רץ במקביל (מעבד יחיד). כלומר המנעול לא ישוחרר וה-spinning מבזבז זמן מעבד."}, "difficulty_estimation": "Easy"}, {"id": 5, "type": "MultipleChoice", "topic": ["File Systems", "I/O", "Atomic Operations"], "content": {"text": "בעיית ה-crash consistency כאשר מוסיפים בלוק נתונים חדש לקובץ קיים (הדוגמה שניתנה בשיעור) תיפתר אם נוכל לבצע 2 כתיבות לדיסק בבת אחת.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. היכולת לבצע 2 כתיבות במקביל לא אומרת שאלו חייבות להיות 2 הכתיבות הראשונות. ראשית נכתוב רק את ה-DATA, מאחר ואין בעיה לקרוס אחרי כתיבת ה-DATA בלבד. לאחר מכן ננצל את היכולת החדשה כדי לעדכן את ה-inode וגם את ה-data bitmap יחד, כך שאם נקרוס לפני אז לא קרה כלום (עודכן רק ה-DATA), ואם נקרוס אחרי אז הפעולה בוצעה במלואה. כך לא יתכן שנקרוס אחרי 2 כתיבות – אלא רק אחרי אחת או 3."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Deadlocks", "Concurrency"], "content": {"text": "מהם ארבעת התנאים לקיום קיפאון? הסבירו כל אחד מהם.", "code_snippet": null, "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "בהתאם לשקפים."}, "difficulty_estimation": "Easy"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "IPC"], "content": {"text": "מריצים את קטע הקוד הבא:\nציירו את עץ התהליכים שנוצר, וציינו עבור כל תהליך בעץ את הפלט שלו. מהם כל הפלטים האפשריים של הקוד הנ\"ל?", "code_snippet": "fork();\nif (fork() == 0) {\n    printf(\"B\");\n} else {\n    wait(NULL);\n    printf(\"A\");\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפלט של התהליך הראשי (שורש העץ) ושל הבן השמאלי הוא A, של הבן הימני ושל הנכד הוא B.\nהפלטים האפשריים הם: BABA, BBAABAAB. פלט נפוץ שפוספס הוא BAAB, במקרה שבו ה-wait של השורש חוזר בעקבות סיום הבן השמאלי שלו, לפני שהבן הימני מדפיס B.\nעץ התהליכים:\n(Image of tree is missing, but the text describes the outputs)"}, "difficulty_estimation": "Medium"}, {"id": 8, "type": "CodeAnalysis", "topic": ["Synchronization", "Mutexes", "Concurrency", "Deadlocks", "Atomic Operations"], "content": {"text": "נתון קטע הקוד הבא למימוש מנעול עבור 2 חוטים, כאשר לכל חוט מזהה (0 או 1) המועבר כפרמטר i:\nהאם המנעול מקיים מניעה הדדית? חופש מקיפאון? הוגנות?", "code_snippet": "int turn;\nvoid lock(int i) {\n    turn = i;\n    while (turn != i);\n}\nvoid unlock(int i) {\n    turn = 1-i;\n}", "options": null}, "sub_questions": [{"id": "מניעה הדדית", "text": "מניעה הדדית:", "code_snippet": null, "options": ["כן", "לא"]}, {"id": "חופש מקיפאון", "text": "חופש מקיפאון:", "code_snippet": null, "options": ["כן", "לא"]}, {"id": "הוגנות", "text": "הוגנות:", "code_snippet": null, "options": ["כן", "לא"]}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "מניעה הדדית – לא מתקיימת.\nדוגמה נגדית: חוט 0 קורא ל-lock, רץ לבד ונכנס לקטע הקריטי, אח\"כ חוט 1 קורא ל-lock ויכנס גם.\nחופש מקיפאון – מתקיים.\nנניח בשלילה שיש קיפאון. אם רק חוט אחד חסום בלולאה, אז הרי הוא עדכן את התור לערך של עצמו (החוט האחר לא רץ או, אם רץ בעבר, בהכרח סיים בעדכון התור לחוט הראשון), לכן זו סתירה. אם 2 החוטים חסומים בלולאה, לא יתכן שהתור הוא לא 0 ולא 1 – אלו הערכים היחידים שמעודכנים אל המשתנה, לכן זו גם סתירה.\nהוגנות – לא מתקיימת.\nדוגמה נגדית: חוט 0 קורא ל-lock ומעדכן 0=turn אך לפני הכניסה ללולאה מגיע חוט 1, משנה את התור ל-1 ונכנס לקטע הקריטי. כעת חוט 0 חסום בהמתנה לתור. כשחוט 1 יוצא מהקטע הקריטי הוא מעדכן את התור ל-0 אבל אז ינסה לתפוס שוב את המנעול (לפני ש-0 יראה את השינוי) ויעדכן שוב את התור ל-1, כך יכנס שוב לקטע הקריטי, וחוזר חלילה.\nתשובה שחזרה על עצמה היא שאם אין מניעה הדדית בהכרח יש חופש מקיפאון – זה לא נכון."}, "difficulty_estimation": "Hard"}, {"id": 9, "type": "Open", "topic": ["Virtual Memory", "Paging", "Memory Management"], "content": {"text": "נתונה מערכת עם זיכרון וירטואלי של 1MB, גודל דף של 2KB, וזיכרון פיזי של 4MB.\nמהם הגדלים של ה-VPN, ה-PFN, וכמה זיכרון פיזי תתפוס טבלת דפים (לינארית) של תהליך, במינימום?\nגודל VPN: ________ גודל PFN: ________ גודל טבלה: ________", "code_snippet": null, "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "כתובת וירטואלית היא 20 ביטים (זיכרון וירטואלי 1MB), מתוכם 11 מייצגים את ההיסט (גודל דף 2KB), לכן נשאר VPN=9.\nכתובת פיזית היא 22 ביטים (זיכרון פיזי 4MB), ההיסט זהה – 11, לכן נשאר PFN=11.\nלכל תהליך יש 512 דפים (2^9) בזיכרון הוירטואלי, כלומר שטבלת הדפים שלו מכילה 512 רשומות. כל רשומה מכילה לפחות 2 בתים (11 ביטים עבור PFN, מעוגל מעלה לחזקה הקרובה של 2), לכן הטבלה כולה תתפוס 1KB."}, "difficulty_estimation": "Medium"}, {"id": 10, "type": "Open", "topic": ["I/O", "Disk Scheduling"], "content": {"text": "נתונים שני דיסקים קשיחים עם הנתונים הבאים:\nA: RPM 7500, seek time 10ms, transfer rate 250 MB/s\nB: RPM 15000, seek time 4ms, transfer rate 125 MB/s\nבהינתן workload אקראי של 4KB וסדרתי של 100MB, איזה דיסק קשיח נעדיף לכל אחד?", "code_snippet": null, "options": null}, "sub_questions": [{"id": "סדרתי", "text": "סדרתי: B / A", "code_snippet": null, "options": ["A", "B"]}, {"id": "אקראי", "text": "אקראי: B / A", "code_snippet": null, "options": ["A", "B"]}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "בחישוב זמני הפעולה לכל תרחיש, נקבל שדיסק A מהיר יותר בתרחיש הסדרתי, ודיסק B מהיר יותר בתרחיש האקראי."}, "difficulty_estimation": "Medium"}]}, {"filename": "os20SB.json", "metadata": {"course_name": "Operating Systems", "year": "2020", "semester": "Summer", "moed": "Moed B", "exam_date": "26.10.2020", "source_file": "os20SB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Concurrency", "Synchronization", "Deadlocks"], "content": {"text": "בבעיית הפילוסופים הסועדים (dining philosophers) ניתן למנוע הרעבה.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. ניתן למנוע הרעבה, לדוגמה בשימוש במנעול הוגן."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling"], "content": {"text": "באלגוריתם תזמון STCF עם overlap, זמן התגובה (response time) הוא אופטימלי.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. בתזמון STCF זמן התגובה גרוע. השימוש ב-overlap לא משנה את זה."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["Memory Management", "Paging"], "content": {"text": ".internal fragmentation יש בעיית buddy allocation באלגוריתם ההקצאה.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. כפי שמופיע בשקפים – ההקצאה היא בחזקות של 2 ולכן כל דרישה להקצאה שאינה חזקה של 2 תגרום לפרגמנטציה."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency", "Context Switch"], "content": {"text": "מנעול מונע החלפת הקשר (context switch) בקטע הקריטי.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. מנעול בפני עצמו לא מונע החלפת הקשר, אלא רק מונע ממספר חוטים להריץ קטע קוד מסוים במקביל (גם אם מתבצעת החלפת הקשר)."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["File Systems", "I/O", "Disk Scheduling"], "content": {"text": "שימוש ב-4-RAID משפר את כל ביצועי הכתיבה לדיסק.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. בתרחיש של כתיבות אקראיות, שימוש ב-4-RAID פוגע בביצועי הדיסק לעומת שימוש בדיסק יחיד. בתרחישי כתיבות סדרתיות או קריאות – הביצועים משתפרים."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Deadlocks", "Synchronization"], "content": {"text": "מה הפתרון לכל אחד מארבעת התנאים לקיום קיפאון (deadlock)\n.Mutual exclusion, Hold-and-wait, No preemption, Circular wait :התנאים הם", "code_snippet": null, "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "בהתאם לשקפים."}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Concurrency"], "content": {"text": "מריצים את קטע הקוד הבא:\nציירו את עץ התהליכים שנוצר, וציינו עבור כל תהליך בעץ את הפלט שלו. מהם כל הפלטים האפשריים של הקוד הנ\"ל?", "code_snippet": "int i = 0;\nif (fork()) {\n    ++i;\n    fork();\n}\nelse if (fork())\n    ++i;\nprintf(\"%d\", i);", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפלט של תהליך אחד (תהליך הנכד משמאל) הוא 0 ושל כל השאר 1, בכל סדר אפשרי.\nלכן הפלטים האפשריים הם: 0111, 1011, 1110, 1111.\nעץ התהליכים: [Diagram of process tree showing P0 forks P1, P0 forks P2, P1 forks P3. P0, P1, P2 print 1, P3 prints 0.]"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["Synchronization", "Mutexes", "Concurrency"], "content": {"text": "נתון קטע הקוד הבא למימוש מנעול עבור 2 חוטים, כאשר לכל חוט מזהה (0 או 1) המועבר כפרמטר ו:\nהאם המנעול מקיים מניעה הדדית? חופש מקיפאון? הוגנות?", "code_snippet": "int turn;\nvoid lock(int i) {\n    turn = 1-i;\n    while (turn != i);\n}\nvoid unlock(int i) {\n    turn = 1-i;\n}", "options": null}, "sub_questions": [{"id": "a", "text": "מניעה הדדית:", "code_snippet": null, "options": ["כן", "לא"]}, {"id": "b", "text": "חופש מקיפאון:", "code_snippet": null, "options": ["כן", "לא"]}, {"id": "c", "text": "הוגנות:", "code_snippet": null, "options": ["כן", "לא"]}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "מניעה הדדית – מתקיימת.\nאם יש 2 חוטים בקטע הקריטי בו-זמנית, שניהם יצאו מהלולאה כלומר 0==turn וגם 1==turn, זו סתירה.\nחופש מקיפאון – לא מתקיים.\nאם רק חוט אחד מנסה לתפוס את המנעול, נניח חוט 0, הוא מעדכן 1=turn ולא יכנס לקטע הקריטי לעולם למרות שהמנעול פנוי.\nהוגנות – מתקיימת.\nאם חוט חסום בלולאת ה-while הוא לא מעדכן יותר את turn, לכן לא יתכן שהחוט השני תופס ומשחרר את המנעול שוב ושוב מאחר וכל חוט מעדכן turn רק לחוט האחר ולא לעצמו."}, "difficulty_estimation": "Hard"}, {"id": 9, "type": "Open", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה מערכת עם זיכרון וירטואלי של 4MB, גודל דף של 1KB, וזיכרון פיזי של 8MB.\nמהם הגדלים של ה-VPN, ה-PFN, וכמה זיכרון פיזי תתפוס טבלת דפים (לינארית) של תהליך, במינימום?\nגודל VPN: ____ גודל PFN: ____ גודל טבלה: ____", "code_snippet": null, "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "כתובת וירטואלית היא 22 ביטים (זיכרון וירטואלי 4MB), מתוכם 10 מייצגים את ההיסט (גודל דף 1KB), לכן נשאר VPN=12.\nכתובת פיזית היא 23 ביטים (זיכרון פיזי 8MB), ההיסט זהה – 10, לכן נשאר PFN=13.\nלכל תהליך יש 4K דפים (2^12) בזיכרון הוירטואלי, כלומר שטבלת הדפים שלו מכילה 4K רשומות. כל רשומה מכילה לפחות 2 בתים (13 ביטים עבור PFN, מעוגל מעלה לחזקה הקרובה של 2), לכן הטבלה כולה תתפוס 8KB."}, "difficulty_estimation": "Medium"}, {"id": 10, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתונים שני דיסקים קשיחים עם הנתונים הבאים:\nA: RPM 7500, seek time 10ms, transfer rate 250 MB/s\nB: RPM 15000, seek time 4ms, transfer rate 125 MB/s\nמה גודל הפעולה המינימלי שנדרש לעשות כדי להבטיח קצב שהוא לפחות 90% מקצב ההעברה המקסימלי של הדיסק?\nועבור 50%\nדיסק קשיח A – קצב 90%: ____ קצב 50%: ____\nדיסק קשיח B – קצב 90%: ____ קצב 50%: ____", "code_snippet": null, "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "זמן הסיבוב של A הוא 8ms, כלומר המתנה לסיבוב של 4ms. מהירות ההעברה היא 250MB/s כלומר לוקח 4ms ל-1MB.\nנניח שגודל הפעולה שמבצעים הוא X (ב-MB), אז הזמן שתיקח פעולה הוא: 4ms + 10ms + X*4ms.\nעם קצב העברה של 90% ב-A (כלומר 225MB/s), זמן ההעברה עבור 1MB הוא 1000/225ms. נכפיל ב-X כדי לקבל את זמן ההעברה של X MB ונקבל 1000X/225ms. הזמנים האלו שווים, כלומר: 225/14+4X = 1000X. מהשוויון הזה נקבל:\nX=31.5MB\nבאופן דומה עבור 50% נקבל: 125/14+4X = 1000X ולכן X=3.5MB\nעבור B עם 90% נקבל: X=6.75MB ועם 50% נקבל: X=0.75MB"}, "difficulty_estimation": "Hard"}]}, {"filename": "os22AA.json", "metadata": {"course_name": "Operating Systems", "year": "2022", "semester": "Semester A", "moed": "Moed A", "exam_date": "11.01.2022", "source_file": "os22AA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Page Replacement", "Virtual Memory", "Memory Management"], "content": {"text": "אלגוריתם השעון בוחר לפנות את הדף הכי ותיק (שניגשו אליו הכי בעבר).", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. אלגוריתם השעון (עם או בלי שדרוגים) מפנה את הדף הראשון שנמצא שלא ניגשו אליו מאז הסיבוב הקודם, לא בהכרח הדף הכי ותיק."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["System Calls", "Concurrency", "Atomic Operations"], "content": {"text": "במקרים מסוימים, תהליכי משתמש יכולים לבטל פסיקות.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. רק לקרנל יש הרשאות לבטל פסיקות (לא מדובר בסיגנלים)."}, "difficulty_estimation": "Easy"}, {"id": 3, "type": "MultipleChoice", "topic": ["Threads", "Processes", "Memory Management"], "content": {"text": "חוטים של אותו תהליך יכולים לגשת למחסנית אחד של השני.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. לכל חוט יש מחסנית נפרדת משלו, אך חוטים של אותו תהליך חולקים את מרחב הכתובות כולו – ולכן יכולים לגשת למחסנית של חוט אחר באמצעות מצביע מתאים לזיכרון."}, "difficulty_estimation": "Easy"}, {"id": 4, "type": "MultipleChoice", "topic": ["Paging", "Memory Management", "Virtual Memory"], "content": {"text": "בדפדוף יש בעיה של פרגמנטציה חיצונית (external fragmentation).", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. דפדוף זו הקצאה בגודל קבוע, תמיד ניתן להשתמש בכל מסגרת ולכן אין פרגמנטציה חיצונית (אך כן יש פנימית)."}, "difficulty_estimation": "Easy"}, {"id": 5, "type": "MultipleChoice", "topic": ["Deadlocks", "Concurrency", "Synchronization"], "content": {"text": "אם יש קיפאון בהכרח יש גם הרעבה.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. יתכן קיפאון ללא הרעבה, לדוגמה מנעול הוגן אשר מגריל כל פעם אם להיכנס ללולאה אינסופית (קיימות גם דוגמאות מציאותיות יותר)."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Virtual Memory", "Paging", "Memory Management"], "content": {"text": "נתונה מערכת עם זיכרון וירטואלי של 32GB וגודל דף של 4KB.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "נתון שטבלת דפים לינארית תופסת 24MB בזיכרון, וכל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת ועוד שלושה ביטים בלבד (ללא תוספות או ריפוד): ביט valid, ביט access, ביט dirty. מה גודל הזיכרון הפיזי המקסימלי במערכת זו? זיכרון פיזי מקסימלי:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "נתון שכל כניסה בטבלת הדפים (PTE) מכילה 32 ביטים בכל רמה, ונדרש שכל טבלה תאוחסן בדף אחד בדיוק. כמה רמות של טבלאות דרושות כדי למפות את מרחב הכתובות הוירטואלי? מספר רמות:", "code_snippet": null, "options": null}, {"id": "6.3", "text": "מה מספר הגישות המקסימלי שעלול להתבצע לזיכרון הראשי, הזיכרון המשני (הדיסק), וה-TLB, בעקבות גישה של תהליך לכתובת וירטואלית כלשהי?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "6.1: 1. גודל הזיכרון הוירטואלי 2^35 בתים וגודל דף 2^12 בתים – ההיסט הוא 12 כלומר VPN הוא 23, ויש 2^23 דפים לתהליך – כלומר 8M (2^23) כניסות בטבלת הדפים. כל שורה בטבלת הדפים היא בגודל PTE, לפני נתוני השאלה 3+PTE=PFN ביטים. אם טבלת הדפים היא 24MB עבור 8M כניסות אז כל כניסה היא בגודל 24MB/8M בתים (24 ביטים). מאחר שנתון שכל PTE מכיל מסר מסגרת ועוד 3 ביטים, אז מספר המסגרת מיוצג ע\"י 21 ביטים, כלומר מקסימום 2^21 מסגרות בזיכרון הפיזי. גודל כל מסגרת הוא 4KB לכן הזיכרון הפיזי המקסימלי הוא 8GB.\n6.2: 2. 32 ביטים לכל PTE = 4 בתים. גודף דף הוא 4KB כלומר בכל דף נכנסות 1024 כניסות (2^10). לתהליך יש 2^23 דפים (כמו בסעיף א'), כלומר שמספר הדף מיוצג ע\"י 23 ביטים וכל רמה בטבלה מיוצגת ע\"י 10 ביטים סה\"כ 3 רמות לטבלת הדפים (3 ביטים עבור הרמה הראשונה, 10 עבור השניה, 10 עבור השלישית).\n6.3: 3. מספר גישות מקסימלי מתרחש ב-page fault ניגש ל-TLB (ונפספס), ניגש לטבלת הדפים (3 גישות לזיכרון, אחת לכל רמה) ונקבל page fault, ניגש לזיכרון ולדיסק כדי לפנות (page out) מסגרת, ואז שוב לזיכרון ולדיסק כדי לטעון את הדף המבוקש (page in), ניגש שוב לזיכרון כדי לעדכן את טבלת הדפים עם מיפוי הדף, נעדכן את ה-TLB, נחזור על הפקודה (גישה נוספת ל-TLB לא חובה לציין), וניגש שוב לזיכרון עבור הנתון עצמו."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Concurrency", "Atomic Operations", "Mutexes"], "content": {"text": "מנעול חד-פעמי הוא מנעול אשר ניתן לנעול פעם אחת בלבד: ברגע שחוט תופס את המנעול בהצלחה, אף חוט אחר לא יכול לתפוס יותר את המנעול לכל אורך התוכנית. פונקציית הנעילה של מנעול חד-פעמי מחזירה 0 לחוטים אשר נכשלו בתפיסת המנעול מבלי לחסום אותם (כלומר, ללא המתנה בדומה לקריאת trylock), ומחזירה 1 לחוט שהצליח. הבהרה: במנעול חד-פעמי, ברגע שחוט מסוים קיבל 1 מפונקציית הנעילה (תפס את המנעול בהצלחה), כל קריאה עתידית בכל חוט תחזיר 0, אפילו אם המנעול פנוי מאחר שהוא חד-פעמי. במנעול חד-פעמי ל-N חוטים מובטח שפונקציית הנעילה של כל מנעול לא נקראת יותר מ-N פעמים בכל ריצת התוכנית. נניח שלרשותנו עומדת פקודת חומרה אטומית ששמה Check&Add, אשר מקדמת מונה באחד ומחזירה האם ערכו החדש שווה לפרמטר C. את הפקודה ניתן לתאר כך: הבהרה: תיאור הפעולה הוא קוד C לצורך הסבר בלבד. פעולת המעבד מבצעת זאת באופן אטומי ולא בכמה פעולות. בכל שאלה זו אין להשתמש באובייקטי סנכרון או פעולות מעבד אטומיות מלבד Check&Add, ויש לדאוג למניעה הדדית וחופש מקיפאון.", "code_snippet": "int check_add(int *p, int C) {\n    assert(*p < C); // check invalid op (crashes if FALSE)\n    return (++*p == C);\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "ממשו מנעול חד-פעמי ל-2 חוטים המשתמש בתא זיכרון יחיד (משתנה אחד x המתקבל כפרמטר). יש לממש את הפונקציות הבאות:", "code_snippet": "void init2(int* x) {\n}\n\nint lock2(int* x) {\n}", "options": null}, {"id": "7.2", "text": "מ ממשו מנעול חד-פעמי ל-3 חוטים המשתמש ב-2 תאי זיכרון (2 משתנים x,y המתקבלים כפרמטר). יש לממש את הפונקציות הבאות:", "code_snippet": "void init3(int* x, int* y) {\n}\n\nint lock3(int* x, int* y) {\n}", "options": null}, {"id": "7.3", "text": "ממשו מנעול חד-פעמי ל-N חוטים (כאשר N פרמטר בפונקציית האתחול). יש להגדיר את מבנה המנעול (struct CALock) ולממש את הפונקציות הבאות:", "code_snippet": "typedef struct _calock {\n} CALock;\nvoid init(CALock *lock, int N) {\n}\nint lock(CALock *lock) {\n}\nvoid destroy(CALock *lock) {\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: 1. נשתמש בפעולה עם 2=C כדי להבדיל בין החוט הראשון שקורא ל-lock2 לבין החוט השני: שימו לב: חשוב להחזיר הפוך מ-check_add. מובטחות עד 2 קריאות אך לא מובטח שיתבצעו 2 קריאות. יתכן שרק חוט אחד ינסה לתפוס את המנעול ואז יכשל – וקיבלנו קיפאון.\n```c\nvoid init2(int *x) {\n    *x = 0;\n}\n\nint lock2(int *x) {\n    return (!check_add(x, 2));\n}\n```\n7.2: 2. הפעולה נותנת לנו להבדיל בין החוט האחרון שביצע אותה לבין כל שאר החוטים, אך כאשר יש 3 חוטים זה לא מספיק - נדע רק להגיד מי החוט השלישי שביצע את הפעולה, וצריך להכריע בין ה-2 הראשונים. לכן נשתמש בפעולה כדי להפריד את החוט השלישי, ובין ה-2 הראשונים נפתור את הבעיה עם סעיף א':\n```c\nvoid init3(int *x, int *y) {\n    *x = *y = 0;\n}\n\nint lock3(int *x, int *y) {\n    if (check_add(x, 3))\n        return 0;\n    return (lock2(y));\n}\n```\n7.3: 3. נמשיך באותו רעיון כמו הסעיף הקודם – כל משתנה יאפשר לנו להפריד את החוט האחרון שביצע קריאה לפעולה החדשה בעזרתו, אז נשתמש ב-1-N משתנים כדי לייצר \"תחרויות\" בין החוטים. בכל תחרות האחרון יעזוב (יכשל בתפיסת המנעול), עד שנשאר רק חוט 1 שיתפוס אותו. שימו לב שהחוט שתפס את המנעול אינו בהכרח החוט הראשון שניסה, אלא החוט הראשון שביצע את הפעולה על המשתנה האחרון, ולא החוט האחרון שקרא לפעולה עבור אף אחד מהמשתנים.\n```c\ntypedef struct _calock {\n    int *carr;\n    int N;\n} CALock;\n\nvoid init(CALock *lock, int N) {\n    lock->carr = (int*) calloc(sizeof(int), N-1);\n    lock->N = N;\n}\n\nint lock(CALock *lock) {\n    for (int i = 0; i < lock->N - 1; ++i) {\n        if (check_add(lock->carr[i], N-i))\n            return 0;\n    }\n    return 1;\n}\n\nvoid destroy(CALock *lock) {\n    free(lock->carr);\n}\n```"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Memory Management"], "content": {"text": "נתונה מערכת קבצים VSFS עם גודל בלוק של 4KB. מספר הבלוקים של DATA במערכת הוא 20,000,000 ומספר ה-inodes הוא 40,000. הגודל של כל inode הוא 128 בתים. הסופר-בלוק מכיל את השדות הבאים: BSIZE – גודל הבלוק (4096 בתים) Nblocks – מספר הבלוקים הכולל Ninodes – מספר ה-inodes I_BMAP_Start – הבלוק הראשון של ה-inode bitmap D_BMAP_Start – הבלוק הראשון של ה-data bitmap כמו-כן בכל inode יש 10 מצביעים ישירים, מצביע אחד עקיף, ומצביע אחד עקיף כפול. בנוסף, מוגדרים בקרנל 2 מערכים שמתארים כמה ביטים פנויים (כמה אפסים) יש בכל בלוק של bitmap:", "code_snippet": "int inode_bmap_stat[ <value_1> ];\nint data_bmap_stat[ <value_2> ];", "options": null}, "sub_questions": [{"id": "8.1", "text": "האם ניתן לדעת מה הגדלים של המערכים הנתונים? אם כן, יש לפרט את הגדלים, אחרת יש לפרט איזה מידע חסר כדי לדעת את ערכם. ניתן לדעת – גודל 1_value: גודל 2_value: לא ניתן לדעת – מידע חסר:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "משתמש ביצע את הפעולה הבאה בטרמינל: 1 mkdir. הניחו שהפעולה מצליחה. כמה בלוקים צריך לקרוא ולכתוב לדיסק בכדי לבצע את הפעולה? קריאות: כתיבות:", "code_snippet": null, "options": null}, {"id": "8.3", "text": "בתיקיית העבודה הנוכחית קיים קובץ רגיל שגודל הוא 45050 בתים. תוכנית משתמש פתחה את הקובץ בסופו (O_APPEND) וביצעה כתיבה של 10 בתים. כמה בלוקים צריך לקרוא מהדיסק בכדי לבצע את פעולת הכתיבה? בסעיף זה אין צורך להתייחס לכתיבות לדיסק. קריאות:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "8.1: 1. בכל אחד מהמערכים, כל תא מציין כמה ביטים פנויים יש בבלוק bitmap המתאים. כלומר לדוגמה, תא 0 של המערך הראשון מייצג כמה ביטים פנויים יש בבלוק הראשון של inode bitmap במערכת, תא 1 מייצג כמה ביטים פנויים יש בבלוק השני, וכן הלאה. כלומר שגודל כל מערך הוא פשוט ככמות הבלוקים ב-bitmap המתאים. גודל בלוק הוא 4KB שהם 32,678 ביטים. מספר ה-inodes הוא 40,000, דרושים 2 בלוקים של inode bitmap לכן הערך של 1_value הוא 2. באופן דומה, יש 2,000,000 בלוקים של DATA ולכך נדרש 611 בלוקים של data bitmap לכן הערך של 611 הוא value_2\n8.2: 2. יש להניח שתיקיית העבודה הנוכחית כבר נמצאת בזיכרון של הקרנל, כולל ה-DATA שלה, לכן ניגש אל הבלוקים הבאים: 1. בלוק inode bitmap בו יש ביט פנוי (נמצא ישר בזכות המערך בקרנל): קריאה וכתיבה כדי לעדכן את הביט המתאים. 2. בלוק Inode מתאים: קריאה וכתיבה כדי לעדכן את ה-inode (בלי לשנות את שאר הבלוק). 3. בלוק data bitmap בו יש ביט פנוי (נמצא ישר בזכות המערך בקרנל): קריאה וכתיבה כדי לעדכן את הביט המתאים. 4. בלוק DATA של התיקייה הנוכחית להוספת הרשומה של d1 (נניח שהפעולה לא מוסיפה בלוק חדש). 5. בלוק DATA שאיתרנו בשלב 3 ליצירת הכניסות שמופיעות בכל תיקייה (כמו ..). צעדים 1-3 דורשים קריאה וכתיבה, צעדים 4-5 דורשים כתיבה בלבד.\n8.3: 3. נתוני ה-inode כבר נמצאים בזיכרון לאחר פתיחת הקובץ (התקבלו גם תשובות שציינו קריאה של הבלוק inode). אם נחלק את גודל הקובץ בגודל בלוק נקבל שהכתיבה מתבצעת החל מבלוק 10 וגולשת אל בלוק 11 (אלו אינדקסים לפי הסדר של הקובץ, לא של הבלוקים עצמם בדיסק / מערכת הקבצים). כדי להגיע אליו נשתמש במצביע עקיף, לכן נצטרך לקרוא את בלוק המצביעים הרלוונטי ואח\"כ את הבלוק עצמו (כי לא משכתבים את כולו). בנוסף נצטרך לקרוא בלוק data bitmap כדי להקצות בלוק חדש (בלוק 11 של הקובץ), אין צורך לקרוא את הבלוק החדש אלא רק לכתוב אליו."}, "difficulty_estimation": "Hard"}]}, {"filename": "os22AB.json", "metadata": {"course_name": "Operating Systems", "year": "2022", "semester": "Semester A", "moed": "Moed B", "exam_date": "01.02.2022", "source_file": "os22AB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["File Systems", "I/O", "Memory Management"], "content": {"text": "בכונן SSD, נתוני קובץ שנגישים אליו לעיתים רחוקות נשארים באותו מיקום פיזי על הדיסק.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון, קובץ שלא משתנה במשך זמן רב נכתב מחדש כדי לחלוק במעטפת הכתיבה עם שאר הבלוקים בדיסק."}, "difficulty_estimation": "Easy"}, {"id": 2, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling"], "content": {"text": "אלגוריתם התזמון SRTF פותר את בעיית ההרעבה של תהליכים.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון, תהליך ארוך יורעב אם מגיעים הרבה תהליכים קצרים למערכת. כך שהם כל הזמן מתזמנים לפני והתהליך הארוך לא מספיק לעולם."}, "difficulty_estimation": "Easy"}, {"id": 3, "type": "MultipleChoice", "topic": ["Threads", "Concurrency"], "content": {"text": "במערכת עם מעבד יחיד, שימוש בחוטים יכול לשפר את ביצועי התוכנית.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון, במעבד יחיד לא ניתן להריץ קוד באופן מקבילי באמת, אך שימוש בחוטים מאפשר לשפר את הביצועים במקרה של חסימה – להמשיך להריץ קוד בזמן ביצוע קלט/פלט."}, "difficulty_estimation": "Easy"}, {"id": 4, "type": "MultipleChoice", "topic": ["Synchronization", "Mutexes", "Concurrency", "Deadlocks"], "content": {"text": "ברשימה מקושרת hand-over-hand עם מנעולים מוצגים, ייתכן הרעבה.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון, מאחר שמתקדמים על המנעולים ברשימה המקושרת אחד אחרי השני וכל מנעול הוא הוגן, הרי שכל חוט ממתין רק לחוטים שלפניו. לא ניתן לנעול חוטים אחרים ברשימה בגלל אופן תפיסת המנעול והשימוש במנעולים הוגנים, ולכן לא ייתכן הרעבה."}, "difficulty_estimation": "Easy"}, {"id": 5, "type": "MultipleChoice", "topic": ["I/O", "System Calls", "Processes"], "content": {"text": "שימוש ב-DMA מאפשר לתהליכים לקבל יותר זמן מעבד.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון, ה-DMA הוא התקן שמטפל בהעברת המידע מ/אל התקני קלט/פלט במקום מערכת ההפעלה והמעבד, וכך המעבד פנוי להריץ תהליכים אחרים במשך יותר זמן."}, "difficulty_estimation": "Easy"}, {"id": 6, "type": "CodeAnalysis", "topic": ["Processes", "IPC", "Signals", "System Calls", "Concurrency"], "content": {"text": "נתונה התוכנית הבאה:", "code_snippet": "void foo(int p_read[2], int p_write[2]) {\n  unsigned int num;\n  int ret;\n  close(p_read[1]);\n  close(p_write[0]);\n\n  while (1) {\n    ret = read(p_read[0], &num, sizeof(int));\n    if (ret == 0)\n      exit(0);\n    printf(\"%d \", num);\n    if (num == 1)\n      exit(0);\n    usleep(50 * 1000);\n    num = (num%2 == 0) ? num/2 : num*3+1;\n    write(p_write[1], &num, sizeof(int));\n  }\n}\n\nint main() {\n  setbuf(stdout, NULL); // cancel buffering\n  int pipe1[2], pipe2[2];\n  const int NUM = 3;\n  pipe(pipe1);\n  pipe(pipe2);\n  if (!fork()) {\n    foo(pipe1, pipe2);\n  }\n  if (!fork()) {\n    foo(pipe2, pipe1);\n  }\n  write(pipe1[1], &NUM, sizeof(int));\n  // while (wait(NULL) > 0); // commented out!\n  exit(0);\n}", "options": null}, "sub_questions": [{"id": "6.1", "text": "ניתן להניח שכל קריאות המערכת מצליחות.\nמה הפלט של התוכנית?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "בהנחה שהרצנו את התוכנית מתוך הטרמינל, האם ה-prompt של הטרמינל עשוי להתערבב עם הפלט של התוכנית?", "code_snippet": null, "options": null}, {"id": "6.3", "text": "אם נכניס את שורה 14 להערה, האם עלול להיווצר מרוץ (race condition)?", "code_snippet": null, "options": null}, {"id": "6.4", "text": "אם נוציא את שורה 30 מהערה, מה תהיה ההשפעה על ריצת התוכנית?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. ב-fork() הילד כותב 3 לתוך הפייפ, ההורה. הביצועים קוראים מהפייפ (כל אחד מפעיל אחר לסירוגין), ויוצרים את הפלט\nהבא:\n3 10 5 16 8 4 2 1\n2. כן. הפרומפט של הטרמינל ממתין לתהליך האב בלבד, שמסתיים לפני תהליכי הבנים.\n3. לא נוצר מרוץ, מה שמסוכן הן הפעולה של תהליכי הבנים וגם זה הקריאות והכתיבות אל הפייפ. ההדפסות מתבצעות ללא חוט, וכל התהליך עובד במרחב הזיכרון הפרטי שלו.\n4. התוכנית תיתקע. בגלל שהתהליך האב לא מסתיים ולא סוגר את קצוות הפייפ, בכדי שזה יהיה תקין עם הקריאה ל-wait, צריך שהתהליך האב יסגור את קצוות הפייפ, כפרט את הצדדים הכותבים ולפני ה-wait."}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "Open", "topic": ["Synchronization", "Threads", "Concurrency", "Atomic Operations", "Semaphores", "Mutexes"], "content": {"text": "הוא אובייקט סנכרון N-חוטים (N פרמטר אתחול) עם פעולה אחת: checkin, אשר נועדה לסנכרן שלב בביצוע של N החוטים.\nבקריאה לפעולה checkin, כל חוט הקורא לפעולה ממתין עד שכל N החוטים ביצעו קריאה לפעולה. רק כאשר כל N החוטים קראו לפעולה checkin, החוטים יחזרו עבודתם (כולם ימשיכו לפעולה הבאה). במילים אחרות, חוט שקורא ל-checkin הוא (הראשון) משחרר מחסום, וכל שאר החוטים שמגיעים ל-checkin ממתינים. חוט ה-N שמבצע קריאה ל-checkin (האחרון) משחרר מחסום את כל החוטים, שממתינים לבין מהקריאה הבאה.\nשימו לב: הפעולה checkin אינה חד-פעמית. לאחר חזרה מקריאה ל-checkin ניתן לקרוא שוב לפעולה ולחכות שוב – עד אשר כל החוטים גם יקראו שוב ל-checkin, וכן הלאה.\nבשאלת זו ניתן להתעלם מבעיות int והבחון שהייצוג אינו אטומי (אין overflow), וניתן להשתמש ב-spinning.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "7.1", "text": "נתונה מערכת עם N חוטים בה לכל חוט יש מזהה i (בין 0 ל-N-1) אשר מועבר כפרמטר לפעולת checkin, ונתון מימוש חלקי ל-Barrier המשתמש במערך בגודל N.\nהשלימו את המימוש ע\"י כתיבת הקוד של הפעולה checkin, ללא שימוש בפעולות אטומיות או אובייקטי סנכרון אחרים. אין להוסיף שדות למבנה או לשנות את הקוד הנתון מלבד היכן שנדרש.", "code_snippet": "typedef struct {\n  int N;\n  int *arr;\n} Barrier;\n\nvoid init(Barrier *bar, int N) {\n  bar->N = N;\n  bar->arr = (int*) calloc(sizeof(int), N);\n}\n\nvoid destroy(Barrier *bar) {\n  free(bar->arr);\n}\n\nvoid checkin(Barrier *bar, int i) {\n\n}", "options": null}, {"id": "7.2", "text": "ממשו Barrier עם שימוש באובייקטי סנכרון ופעולות אטומיות שנלמדו, תוך הקפדה על שימוש בזיכרון מינימלי. יש להגדיר את מבנה האובייקט (struct Barrier) ולממש את הפעולות הנתונות.\nשימו לב: בפעולת checkin בסעיף זה לא מתקבל הפרמטר i, לכן המימוש צריך להיות שונה ממסעיף הקודם.", "code_snippet": "typedef struct __barrier {\n\n} Barrier;\n\nvoid init(Barrier *bar, int N) {\n\n}\n\nvoid destroy(Barrier *bar) {\n\n}\n\nvoid checkin(Barrier *bar) {\n\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. נשתמש במערך בתור בורג לכל חוט, בו נספור כמה פעמים החוט קרא לפעולה checkin.\nובכל קריאה לפעולה החוט קודם את התא שלו ב-1 (הוא היחיד שמקדם את התא ולכן ניתן לקדם באופן בטוח), ואז יעבור על כל המערך כדי להמתין שכל שאר החוטים יכלו לפתוח את אותו ערך – כלומר קראו ל-checkin לפחות אותה כמות של פעמים. אז אפשר להתקדם.\n```c\nvoid checkin(Barrier *bar, int i) {\n  bar->arr[i]++;\n  for (int t = 0; t < bar->N; t++) {\n    while (bar->arr[t] < bar->arr[i]); // wait for t checkin\n  }\n}\n```\n2. נשתמש במונה שיספור כמה פעמים נקרא checkin ע\"י כל החוטים. כל פעם שמגיעים לפעולה של N – זה סימון שכל החוטים קראו ל-checkin (פעם אחת אם N, פעמיים אם 2N וכן הלאה).\nכאשר חוט קורא ל-checkin, הוא יקדם את המונה הגלובלי באופן אטומי (עם F&A ולפי הערך שיתקבל, יחכה עד שיגיע לפעולה הבאה של N – אז נדע שכל החוטים קראו ל-checkin לפחות אותה כמות של פעמים.\n```c\ntypedef struct __Barrier {\n  int N;\n  int checked;\n} Barrier;\n\nvoid init(Barrier *bar, int N) {\n  bar->N = N;\n  bar->checked = 0;\n}\n\nvoid checkin(Barrier *bar) {\n  int val = fetch_and_add(&bar->checked, 1);\n  while ((bar->checked / bar->N) == (val / bar->N));\n}\n\nvoid destroy(Barrier *bar) {\n  // empty\n}\n```"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתונה מערכת עם workload אקראי של 1MB וסדרתי של 50MB. בנוסף נתונים שלושה דיסקים קשיחים עם הנתונים הבאים:\nRPM: NEXUS 1200, PYLON 5400, PHOTON 5400\nSEEK TIME: NEXUS 10ms, PYLON 50ms, PHOTON 10ms\nTRANSFER RATE: NEXUS 200 MB/s, PYLON 100 MB/s, PHOTON 150 MB/s\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "איזה דיסק קשיח עדיף עבור ה-workload האקראי, ואיזה עדיף עבור הסדרתי?\nעבור האקראי:\nעבור הסדרתי:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "עבור ה-workload הסדרתי: מה אחוז הביצועים שנגיע אליו עבור כל אחד מהדיסקים הקשיחים?\nכלומר מה היחס (באחוזים) בין המהירות בפועל לבין המהירות המקסימלית של כל דיסק.\n:NEXUS\n:PYLON\n:PHOTON", "code_snippet": null, "options": null}, {"id": "8.3", "text": "לשיפור ביצועים ב-workload באקראי, הוחלט להשתמש במערך RAID-4 של דיסקים קשיחים מסוג PYLON.\nמה המספר המינימלי של דיסקים שנצטרך כדי לשפר את הביצועים על פני שימוש בדיסק אחד ללא RAID? יש לתת תשובה נפרדת לכל תרחיש:\nתרחיש ראשון:\nכמות דיסקים:\nתרחיש שני:\nכמות דיסקים:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. RPM 1200 הוא זמן סיבוב 50ms ← זמן המתנה לסיבוב של 25ms.\nRPM של 5400 - זמן המתנה לסיבוב של 5ms.\nזמן המיקום (seek+wait) לכל דיסק הוא:\nNEXUS 35ms\nPYLON 55ms\nPHOTON 15ms\nהזמן ב-ms שלוקח להעביר 1MB לכל דיסק הוא 1000 חלקי קצב ההעברה המקסימלי של הדיסק:\nNEXUS 5ms\nPYLON 10ms\nPHOTON 6.66ms\nבתרחיש האקראי של 1MB, סה\"כ הזמנים לפעולה לכל דיסק:\nNEXUS 40ms\nPYLON 65ms\nPHOTON 21.66ms\nנעדיף את הקצר ביותר שהוא PHOTON.\nבתרחיש הסדרתי של 50MB, סה\"כ הזמנים לפעולה לכל דיסק:\nNEXUS 250ms\nPYLON 500ms\nPHOTON 333ms\nנעדיף את הקצר ביותר שהוא NEXUS.\n2. לפי הנתונים מעלה, זה הקצב שנגיע אליו בתרחיש הסדרתי עבור כל דיסק:\nNEXUS 175 MB/s\nPYLON 90 MB/s\nPHOTON 144 MB/s\nבאחוזים מהקצב המקסימלי נקבל:\nNEXUS 87.5%\nPYLON 90%\nPHOTON 96%\n3. לפי הנתונים מעלה, זה הקצב שנגיע אליו בתרחיש האקראי עבור כל דיסק:\nNEXUS 25 MB/s\nPYLON 15.4 MB/s\nPHOTON 46 MB/s\nכלומר עלינו להגיע לקצב גבוה יותר מ-46MB/s כדי שה-RAID ישפר.\nבתרחיש אקראי של קריאות הביצועים של 4-RAID עם N דיסקים הם N-1)*R) כאשר R קצב ההעברה בתרחיש האקראי, במקרה שלנו 15.4=R ולכן 4=N.\nבתרחיש אקראי של כתיבות הביצועים של 4-RAID הם 2/R ללא תלות בכמות הדיסקים, לכן לא נוכל לשפר את הביצועים על פני אף אחד מהדיסקים הקיימים."}, "difficulty_estimation": "Medium"}]}, {"filename": "os22AC.json", "metadata": {"course_name": "Operating Systems", "year": "2022", "semester": "Semester A", "moed": "Moed C", "exam_date": "01.02.2022", "source_file": "os22AC.pdf"}, "questions": [{"id": 1, "type": "Open", "topic": ["Synchronization", "Semaphores", "Deadlocks"], "content": {"text": "האם יתכן קיפאון בתוכנית שמשתמשת רק בסמפורים שאינם בינאריים? אם כן, יש להדגים תרחיש שיוביל לקיפאון, אחרת יש להסביר בפירוט מדוע לא.\nיתכן / לא יתכן", "code_snippet": null, "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "יתכן. עם 2 סמפורים שמאותחלים ל-2, אפשר להגיע לאותה בעיה בסיסית שהוצגה בשיעור של קיפאון אם כל חוט מנסה להקצות לעצמו 2 משאבים מכל סמפור."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "Open", "topic": ["Scheduling", "CPU Scheduling"], "content": {"text": "מתי נעדיף להשתמש בתזמון lottery על פני תזמון stride ומדוע? מתי נעדיף להשתמש בתזמון stride על פני תזמון lottery ומדוע?", "code_snippet": null, "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "Open", "topic": ["File Systems", "I/O"], "content": {"text": "מתי נעיף להשתמש בכל אחת מרמות ה-RAID שנלמדו (0, 1, 4, 5)? יש לפרט ולנמק את הסיבות לשימוש בכל רמה.", "code_snippet": null, "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "Open", "topic": ["Scheduling", "CPU Scheduling", "Concurrency"], "content": {"text": "SQMS תזמון (single-queue multiprocessor scheduling) כפי שנלמד הוא בעייתי. הציעו דרך לשפר אותו באופן משמעותי, מבלי להשתמש בתורים נוספים. יש לפרט את השינויים ולנמק מדוע ישפרו את הביצועים.", "code_snippet": null, "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "Open", "topic": ["File Systems"], "content": {"text": "למה משמש ה-imap במערכת הקבצים LFS? מתי וכיצד נשתמש בו? מתי נקרא אותו מהדיסק?", "code_snippet": null, "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Virtual Memory", "Paging", "Memory Management"], "content": {"text": "מתי מתרחש TLB miss? מה התהליך המלא שקורה בעקבות TLB miss?", "code_snippet": null, "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Mutexes", "Concurrency", "Atomic Operations", "Threads"], "content": {"text": "נתון קטע הקוד הבא למימוש מנעול עבור N חוטים, כאשר לכל חוט מזהה ייחודי (בין 0 ל-1-N) המועבר כפרמטר me לפונקציית lock:", "code_snippet": "typedef struct {\nint turn;\nint busy;\n} FlakyLock;\n\nvoid init(FlakyLock *lock) {\nlock->busy = 0;\n}\n\nvoid lock(FlakyLock *lock, int me) {\ndo {\ndo {\nlock->turn = me;\n} while (lock->busy);\nlock->busy = 1;\n} while (lock->turn != me);\n}\n\nvoid unlock (FlakyLock *lock) {\nlock->busy = 0;\n}", "options": null}, "sub_questions": [{"id": "a", "text": "האם המנעול מקיים מניעה הדדית?", "code_snippet": null, "options": ["כן", "לא"], "solution": {"is_present_in_file": true, "correct_option": "כן", "explanation": "מניעה הדדית -מתקיימת.\nנניח בשלילה שיש 2 חוטים (או יותר) בקטע הקריטי. שניהם יצאו מהלולאה החיצונית כלומר כל אחד ראה שה-turn שווה למזהה שלו. נבחין שהיחיד שמעדכן את turn למזהה של חוט הוא אותו חוט עצמו כלומר כל אחד מ-2 החוטים עדכן בשלב מסוים את התור עבור עצמו.\nנסתכל על החוט השני שיצא מהלולאה, חוט זה בהכרח עדכן את התור אחרי שהחוט הראשון יצא מהלולאה (אחרת היה רואה שהתור לא שלו). אותו חוט ראשון, לפני היציאה מהלולאה עדכן גם את busy ל-1. החוט השני בודק את המשתנה busy אחרי עדכון התור (שהתבצע אחרי שהחוט הראשון נכנס לקטע הקריטי, כלומר בהכרח אחרי שעדכן כבר את busy), לכן החוט השני בהכרח חסום בלולאה הפנימית ולא יתכן שנכנס לקטע הקריטי."}}, {"id": "b", "text": "חופש מקיפאון:", "code_snippet": null, "options": ["כן", "לא"], "solution": {"is_present_in_file": true, "correct_option": "לא", "explanation": "חופש מקיפאון – לא מתקיים.\nדוגמה נגדית: חוט 0 מנסה לתפוס את המנעול, מעדכן את התור ל-0 ואז את busy ל-1. לפני שמגיע לתנאי בלולאה החיצונית, חוט 1 מנסה לתפוס את המנעול ומעדכן את התור ל-1 וכעת חסום בלולאה הפנימית בגלל busy. חוט 0 לא עובר את הלולאה החיצונית (כי התור הוא 1) וחוזר ללולאה הפנימית, שם מעדכן את התור ל-0 וחסום בגלל busy. 2 החוטים חסומים ולא יצליחו לתפוס את המנעול לעולם, למרות שהמנעול פנוי."}}, {"id": "c", "text": "הוגנות:", "code_snippet": null, "options": ["כן", "לא"], "solution": {"is_present_in_file": true, "correct_option": "לא", "explanation": "הוגנות – לא מתקיימת.\nדוגמה נגדית: חוט 0 מנסה לתפוס את המנעול, מעדכן את התור ל-0 ונעצר לפני עדכון busy. חוט 1 מנסה לתפוס את המנעול, מעדכן את התור ל-1 ומתקדם ונכנס אל הקטע הקריטי. כעת חוט 0 יתקדם ויראה שלא תורו, לכן יהיה חסום בלולאה הפנימית.\nחוט 1 ישחרר את המנעול (יעדכן busy ל-0) ולפני שחוט 0 יראה זאת, חוט 1 ינסה לתפוס את המנעול שוב ויעדכן שוב את התור ל-1 ואת busy ל-1 (ויכנס לקטע הקריטי). חוט 0 ממשיך להיות חסום בלולאה הפנימית. כך חוזר חלילה."}}], "points": 20, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 8, "type": "Open", "topic": ["Memory Management", "Paging", "Virtual Memory"], "content": {"text": "נתונה מערכת עם זיכרון פיזי של 64KB וגודל דף של 512B. כל טבלת דפים תופסת דף יחיד, ותהליך התרגום של כתובת וירטואלית לפיזית מתבצע ברמה אחת בלבד. כל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת, ריפוד, ועוד שלושה ביטים: ביט valid, ביט access, ביט dirty", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "מה גודל הזיכרון הוירטואלי של תהליך?\nגודל זיכרון:", "code_snippet": null, "options": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. תרגום ברמה אחת זו טבלת דפים לינארית. כתובת פיזית היא 216 בתים כלומר 16 ביטים לכתובת, מתוכם 9 ביטים עבור היסט (גודל דף 29 בתים). לכן ה-PFN הוא 7 ביטים.\nכל PTE מכיל PFN ועוד 3 ביטים, נוסיף ריפוד כדי להגיע לחזקה הקרובה של 2 ונקבל 16 ביטים = 2 בתים לכל כניסה בטבלת הדפים.\nגודל דף הוא 512B ונתון שטבלת הדפים תופסת דף יחיד, לכן יש 256 דפים לתהליך, גודל כל דף 512B וסה\"כ הזיכרון הוירטואלי הוא 128KB."}}, {"id": "8.2", "text": "נתון שחצי מהזיכרון הפיזי במערכת משוריין עבור מערכת ההפעלה, והמערכת אינה תומכת בהחלפה (swapping) או במנגנון copy-on-write.\nנניח שהרצנו תהליך יחיד במערכת (לא רץ במערכת אף תהליך אחר) אשר מבצע קריאות ל-fork בלולאה עד שנגמר הזיכרון הפיזי במערכת. התהליך המקורי (וכל תהליך בן שנוצר) משתמש ב-10 דפים של קוד ו-5 דפים של מחסנית.\nכמה תהליכי משתמש יכולים להיווצר סך הכל, כולל התהליך הראשי?\nמספר תהליכים:", "code_snippet": null, "options": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "2. בזיכרון הפיזי יש 128 מסגרות (לפי סעיף קודם), חצי משוריינות למערכת ההפעלה (מרחב הקרנל) כלומר 64 לקרנל ו-64 לתהליכים (מרחב המשתמש).\nכל תהליך דורש מסגרת אחת במרחב הקרנל עבור טבלת הדפים.\nהקוד משותף לכל התהליכים, לכן במרחב המשתמש נתפוס 10 מסגרות עבור הקוד (לכל התהליכים יחד), ועוד 5 מסגרות עבור המחסנית של כל תהליך.\nעם 10 תהליכים נקבל שתפוסות 10 מסגרות בקרנל ו-60 מסגרות במשתמש ולא נוכל ליצור תהליכים נוספים (כי אין מספיק מקום במרחב המשתמש)."}}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}]}, {"filename": "os22BA.json", "metadata": {"course_name": "Operating Systems", "year": "2022", "semester": "Semester B", "moed": "Moed A", "exam_date": "13.06.2022", "source_file": "os22BA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "בכונן SSD, קריאות מרובות מאותו קובץ אינן מאיצות את שחיקת הדיסק.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. קריאות אמנם מגבירות את הסיכוי להפרעות (disturbance) אבל לא שוחקות את הדיסק (זיכרון flash נשחק ממחזורי מחיקה + כתיבה)."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling"], "content": {"text": "זמן המחזור הממוצע של תזמון FIFO תמיד עדיף או שווה ל-RR.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. לדוגמה עבור תהליך ארוך שמידע אחריו מגיע תהליך קצר, זמן המחזור הממוצע של FIFO גרוע יותר."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency", "Atomic Operations"], "content": {"text": "במשתני תנאי (condition variable), אם נבטל את תפיסת המנעול המובנית ב-wait ובמקום זאת נבצעה באופן ידני מיד לאחר כל קריאה ל-wait, זה לא ישפיע על הנכונות ולא יוסיף בעיות חדשות.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. ב-wait שחרור המנעול והכניסה להמתנה מתבצעות באופן אטומי, אבל לאחר התעוררות (קבלת הסיגנל) מתבצעת תפיסת מנעול כרגיל, ואין הבדל אם תפיסת המנעול מחדשת מתבצעת בתוך ה-wait או באופן ידני מיד לאחר ה-wait, כל עוד היא מתבצעת."}, "difficulty_estimation": "Hard"}, {"id": 4, "type": "MultipleChoice", "topic": ["Threads", "Processes", "Concurrency"], "content": {"text": "חוטים במרחב המשתמש (user threads) יכולים לשפר את ביצועי התוכנית.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. בשימוש בחוטים במרחב המשתמש עדיין ניתן לשפר את ביצועי התוכנית ע\"י חפיפה (overlap) – הרצת קוד בחוט אחד בזמן שחוט אחר ממתין לקלט/פלט."}, "difficulty_estimation": "Easy"}, {"id": 5, "type": "MultipleChoice", "topic": ["I/O", "System Calls"], "content": {"text": "שימוש ב-DMA חוסך את זמן העברת הנתונים מ/אל ההתקן בלבד.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. שימוש ב-DMA חוסך לא רק את העברת הנתונים, אלא גם את הטיפול בפסיקות ושליחת פקודות מחדש במקרה של פעולות קריאה/כתיבה גדולות."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה מערכת עם גודל דף של 4KB וטבלת דפים היררכית. כל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת ועוד ביט present בלבד. נתון שהגודל של PTE ו-PDE זהה, וכל טבלה/חלק מאוחסנים בדף אחד בדיוק (לא יותר ולא פחות). יש לפרט ולנמק את החישובים בכל סעיף.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "נתון שעבור תהליך המשתמש בכל הדפים במרחב הכתובות שלו, טבלת דפים ב-3 רמות תופסת 1+2048+20482 מסגרות בזיכרון הפיזי. מה מרחב הכתובות של תהליך ומה גודל הזיכרון הפיזי המקסימלי? מרחב הכתובות: זיכרון פיזי מקסימלי: נימוק:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "כיצד תשתנה התשובה לסעיף הקודם אם עבור תהליך שמשתמש בכל הדפים במרחב הכתובות שלו, טבלת דפים ב-2 רמות תופסת 1+1024 מסגרות בזיכרון הפיזי? מרחב הכתובות: זיכרון פיזי מקסימלי: נימוק:", "code_snippet": null, "options": null}, {"id": "6.3", "text": "נתון תהליך המשתמש ב-5 דפים של זיכרון, כאשר 2 מהדפים רצופים בזיכרון התהליך. מה הגודל המינימלי והמקסימלי של הזיכרון הפיזי שתתפוס טבלת הדפים של התהליך, לפי נתוני כל אחד מהסעיפים הקודמים? יש לספק 4 תשובות. גודל מינימלי 6.1: גודל מינימלי 6.2: גודל מקסימלי 6.1: גודל מקסימלי 6.2:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. עבור תהליך שמשתמש בכל הדפים בזיכרון שלו כל חלקי הטבלה יהיו מלאים. ברמה הראשונה תמיד יש מסגרת אחת, וברמה השלישית יש בריבוע לעומת הקודמת – כלומר שיש 2048 כניסות בכל חלק של הטבלה. לפי גודל הדף, כל כניסה היא 16 ביט (2 בתים). כל PTE מכיל מספר מסגרת ועוד ביט אחד כלומר 15 עבור ה-PFN. גודל מסגרת 4KB לכן הזיכרון הפיזי הוא 2^12*2^15 = 128MB. לפי גודל הטבלה יש 3 רמות ובכל אחת 2^11 כניסות, כלומר ה-VPN הוא 33 ביטים, מכאן שלתהליך יש 2^33 דפים. מרחב הכתובות הוא 32TB.\n2. כמו הסעיף הקודם רק עם 1024 כניסות בכל טבלה, לכן כל כניסה היא 32 ביט. לפיכך יש 31 ביט עבור PFN, זיכרון פיזי מקסימלי הוא 2^12*2^31 = 4TB. לפי גודל הטבלה יש 2^11 כניסות בכל רמה, כלומר ה-VPN הוא 22 ביטים, לתהליך יש 2^22 דפים. מרחב הכתובות הוא 4GB.\n3. במינימום ל-2 הסעיפים, המיפויים של כל הדפים נמצאים באותה טבלה ברמה האחרונה, ולכן הטבלה כולה תופסת דף אחד בכל רמה. מינימום 6.1 זה 3 מסגרות, מינימום 6.2 זה 2 מסגרות. במקסימום, נרצה שהמיפוי של כל דף יהיה בחלק אחר של הטבלה (תת-טבלה נפרדת ברמה התחתונה), גם עבור 2 הדפים הרצופים – המיפוי של אחד יהיה האחרון בחלק שלו והמיפוי של השני יהיה הראשון בחלק הבא. בכל מקרה יש מסגרת אחת ברמה העליונה. עבור 6.1 יהיו 5 מסגרות ברמה השניה ועוד 5 בשלישית, סה\"כ 11 מסגרות. עבור 6.2 יהיו 5 ברמה השניה, סה\"כ 6 מסגרות."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "Open", "topic": ["Synchronization", "Concurrency", "Semaphores", "Mutexes"], "content": {"text": "בשאלה זו יש לממש מנעול קוראים-כותבים (Reader-Writer Lock) אשר מקיים את שלוש התכונות: מניעה הדדית, חופש מקיפאון, והוגנות. ראשית, יש להגדיר מחדש את תכונות אלו באופן שתואם למנעול קוראים-כותבים, ולאחר מכן יש לספק מימוש מנעול אשר מקיים את התכונות.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "7.1", "text": "עבור מנעולים נלמדו שלוש תכונות שמימוש יכול לקיים: מניעה הדדית, חופש מקיפאון, והוגנות. תכונות אלו אפיינו את הפעולה הרצויה של מנעול רגיל. הגדירו מחדש את שלוש תכונות אלו, כך שיאפיינו במדויק את אופן הפעולה של מנעול קוראים-כותבים. כלומר, יש לנסח מחדש את ההגדרות כך שיהיו תואמות באופן ספציפי לתנאים הנדרשים במימוש מנעול קוראים-כותבים. שימו לב: ההגדרות אינן בהכרח זהות לאלו של מנעול רגיל (לדוגמה, כי מתאפשר יותר מחוט אחד בקטע הקריטי). מניעה הדדית: חופש מקיפאון: הוגנות:", "code_snippet": null, "options": null}, {"id": "7.2", "text": "ממשו מנעול קוראים-כותבים אשר מקיים את שלוש התכונות, עם שימוש בסמפורים בלבד (ללא פעולות אטומיות או אובייקטי סנכרון אחרים)", "code_snippet": "typedef struct __rw_lock {\n} RWLock;\nvoid init(RWLock *lock) {\n}\nvoid destroy (RWLock *lock) {\n}\nvoid acquire_writelock(RWLock *bar) {\n}\nvoid release_writelock(RWlock *bar) {\n}\nvoid acquire_readlock(RWlock *bar) {\n}\nvoid release_readlock (RWlock *bar) {\n}\n", "options": null}, {"id": "7.3", "text": "הוכיחו בקצרה שמימוש המנעול בסעיף הקודם אכן מקיים את שלוש התכונות. מניעה הדדית: חופש מקיפאון: הוגנות:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. מניעה הדדית: יש לכל היותר חוט כותב אחד בקטע הקריטי, או כל מספר של חוטים קוראים בקטע הקריטי. לא יתכן חוט כותב וקורא בו זמנית בקטע הקריטי.\nחופש מקיפאון: אם אף חוט לא נמצא בקטע הקריטי, חוט כלשהו יכנס לקטע הקריטי בסופו של דבר. אם יש רק חוטים קוראים בקטע הקריטי, חוט קורא כלשהו יכנס לקטע הקריטי בסופו של דבר.\nהוגנות: זהה להגדרה של מנעול רגיל (אם חוטים נכנסים ויוצאים מהקטע הקריטי, אז כל חוט נכנס לקטע הקריטי בסופו של דבר).\n2. המימוש מבוסס על הפתרון שנלמד בשיעור, עם שימוש בסמפורים בינאריים במקום מנעולים. כדי להתמודד עם הרעבת הכותבים, נוסיף מנעול הוגן נוסף (סמפור בינארי) ל-2 פעולות הנעילה, אשר יוודא שלא ניתן לעקוף אף חוט מספר לא מוגבל של פעמים. פעולות השחרור יהיו זהות.\n```c\ntypedef struct _rw_lock {\n    int numReaders;\n    sem_t writelock; // binary semaphore (init to 1)\n    sem_t readlock; // -\"-_\n    sem_t enterlock; // -\"-\n} RWLock;\nvoid acquire_writelock(RWLock *lock) {\n    sem_wait(&lock->enterlock); // don't allow any acquire\n    sem_wait(&lock->writelock);\n    sem_post(&lock->enterlock); // now others can acquire\n}\nvoid acquire_readlock(RWLock *lock) {\n    sem_wait(&lock->enterlock); // don't allow any acquire\n    sem_wait(&lock->readlock);\n    if (++lock->numReaders == 1)\n        sem_wait(&lock->writelock);\n    sem_post(&lock->readlock);\n    sem_post(&lock->enterlock); // now others can acquire\n}\n```"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "Memory Management"], "content": {"text": "נתונה מערכת קבצים VSFS עם סופר-בלוק בבלוק 1, ושאר מערכת הקבצים מבלוק 2 והלאה. תוכן הסופר-בלוק מיוצג ע\"י המבנה הבא: כל inode מכיל 9 מצביעים ישירים, 2 מצביעים עקיפים, ו-1 מצביע עקיף כפול. גודל מצביע הוא 4 בתים, ונתונים הערכים הבאים: bsize = 4096 inode_size = 128 nblocks = 200 * 1000 * 1000 ninodes = 12 * 1000 * 1000 יש לפרט ולנמק את החישובים בכל סעיף.", "code_snippet": "struct superblock {\nint bsize; // block size\nint inode_size; // sizeof(struct inode)\nint nblocks; // number of data blocks on the disk\nint ninodes; // number of inodes\nint inode_start; // start of inodes area\nint data_start; // start of data block area\nint i_bmap_start; // start of inode bit map\nint d_bmap_start; // start of data bit map\nint max_file_size; // maximum size of file\n};", "options": null}, "sub_questions": [{"id": "8.1", "text": "לגבי כל אחד מהשדות הבאים, ציינו האם ניתן לדעת את ערכו. אם כן, יש לציין מה הערך, אחרת יש לציין מה הנתון החסר. inode_start: ניתן לדעת / לא ניתן לדעת data_start: ניתן לדעת / לא ניתן לדעת i_bmap_start: ניתן לדעת / לא ניתן לדעת d_bmap_start: ניתן לדעת / לא ניתן לדעת max_file_size: ניתן לדעת / לא ניתן לדעת", "code_snippet": null, "options": null}, {"id": "8.2", "text": "נתון קובץ בגודל המקסימלי האפשרי. המשתמש ביצע מחיקה של קובץ זה ממערכת הקבצים (לחלוטין, כלומר שלא נותרו עוד hard-links אל הקובץ), כאשר לפני הפעולה ידוע רק מספר ה-inode של הקובץ ושל התיקייה המכילה אותו, ואף cache אינו מכיל מידע רלוונטי. יש להניח שזה הקובץ היחיד בתיקייה. מה מספר הבלוקים המקסימלי שנצטרך לקרוא ולכתוב תוך כדי המחיקה, במקרה המקסימלי? יש לפרט את כל הבלוקים. בלוקים לקריאה: בלוקים לכתיבה:", "code_snippet": null, "options": null}, {"id": "8.3", "text": "נתונה מערכת קבצים חדשה וריקה מלבד תיקייה אחת ובה קובץ יחיד בשם a.txt בגודל 40,000 בתים. בתיקייה זו, משתמש ביצע את הפקודות הבאות: מיד לאחר מכן, המשתמש ביצע את הפקודה הבאה: rm -r d1 # remove all files in d1, and d1 itself תארו את כל הפעולות במערכת הקבצים בעקבות הרצת הפקודה rm, לפי סדר הביצוע ובמקרה המינימלי. יש לפרט כמה בלוקים צריך לכתוב, לקרוא, ומאיזה סוג (DATA, inode, inode bitmap, וכו'). כמות בלוקים שנקראים: בלוקים לכתיבה:", "code_snippet": "mkdir d1\ncp a.txt d1/x.txt\nIn a.txt d1/y.txt\nln -s a.txt d1/z.txt\nrm -r d1 # remove all files in d1, and d1 itself", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. גודל בלוק הוא 4096B, כלומר 32,768 ביטים עבור כל bitmap. יש 12,000,000 inodes לכן נדרש 367 בלוקים עבור inode bitmap. גודל כל inode הוא 128 בתים לכן נדרש 375,000 בלוקים עבור inodes. יש 200,000,000 בלוקים של DATA לכן נדרש 6104 בלוקים עבור data bitmap לפי סדר ברירת המחדל של VSFS נקבל: אזור inode bitmap ראשון לכן i_bmap_start הוא 2 אזור data bitmap שני לכן יתחיל אחרי 367 בלוקים נוספים – d_map_start הוא 369 אזור inodes שלישי לכן יתחיל אחרי 6104 בלוקים נוספים – inode_start הוא 6473. אזור data רביעי לכן יתחיל אחרי 375,000 בלוקים נוספים – data_start הוא 381473 בכל בלוק נכנסים 1028 מצביעים, לכן גודל הקובץ המקסימלי max_file_size הוא: (9 + 2*1024 + 1024^2) * 4KB\n2. כדי למחוק קובץ אין צורך לגשת לכל הבלוקים שלו, אך כן נדרש לסמן את כל הביטים של כל הבלוקים שלו ב- data bitmap. הבלוקים האלו כוללים לא רק את אלו המייצגים את נתוני הקובץ אלא גם את הבלוקים של המצביעים. יש בלוק 1 של מצביעים במצביע העקיף, ועוד 1+1024 דרך המצביע העקיף הכפול. מאחר שמתואר המקרה המקסימלי, זה ידרוש גישה (קריאה + כתיבה) של כל 6104 הבלוקים ב-data bitmap. כדי לדעת באילו בלוקים נמצאים נתוני הקובץ נצטרך לקרוא את כל הבלוקים של המצביעים עצמם: 2 בלוקים של המצביעים הישירים ועוד 1+1024 של המצביע העקיף, וגם לקרוא את ה-inode של הקובץ: עוד 1028 קריאות. בנוסף, נדרש למחוק את הקובץ מהתיקייה המכילה אותו – קריאה וכתיבה של ה-inode של התיקייה וגם של ה-DATA של אותה תיקייה (זה הקובץ היחיד לכן יופיע בבלוק DATA הראשון של התיקייה): קריאה וכתיבה של 2 בלוקים. לסיום נצטרך לקרוא ולכתוב בלוק אחד של inode bitmap כדי לסמן שהקובץ מחוק. יש לשים לב שלא נדרש לכתוב אל ה-inode של הקובץ – כדי למחוק קובץ נעדכן ב-inode bitmap ואין צורך לשנות כלום ב-inode עצמו. קריאה של 7135 בלוקים (1 + 2 + 1028 + 6104) כתיבה של 6107 בלוקים (1 + 2 + 6104)\n3. לפי גודל הקובץ (40,000) הנתונים שלו תופסים 10 בלוקים של DATA. לפי מבנה ה-inode ל-9 הראשונים ניגש ממצביע ישיר, ואל העשירי דרך מצביע עקיף. אלו הפעולות שיש לבצע: 1. קריאת inode של התיקייה ואז DATA כדי לאתר את הכניסה של d1. 2. קריאת inode של d1 ואז ה-DATA כדי לאתר את הכניסות של x,y,z. 3. מחיקת x: קריאת ה-inode של x, קריאת בלוק מצביעים, לאחר מכן קריאה וכתיבה של ה-data bitmap לשחרור כל הנתונים של x (במקרה המינימלי הכל באותו בלוק), ובנוסף קריאה וכתיבה של בלוק אחד של inode bitmap לשחרור x. 4. מחיקת ע: קריאת ה-inode, זה hard-link לכן נדרש רק לעדכן את ה-inode לקישור אחד פחות. 5. מחיקת z: כמו מחיקת x אך מכיל רק בלוק DATA יחיד עם תוכן הקישור הסימבולי. 6. מחיקת הרשומות מהתיקייה לא נספרת כי התיקייה נמחקת כולה (אין צורך לעדכן נתונים). 7. מחיקת d1: עדכון (קריאה וכתיבה) של data bitmap וגם inode bitmap. 8. עדכון התיקייה הנוכחית (בה נמצא (d1): קריאת inode, קריאה ועדכון של DATA. במקרה המינימלי, כל ה-inodes באותו בלוק (ובהתאם ב-inode bitmap) וכל ה-DATA נמצאים באותו בלוק data bitmap, לכן יש רק קריאה וכתיבה אחת לכל אחד מאלו. נקבל סה\"כ: 7 קריאות ו-4 כתיבות."}, "difficulty_estimation": "Hard"}]}, {"filename": "os22BB.json", "metadata": {"course_name": "Operating Systems", "year": "2022", "semester": "Semester B", "moed": "Moed B", "exam_date": "18.07.2022", "source_file": "os22BB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Disk Scheduling", "I/O"], "content": {"text": "בתזמון SCAN לעומת C-SCAN, הראש הקורא-כותב עובר את אותו מרחק בסקטורים, וההבדל מתבטא רק בסדר הטיפול בבקשות / סקטורים.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. דוגמה נגדית: הראש הקורא-כותב היה בסקטור 40 והגיעו בקשות ל-10 ו-20. בתזמון SCAN נטפל קודם ב-20 ואז 10 (מרחק כולל של 30), אך ב-C-SCAN נטפל קודם ב-10 ואז ב-20 (מרחק כולל של 40)."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Memory Management", "Concurrency", "IPC"], "content": {"text": "בגישה לזיכרון משותף יש הבדל בביצועים בין פעולות קריאה לפעולות כתיבה.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. פעולות כתיבה דורשות אקסקלוסיביות ושליחת הודעת invalidate על גבי ה-bus ולכן פוגעות יותר בביצועים לעומת קריאות שיכולות להתבצע באופן מקומי גם כאשר למעבדים אחרים יש את אותו ערך.\nהסבר נוסף: עבור זיכרון משותף בין תהליכים עם מנגנון copy-on-write, פעולות כתיבה יכולות לגרור שכפול של הזיכרון."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "אם כל המסגרות בזיכרון תפוסות, לא ניתן להקצות זיכרון חדש לתהליכים.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. באמצעות מנגנון ההחלפה אנו לא מוגבלים לכמות המסגרות בזיכרון הפיזי ויכולים לאחסן דפים בדיסק."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Processes", "Scheduling"], "content": {"text": "תהליך במצב Ready יכול להסתיים.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. ע\"י קריאות חיצוניות כמו kill ניתן לעצור תהליך גם כשהוא לא במצב Running.\n(התקבל גם: לא נכון, כאשר מתייחסים לריצה תקינה וסיום יזום ע\"י התהליך)."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Synchronization", "Deadlocks", "Mutexes"], "content": {"text": "בשימוש במנעולים המקיימים חופש מקיפאון ניתן להגיע לקיי יע לקיפאון.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. הדוגמה הקלאסית של קיפאון (2 חוטים שתופסים 2 מנעולים בסדר הפוך) יכולה להוביל לקיפאון גם אם 2 המנעולים מקיימים חופש מקיפאון."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "IPC"], "content": {"text": "נתונה התוכנית הבאה:\nניתן להניח שכל הקריאות ל-fork הצליחו.", "code_snippet": "int main() {\n  int r1 = fork() || fork();\n  if (r1) {\n    char* args[3] = {\"echo\", \"r1: TRUE\", NULL};\n    execvp(args[0], args);\n    printf(\"r1: TRUE\\n\");\n  } else {\n    printf(\"r1: FALSE\\n\");\n  }\n  wait(NULL);\n\n  int r2 = fork() && fork();\n  if (r2) {\n    char* args[3] = {\"echo\", \"r2: TRUE\", NULL};\n    execvp(args[0], args);\n  }\n  else {\n    printf(\"r2: FALSE\\n\");\n  }\n  if (r1 || r2)\n    printf(\"END\\n\");\n}"}, "sub_questions": [{"id": "6.1", "text": "כתבו פלט אפשרי של התוכנית הנתונה בהנחה שכל קריאות המערכת הצליחו, ולאחריו הסבר.", "code_snippet": null, "options": null}, {"id": "6.2", "text": "כמה תהליכים נוצרו במהלך ריצה תקינה של התוכנית, כולל התהליך הראשי?\nמספר תהליכים:\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.3", "text": "האם יתכנו זומבים בשלב כלשהו במהלך הריצה? אם כן, יש לציין את כל תהליכי הזומבים האפשריים בכל שלב, אחרת להסביר מדוע לא.\nיתכנו זומבים / לא יתכנו זומבים", "code_snippet": null, "options": null}, {"id": "6.4", "text": "במידה ולא קיים הקובץ echo במערכת, האם התשובה לסעיף 6.2 תשתנה?\nאם כן, יש לציין את התשובה לאחר השינוי, אחרת להסביר מדוע אין שינוי.\nהתשובה תשתנה: / התשובה לא תשתנה", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. בשורת ()fork() || fork נוצרים 2 תהליכים חדשים: תהליך בן ותהליך נכד.\nהקריאה ל-execvp לא חוזרת, כלומר 2 התהליכים שיגיעו לשורה 5 (האב והבן) לא ימשיכו הלאה.\nהתהליך שמגיע ל-wait בשורה 10 הוא הנכד, אין לו בנים לכן מיד ימשיך הלאה.\nבשורת ()fork() && fork נוצרים 2 תהליכים חדשים: 2 תהליכי בנים (של הנכד המקורי).\nל-execvp בשורה 15 מגיע תהליך יחיד (הנכד המקורי), ולא ממשיך הלאה.\nאף אחד לא ידפיס את הפלט בשורה 20 (עבור 2 התהליכים שנותרו מתקיים 0==r1==r2).\nפלט:\nr1: TRUE\nr1: TRUE\nr1: FALSE\nr2: TRUE\nr2: FALSE\nr2: FALSE\n2. לפי ההסבר בסעיף הקודם נוצרו 5 תהליכים.\n3. כל תהליך יכול להיות זומבי מלבד התהליך הראשי (שלא ידוע לגביו).\nאין אף מנגנון שמכתיב סדר בין התהליכים. בכל נקודה בריצה, כל תהליך בן שמסתיים לפני תהליך האב שלו יהפוך לזומבי עד שתהליך האב יסתיים גם.\n4. אם echo לא קיים אז כל הקריאות ל-execvp יכשלו והתהליכים ימשיכו הלאה לפקודה הבאה במקום לא לחזור מהקריאה.\n2 התהליכים שהגיעו לשורה 5 ימשיכו לשורה 12, כל אחד מהם מייצר 2 תהליכי בנים שלא נוצרו קודם. נוספו 4 תהליכים שלא היו קודם, סה\"כ 9 תהליכים."}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "Open", "topic": ["Synchronization", "Mutexes", "Atomic Operations", "Concurrency", "Threads"], "content": {"text": "מנעול ניתן לביטול (Abortable Lock) הוא מנעול אשר, מלבד פעולת הנעילה הסטנדרטית, מכיל פעולה נוספת שיכולה לחזור מבלי לתפוס את המנעול. לדוגמה, המנעול המובנה של לינוקס הוא מנעול ניתן לביטול עם 2 הפעולות שנלמדו: trylock, timedlock.\nפעולת נעילה נוספת זו נדרשת להחזיר 0 אם תפסה את המנעול בהצלחה, ומספר אחר אם לא. ניתן להניח שהחוט בודק את ערך ההחזר ולא נכנס לקטע הקריטי אם הנעילה נכשלה.\nלשאלה זו מצורפים המימושים הרגילים שנלמדו בכיתה (ללא ביטול) של שני המנעולים הבאים: מנעול TTAS, מנעול Anderson Queue Lock) ALock). המימושים מצורפים ללא פונקציות אתחול והריסה. הקבוע N הוא מספר החוטים המקסימלי, והמשתנה mine הוא משתנה עזר ייחודי לכל חוט (אשר ערכו נשמר בין קריאות עבור אותו חוט בלבד).\nבשאלה זו יש לממש מנעול ניתן לביטול ע\"י מימוש פעולת trylock, המבוסס על מנעולים אלו.\nשימו לב: בכל סעיף נדרש גם לעדכן את פעולת lock (נעילה ללא ביטול) כך שתעבוד עם השינויים. ניתן להניח שחוט אשר קרא ל-trylock ונכשל לא יבצע קריאה נוספת ל-trylock לפני שתפס את המנעול בהצלחה. כלומר, אחרי קריאת trylock שנכשלה מובטח שהקריאה הבאה של החוט (אם תהיה כזו) תהיה קריאה ל-lock.\nיש לשמור על כל התכונות של המימוש הקיים של כל מנעול (מניעה הדדית, חופש מקיפאון, הוגנות). ניתן להשתמש בפעולות אטומיות כרצונכם, אך לא ניתן להשתמש באובייקטי סנכרון אחרים.", "code_snippet": "typedef struct {\n  int state;\n} TTASLock;\n\nvoid lock(TTASLock *lock) {\n  while (1) {\n    while (lock->state);\n    if (!testAndSet(&lock->state, 1))\n      return;\n  }\n}\n\nvoid unlock (TTASLock *lock) {\n  lock->state = 0;\n}\n\ntypedef struct {\n  int next;\n  int flags[N];\n} ALock; // Anderson queue lock\n\nvoid lock(ALock *lock, int *mine) {\n  *mine = fetchAndAdd(&lock->next);\n  while (!lock->flags[(*mine) % N]);\n}\n\nvoid unlock (ALock *lock, int *mine) {\n  lock->flags[(*mine) % N] = 0;\n  lock->flags[(*mine+1) % N] = 1;\n}"}, "sub_questions": [{"id": "7.1", "text": "ממשו מנעול TTAS הניתן לביטול.\nהסבר:", "code_snippet": "typedef struct _ttas_lock {\n    int state;\n} TTASLock;\n\nvoid init(TTASLock *lock) {\n    lock->state = 0;\n}\n\nint destroy(TTASLock *lock) {\n    return 0;\n}\n\nvoid lock(TTASLock *lock) {\n    while (1) {\n        while (lock->state);\n        if (!testAndSet(&lock->state, 1))\n            return;\n    }\n}\n\nint trylock(TTASLock *lock) {\n    if ((lock->state) || (testAndSet(&lock->state, 1)))\n        return 1;\n    else\n        return 0;\n}\n\nvoid unlock(TTASLock *lock) {\n    lock->state = 0;\n}", "options": null}, {"id": "7.2", "text": "ממשו מנעול אנדרסון (ALock) הניתן לביטול.\nהסבר:", "code_snippet": "typedef struct _a_lock {\n    int next;\n    int flags[2*N];\n} ALock;\n\nvoid init(ALock *lock) {\n    for (int i = 1; i < 2*N; ++i)\n        lock->flags[i] = 0;\n    lock->flags[0] = 1;\n    lock->next = 0;\n}\n\nint destroy(ALock *lock) {\n    return 0;\n}\n\nvoid lock(ALock *lock, int *mine) {\n    *mine = fetchAndAdd(&lock->next);\n    while (!lock->flags[(*mine) % (2*N)]);\n}\n\nint trylock (ALock *lock, int *mine) {\n    *mine = fetchAndAdd(&lock->next);\n    return ! testAndSet(&lock->flags[(*mine)%(2*N)], 1);\n}\n\nvoid unlock (ALock *lock, int *mine) {\n    lock->flags[(*mine)%(2*N)] = 0;\n    int i = 1;\n    while (testAndSet(&lock->flags[(*mine + i)%(2*N)], 1)) {\n        lock->flags[(*mine + i)%(2*N))] = 0;\n        ++i;\n    }\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. הוספת הפעולה trylock אינה משפיעה על אף אחת מפעולות המנעול האחרות.\n2. במנעול ALock לא ניתן לחזור סתם בפונקציית הנעילה, מאחר שכל חוט צריך לקדם את התור ביציאה מהקטע הקריטי. אם נקדם את התור מוקדם מדי לא תתקיים מניעה הדדית, ואם לא נקדם את התור לא יתקיים חופש מקיפאון.\nבמקום זאת, נשאיר סימון מיוחד בתא אשר יבהיר לחוט שלפנינו שעליו לקדם את התור פעם נוספת. את עדכון התא נדאג לבצע עם פעולת TAS כדי לעדכן באופן אטומי. שינוי נוסף שנדרש הוא הגדלת המערך מ-N ל-2N, מאחר שחוט שמבצע trylock עלול לקרוא ל-lock ולתפוס תא נוסף במערך.\nהסימון המיוחד הוא ערך של 1 בתא. כלומר, אם חוט ינסה לעדכן את התא הבא ל-1 ויראה שהערך בו הוא כבר 1, אז זה יסמן שעליו להמשיך להתקדם במערך."}, "difficulty_estimation": "Medium"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Disk Scheduling"], "content": {"text": "שאלה 8", "code_snippet": null}, "sub_questions": [{"id": "8.1", "text": "קריאת המערכת lseek מאפשרת למקם את סמן המיקום הנוכחי בקובץ גם מעבר לסוף הקובץ, ובכך ליצור \"חור\" בנתוני הקובץ. אם בהמשך נקרא את הנתונים מהחור שנוצר, ערכי הבתים שיוחזרו יהיו כולם אפס.\nנתונות שתי אפשרויות למימוש היכולת הזו במערכת הקבצים. באפשרות הראשונה, בביצוע Iseek נקצה את כל הבלוקים החסרים ונאפס אותם כחלק מהפעולה של קריאת המערכת. באפשרות השניה, לא נבצע הקצאה מראש (עם ביצוע הפעולה) אלא רק כאשר תתבצע פעולה במיקום שהוא חלק מה\"חור\" (קריאה או כתיבה של נתונים אלו).\nתארו את היתרונות והחסרונות של כל אפשרות.", "code_snippet": null, "options": null}, {"id": "8.2", "text": "נתונה מערכת שצריכה לייצר קבצים בגודל משתנה (שאינו ידוע מראש), כך שתוכן כל הנתונים בקבצים אלו הוא 0 (כל הבתים הם 0). ידוע שהגודל המקסימלי לכל קובץ הוא 100MB, והגודל הממוצע של הקבצים הוא 10MB.\nלצורך מימוש המערכת, סטודנט א' הציע להתעלם מהגודל הנדרש בפועל לכל קובץ ותמיד לייצר קבצים בגודל 100MB. סטודנט הציע לא להתעלם מהגודל הנדרש אלא בכל פעם שנדרש ליצור קובץ, ניצור קובץ ריק ואז נכתוב אליו 1MB שוב ושוב עד שגודל הקובץ יגיע או יחרוג מהגודל המדויק הנדרש עבור הקובץ הספציפי.\nמלאו את הטבלה הבאה עם נתונים של שני דיסקים קשיחים כך שהפתרון של סטודנט א' יהיה מהיר יותר עם הדיסק הראשון (מאשר עם השני), והפתרון של סטודנט ב' יהיה מהיר יותר עם הדיסק השני.\nיש להתעלם מפעולות במערכת הקבצים מלבד הכתיבה לקבצים עצמם (כמו גישה ל-inode, חיפוש ב-bitmap וכו').\nניתן להניח שכל פעולת הקצאה מוצאת בלוקים רציפים, אך פעולות הקצאה נפרדות לא בהכרח יהיו רציפות.\nRPM\nSEEK TIME\nTRANSFER RATE\nדיסק ראשון\nדיסק שני", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. הקצאת כל הבלוקים מראש: פעולת ה-Iseek איטית, אבל פעולות עתידיות על הקובץ יהיו מהירות בכל מיקום, ולא נצטרך לשמור מידע נוסף.\nלא להקצות מראש: פעולת ה-Iseek מהירה, אבל פעולות עתידיות עלולות להיות איטיות ונצטרך לשמור ב-inode מידע נוסף על מיקום החורים בקובץ.\n2. עבור סטודנט א' נדרש לכתוב יותר מידע (100MB לקובץ, במקום 10MB לקובץ בממוצע) אבל לכל קובץ נכתוב בכתיבה רציפה אחת, לכן נרצה דיסק עם קצב מהיר אבל זמן מיקום איטי כך כתיבות מרובות יהיו איטיות בגלל זמן המיקום בכל כתיבה.\nעבור סטודנט ב' נדרש לכתוב פחות מידע (10MB בממוצע לקובץ) אבל בפעולות כתיבה נפרדות של 1MB, דומה לפעולה אקראית. לכן נרצה דיסק עם זמן מיקום מהיר וקצב איטי כך לא תהיה השפעה גדולה לחלוקה לכתיבות מרובות (אקראיות), אך תהיה השפעה גדולה לכתיבה של פחות נתונים בסה\"כ.\nדיסק ראשון:\nRPM: 30 (1s)\nSEEK TIME: 1s\nTRANSFER RATE: 100 MB/s\nדיסק שני:\nRPM: 30,000 (1ms)\nSEEK TIME: 1ms\nTRANSFER RATE: 10 MB/s\nעבור סטודנט א':\nבדיסק הראשון זמן הטיפול הממוצע בכל קובץ הוא 3 שניות (זמן סיבוב: שניה, זמן seek: שניה, זמן העברה: שניה).\nבדיסק השני זמן הטיפול מעל 10 שניות (זמן ההעברה לבד הוא 10 שניות).\nעבור סטודנט ב':\nבדיסק הראשון זמן הטיפול הממוצע בכל קובץ הוא מעל 20 שניות (גודל ממוצע של 10MB, כל פעולה של 1MB תיקח 2 שניות רק לזמן ההמתנה לסיבוב +seek, לזה יש להוסיף את זמן ההעברה).\nבדיסק השני זמן הטיפול הממוצע הוא 1.02 שניות (לכל פעולה של 1MB יתקיים – זמן סיבוב: 1ms, זמן seek: 1ms, זמן העברה: 100ms)."}, "difficulty_estimation": "Medium"}]}, {"filename": "os22BC.json", "metadata": {"course_name": "Operating Systems", "year": "2022", "semester": "Semester B", "moed": "Moed C", "exam_date": "18.08.2022", "source_file": "os22BC.pdf"}, "questions": [{"id": 1, "type": "Open", "topic": ["Virtual Memory", "Paging", "Memory Management", "TLB", "System Calls"], "content": {"text": "נתונה מערכת עם מנגנון חדש של זיכרון וירטואלי המתבסס על דפדוף והחלפה, אך מספק לתהליכים זיכרון וירטואלי לא מוגבל. כלומר, לכל תהליך מספר אינסופי של דפים זמינים והתהליך יכול לפנות לכל כתובת (כל מס' טבעי). הזיכרון הפיזי במערכת עדיין סופי, אך ניתן להניח שזמין נפח לא מוגבל של זיכרון משני (דיסק קשיח).\nתארו בכלליות מימוש של תהליך תרגום עבור מערכת זו, המקבל כקלט מספר דף ומחזיר כפלט מספר מסגרת, ופרטו את כל השינויים הנדרשים במערכת עבורו.\nכלומר, יש לתאר את אלגוריתם התרגום עם כל השינויים הנדרשים: בקוד ומבני הנתונים של מערכת ההפעלה, ברכיבי החומרה, וכו' (כמו טבלת הדפים, page fault, שימוש ב-TLB).\nשימו לב: גודל הקלט אינו מוגבל (כמות הדפים אינסופית) וניתן להניח שהוא רצף ביטים (מערך ביטים וגודלו). ניתן לשנות את אופן הפעולה של רכיבי חומרה אך לא את המבנה הבסיסי שלהם (לדוגמה, ניתן לשנות את גודל הרשומה או אופן החיפוש ב-TLB, אך לא את כמות הזיכרון הכללת בו או הגדרת רכיב חדש לחלוטין).", "code_snippet": null, "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Hard"}, {"id": 2, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "I/O", "Concurrency"], "content": {"text": "באופן כללי, כל תוכנית shell מבצעת לולאה בסגנון הבא (פסאודו-קוד):\nבשאלה זו יש לממש את execute_cmd עם תמיכה בהרצה ברקע (&) וגם redirection (<>) של הקלט והפלט הסטנדרטי (אין תמיכה ב-redirection של stderr). להלן הארגומנטים שהפונקציה מקבלת:\nprog_name – שם התוכנית שהמשתמש מבקש להריץ.\nprog_args – מערך הארגומנטים לתוכנית. ניתן להניח שתא 0 מכיל את שם התוכנית והתא האחרון מכיל NULL, ואין במערך סימנים או ערכים של redirection או הרצה ברקע.\nin_file / out_file – שמות קבצים עבור redirection. אם לא התבצע redirection, יתכן שיסופק אחד מהם, שניהם, או אף אחד מהם.\nrun_bg – בוליאני שמציין הרצה ברקע או לא. ניתן להתעלם מזומבים.", "code_snippet": "while (1) // SHELL main loop\n{\nprintf(\"==> \");\nparse_cmd(...);\nexecute_cmd(...);\n}\nvoid execute_cmd(char* prog_name, char** prog_args,\nchar* in_file, char* out_file, int run_bg) {", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "CodeAnalysis", "topic": ["Synchronization", "Mutexes", "Semaphores", "Atomic Operations", "Concurrency", "Threads"], "content": {"text": "מנעול N-Lock הוא מנעול המאפשר ל-N חוטים להיכנס בו-זמנית לקטע הקריטי. מנעול זה נדרש לקיים:\n- מניעה הדדית – יש לכל היותר N חוטים בקטע הקריטי בו-זמנית.\n- חופש מקיפאון – אם חוטים מנסים לתפוס את המנעול ויש פחות מ-N חוטים בקטע הקריטי, חוט כלשהו יצליח לתפוס לקטע הקריטי בזמן סופי.\n- הוגנות – יהיה סדר כלשהו של כניסה.\nניתן לממש מנעול N-Lock באמצעות סמפור מותאם ל-N.\nבשאלה זו יש לממש מנעול N-Lock ללא שימוש בפעולות אטומיות או אובייקטי סנכרון, מלבד 2 הפעולות האטומיות:\nint fetchAndAdd(int *ptr)\nint fetchAndSub(int *ptr)", "code_snippet": "typedef struct {\n} NLock;\n\nvoid init(NLock *lock) {\n}\n\nvoid destroy(NLock *lock) {\n}\n\nvoid lock(NLock *lock) {\n}\n\nvoid unlock (NLock *lock) {\n}", "options": null}, "sub_questions": null, "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Hard"}]}, {"filename": "os23AA.json", "metadata": {"course_name": "Operating Systems", "year": "2023", "semester": "Semester A", "moed": "Moed A", "exam_date": "30.01.2023", "source_file": "os23AA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Synchronization", "Semaphores"], "content": {"text": "כל שימוש במשתנה תנאי (condition variable) אפשר להחליף בשימוש בסמפור.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. כפי שנלמד, לא ניתן לממש משתנה תנאי באמצעות סמפור."}, "difficulty_estimation": "Easy"}, {"id": 2, "type": "MultipleChoice", "topic": ["Memory Management", "Concurrency", "Atomic Operations"], "content": {"text": "בגישה לזיכרון משותף במעבדים עם write-through cache, אין הבדל בביצועים בין פעולות קריאה לפעולות כתיבה.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. בכתיבה תמיד נשלח עדכון על גבי ה-bus, אך בקריאה יתכן שהפעולה תתבצע מקומית ב-cache של המעבד."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["Virtual Memory", "Paging", "Memory Management"], "content": {"text": "אם הזיכרון המשני מלא לחלוטין, יתכן שעדיין נוכל לטפל במקרה של page fault.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. אם יש מסגרת פנויה לא נדרש page out (ומקום בדיסק), וגם אם יש מסגרת לפינוי שכבר קיימת בדיסק (0=dirty)."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "Signals"], "content": {"text": "תהליך שהסתיים נמחק מעץ התהליכים רק כאשר תהליך האב שלו (לפי העץ) מבצע קריאה ל-wait.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. אם תהליך האב מתעלם מסיגנל SIGCHLD, תהליך הבן נמחק מיד כשמסתיים ללא מענה. (הסבר שגוי: אם תהליך האב מסתיים תהליך הבן נמחק מעץ התהליכים, אך זה קורה עקב wait של init – תהליך האב החדש)."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["I/O", "File Systems", "Disk Scheduling"], "content": {"text": "בכונן SSD, פעולות כתיבה מהירות יותר מפעולות קריאה.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. כתיבה אקראית מהירה יותר מקריאה סדרתית בגלל מבנה הלוג שהופך כתיבות אקראיות לסדרתיות, אך כתיבה סדרתית עדיין איטית יותר מקריאה סדרתית."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Scheduling", "CPU Scheduling"], "content": {"text": "בתזמון תהליכים, הרעבה מוגדרת כמצב בו ייתכן שתהליך מסוים לעולם לא יסתיים, ואפקט השיירה מוגדר במצב בו ייתכן שתהליכים קצרים יתעכבו זמן רב עקב תהליך ארוך שתופס את המעבד.\nעבור תזמון Stride ניתן להניח שתהליך חדש מקבל ערך pass שהוא המינימלי מבין כל התהליכים במערכת.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "עבור כל אחד מאלגוריתמי התזמון הבאים, האם מתאפשרת הרעבה? יש לתת דוגמה קצרה היכן שכן, או הוכחה היכן שלא.", "code_snippet": null, "options": ["FCFS", "SJF", "SRTF", "RR", "MLFQ", "Lottery", "Stride"]}, {"id": "6.2", "text": "עבור כל אחד מאלגוריתמי התזמון הבאים, האם ייתכן אפקט השיירה? יש לתת דוגמה קצרה היכן שכן, או הוכחה היכן שלא. כמה תהליכים נוצרו במהלך ריצה תקינה של התוכנית, כולל התהליך הראשי?", "code_snippet": null, "options": ["FCFS", "SJF", "SRTF", "RR", "MLFQ", "Lottery", "Stride"]}, {"id": "6.3", "text": "סטודנט כתב תוכנית בה כתיבות לקבצים נאגרות בחוצץ (buffer) בזיכרון ונכתבות בבת אחת ובאופן רציף כאשר הסגמנט מתמלא. כשהריץ את התוכנית, בתחילה הקוד התנהג כצפוי והביצועים השתפרו ככל שגודל הסגמנט היה גדול יותר, עד גודל מסוים ממנו ביצועי התוכנית הדרדרו משמעותית (למרות שביצועי הכתיבה לדיסק המשיכו להשתפר).\nמה הסיבה לכך שביצועי התוכנית הדרדרו, למרות שפעולות הכתיבה לדיסק המשיכו להשתפר?", "code_snippet": null, "options": null}, {"id": "6.4", "text": "הציעו דרך לטפל בבעיה בה נתקל הסטודנט בסעיף הקודם.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "6.1:\nFCFS: לא. תהליכים מטופלים לפי הסדר, לכן בהכרח יגיע תורו של כל תהליך. (התייחסות לתהליכים בלולאה אינסופית לא נכונה, כי אין כזה דבר ב-FCFS)\nSJF: כן. תהליך ארוך יתעכב אחרי תהליכים קצרים שעלולים להגיע כל הזמן. כמו SJF\nSRTF: כן. כמו SJF\nRR: לא. תמיד יגיע תורו של כל תהליך לרוץ, בהתאם לסדר התור.\nMLFQ: לא. בזכות ה-priority boost, כל תהליך יקבל זמן ריצה בסופו של דבר.\nLottery: כן. אם תהליך מסוים לא יוגרל שוב ושוב.\nStride: כן. אם תהליכים חדשים מגיעים כל הזמן, ה-pass שלהם קטן מכל הקיימים.\n\n6.2:\nFCFS: כן. תהליכים מטופלים לפי הסדר, לכן תהליך ארוך שיגיע ראשון יגרום לתהליכים קצרים להתעכב אחריו.\nSJF: כן. אם תהליכים קצרים מגיעים רגע אחרי תהליך ארוך, הם מתעכבים אחריו.\nSRTF: לא. תהליכים קצרים תמיד יטופלו לפני ארוכים.\nRR: לא. כל תהליך יקבל קוונטה קבועה לפי סדר התור, בלי קשר לזמן הריצה שלו.\nMLFQ: לא. כמו RR, בנוסף לכך גם תהליך ארוך ירד בעדיפות ויקבל פחות זמן מעבד עם הזמן.\nLottery: כן. תהליך ארוך עם עדיפות גבוהה עלול להשתלט על המעבד כי אחרים לא יוגרלו.\nStride: כן. תהליך ארוך עם stride נמוך ישתלט על המעבד לזמן רב ואחרים יתעכבו אחריו.\n\n6.3: בגלל השימוש ב-LRU (או קירוב שלו), כאשר הגדלנו את החוצץ מעבר לסף מסוים נפגעו הביצועים של התוכנית (בדומה לדוגמה מהשיעור של loop.c).\n\n6.4: להגביל את גודל הסגמנט המקסימלי באופן תואם לגודל ה-cache, או להחליף את גודל ה-cache לאלגוריתם ללא הבעיה של LRU."}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Deadlocks", "Concurrency"], "content": {"text": "נתונה מערכת בה נדרש לנהל N \"מחסנים\" שונים (בכל מחסן פעולות של יצרן-צרכן). לצורך כך הוגדר מערך של N מכל סמפור בפתרון שנלמד בשיעור.\nלהלן הקוד לניהול N המחסנים, כאשר הפרמטר t מייצג את אינדקס המחסן אליו פונים בפעולה (כדי לייצר או לצרוך מוצר) ושתי הפונקציה add_item/remove_item מוסיפות ומסירות מוצר ממחסן t בהתאמה (אך הן לא בטוחות לשימוש במקביל):\nבמערכת הנ\"ל עלתה דרישה לממש פעולה חדשה אשר צורכת מוצרים מכמה מחסנים בו-זמנית (באופן אטומי, אך לא יותר ממוצר אחד מכל מחסן). הפעולה מקבלת כארגומנט את המערך הבוליאני [items[N, כאשר התא 1 במערך מציין האם יש לצרוך מוצר ממחסן 1. להלן הקוד שנכתב למימוש הפעולה: סטודנט טען שבפעולה זו, כפי שניתן לראות בקוד, תפיסת המשאבים מתבצעת תמיד בסדר קבוע וכך מופר תנאי הקיפאון של המתנה מעגלית. למרות טענתו, בהרצת המערכת עם שימוש בפעולה זו ניתן להגיע למצב של קיפאון.", "code_snippet": "1 sem_t empty[N]; // init all to MAX\n2 sem_t full[N]; // init all to 0\n3 sem_t mutex(N); // init all to 1\n4 void produce(int t) {\n5     sem_wait(&empty[t]);\n6     sem_wait(&mutex[t]);\n7     add_item(t);\n8     sem_post(&mutex[t]);\n9     sem_post(&full[t]);\n10}\nvoid consume(int t) {\n    sem_wait(&full[t]);\n    sem_wait(&mutex[t]);\n    remove_item(t);\n    sem_post(&mutex[t]);\n    sem_post(&empty[t]);\n}\n\n1 void consume_several (int items [N]) {\n2     for (int i = 0; i < N; ++i) {\n3         if (items[i]) {\n4             sem_wait(&full[i]);\n5         }\n6     }\n7     for (int i = 0; i < N; ++i) {\n8         if (items[i]) {\n9             sem_wait(&mutex[i]);\n10            remove_item(i);\n11            sem_post(&mutex[i]);\n12            sem_post(&empty[i]);\n13        }\n14    }\n15}"}, "sub_questions": [{"id": "7.1", "text": "תארו ריצה המובילה לקיפאון.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "האם טענת הסטודנט נכונה? אם כן, יש להסביר כיצד יתכן קיפאון למרות שהופר תנאי הקיפאון של המתנה מעגלית, אחרת יש להסביר מדוע טענתו שגויה. (רמז: איזו הנחה נסתרת לגבי המשאבים הנחנו בלימוד 4 תנאי הקיפאון, שאינה מתקיימת פה?)\nהטענה נכונה / הטענה לא נכונה", "code_snippet": null, "options": ["הטענה נכונה", "הטענה לא נכונה"]}, {"id": "7.3", "text": "תקנו את הפעולה consume_several כך שתעבוד באופן תקין ללא קיפאון או livelock. יש לשנות את שורות 2-6 בלבד. ניתן להוסיף משתנים גלובליים ולהיעזר בקריאה sem_trywait, אובייקטי סנכרון ופעולות אטומיות כרצונכם (רמז: יש בשאלה 2 דרישות). יש לתאר בקצרה את הפתרון ולכתוב קוד ברור. משתנים גלובליים (יש לציין ערכי אתחול בהערה):", "code_snippet": "void consume_several (int items[N]) {\n    for (int i = 0; i < N; ++i) {\n        if (items[i]) {\n            sem_wait(&full[i]);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        if (items[i]) {\n            sem_wait(&mutex[i]);\n            remove_item(i);\n            sem_post(&mutex[i]);\n            sem_post(&empty[i]);\n        }\n    }\n}"}], "points": null, "solution": {"is_present_in_file": true, "correct_option": "הטענה לא נכונה", "explanation": "7.1: 1. נניח 1=MAX והמחסנים ריקים. חוט 1 מייצר מוצר למחסן 0 (כלומר: [0]full הוא 1, כל השאר הם 0). חוט 2 מפעיל consume_several כדי לצרוך ממחסנים 0+1. הוא מקטין את [0]full ל-0 וחסום על [1]full. חוט 3 מפעיל consume כדי לצרוך ממחסן 0, חסום כי המחסן ריק ([0]full הוא 0). חוט 4 מפעיל produce כדי לייצר אל מחסן 0, חסום כי המחסן מלא ([0]empty הוא). לא יתכן שמחסן 0 גם ריק וגם מלא.\n\n7.2: הטענה לא נכונה. 2. הסטודנט צודק. בתנאי הקיפאון יש התייחסות למשאבים המתנהגים בדומה למנעול חוט מקצה את המשאבים הדרושים לו בתחילת הפעולה (כמו תפיסת מנעולים), ומשחרר אותם בסוף הפעולה (כמו שחרור מנעולים). בבעיית יצרן-צרכן אין הקצאה ושחרור, אלא להיפך – חוט קודם צריך \"לשחרר\" את המשאב (לייצר מוצר) לפני שחוט אחר יכול לתפוס אותו (לצרוך את המוצר).\n\n7.3: 3. כדי להימנע מקיפאון נפעל באופן דומה לפתרון של no preemption. בהקצאת המוצרים לפעולה נשתמש ב-trywait במקום wait. אם הגענו למחסן שבו אין מוצר לצרוך (ה-trywait נכשל) אז נחזיר את כל ההקצאות הקודמות (ע\"י post לכל המחסנים הקודמים) וננסה שוב מההתחלה. כך חוט לא יהיה חסום בהמתנה למשאב ולא יהיה קיפאון. כדי להימנע מ-livelock, נתפוס מנעול גלובלי הוגן master בתחילת כל ניסיון ונשחרר בסוף הניסיון (בין אם הצלחנו ובין אם לא). כך יגיע תורו של כל חוט לנסות להקצות מוצרים באופן בלעדי (בגלל ההוגנות). שימו לב: פתרון זה לא מונע הרעבה (כל פעם שמגיע תורו של חוט לא זמינים המוצרים שהוא צריך, אך מיוצרים כל פעם בתורם של חוטים אחרים). פתרון אפשרי נוסף ל-livelock הוא המתנה אקראית. פתרון שגוי שחזר על עצמו הוא עדכון מערך items ל-0 בכל תא בו נכשלנו בהקצאת המוצר. פתרון זה לא תקין מאחר שאנו לא יכולים לשנות את הפרמטר של המשתמש – יש לצרוך את כל המשאבים שהפעולה דורשת, ולהמתין עד שזה יתאפשר. משתנים גלובליים (יש לציין ערכי אתחול בהערה): sem_wait(&master); // fair global lock to avoid livelock int i = 0; while (i!= N) { if ((!items[i]) || (!sem_trywait(&full[i]))) { ++i; } else { // failed - give up and restart to avoid deadlock for (int k = 0; k < i; ++k) if (items[k]) sem_post(&full[k]); i = 0; sem_post(&master); // release & grab to allow other sem_wait(&master); // threads to try (avoid livelock) } } sem_post(&master);"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתון דיסק קשיח עם הנתונים הבאים:\nמהירות סיבוב: RPM 12,000\nגודל מצביע: 4 בתים.\nגודל סקטור: 1024 בתים.\nגודל בלוק: 4KB.\n8 משטחים (4 platters דו-צדדיים).\nצפיפות הסקטורים בכל רצועה (track) היא בהתאם ל-4 אזורים: A,B,C,D. בכל אזור יש 1200 רצועות.\nבאזור A יש 4000 סקטורים לרצועה, באזור B יש 3000 סקטורים לרצועה,\nבאזור C יש 2000 סקטורים לרצועה, באזור D יש 1000 סקטורים לרצועה.\nזמן ה-seek הממוצע הוא 7ms, ובין שתי רצועות סמוכות הוא 1.5ms.\nנתון שיפור track skew: בקריאת סקטורים עוקבים ברצועות סמוכות אין המתנה לסיבוב.\nמהירות העברת המידע של הדיסק תואמת להעברת המידע ברצועה אחת ב-A תוך כדי זמן סיבוב אחד בדיוק.\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "מה הזמן המינימלי שתיקח פעולת קריאה של 1000 בלוקים רצופים בכל אזור, אם נעשה שימוש במשטח אחד בלבד? הניחו שמיקום הראש הקורא-כותב לפני כל פעולה אינו ידוע.\nמינימום A:\nמינימום B:\nמינימום C:\nמינימום D:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "נתונה גרסה חדשה של הדיסק, בה כל הנתונים זהים מלבד קצב העברת מידע של MB/s 100.\nהאם הגרסה החדשה זולה יותר (פחות טובה), יקרה יותר, או שאי אפשר לדעת?\nהגרסה החדשה: זולה יותר / יקרה יותר", "code_snippet": null, "options": ["זולה יותר", "יקרה יותר", "אי אפשר לדעת"]}, {"id": "8.3", "text": "הוחלט לנהל מערכת קבצים VSFS על גבי הדיסק הנתון בשאלה. לצורך כך, 99% מהבלוקים בדיסק הוגדרו להיות ה- data region של מערכת הקבצים.\nבכל inode יש 9 מצביעים ישירים ו-3 מצביעים עקיפים.\nכמה קבצים בגודל המקסימלי נוכל להחזיק בדיסק הנתון? ניתן להניח שאין מגבלה על כמות ה-inodes.\nקבצים בגודל המקסימלי:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "8.1:\nזמן הסיבוב הוא 5ms, לכן המתנה ממוצעת לסיבוב היא 2.5ms. כל פעולה מתחילה ב-seek ממוצע של 7ms והמתנה לסיבוב, כלומר זמן מיקום של 9.5ms. בנוסף, 1000 בלוקים הם 4000 סקטורים.\nאזור A: 4000 סקטורים זו רצועה אחת לכן הקריאה תיקח זמן סיבוב שלם (5ms), סה\"כ 14.5ms.\nאזור B: רצועה ושליש, לכן הקריאה תיקח זמן סיבוב ושליש (6.66ms) וזמן מעבר בין רצועות (1.5ms) כי הקריאה כולה באותו משטח (אחרת לא היה נדרש זמן המעבר), סה\"כ 17.66ms\nאזור C: בדיוק 2 רצועות ב-2 סיבובים (10ms) וזמן המעבר ביניהן (1.5ms), סה\"כ 21ms.\nאזור D: בדיוק 4 רצועות ב-4 סיבובים (20ms) ו-3 מעברים (4.5ms), סה\"כ 34ms.\n\n8.2: בדיסק המקורי מעבירים רצועה ב-A בזמן סיבוב בדיוק, כלומר שקצב העברת הנתונים הוא 4000 סקטורים לסיבוב, כלומר 4000KB / 5ms - כמעט 800MB/s. זה קצב משמעותית מהיר יותר מ-MB/s 100, לכן הדיסק החדש יהיה זול יותר.\n\n8.3: במשטח אחד בדיסק יש 120*(4000+3000+2000+1000) = 12 מיליון סקטורים, על 8 משטחים זה סה\"כ 96 מיליון סקטורים, או 24 מיליון בלוקים. 99% מהם זה 23,760,000 בלוקים של DATA. גודל בלוק 4KB גודל מצביע 4B כלומר 1024 מצביעים בבלוק. גודל הקובץ המקסימלי (בבלוקים) הוא 9 בלוקים בגישה ישירה ועוד 1024*3 בגישה עקיפה. המקום שהוא תופס בדיסק הוא כמות זו ועוד 3 בלוקים נוספים עבור הבלוקים העקיפים של המצביעים, סה\"כ 3084 בלוקים לקובץ. נחלק 23,760,000 ב-3084 ונקבל 7704 קבצים. תשובה שגויה היא חישוב כמות הבלוקים לפי גודל הקובץ בלבד (3081) במקום המקום שהוא תופס בדיסק, ואז מגיעים ל-7711 קבצים."}, "difficulty_estimation": "Hard"}]}, {"filename": "os23AB.json", "metadata": {"course_name": "Operating Systems", "year": "2023", "semester": "Semester A", "moed": "Moed B", "exam_date": "20.02.2023", "source_file": "os23AB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Memory Management", "Virtual Memory"], "content": {"text": "אם הזיכרון המשני מלא לחלוטין, לא ניתן להקצות זיכרון נוסף לתהליכים קיימים או להריץ תהליכים חדשים.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. יתכן שעדיין יש מסגרות פנויות בזיכרון הראשי."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency", "Mutexes"], "content": {"text": "במערכת המשתמשת במנעולים הוגנים בלבד (ללא אובייקטי סנכרון אחרים), לא תיתכן הרעבה.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. בדומה לקיפאון, גם הרכבה של מנעולים הוגנים עלולה לגרום להרעבה. לדוגמה, מימוש מנעול קוראים-כותבים שנלמד בשיעור גורם להרעבת הכותב גם בשימוש במנעולים הוגנים."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "בכונן SSD נעדיף מערכת קבצים מבוססת לוג (כמו LFS) על-פני מערכת קבצים סטנדרטית (כמו VSFS), אחרת חלקים מהדיסק ישחקו משמעותית יותר מהר.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. כונן SSD דואג ברמת החומרה לפיזור הכתיבות כך שניתן להשתמש בו כרגיל, ללא תלות במערכת הקבצים שנבחר לשים בו."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Memory Management"], "content": {"text": "בהקצאות זיכרון בגודל קבוע אין אף סוג של פרגמנטציה.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. יש פרגמנטציה פנימית אם נדרש למשתמש פחות זיכרון מהגודל הקבוע."}, "difficulty_estimation": "Easy"}, {"id": 5, "type": "MultipleChoice", "topic": ["File Systems", "I/O", "Disk Scheduling"], "content": {"text": "בדיסק קשיח עם מערכת קבצים VSFS, כתיבה סדרתית גדולה לקובץ תמיד תהיה מהירה או שווה במהירות למספר כתיבות אקראיות של אותה כמות מידע סך הכל לאותו קובץ.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. תלוי בהקצאה, יתכן שקובץ יתפזר על פני בלוקים בדיסק באופן שכתיבה סדרתית למעשה תתורגם לפעולות אקראיות בדיסק, בעוד שפעולה אקראית עלולה במקרה לפנות לבלוקים רציפים וכך להתבצע מהר יותר."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Virtual Memory", "Paging", "Page Replacement", "Memory Management"], "content": {"text": "נתונה מערכת המשתמשת באלגוריתם השעון (עם כל השדרוגים), בה רץ תהליך יחיד עם טבלת הדפים הלינארית המופיעה בהמשך. כל כניסה בטבלה מחולקת לעמודות אך כל שורה מייצגת רצף אחד של ביטים עבור PTE אחד. בטבלת הדפים הנתונה: P=Present, V=Valid, A=Accessed (Reference), D=Dirty. העמודה הימנית היא לתיאור בלבד ואינה חלק מנתוני ה-PTE. ידוע שגודל הטבלה קטן מדף אחד. בשאלה זו יש להתעלם מכל הזיכרון ומבני הנתונים של הקרנל מלבד טבלאות הדפים. יש לפרט ולנמק את כל החישובים.\n\nPFN     P V A D   ריפוד   סגמנט\n00100   1 1 1 0   0000000000   TEXT\n00000   0 1 0 0   000000000\n11101   1 1 0 0   0000000000\n00000   0 0 0 0   0000000000\n00010   1 1 1 0   0000000   DATA\n00000   0 0 0 0   0000000000\n10011   1 1 0 1   0000000   STACK\n00000   0 1 0 0   000000000\n10100   1 1 0 1   0000000000\n00000   0 0 0 0   0000000000\n00000   0 1 0 0   000000000\n01011   1 1 1 0   0000000   HEAP\n01101   1 1 1 0   0000000000\n00000   0 0 0 0   0000000000\n11010   1 1 1 0   0000000000\n00000   0 1 0 0   0000000", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "איזה נתון חסר כדי לחשב את גודל הזיכרון הוירטואלי וגודל הזיכרון הפיזי המקסימלי? מה יהיו גדלים אלו אם הערך של הנתון החסר הוא X?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "נניח שהתהליך הנתון הריץ את שורת הקוד הבאה: `int pid1 = fork();` נתון שהקריאה הצליחה, ותהליך הבן שנוצר עוד לא קיבל זמן מעבד. כמה מסגרות בזיכרון יהיו תפוסות מיד לאחר ביצוע כל שורת קוד זו (ביחס למצב בו שהיה בדיוק לפני הרצת שורה זו)?", "code_snippet": "int pid1 = fork();", "options": null}, {"id": "6.3", "text": "נניח שכל שאר המסגרות בזיכרון (שאינן בשימוש ע\"י התהליך הנתון) שמורות לקרנל. התהליך ניגש לכתובת בדף מספר 10. איזה דף יפונה מהזיכרון? מה יהיה הערך החדש של ה-PTE של דף 10?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "6.1: הנתון החסר הוא גודל הדף. לכל תהליך יש 16 דפים (לפי מספר הכניסות בטבלה), לכן מרחב הכתובות הוא X*16 בתים. ה-PFN הוא 5 ביטים (לפי כמות הביטים בטבלה), סה\"כ 32 מסגרות וזיכרון פיזי X*32.\n\n6.2: התהליך הנוכחי תופס 9 מסגרות בזיכרון – 8 עבור זיכרון התהליך (כל דף עבורו 1=P) ועוד מסגרת אחת לטבלת הדפים (כפי שנתון, טבלת הדפים הלינארית קטנה מדף). בקריאה ל-fork לא תשוכפל אף מסגרת מהזיכרון בגלל copy-on-write, אלא אחרי ה-fork נתפוס רק מסגרת אחת נוספת עבור טבלת הדפים של התהליך החדש. מסגרת נוספת תידרש אחרי ההשמה למשתנה pid1. נצטרך לשכפל חלק מהמחסנית של תהליך האב בגלל -copy on-write. המחסנית היא דף אחד לכן זה ידרוש בדיוק מסגרת אחת נוספת. סה\"כ יהיו תפוסות עוד 2 מסגרות.\n\n6.3: אלגוריתם השעון מחפש בעדיפות דף שלא ניגשו אליו לאחרונה (0=A) וגם שלא בוצע בו שינוי (0=D). הדף היחיד שמקיים את 2 התנאים וגם נמצא בזיכרון (1=P) הוא דף מספר 2. נפנה את דף 2 מהזיכרון, ובתוך המסגרת שבה היה דף 2 נשים את דף 10, כלומר: PFN=11101, P=V=A=1, הביט D יכול להיות 0 או 1 בהתאם לפעולה שבוצעה."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Threads", "Concurrency", "Synchronization", "Race Conditions"], "content": {"text": "נתונה התוכנית הבאה לקידום מונה משותף counter ע\"י חוטים מרובים, כאשר ערכי הקבועים T,N אינם ידועים (אך הם לכל הפחות 2). כל החוטים מריצים את אותה פונקציה foo או bar, כמפורט בהמשך. קמפלו והריצו את תוכנית זו פעמיים: פעם אחת כאשר כל החוטים שנוצרים (בשורה 23) מריצים את הפונקציה foo, ופעם נוספת כאשר כל החוטים שנוצרים מריצים את הפונקציה bar. ניתן להניח שכל קריאות המערכת הצליחו. יש לפרט בקצרה ובבירור את תזמוני הריצות שמובילים לכל אחת מהתשובות.", "code_snippet": "1 #define T ?? // 2 or more\n2 #define N ?? // 2 or more\n3 int counter = 0;\n4\n5 void* foo(void* arg)\n6{\n7   for (int i = 0; i < N; ++i) {\n8     ++counter;\n9   }\n10  return NULL;\n11}\n12\n13 void* bar (void* arg)\n14 {\n15   while (counter < N) {\n16     ++counter;\n17   }\n18  return NULL;\n19}\n20\n21 void main() {\n22   pthread_t threads [T];\n23   for (int i = 0; i < T; ++i)\n24     pthread_create(&threads [i], NULL, ??, NULL);\n25   for (int i = 0; i < T; ++i)\n26     pthread_join(threads[i], NULL);\n27   printf(\"counter = %d\\n\", counter);\n28 }", "options": null}, "sub_questions": [{"id": "7.1", "text": "מה הערך המינימלי של counter (כפונקציה של T,N) שיודפס בסוף התוכנית, כאשר החוטים מריצים את foo? רמז: הערך המקסימלי הוא T*N.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "מה הערך המקסימלי של counter (כפונקציה של T,N) שיודפס בסוף התוכנית, כאשר החוטים מריצים את bar? רמז: הערך המינימלי הוא N.", "code_snippet": null, "options": null}, {"id": "7.3", "text": "נתון 2=T והחוטים שנוצרים מריצים את bar. מה המספר המקסימלי של פעמים (כפונקציה של N) שחוט כלשהו עלול להריץ את שורה 15? (רמז: המינימלי הוא 0)", "code_snippet": null, "options": null}, {"id": "7.4", "text": "נניח שלכל חוט שנוצר בשורה 23 יש מזהה ייחודי בין 0 ל-1-T. כמו-כן נתונה הפונקציה `int get_id()`, אשר מחזירה את מזהה החוט עבור החוט הקורא לה (שימו לב: המזהה אינו ה-TID, הפונקציה מחזירה ערך שונה בהתאם לחוט שקורא לה, ובטוחה לשימוש במקביל). ברצוננו לתקן את הפונקציה foo כך שבהרצת התוכנית עם foo, החוטים יקדמו את המונה לסירוגין (ובאופן נכון). כלומר, חוט 0 יקדם את המונה פעם אחת, ואז חוט 1 יקדם את המונה פעם אחת, אז חוט 2 יקדם פעם אחת, וכן הלאה עד חוט 1-T, אחריו חוט 0 יקדם את המונה פעם שניה, חוט 1 יקדם את המונה פעם שניה, וכו' לפי הסדר עד אשר כל חוט קידם את המונה N פעמים. ניתן להגדיר משתנים גלובליים ולהשתמש בסמפורים כרצונכם, אך אין להשתמש בפעולות אטומיות או אובייקטי סנכרון מלבד סמפורים. משתנים גלובליים (יש לציין ערכי אתחול בהערה):", "code_snippet": "void* foo(void* arg) {\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: מינימום 2. ריצה לדוגמה: חוט 1 רוצה לקדם את המונה, קורא ערך 0 ונעצר לפני כתיבה של 1. חוט 2 מקדם את המונה 1-N פעמים, נעצר לפני הקידום האחרון (לפני כולו עוד לא קרא את המונה). שאר החוטים כולם מקדמים את המונה N פעמים ומסיימים. חוט 1 חוזר לרוץ וכותב 1 אל המונה (למעשה \"מאפס\" את שאר הקידומים שנעשו). חוט 2 רוצה לקדם את המונה, קורא ערך 1 ונעצר לפני כתיבה של 2. חוט 1 מקדם את המונה עוד 1-N פעמים שנשאר לו, ומסיים. חוט 2 חוזר לרוץ וכותב 2 אל המונה, קידם סה\"כ N פעמים ולכן מסיים.\n\n7.2: מקסימום 1-N+T. ריצה לדוגמה: חוט 1 נכנס ללולאה ומקדם את המונה עד שערכו 1-N. כל T החוטים במקביל בודקים את תנאי הלולאה ונכנסים ללולאה (המונה קטן מ-N). לפי הסדר, כל חוט מקדם את המונה בנפרד פעם אחת, סה\"כ T פעמים. כל החוטים מסיימים, ערך המונה הוא N-1+T.\n\n7.3: מקסימום N^2/2. ריצה לדוגמה: חוט 1 רוצה לקדם את המונה, קורא ערך 0 ונעצר לפני כתיבה של 1. חוט 2 מקדם את המונה עד N (סה\"כ N פעמים), נעצר לפני הכניסה ללולאה. חוט 1 חוזר לרוץ וכותב 1 אל המונה, רוצה לקדם שוב וקורא 1 ונעצר לפני כתיבה של 2. חוט 2 מקדם את המונה עד N (סה\"כ 1-N פעמים), נעצר לפני הכניסה ללולאה. חוט 1 חוזר לרוץ וכותב 2 אל המונה, רוצה לקדם שוב וקורא 2 ונעצר לפני כתיבה של 3. וכן הלאה. סה\"כ חוט 2 מקדם את המונה 1+(N-2)+...+1+(N-1) פעמים, כלומר N^2/2.\n\n7.4: גלובליים: sem_t sems[T]; // Initialized: sems[0] = 1, sems[1..T-1] = 0\n\nvoid* foo(void* arg)\n{\n  for (int i = 0; i < N; ++i) {\n    sem_wait(&sems[get_id()]);\n    ++counter;\n    sem_post(&sems[(get_id()+1)%T]);\n  }\n  return NULL;\n}"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "Memory Management", "Copy-on-Write"], "content": {"text": "ב-VSFS קיים שדרוג של copy-on-write, אשר מאפשר להתייחס לאותו בלוק מידע (DATA) מכמה מקומות שונים (לדוגמה, להצביע אליו מכמה inodes שונים). לצורך השדרוג, נקצה אזור חדש בדיסק (סט בלוקים) שיכיל מספר עבור כל בלוק DATA, המייצג כמה הפניות יש אל אותו בלוק. נניח שכמות ההפניות המקסימלית לכל בלוק היא 255. בהעתקת קובץ בתוך מערכת הקבצים, לא נשכפל את המידע והמצביעים אלא רק ניצור inode חדש בו ערכי המצביעים זהים לקובץ המקור. במחיקה של קובץ (לחלוטין, כלומר לא נותרו hard links אל הקובץ) נחסיר 1 מכמות ההפניות של כל הבלוקים של הקובץ. בעדכון נתוני קובץ, נשכפל את הבלוקים ששונו ונעדכן את מספר ההפניות בהתאם (יחד עם עדכון המצביעים עבור ה-inode בו בוצע העדכון). יש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "נתונה מערכת קבצים עם גודל בלוק של 4KB. במערכת VSFS סטנדרטית (ללא השדרוג) נתון שיש מקום ל-10,000,000 בלוקים של DATA. לכמה בלוקים של DATA יהיה מקום עם השדרוג הנתון? כלומר, נתון דיסק קשיח ועליו מערכת קבצים VSFS סטנדרטית (ללא השדרוג) עם data region המכיל 10,000,000 בלוקים של DATA. ביצעו את השדרוג הנתון למערכת הקבצים, ללא שינוי שאר נתוני מערכת הקבצים מלבד שינוי גודל ה-data region לטובת הקצאת האזור החדש בדיסק (כלומר, ללא שינוי גודל בלוק, גודל inode, כמות inodes, וכו'). לכמה בלוקים של DATA יהיה מקום בדיסק לאחר השדרוג?", "code_snippet": null, "options": null}, {"id": "8.2", "text": "במערכת הקבצים מהסעיף הקודם (לאחר השדרוג), נתון ש-inode מכיל 10 מצביעים ישירים, מצביע אחד עקיף, ומצביע אחד עקיף כפול. גודל מצביע הוא 4 בתים. משתמש ביצע העתקה של קובץ רגיל שגודל 45040 בתים, ואז ביצע כתיבה של 10 בתים אל סוף הקובץ המקורי. כמה בלוקים צריך לקרוא ולכתוב בדיסק בשביל לבצע כל אחת מהפעולות, במקרה המקסימלי? (בסעיף זה אין צורך להתייחס לגישה לתיקיות או לעדכון זמני גישה ב-inode, ניתן להניח שה-inode של קובץ המקורי כבר בזיכרון, ואף cache אינו מכיל מידע רלוונטי לביצוע הפעולה)", "code_snippet": null, "options": null}, {"id": "8.3", "text": "סטודנט טען כי עם השדרוג של copy-on-write, אין יותר צורך ב-data bitmap מדוע זה נכון, ומה היתרונות והחסרונות של ויתור על ה-data bitmap", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "8.1: ה-data region מכיל 10 מיליון בלוקים, כעת צריך באותה כמות בלוקים להכיל גם את האזור החדש של מספר ההפניות. כל הפניה לבלוק דורשת בית אחד (8 ביטים לייצוג מספר 0-255), לכן בכל בלוק 4KB נכנסות 4096 הפניות. כלומר, אם יש X בלוקים של DATA לאחר השינוי, נצטרך X/4096 בלוקים של הפניות (מעוגל מעלה). סה\"כ הבלוקים צריך להיות עדיין 10 מיליון, כלומר שאנו מחפשים X מקסימלי המקיים את המשוואה: X+X/4096 <= 10,000,000 התשובה היא X=9997559.\n\n8.2: קובץ המקור משתמש בכל 10 המצביעים הישירים ובמצביע עקיף אחד, עם בלוק מצביעים שמכיל מצביע יחיד. העתקה: נצטרך לקרוא ולכתוב inode bitmap עבור הקובץ החדש, לקרוא ולכתוב בלוק עם ה-inode החדש (נתוני המצביעים זהים ל-inode המקורי בגלל השימוש ב-copy-on-write), ובנוסף נקרא ונכתוב במקסימום 12 בלוקים של הפניות, להגדלה ב-1 של ההפניות לכל הבלוקים של DATA שמשתמש בהם הקובץ המקורי (כולל בלוק המצביעים העקיף גם אליו יש 2 הפניות כעת). סה\"כ 14 בלוקים לקריאה וכתיבה. כתיבה: הכתיבה לא גורמת להוספה של בלוק חדש אלא רק כתיבה לבלוק האחרון (ה-11) של הקובץ. הבלוק משותף (בגלל ההעתקה) ולכן צריך לשכפל אותו. בעקבות השכפול משתנה גם בלוק המצביעים, גם הוא משותף ולכן צריך לשכפל גם אותו. נצטרך לקרוא בלוק עקיף של מצביעים (כדי למצוא את בלוק ה-DATA), ואז לקרוא ולכתוב במקסימום 2 בלוקים של הפניות (אחד לכל בלוק), אח\"כ לקרוא בלוקים של data bitmap עד שנמצא מקום פנוי ואז לכתוב במקסימום 2 מהם (אם נמצא מקום פנוי אחד בכל בלוק), ולבסוף לכתוב את הנתונים המשוכפלים עצמם (2 בלוקים לכתיבה בלבד) ולעדכן את ה-inode של קובץ המקור עם המצביע המעודכן (קריאה וכתיבה). סה\"כ 6 קריאות ו-7 כתיבות. (יתכן שידרשו יותר קריאות של ה-data bitmap אך זה לא נדרש בשאלה)\n\n8.3: הטענה נכונה כי ניתן להשתמש באזור ההפניות כדי לדעת אם בלוק פנוי אם לבלוק DATA יש 0 הפניות, אז אף קובץ לא משתמש בו והבלוק פנוי. יתרונות: נוכל לחסוך מקום בדיסק שתפס ה-data bitmap. חסרונות: ידרשו יותר גישות כדי למצוא ו/או לפנות מקום פנוי, מאחר וכל בלוק של הפניות מכיל נתונים על פחות בלוקים מאשר ה-bitmap."}, "difficulty_estimation": "Hard"}]}, {"filename": "os23AC.json", "metadata": {"course_name": "Operating Systems", "year": "2023", "semester": "Semester A", "moed": "Moed C", "exam_date": "28.03.2023", "source_file": "os23AC.pdf"}, "questions": [{"id": 1, "type": "Open", "topic": ["Memory Management", "Paging", "Virtual Memory"], "content": {"text": "נתונה מערכת עם זיכרון פיזי בגודל 64KB וגודל דף של 512B. נתון שכל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת בלבד, ונדרש שכל טבלה תאוחסן בדף אחד בדיוק."}, "sub_questions": [{"id": "1.1", "text": "בהינתן שתהליך תרגום כתובת וירטואלית לפיזית מתבצע ברמה אחת בלבד, מה גודל הזיכרון הוירטואלי של תהליך?\nמרחב הכתובות:", "code_snippet": null, "options": null}, {"id": "1.2", "text": "שדרגו את רכיב ה-MMU במערכת כך שיתמוך בתהליך תרגום של שתי רמות. מה גודל הזיכרון הוירטואלי של תהליך?\nמרחב הכתובות:", "code_snippet": null, "options": null}, {"id": "1.3", "text": "במערכת של הסעיף הראשון (1.1) נתון ש-4KB מתוך הזיכרון הפיזי משוריין לטובת הקרנל, וזמין במערכת שטח החלפה (swap space) בגודל 256KB שכרגע כולו פנוי. בהנחה שהזיכרון של הקרנל כולו פנוי, כמה תהליכי משתמש יכולים לרוץ במערכת?\nמספר תהליכים:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1: ה-PFN הוא 7 ביטים, כלומר גודל כל כניסה בטבלת הדפים הוא בית אחד (לאחר ריפוד – עיגול לחזקה הקרובה של 2). לכן לכל תהליך יש 512 דפים (טבלת הדפים דיוק בגודל דף), ומרחב הכתובות הוא 256KB.\n1.2: כמו בסעיף הקודם יש 512 כניסות בכל טבלה/חלק, כעת יש 2 רמות לכן סה\"כ 512^2 כניסות ברמה התחתונה, כלומר 256K דפים לכל תהליך. נכפיל בגודל דף ונקבל מרחב כתובות של 128MB.\n1.3: המגבלה תהיה הזיכרון של הקרנל עבור טבלאות הדפים של התהליכים. אין משמעות לגודל ה-swap space מאחר וטבלאות הדפים לא נשמרות בו. ב-4KB ניתן להכניס טבלאות דפים של 8 תהליכים."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Concurrency", "Threads"], "content": {"text": "בסניף דואר מקומי יש פקיד יחיד ו-2 סוגי תורים: תור רגיל ותור מהיר. הפקיד מטפל בלקוחות לפי סדר הגעתם. לקוחות בתור המהיר עוקפים את הלקוחות בתור הרגיל, כך שהפקיד מטפל בהם קודם ולפי סדר הגעתם לתור המהיר. במילים אחרות, כאשר הפקיד פנוי הוא מטפל בלקוחות לפי החוקיות הבאה:\n- אם יש לקוחות ממתינים בתור המהיר, הפקיד מטפל בלקוח הבא מהתור המהיר.\n- אחרת, אם יש לקוחות ממתינים בתור הרגיל, הפקיד מטפל בלקוח הבא מהתור הרגיל.\nשימו לב: אין להתחיל טיפול בלקוח מהתור הרגיל אם יש לקוחות ממתינים בתור המהיר. בכל רגע נתון מטופל לקוח אחד בלבד.\nלצורך מחשוב הסניף הוחלט לייצג כל לקוח ע\"י חוט ולממש אובייקט סנכרון עם 4 פעולות:\n- לקוח קורא לפעולה enter_regq כדי להיכנס לתור הרגיל, ולפעולה enter_fastq כדי להיכנס לתור המהיר. פעולות אלו חוזרות רק כאשר הגיע תורו של הלקוח, אז הוא ניגש לטיפול אצל הפקיד.\n- לקוח שסיים את הטיפול אצל הפיקוד קורא לפעולה exit_regq אם המתין בתור הרגיל, ולפעולה exit_fastq אם המתין בתור המהיר. רק אחרי שקריאה זו הסתיימה, הפקיד פנוי לטפל בלקוח הבא.\nבשאלה זו יש לממש את אובייקט הסנכרון כך שיקיים את 3 התכונות: מניעה הדדית, חופש מקיפאון, והוגנות. ניתן להשתמש באובייקטי סנכרון ופעולות אטומיות כרצונכם.\nמשתנים גלובליים (יש לציין ערכי אתחול בהערה):", "code_snippet": "void enter_regq() {\n}\nvoid enter_fastq() {\n}\nvoid exit_regq() {\n}\nvoid exit_fastq() {\n}", "options": null}, "sub_questions": null, "points": 34, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "int fast_wait = 0;\nsem_t fastlock; // init to 1 (any fair lock)\nsem_t reglock; // init to 1 (any fair lock)\n\nvoid enter_regq() {\n    sem_wait(&reglock); // wait until I'm first in regq\n    while (1) {\n        sem_wait(&fastlock); // prevent fastq entering\n        if (fast_wait == 0) // make sure no fast q are waiting\n            return;\n        sem_post(&fastlock); // otherwise release and retry\n    }\n}\nvoid exit_regq() {\n    sem_post(&fastlock); // release both q locks\n    sem_post(&reglock); // (order doesn't matter)\n}\nvoid enter_fastq() {\n    fetch_and_add(&fast_wait, 1); // mark waiting in fast q\n    sem_wait(&fastlock); // wait for turn\n}\nvoid exit_fastq() {\n    fetch_and_add(&fast_wait, -1); // no longer waiting\n    sem_post(&fastlock); // proceed to next in line\n}"}, "difficulty_estimation": "Hard"}, {"id": 3, "type": "Open", "topic": ["File Systems", "I/O"], "content": {"text": "נתונה מערכת קבצים VSFS על גבי דיסק עם גודל סקטור וגודל בלוק של 4KB. נתון שיש במערכת 1,000,000 בלוקים פנויים של DATA ו-100,000 inodes פנויים. יש לפרט ולנמק את כל החישובים."}, "sub_questions": [{"id": "3.1", "text": "משתמש הריץ את הסקריפט הבא בשפת BASH (ראו הערות לכל שורה):\nכמה בלוקים של DATA וכמה inodes פנויים יהיו לאחר הרצת הסקריפט?\nמספר בלוקים:\nמספר inodes:", "code_snippet": "for d in a{1..10}; do\n    mkdir $d\n    # iterate over a1, a2, ..., a10\n    # create dirs a1, a2, ..., a10\n    for x in b{1..10}; do\n        mkdir $d/$x\n        # iterate over b1, b2, ..., b10\n        # create dirs $d/b1, $d/b2, ...\n        for f in h{1..10}; do\n            # iterate over h1, h2, ..., h10\n            echo hello > $d/$x/$f\n        done\n        # close the loop: for f ...\n    done\n    # close the loop: for x ...\ndone\n# close the loop: for d ...", "options": null}, {"id": "3.2", "text": "לאחר הרצת הסקריפט מהסעיף הקודם, המשתמש הריץ את הפקודה הבאה:\nrm -rf a* # recursively remove all files and dirs\nהאם כמות הבלוקים ו-inodes הפנויים חזרה בדיוק למה שהייתה קודם (לפני הרצת הסקריפט המקורי)?\nהכמות חזרה\n/\nהכמות לא חזרה: מספר בלוקים:\nמספר inodes:", "code_snippet": "rm -rf a* # recursively remove all files and dirs", "options": null}, {"id": "3.3", "text": "במצב המקורי של המערכת (לפני המתואר בסעיפים הקודמים), משתמש הריץ את הסקריפט BASH הבא:\nמה תהיה ההשפעה של הסקריפט על מערכת הקבצים (מבחינת הבלוקים הפנויים)?\nהאם הסקריפט ירוץ לנצח? אם כן יש לתאר כיצד זה יתכן, אחרת לתאר מדוע לא.\nירוץ לנצח\n/\nלא ירוץ לנצח", "code_snippet": "x=1;\nwhile [ $x ] ; do # practically, kind of infinite loop\n    echo hello > $x\n    let x=$x+1 # like x++ in C language\ndone", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "3.1: נוצרות 10 תיקיות בלולאה החיצונית, 100 באמצעית (10 לכל אחת בראשונה), ו-1000 קבצים בלולאה הפנימית (10 לכל תיקייה בלולאה האמצעית).\nבכל תיקייה יש קובץ יחיד לכן מספיק המינימום של בלוק DATA אחד וכך גם לכל קובץ, לכן בסה\"כ נוצלו 1110 בלוקים של DATA ו-1110 inodes.\n3.2: כן, לאחר מחיקת כל הקבצים והתיקיות נפנה את כל הבלוקים וה-inodes, לכן כמות הבלוקים ו-inodes הפנויים תהיה זהה (מאחר שהכל משוחרר במחיקה).\n3.3: ייווצרו קבצים עד שלא יהיו יותר inodes פנויים – כל קובץ תופס בלוק DATA אחד, לכן המגבלה תהיה כמות ה-inodes (מאחר שיש יותר בלוקי DATA). לאחר מכן הסקריפט ימשיך לרוץ בלולאה אינסופית אך יודפסו הודעות שגיאה."}, "difficulty_estimation": "Medium"}]}, {"filename": "os23BA.json", "metadata": {"course_name": "Operating Systems", "year": "2023", "semester": "Semester B", "moed": "Moed A", "exam_date": "25.06.2023", "source_file": "os23BA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Memory Management", "Virtual Memory", "I/O"], "content": {"text": "אם הזיכרון הראשי (RAM) מספיק גדול, לא נצטרך לעולם לקרוא או לכתוב נתוני תהליך מ/אל הזיכרון המשני (דיסק).", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. עדיין נצטרך לקרוא נתוני תהליך מהדיסק, לדוגמה את קוד התהליך. בנוסף יש שימוש ב-swapping גם כשהזיכרון לא בהכרח מלא, בגלל high/low watermark."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Synchronization", "Mutexes", "Concurrency", "Deadlocks"], "content": {"text": "מנעול הוגן אינו מבטיח שכל חוט שמנסה לתפוס את המנעול בהכרח יצליח לתפוס אותו בשלב מסוים.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. במרה שאף חוט אינו מצליח לתפוס את המנעול (קיפאון), או שמתקיים במערכת קיפאון/הרעבה ללא קשור לתכונות המנעול (כמו הרעבת הכותבים במנעול קוראים-כותבים, גם בשימוש במנעול הוגן)."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["File Systems"], "content": {"text": "ב-LFS, נעדיף להשתמש בסגמנט גדול ככל הניתן.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. סגמנט גדול ייתן ביצועים טובים יותר אך סיכון גדול יותר לאיבוד נתונים."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Processes", "Scheduling", "System Calls"], "content": {"text": "תהליך יכול לעבור באופן יזום (ע\"י התהליך) ממצב Running למצב Ready.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. ע\"י קריאת המערכת yield."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling"], "content": {"text": "בתזמון RR, זמן התגובה הוא אופטימלי.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. זמן התגובה של RR טוב אך אינו אופטימלי (וגם לא אידיאלי) אפילו עם קוונטה מינימלית, כי תהליך חדש מתווסף לסוף התור וממתין לקוונטה של כל התהליכים לפניו."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה מערכת עם זיכרון וירטואלי של 1GB וגודל דף של 4KB. נתון שבכל דף/חלק של טבלת הדפים נכנסות 1024 רשומות (PTE / PDE), וה-MMU משתמש ב-5 ביטים של סטטוס. יש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "מה גודל הזיכרון הפיזי המקסימלי האפשרי במערכת זו?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "כמה רמות דרושות לטבלת הדפים במערכת זו, וכמה ביטים בכתובת הווירטואלית משמשים לכל רמה?", "code_snippet": null, "options": null}, {"id": "6.3", "text": "תהליך ביצע הקצאת זיכרון דינמית (malloc) של 5MB. כמה מסגרות יתפסו בזיכרון הראשי בעקבות ביצוע פקודה זו, במקרה המקסימלי?", "code_snippet": null, "options": null}], "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. בכל דף של 4KB יש 1024 רשומות PTE, כלומר גודל כל רשומה הוא 4 בתים = 32 ביטים. במקרה המקסימלי ה-PFN הוא כל הביטים מלבד 5 של סטטוס, לכן בזיכרון הפיזי יש 2^27 מסגרות. סה\"כ הזיכרון הפיזי הוא כפול גודל דף/מסגרת של 4KB, כלומר 512GB.\n2. לכל תהליך יש 1GB/4KB = 2^18 דפים. בכל דף של טבלת הדפים נכנסות 1024=2^10 רשומות כלומר צריך 2 רמות כדי למפות את כל הדפים. עבור הרמה התחתונה נשתמש ב-10 ביטים ועבור הרמה העליונה ב-8 ביטים.\n3. הקצאה של 5MB היא למעשה הקצאה של 5MB/4KB = 1280 דפים רצופים בזיכרון הוירטואלי של התהליך, או 1281 במקרה המקסימלי (אם ההקצאה לא מיושרת לתחילת הדף אלא מתחילה באמצע דף כלשהו). במקרה המקסימלי, 1281 דפים יכולים להתפרס על פני 3 חלקים שונים של טבלת הדפים ההיררכית. אם כל 3 חלקים אלו של טבלת הדפים לא הוקצו עד כה, נצטרך להקצות 1281 מסגרות חדשות עבור הזיכרון עצמו ועוד 3 מסגרות עבור החלקים של טבלת הדפים סה\"כ 1284 מסגרת במקרה המקסימלי. (יש לשים לב שהרמה הראשונה של טבלת הדפים בהכרח כבר קיימת, ולכן לא נכללת)"}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Mutexes", "Concurrency", "Deadlocks"], "content": {"text": "נתונה מערכת מרובת חוטים המנהלת N משאבים אקסקלוסיביים, כלומר שמותר לגשת רק לאחד מהמשאבים בכל רגע נתון (אך ניתן לגשת לאותו משאב ע\"י מספר חוטים במקביל). המשאבים ממוספרים 1-N...0. חוט אשר מעוניין לגשת למשאב i קורא לפעולה (enter(i לפני הגישה למשאב, ולפעולה (exit(i לאחר סיום השימוש במשאב. הקריאה (enter(i צריכה לחסום את החוט הקורא עד אשר הוא רשאי לגשת למשאב i (ואז הקריאה חוזרת). בשאלה זו יש לכתוב אובייקט סנכרון עבור מערכת זו (מימוש לפעולות enter, exit) כך שחוטים שונים יוכלו לקרוא לפעולות אלו במקביל והמערכת תעבוד באופן תקין: - מניעה הדדית: בכל רגע נתון, לא נעשית גישה ליותר ממשאב אחד. - חופש מקיפאון: אם חוט מנסה לגשת למשאב i ואין חוט הניגש למשאב שונה מ-i, החוט יצליח לגשת אל i. לצורך הפתרון הוגדרו המשתנים הגלובליים הבאים: int r=-1,c=0; sem_t mutex; // init to 1 אין להוסיף משתנים גלובליים, סטטיים, או להשתמש בפקודות מכונה אטומיות או אובייקטי סנכרון נוספים. void enter(int i) { } void exit(int i) { }", "code_snippet": "int r=-1,c=0;\nsem_t mutex; // init to 1\nvoid enter(int i) {\n}\nvoid exit(int i) {\n}"}, "sub_questions": null, "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפתרון נעזר במנעול ו-2 משתנים: המונה r מציין את אינדקס המשאב בשימוש כרגע, והמונה c מציין כמה חוטים משתמשים כרגע במשאב זה (כאשר 0==c אף משאב לא בשימוש). בניסיון גישה למשאב נתפוס את המנעול ונבדוק אם המשאב זמין (0==c כלומר אף משאב לא בשימוש, או r שווה למשאב שרוצים לגשת אליו). אם כן נוכל לקדם את c ולחזור, אחרת נשחרר את המנעול וננסה מחדש. המנעול הוגן, לכן נבטיח שלא יהיה קיפאון (אחרת יתכן שאותו חוט ינסה שוב ושוב לגשת למשאב לא זמין וימנע מאחרים לגשת או לשחרר את המשאב). שימו לב: למרות השימוש במנעול הוגן תיתכן הרעבה בפתרון, אך לא נדרשה הוגנות בשאלה.", "code_snippet": "void enter(int i) {\n    while (1) {\n        sem_wait(&mutex);\n        if ((r == i) || (c == 0)) {\n            r = i;\n            ++c;\n            sem_post(&mutex);\n            return;\n        }\n        sem_post(&mutex);\n    }\n}\nvoid exit(int i) {\n    sem_wait(&mutex);\n    --c;\n    sem_post(&mutex);\n}"}, "difficulty_estimation": "Medium"}, {"id": 8, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתון דיסק קשיח עם הנתונים הבאים: - מהירות סיבוב: 6,000 RPM - גודל סקטור: 1024 בתים. - גודל בלוק: 4KB. - 4 משטחים (2 platters דו-צדדיים). - צפיפות הסקטורים בכל רצועה היא בהתאם ל-4 אזורים: A, B, C, D. בכל אזור 50 רצועות, והאזורים מסודרים בדיסק מבחוץ פנימה – כאשר A הוא החיצוני ביותר ו-D הפנימי ביותר. - באזור A יש 2000 סקטורים לרצועה, באזור B יש 1500 סקטורים לרצועה, - באזור C יש 1000 סקטורים לרצועה, באזור D יש 500 סקטורים לרצועה. - זמן ה-seek הממוצע הוא 20ms, בין שתי רצועות סמוכות הוא 2ms, וזמן ה-seek המקסימלי הוא 40ms. - שיפור track skew: בקריאת סקטורים עוקבים ברצועות סמוכות אין המתנה לסיבוב. הבהרה: בקורס נהגנו לחשב זמנים ממוצעים. בשאלה זו נתונים זמנים בפועל שעלולים להיות גבוהים או נמוכים מהממוצע, עד כדי הנתונים שסופקו לגבי הדיסק. יש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "קוראים תוכן של קובץ בדיסק בגודל 100 בלוקים, אשר מפוצל על פני שתי רצועות באותו משטח (בתוך כל רצועה המידע יושב באופן רציף). מדדו וניטרו פעולה זו וגילו שמתבצעים, לפי הסדר: 1. השהיה מסוימת למשך זמן לא ידוע. 2. העברת 300KB של נתונים במשך 1.5ms. 3. השהיה של 50ms. 4. העברת שאר המידע של הקובץ (100KB) ברצף אחד, ללא השהיות נוספות. כמה זמן נמשכה העברת המידע בשלב 4?", "code_snippet": null, "options": null}, {"id": "8.2", "text": "נתון קובץ בגודל 100MB. כיצד כדאי למקם את נתוני הקובץ בתוך הדיסק, כך שקריאה של כולו תתבצע באופן המהיר ביותר (במקרה הממוצע)? כמה זמן תיקח הפעולה במקרה זה?", "code_snippet": null, "options": null}, {"id": "8.3", "text": "מה שטח האחסון הכולל בדיסק (כמה בתים של נתונים ניתן לאחסן בדיסק כולו)?", "code_snippet": null, "options": null}], "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. שלב 1 מתאים לזמן המיקום של הפעולה (seek + המתנה לסיבוב). לפי קצב העברה של 300KB ב-1.5ms, שלב 2 מתאים להעברה של נתונים מרצועה באזור A. שלב 3 תואם לזמן ה-seek והמתנה לסיבוב המקסימליים, כלומר שבהכרח עשינו את המרחק הכי רחוק בדיסק – מרצועה באזור A לרצועה באזור D. לכן בשלב 4 קוראים 100KB מרצועה באזור D. נחשב זמן העברה בפועל לפי זמן הסיבוב וכמות הנתונים – 100KB הם חמישית מהנתונים ברצועה ולכן ההעברה תיקח חמישית סיבוב – 2ms.\n2. הקובץ מכיל 102,400 סקטורים. נרצה לשים את כולם באופן רציף באזור A שם קוראים בקצב הכי מהיר. בכל רצועה ב-A יש 2000 סקטורים שניתן לקרוא ברצף, ובפיזור נכון על פני 4 המשטחים נוכל לקרוא 8000 סקטורים (2000 מכל משטח) ברצף ללא seek או המתנה לסיבוב ביניהם. מתוך הכמות הנדרשת, נוכל לחלק באופן הזה 96,000 סקטורים על פני 12 צילינדרים (48 רצועות על גבי 4 משטחים). כלומר שקריאה של 48 הרצועות האלו תתבצע עם זמן 11 מעברים בין רצועות בלבד (של 2ms לכל מעבר) וללא 22ms – seek למעברים ועוד 48 סיבובים לקריאה עצמה (480ms) – סה\"כ 502ms נותרו עוד 6400 סקטורים של הקובץ, אותם נשים בצילינדר נוסף (עדיין באזור A). בכל סיבוב ניתן לקרוא רצועה שלמה שהיא 2000 סקטורים, לכן נקרא 6400 סקטורים ב-3.2 סיבובים (32ms) ועוד זמן המעבר (seek) לרצועה זו של 2ms – סה\"כ תוספת של 34ms. לזה נוסיף זמן seek ממוצע 20ms + המתנה לסיבוב 5ms בתחילת הפעולה. נקבל סה\"כ 561ms. תשובה שגויה, המחלקת את הנתונים על-פני משטח אחד בלבד, תגיע לזמן מינימלי של 643ms.\n3. בכל אזור יש 50 רצועות, ובמשטח שלם יש 50*(2000+1500+1000+500) = 250,000 סקטורים. בדיסק יש 4 משטחים, כלומר מיליון סקטורים של 1KB."}, "difficulty_estimation": "Medium"}]}, {"filename": "os23BB.json", "metadata": {"course_name": "Operating Systems", "year": "2023", "semester": "Semester B", "moed": "Moed B", "exam_date": "16.07.2023", "source_file": "os23BB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "אם הזיכרון הראשי (RAM) מלא, הקצאת זיכרון של דף חדש לתהליך בהכרח גוררת כתיבה לשטח ההחלפה ( swap space).\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. אם יש מסגרת לפינוי עבורה 0=Dirty, אין צורך לכתוב ל-swap."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Synchronization", "Semaphores", "Concurrency"], "content": {"text": "כל מימוש תקין של סמפור הוא הוגן.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. מימוש הסמפור המובנה בלינוקס הוא הוגן, אך בהגדרת אובייקט הסנכרון אין חובה לממש הוגנות. יש להבדיל מאובייקט כמו מנעול קוראים-כותבים שאינו הוגן – בגלל אופן השימוש בסמפורים/מנעולים הפנימיים. זה לא מפריך את הטענה שכן הסמפורים/מנעולים הפנימיים כן הוגנים, רק האובייקט שנוצר (שאינו הסמפור) אינו הוגן."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["File Systems", "Security"], "content": {"text": "ב-LFS ניתן להוסיף מנגנון להתמודדות עם קריסות.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. ע\"י שימוש בטרנזקציות בדומה ל-journaling נוכל להבטיח התמודדות עם קריסות."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Processes", "Virtual Memory", "System Calls"], "content": {"text": "בביצוע ()fork ללא copy-on-write, ישוכפל כל הזיכרון של תהליך האב.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. שטחי זיכרון שאינם ניתנים לכתיבה (כמו הקוד / TEXT) עדיין ישותפו ולא ישוכפלו."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling", "Processes"], "content": {"text": "החלק של אלגוריתם התזמון שבוחר את התהליך הבא לביצוע ממומש כולו בתוכנה ולא בחומרה.\nנכון / לא נכון", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. תהליך הוא מבנה נתונים של הקרנל, לכן בחירת התהליך הבא לביצוע בהכרח מתבצעת ע\"י הקרנל בלבד – בקוד של מערכת ההפעלה."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Concurrency", "Scheduling"], "content": {"text": "נתונה התוכנית הבאה: \nנתון שיש מעבד יחיד ואלגוריתם התזמון הוא FIFO, וניתן להניח שכל קריאות המערכת הצליחו.\nתזכורת: יש לצרף הסבר ברור לכל סעיף.", "code_snippet": "1 int main()\n2 {\n3   int arr[N]={0}; // init all to 0\n4   char *e[] = {\"echo\", \"hello\",NULL};\n5   setbuf(stdout, NULL);\n6 \n7   for(int i = 0; i < N; ++i)\n8     arr[i] = (fork() > 0); // 0 or 1\n9 \n10  for(int i = 0; i < N; ++i)\n11    printf(\"%d \", arr[i]);\n12 \n13  if (arr[0])\n14    execvp(e[0], e);\n15  else\n16    printf(\"\\n\");\n17 }", "options": null}, "sub_questions": [{"id": "6.1", "text": "כתבו פלט אפשרי של התוכנית כאשר מתקיים 3=N.", "code_snippet": null, "options": null}, {"id": "6.2", "text": "כמה תהליכים נוצרו במהלך ריצה תקינה של התוכנית, כולל התהליך הראשי, עבור ערך כלשהו של N? (כלומר, התשובה צריכה להיות פונקציה של N).", "code_snippet": null, "options": null}, {"id": "6.3", "text": "כיצד ישתנה פלט התוכנית אם אלגוריתם התזמון הוא MLFQ במקום FIFO?\nיש לענות לגבי המקרה הכללי ולא ביחס לסעיפים קודמים. אין צורך לכתוב את הפלט החדש, אלא לתאר בפירוט מה השינוי שיתרחש.", "code_snippet": null, "options": null}, {"id": "6.4", "text": "כיצד ישתנה פלט התוכנית אם בתנאי בשורה 13 נבדוק את [1-arr[N במקום [0]arr?\nיש לענות לגבי המקרה הכללי ולא ביחס לסעיפים קודמים. אין צורך לכתוב את הפלט החדש, אלא לתאר בפירוט מה השינוי שיתרחש.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. פלט התהליכים יהיה לפי סדר היצירה שלהם, כאשר בכל תהליך במערך arr יהיו ערכי ההחזר של כל קריאות ה-fork לפי נקודת מבטו (1 אם היה אב, 0 אם בן). כל תהליך שאינו שתת-עץ התהליך שנוצר קריאת ה-fork הראשונה מדפיס גם hello בגלל הקריאה ל-execvp.\n1 1 1 hello\n011\n10 1 hello\n1 1 0 hello\n001\n010\n100 hello\n000\n2. בכל קריאה ל-fork מוכפל מספר התהליכים, סה\"כ 2^N תהליכים.\n3. תוכן ההדפסות יישאר זהה (כל תהליך ידפיס את אותו דבר), אך סדר ההדפסות ישתנה – כל סדר הדפסות יהיה אפשרי עם הפלטים הנתונים, כולל ערבוב בין הדפסות התהליכים.\n4. אותו מספר תהליכים ידפיסו hello, אך אלו יהיו תהליכים שונים – כל התהליכים שהם לא עלה בעץ התהליכים ידפיסו hello (בעצם, כל התהליכים שהם תהליכי האב בקריאה האחרונה ל-fork בלולאה הראשונה)."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Threads", "Concurrency", "Atomic Operations", "Mutexes", "Semaphores"], "content": {"text": "בסניף קופת חולים מקומי יש N חדרים אליהם מטופלים יכולים להיכנס.\nכל מטופל שמגיע מקבל מספר וממתין לתורו. כאשר מגיע תורו, המטופל נכנס לחדר המתאים עד לסיום הטיפול. אין הבדל בין החדרים וכל מטופל יכול לקבל טיפול בכל חדר, אך בכל חדר יש לטפל במטופל אחד בלבד בכל רגע נתון.\nלצורך מחשוב הסניף הוחלט לייצג כל מטופל ע\"י חוט ולהשתמש באובייקט סנכרון עם הפעולות הבאות:\nget_number – מטופל קורא לפעולה זו עם הגיעו לסניף ומקבל חזרה את המספר שלו בתור. יש להחזיר מספרים בסדר עולה (כלומר, החל מ-0 ללא דילוגים או כפילויות). אין צורך לטפל ב-overflow.\nwait_for_room – מטופל קורא לפעולה זו מיד לאחר קבלת המספר. הפעולה חוזרת רק כאשר הגיע תורו של המטופל, ומחזירה את מספר החדר (0 עד 1-N) אליו המטופל צריך להיכנס. לאחר שפעולה זו חוזרת, המטופל מיד נכנס לחדר המתאים.\nleave_room – מטופל קורא לפעולה זו לאחר סיום הטיפול, כאשר הוא עוזב את החדר. לאחר הקריאה לפעולה זו (ורק לאחריה), החדר המתאים פנוי לקבלת מטופל נוסף.\nבשאלה זו יש לממש את אובייקט הסנכרון עבור הסניף כך שחוטים שונים יוכלו לקרוא לפעולות אלו במקביל והמערכת תעבוד באופן תקין:\nבכל רגע נתון, בכל חדר יש לכל היותר מטופל אחד.\nאם יש חדר פנוי ויש מטופלים ממתינים, מטופל כלשהו יכנס לחדר.\nמטופלים יכנסו לחדרים לפי הסדר של מספרי התור שלהם. כלומר, לא יתכן מצב שבו מטופל עם תור 1+X נכנס לטיפול בחדר כלשהו בזמן שמטופל X חסום (ואין חדר פנוי עבורו).\nניתן להניח שימוש נכון באובייקט הסנכרון, כך שכל מטופל קורא לפעולות אלו לפי הסדר ומעביר את הארגומנטים הנכונים.\nלצורך הפתרון הוגדר הקבוע N והמשתנים הגלובליים הבאים:\nint r[N] = {0}; // init all to 0\nint next = 0, turn = N-1;\nאין להוסיף משתנים גלובליים או סטטיים.\nמותר להשתמש בפעולות מכונה אטומיות שנלמדו (רמז: fetch_and_add, test_and_set).\nיש לתאר בקצרה את הפתרון ולכתוב קוד ברור.\nתיאור הפתרון:", "code_snippet": "int get_number() {\n}\nint wait_for_room(int myNumber) {\n}\nvoid leave_room(int myRoom) {\n}", "options": null}, "sub_questions": null, "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "הפתרון נעזר ב-F&A כדי להגדיר תור לכל חוט ולעבור לתור הבא (בדומה למנעול ticket lock).\nכדי לתפוס חדר, כל חוט ממתין לתורו (יש N במקביל) ואז מנסה לתפוס חדר עם פעולת TAS אשר מבטיחה שלא יקרה מצב ש-2 חוטים נכנסים לאותו חדר. למעשה כל חדר הוא מעין מנעול TAS, וכל חוט מנסה לתפוס פעם אחת את המנעול של כל חדר (מובטח שיצליח מאחר שיש N חוטים ו-N חדרים).. המערך r הוא מערך בוליאני המציין לכל חדר אם הוא פנוי או תפוס. חובה להשתמש ב-TAS בגלל שיש N חוטים שעלולים לנסות לתפוס חדר במקביל.", "code_snippet": "int r[N] = {0};\nint next = 0, turn = N-1;\n\nint get_number() {\n    return fetch_and_add(&next);\n}\nint wait_for_room(int myturn) {\n    while (myturn > turn);\n    for (int i = 0; i < N; ++i) {\n        if (!test_and_set(r[i]))\n            return i;\n    }\n}\nvoid leave_room(int myRoom) {\n    r[myRoom] = 0;\n    fetch_and_add(&turn);\n}"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Memory Management"], "content": {"text": "נתון דיסק קשיח ועליו מערכת קבצים VSFS עם שדרוג: בכל inode יש מקום ל-128 בתים של נתונים של הקובץ. בתים אלו נשמרים בשדה בתוך ה-inode עצמו, ולא בתוך בלוק DATA כמו שאר נתוני הקובץ. רק כאשר גודל הקובץ חורג מכמות זו, מערכת הקבצים תשתמש במצביעים עבור המשך נתוני הקובץ. כמו-כן נתון:\nגודל בלוק הוא 4KB וגודל מצביע הוא 4 בתים.\nגודל inode הוא 256 בתים (כולל 128 הבתים של הנתונים).\nבכל inode יש 5 מצביעים ישירים, 2 מצביעים עקיפים, 1 מצביע עקיף כפול, ו-1 מצביע עקיף משולש.\nבנתונים (DATA) של תיקייה קיימת טבלה עם 2 עמודות, גודל כל שורה בטבלה הוא מספר התווים בשם הקובץ (בית אחד לכל תו) + 8 בתים נוספים.\nגודל הנתונים של קישור סימבולי הוא בית אחד לכל תו.\nיש לפרט ולנמק את כל החישובים בכל סעיף.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה בלוקים של DATA הוא יתפוס?\nגודל מקסימלי:\nכמות בלוקים:\nנימוק:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "משתמש פתח את הקובץ: /home/mta/a.txt\nידוע שקובץ זה הוא קישור סימבולי אל הקובץ: /usr/local/bin/ls\nנתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה. כמה בלוקים צריך לקרוא ולכתוב במקרה המינימלי בשביל לבצע את הפעולה?\nניתן להניח כל תרחיש שיוביל למספר הבלוקים המינימלי כל עוד הוא עומד בנתונים ובמגבלות שצוינו.\nמספר בלוקים מינימלי לקריאה:\nלכתיבה:\nנימוק:", "code_snippet": null, "options": null}, {"id": "8.3", "text": "סטודנט טען שהשדרוג הנתון (128 בתים של נתונים בתוך ה-inode עצמו) צפוי להביא להשפעה מועטה מאוד על הביצועים של מערכת הקבצים. הסבירו מדוע הוא צודק.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. בכל בלוק עקיף נכנסים 4096/4 = 1024 מצביעים.\nלפי המצביעים ב-inode נקבל 1024^3 + 1024^2 + 1024*2 + 5 בלוקים עם נתוני הקובץ, לזה נוסיף את 128 הבתים בתוך ה-inode עצמו בשביל: (1024^3 + 1024^2 + 2048 + 5)*4KB + 128B.\nבשביל כמות הבלוקים נוסיף את הבלוקים של המצביעים – 2 עקיפים, אחד עקיף כפול שמוביל לעוד 1024 עקיפים, ואחד עקיף משולש שמוביל ל-1024 עקיפים כפולים ו-1024^2 עקיפים.\nסה\"כ נקבל: 5 + 2+2048 + 1+1024+1024^2 + 1+1024+1024^2+1024^3.\n2. במינימום, כל התיקיות לאורך הדרך מכילות את הרשומות שאנו נדרשים אליהן בתוך 128 הבתים של ה-inode, כך שיש רק לקרוא את ה-inode בדרך:\nשל השורש, אז home ואז mta ואז a.txt.\nמכאן נקרא את usr (השורש כבר נטען) ואז local ואז bin.\nבנוסף יש לעדכן את זמני הגישה אל a.txt ואל ls.\nבמקרה המינימלי, כל ה-inodes נמצאים באותו בלוק ולכן נבצע את כל הפעולה בקריאה אחת וכתיבה אחת.\n3. השיפור עוזר בקריאה של קבצים קטנים, אך כפי שלמדנו במערכות היום רוב הנתונים גם ככה ב-cache ונבצע מעט קריאות כאלו, לכן השיפור עלול להיות קטן מאוד."}, "difficulty_estimation": "Hard"}]}, {"filename": "os23SA.json", "metadata": {"course_name": "Operating Systems", "year": "2023", "semester": "Summer", "moed": "Moed A", "exam_date": "07.12.2023", "source_file": "os23SA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "ב-VSFS, פעולת העתקה של קובץ בתוך אותה מערכת קבצים לרוב תהיה מהירה יותר מאותה פעולת העתקה בין מערכות קבצים שונות.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. מערכות קבצים שונות יכולות לשבת על התקנים שונים ואז ניתן לקרוא ולכתוב במקביל את הקובץ במהלך ההעתקה, בעוד שאותה מערכת קבצים לרוב נמצאת באותו כונן ונוכל לבצע רק פעולה אחת בכל פעם."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency", "Semaphores"], "content": {"text": "במשתני תנאי, שימוש ב-broadcast במקום signal פותר את בעיית ה-lost signal.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. בתרחיש הראשון שנלמד ל-lost signal, לא משנה אם יתבצע broadcast."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "יש מקרים בהם עדיף להשתמש ב-4-RAID על פני 5-RAID.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. 5-RAID עדיף על 4-RAID בכל פרמטר."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "File Systems"], "content": {"text": "בביצוע ()fork, הקבצים הפתוחים בתהליך האב נפתחים מחדש עבור תהליך הבן.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. בביצוע fork, טבלת הקבצים הפתוחים משתכפלת אך הקבצים לא נפתחים מחדש, ותהליך הבן יצביע לאותם קבצים שפתוחים אצל האב."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Scheduling", "Deadlocks", "Concurrency"], "content": {"text": "בהרצת תהליכים וחוטים עם אלגוריתם התזמון FCFS לא יתכן שיתרחש קיפאון.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. תזמון FCFS חוט אחד יסיים לפני שהשני מתחיל ולכן לא מתקיים התנאי של hold and wait"}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה מערכת בה רוחב כתובת וירטואלית הוא 32 ביט וגודל הזיכרון הפיזי הוא 1GB. כל כניסה בטבלת הדפים היא בגודל 3 בתים, כאשר 6 ביטים משמשים לסטטוס ואף ביט לא משמש לריפוד.\nתהליך הריץ את קטע הקוד הבא (M,N הם קבועים מספריים כלשהם שהוגדרו מראש):\nלאחר הרצת הקוד הנ\"ל, תוכן ה-TLB שהתווסף בעקבות הגישות למערך בשורה 4 הוא להלן (ניתן להניח שאף מיפוי של המערך לא היה ב-TLB לפני כן):\nמסגרת דף סטטוס\n2 11B ......\n3 2 ......\nהמספרים הנתונים הם בבסיס 16.\nיש לפרט ולנמק את כל החישובים.", "code_snippet": "1 int arr[N];\n2 int step = M;\n3 for (int i = 0; i < N; i += step)\n4    arr[i] = arr[i] + 1;"}, "sub_questions": [{"id": "6.1", "text": "מה גודל דף ומסגרת במערכת?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "ידוע שבגישה הראשונה למערך כאשר 0=i התהליך פנה לכתובת 2008 (בבסיס 16). מה הכתובת הפיזית בה מתחיל המערך arr?", "code_snippet": null, "options": null}, {"id": "6.3", "text": "מה הגודל המינימלי והמקסימלי של N (גודל המערך arr) אם גודל int הוא 4 בתים?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "6.1: 1. כל כניסה בטבלת הדפים היא 24 ביט מתוכם 6 לסטטוס ואין ריפוד, כלומר 18 ביטים למספר מסגרת. הזיכרון הפיזי הוא 1GB = 2^30 כלומר 30 ביטים, ולפי 18 ביטים למסגרת יש 12 ביטים להיסט. גודל מסגרת = גודל דף ולפי ההיסט 2^12 בתים, כלומר גודל הדף/מסגרת הוא 4KB.\n6.2: 2. עבור הכתובת 2008 (בבסיס 16) ← לפי סעיף קודם ההיסט 12 ביטים כלומר 008, ומספר הדף 2. לפי ה-TLB דף 2 ממופה למסגרת 11B, נחבר חזרה עם אותו היסט ונקבל כתובת פיזית 11B008 (בבסיס 16).\n6.3: 3. לפי ה-TLB הגישה לתאי המערך גררה גישה ל-2 דפים בלבד. במקרה המינימלי, המערך מכיל איבר אחד בסוף הדף הראשון ואחד בתחילת הדף השני (אותו איבר לא יכול להתחלק בין 2 דפים בגלל שהזיכרון מיושר), כלומר המינימום הוא 2=N. עבור המקרה המקסימלי, קודם כל נשים לב שבכל דף בגודל 4KB נכנסים 1024 איברים של המערך (4 בתים כל אחד). המקרה המקסימלי הוא כאשר הפרמטר step/M הוא 2047. במקרה זה נבצע בדיוק 2 גישות למערך – תא 0 בתחילת הדף הראשון, ותא 2047 בסוף הדף האחרון. אנו יודעים שלא התבצעה גישה נוספת, כלומר שבגישה הבאה לתא 4094 חרגנו מגודל המערך N, כלומר המקסימום הוא 4093=N. אם נתעלם מהפרמטר של step/M (במקרה שהוא 1), אז במקרה המקסימלי המערך ממלא את 2 הדפים אליהם ניגשנו ולא יותר, כלומר 2048=N."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Concurrency", "Mutexes", "Threads"], "content": {"text": "להלן קוד למימוש מנעול עבור 2 חוטים, כאשר לכל חוט מזהה (0 או 1) המועבר בתור הפרמטר i:", "code_snippet": "1 int flag[2] = {0};\n2 int label[2] = {0};\n3 void lock(int i) {\n4    int j = 1-i;\n5    flag[i] = 1;\n6    label[i] = 1 + label[j];\n7    while ((flag[j]) && (label[i] > label[j]));\n8 }\n9 void unlock(int i) {\n10   flag[i] = 0;\n11 }"}, "sub_questions": [{"id": "7.1", "text": "הדגימו ריצה אפשרית המוכיחה כי המנעול אינו מקיים מניעה הדדית.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "שינו את הקוד כך שבשורה 7 האופרטור < הוחלף באופרטור =<. הדגימו ריצה אפשרית (לאחר השינוי) המוכיחה כי המנעול אינו מקיים חופש מקיפאון.", "code_snippet": null, "options": null}, {"id": "7.3", "text": "האם המנעול הוגן? אם כן יש להוכיח, אחרת יש להראות דוגמה נגדית. רמז: התשובה זהה עם או בלי השינוי המתואר בסעיף הקודם.", "code_snippet": null, "options": ["המנעול הוגן", "המנעול לא הוגן"]}, {"id": "7.4", "text": "תקנו את המנעול כך שיקיים את 3 התכונות: מניעה הדדית, חופש מקיפאון, הוגנות. אין להוסיף משתנים גלובליים או מקומיים, וללא שימוש בפקודות אטומיות או אובייקטי סנכרון אחרים. יש לתאר בקצרה את השינוי ולכתוב קוד ברור.", "code_snippet": "void lock(int i)\n\nvoid unlock(int i)", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: 1. שני החוטים יגיעו במקביל לשורה 6 ויקבלו את אותו הערך עבור ה-label (כל אחד יקרא את הערך של החוט השני לפני שיכתוב את שלו). בריצה זו, שני החוטים יעברו את התנאי בשורה 7 ויכנסו לקטע הקריטי.\n7.2: 2. עבור אותה ריצה, כאשר שני החוטים יגיעו לשורה 7 עם השינוי – שניהם יהיו חסומים בלולאה ולכן יהיה קיפאון.\n7.3: 3. המנעול הוגן. נניח בשלילה שהמנעול לא הוגן, אז יתכן מצב שבו חוט כלשהו (ללא הגבלת הכלליות, חוט 0) חסום לצמיתות בזמן שחוט אחר (חוט 1) תופס ומשחרר את המנעול מספר לא מוגבל של פעמים. חוט 0 יכול להיות חסום רק בשורה 7, אך אם הגיע אליה הוא קיבל ערך כלשהו ל-label אותו כבר כתב לתא המתאים. בפעם הבאה שחוט 1 יריץ את שורה 6 הוא בהכרח יקרא את ערך זה ויכתוב ערך label עבור עצמו שגדול יותר מה-label של חוט 0, ולכן יהיה חסום בלולאה בשורה 7 (לפחות עד שחוט 0 יתפוס וישחרר את המנעול) – בסתירה לכך שחוט 1 תופס ומשחרר את המנעול בלי הגבלה בזמן שחוט 0 חסום.\n7.4: 4. ניתן לממש מנעול פטרסון (המנעול המשתמש ב-turn + flag) ע\"י שימוש במערך הדגלים באותו אופן כמו פטרסון, ושימוש בתא 0 מתוך מערך ה-label עבור המשתנה turn של פטרסון."}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Memory Management"], "content": {"text": "נתונה מערכת קבצים LFS עם הנתונים הבאים:\nגודל בלוק הוא 2KB.\nגודל מצביע הוא 4 בתים.\nגודל סגמנט הוא 2000 בלוקים.\nבכל inode יש 6 מצביעים ישירים, 1 מצביע עקיף, 1 מצביע עקיף כפול, 1 מצביע עקיף משולש.\nבמערכת זו קיים קובץ בשם XYZ בגודל 2MB.\nידוע שביצירת הקובץ XYZ כל נתוניו נכתבו בבת אחת, ובתחילת הכתיבה הסגמנט של מערכת הקבצים היה ריק.\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null}, "sub_questions": [{"id": "8.1", "text": "לכמה בלוקים בדיסק יש לכתוב כדי ליצור את הקובץ XYZ (כולל כתיבת הנתונים)? יש לפרט את סוגי הבלוקים ולציין כיצד התוכן שלהם קשור לקובץ XYZ. ניתן להניח שסגמנט חלקי נכתב לדיסק בסופו של דבר, אך יש להתייחס רק לבלוקים הרלוונטיים לקובץ XYZ (ולא לשאר הבלוקים בסגמנט שהתווספו ללא קשר ל-XYZ) - אין צורך להתייחס לכתיבות עבור הוספת הקובץ לתיקייה בה הוא נמצא.", "code_snippet": null, "options": null}, {"id": "8.2", "text": "תהליך ניגש לבית האחרון בקובץ XYZ. כמה בלוקים יש לקרוא ולכתוב כדי לבצע את הפעולה בהנחה שה-inode של XYZ ידוע מראש, ואף נתון רלוונטי לא נמצא מראש ב-cache? יש לפרט את כל הבלוקים, הפעולה שמתבצעת עליהם, והסיבה שיש לגשת אליהם.", "code_snippet": null, "options": null}, {"id": "8.3", "text": "תהליך פתח את הקובץ XYZ וביצע כתיבה של בית אחד במיקום 12,300 בקובץ. כמה בלוקים יש לקרוא ולכתוב כדי לבצע את הפעולה, בהנחה שה-inode של XYZ ידוע מראש, ואף נתון רלוונטי לא נמצא מראש ב-cache? יש לפרט את כל הבלוקים, הפעולה שמתבצעת עליהם, והסיבה שיש לגשת אליהם.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "8.1: 1. 2MB הם 1024 בלוקים של נתונים. בכל בלוק נכנסים 512 מצביעים. ב-6 מצביעים ישירים + בלוק עקיף נכנסים 518 בלוקים של נתוני הקובץ (סה\"כ 519 בלוקים של DATA כולל העקיף). נשתמש בבלוק עקיף כפול עם מצביע אחד וזה יספיק לבלוקים הנוספים. סה\"כ 1024 לנתונים + 1 עקיף כפול + 2 עקיפים ישירים = 1027 בלוקים. בנוסף נצטרך לעדכן בלוק של inode + בלוק של imap. סה\"כ 1029 בלוקים. (צריך גם לעדכן את ה-CR אך זה לא נדרש בתשובה)\n8.2: 2. הבית האחרון בקובץ נמצא דרך גישה מהמצביע העקיף הכפול. לקרוא: inode ,imap CR, 2 בלוקים עקיפים, בלוק עם נתונים. סה\"כ 6 קריאות. לכתוב: צריך לעדכן זמן גישה ב-inode, בעקבותיו גם לעדכן imap. סה\"כ 2 כתיבות. (צריך לעדכן גם את ה-CR אך זה לא נדרש בתשובה)\n8.3: 3. בית 12,300 נמצא בבלוק השביעי בקובץ כלומר מהמצביע העקיף הראשון. לקרוא: inode,imap,CR, בלוק עקיף. סה\"כ 4 קריאות. לכתוב: בלוק נתונים שהתעדכן, בלוק עקיף מעודכן להצביע לנתונים החדשים, inode מעודכן, imap מעודכן. סה\"כ 4 כתיבות. (צריך גם לקרוא את בלוק הנתונים ולעדכן את ה-CR אך זה לא נדרש בתשובה)"}, "difficulty_estimation": "Hard"}]}, {"filename": "os23SB.json", "metadata": {"course_name": "מערכות הפעלה", "year": "2023", "semester": "Summer", "moed": "Moed B", "exam_date": "28.12.2023", "source_file": "os23SB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["File Systems", "Memory Management"], "content": {"text": "ב-LFS אין inode bitmap וגם אין inode region, לכן אין מגבלה על כמות ה-inodes במערכת הקבצים.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. כמות ה-inodes ב-LFS מוגבלת בגלל ה-imap."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Deadlocks", "Concurrency", "Synchronization"], "content": {"text": "בכל קוד או מערכת שמקיימים את כל 4 תנאי הקיפאון, בהכרח קיימת ריצה כלשהי שתוביל לקיפאון.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. אם אחד התנאים לא מתקיים אז לא יתכן קיפאון, אך ההיפך לא בהכרח נכון (לדוגמה עם חוט יחיד, או בקטעי קוד שלא יתכן שירוצו במקביל)."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["I/O", "File Systems", "Disk Scheduling"], "content": {"text": "בתרחיש של קריאות סדרתיות, הביצועים של 5-RAID (עם כל השדרוגים) זהים לביצועים של 0-RAID.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. כפי שנלמד, קריאות סדרתיות ב-5-RAID יכולות לנצל את כל הדיסקים בדומה ל-0-RAID."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "File Systems"], "content": {"text": "בביצוע ()fork מיד לאחר פתיחת קובץ, סגירת הקובץ אחרי ה-fork בתהליך האב תסגור אותו גם בתהליך הבן.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "לא נכון", "explanation": "לא נכון. סגירת הקובץ רק מוחקת את המצביע אל ה-FD שלו מטבלת הקבצים הפתוחים של תהליך האב, עבור תהליך האב בלבד ואינה משפיעה על תהליך הבן."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["CPU Scheduling", "Scheduling", "Processes"], "content": {"text": "באלגוריתם התזמון MLFQ, לא קיים תרחיש שיוביל להרעבה של תהליך.", "code_snippet": null, "options": ["נכון", "לא נכון"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "נכון", "explanation": "נכון. בגלל priority boost כל תהליך תמיד יקבל זמן ריצה בסופו של דבר."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה מערכת בה אין טבלאות דפים, ובמקום זאת יש ל-MMU (בזיכרון של הרכיב עצמו) טבלת תרגום כתובות אחת ויחידה לכל התהליכים והמסגרות. טבלת מיפוי זו היא טבלה הפוכה: האינדקס לטבלה הוא מספר מסגרת, ותוכן כל תא בטבלה הוא מזהה תהליך, מספר הדף של התהליך – אשר ממופה למסגרת המתאימה לאינדקס של התא, ביטים של סטטוס וריפוד (אם נדרש).", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "לפי מה ניתן לקבוע כמה כניסות צריכות להיות בטבלת המיפוי?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "כיצד יתבצע תרגום כתובות במערכת זו? יש לתאר באופן מלא את תהליך התרגום כולו, החל מגישה של תהליך לכתובת הווירטואלית ועד למציאת הכתובת הפיזית המתאימה. ניתן להניח שקיים בטבלה מיפוי עבור הדף אליו ניגש התהליך.", "code_snippet": null, "options": null}, {"id": "6.3", "text": "מה היתרון העיקרי של מערכת זו על פני מערכות עם טבלאות דפים סטנדרטיות?", "code_snippet": null, "options": null}, {"id": "6.4", "text": "איזו פעולה או מנגנון קיימים במערכות עם טבלאות דפים סטנדרטיות ובלתי אפשרי לממש במערכת עם טבלה זו בלבד, ומדוע?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "6.1: 1. לפי מספר המסגרות בזיכרון הפיזי – לכל מסגרת יש כניסה בטבלה.\n6.2: 2. תהליך ניגש לכתובת וירטואלית, ה-MMU מפרק למספר דף והיסט, ה-MMU מבצע חיפוש בכל טבלת המיפוי כדי לראות אם יש מסגרת המכילה את הדף – אם כן יבוצע מיפוי של הדף למסגרת לפי אינדקס הרשומה, יחד עם ההיסט זו הכתובת הפיזית.\n6.3: 3. מאחר שהחיפוש בטבלת המיפוי מתבצע בחומרה, נוכל לחפש בכל הטבלה בבת אחת ולמצוא את המיפוי מאוד מהר. טבלה הפוכה מקלה מאוד על מימוש אלגוריתמי פינוי כמו אלגוריתם השעון (אין צורך במבנה נתונים נוסף).\n6.4: 4. החלפה (swapping). מאחר שאין טבלת דפים, אין כל נתון לגבי דף של תהליך שאינו ממופה למסגרת, ולכן אין דרך למפות דפים אל הדיסק."}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Concurrency", "Threads"], "content": {"text": "להלן פתרון לבעיית יצרן-צרכן, אשר עושה שימוש ב-3 סמפורים (full, empty, mutex) המאותחלים באופן זהה לפתרון שנלמד בהרצאה: שימו לב: הקוד הנתון שונה מזה שנלמד בכיתה. הפתרון משתמש במבנים ופונקציות הבאות: Item – מבנה (struct) המייצג מוצר. produce_item/ consume_item – פונקציות ליצירה וצריכה של מוצר. פונקציות אלו פועלות על מוצר בודד ובטוחות לשימוש במקביל (כל עוד הן מופעלות על מוצרים שונים). remove_item / add_item – פונקציות להוספה והסרה של מוצר (מהמחסן). פונקציות אלו אינן בטוחות לשימוש במקביל.", "code_snippet": "void produce() {\n    Item item = produce_item();\n    sem_wait(&empty);\n    sem_wait(&mutex);\n    add_item(item);\n    sem_post(&full);\n    sem_post(&mutex);\n}\nvoid consume() {\n    sem_wait(&full);\n    sem_wait(&mutex);\n    Item item = remove_item();\n    sem_post(&empty);\n    sem_post(&mutex);\n    consume_item(item);\n}"}, "sub_questions": [{"id": "7.1", "text": "האם המימוש הנתון פותר באופן נכון את בעיית יצרן-צרכן? אם כן, יש להוכיח שהפתרון עובד נכון, אחרת יש לתאר את התרחיש הבעייתי ולהסביר אותו.", "code_snippet": null, "options": ["פותר נכון", "לא פותר"]}, {"id": "7.2", "text": "נתונה מערכת מיוחדת בה כל שורת קוד היא אטומית (לא משנה מה מבוצע באותה שורה, מובטח ששורת הקוד כולה מתבצעת באופן אטומי). במערכת זו נתונים 2 משתנים גלובליים x,y המאותחלים ל-0, וסמפור משותף mutex המאותחל ל-1. שני חוטים מריצים במקביל את קטעי הקוד הבאים: פרטו את כל זוגות הערכים האפשריים עבור המשתנים x, y אשר יכולים להתקבל לאחר ש-2 החוטים מסיימים את הריצה שלהם (ניתן להניח שאף חוט אחר לא ניגש למשתנים אלו). לכל זוג ערכים יש לפרט ולהסביר בקצרה את הריצות המובילות אליו.", "code_snippet": "void* thread1 (void*) {\n    x = 2;\n    sem_wait(&mutex);\n    y = y + x;\n    x = 4;\n    sem_post(&mutex);\n}\nvoid* thread2(void*) {\n    x = x + 1;\n    sem_wait(&mutex);\n    y = y - 2;\n    x = x - y;\n    sem_post(&mutex);\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: 1. הפתרון עובד נכון – אין משמעות לסדר שחרור הסמפורים והוא אינו משפיע על נכונות, כל עוד כל הסמפורים שנתפסו משוחררים (ללא עיכוב).\n7.2: 2. נתייחס רק לשורות 2,4,5 של כל חוט. כשחוט מסוים מריץ את שורה 4, הוא בהכרח יריץ את שורה 5 לפני שורה 4 של החוט השני (בגלל המנעול). נקרא לחוט הראשון A ולחוט השני B, יש 8 ריצות אפשריות (לפי חוט ושורה):\n(x=5, y=0) A2 A4 A5 B2 B4 B5\n(x=4, y=0) A2 A4 B2 A5 B4 B5\n(x=3, y=1) A2 B2 A4 A5 B4 B5\n(x=4, y=3) A2 B2 B4 B5 A4 A5\n(x=4, y=0) B2 B4 B5 A2 A4 A5\n(x=4, y=2) B2 B4 A2 B5 A4 A5\n(x=4, y=2) B2 A2 B4 B5 A4 A5\n(x=4, y=0) B2 A2 A4 A5 B4 B5\nסה\"כ 5 זוגות ערכים."}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "Memory Management"], "content": {"text": "נתונה מערכת קבצים VSFS עם שדרוג של extents, כך שבכל inode יש extents במקום מצביעים ישירים. מצביעים עקיפים ומצביעים בתוך בלוקים עובדים כרגיל, ללא extents. למערכת הנתונים הבאים: - גודל בלוק הוא 1024B. - גודל מצביע הוא 4B. - גודל inode הוא 64B. - בכל inode יש 4 extents, 1 מצביע עקיף, 1 מצביע עקיף כפול. - כל extent מורכב ממצביע רגיל לבלוק ועוד בית בודד (1B) המייצג כמות בלוקים 1-256. יש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה בלוקים של DATA הוא יתפוס? גודל מקסימלי: כמות בלוקים: נימוק:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "סטודנט טוען כי אם נשנה את גודל המצביע מ-4B ל-2B, לא נוכל ליצור קובץ בגודל המקסימלי המתאפשר ע\"י המצביעים ב-inode. הסבירו מדוע הסטודנט צודק.", "code_snippet": null, "options": null}, {"id": "8.3", "text": "מה גודל הקובץ המקסימלי המתאפשר בפועל, כאשר משנים את גודל המצביע ל-2B (כמפורט בסעיף הקודם)? תנו דוגמה לערכים חוקיים לכל המצביעים השונים ב-inode (כולל extents והתוכן של בלוקים עקיפים) אשר מייצגים קובץ בגודל מקסימלי זה. שימו לב ששינוי גודל המצביע משפיע על כמות המצביעים בבלוק לעומת הסעיף הראשון (שאלה 8.1).", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "8.1: 1. בכל בלוק נכנסים 1024/4=256 מצביעים. כל extent יכול להצביע ל-256 בלוקים במקסימום. לכן לפי נתוני ה-inode כל קובץ יכול להכיל: 1024 בלוקים (דרך 4 extents) + 256 בלוקים (דרך מצביע עקיף) + 65536 בלוקים (דרך מצביע עקיף כפול שמצביע ל-256 בלוקים מלאים במצביעים).\nגודל קובץ מקסימלי: 68420608 Bytes (66816 KB)\nכמות בלוקים: 66816\nנימוק: 4 extents * 256 blocks/extent = 1024 data blocks. 1 indirect pointer * (1024B/4B) = 256 data blocks. 1 double indirect pointer * (1024B/4B) * (1024B/4B) = 65536 data blocks. Total data blocks = 1024 + 256 + 65536 = 66816. Max size = 66816 * 1024B = 68420608 Bytes.\n\n8.2: 2. כאשר גודל המצביע הוא 2 בתים, ניתן להצביע למקסימום של 65536 בלוקים של DATA אשר הם פחות מגודל הקובץ המקסימלי לפי המצביעים ב-inode.\n\n8.3: 3. עם העדכון נכנסים 1024/2=512 מצביעים בכל בלוק. מאחר שאנו מוגבלים ל-65536 בלוקים של DATA (כולל מצביעים). כדי להגיע לגודל הקובץ המקסימלי בפועל, נסדר את הערכים במצביעים לפי הסדר. המצביעים ב-inode יהיו:\n1. extent המצביע לבלוק 0 עם גודל 256.\n2. extent המצביע לבלוק 256 עם 256 בלוקים.\n3. extent המצביע לבלוק 512 עם 256 בלוקים.\n4. extent המצביע לבלוק 768 עם 256 בלוקים.\n5. מצביע עקיף יצביע לבלוק 1024 (הבלוק הפנוי הבא). בבלוק זה:\n   . נכנסים מצביעים ל-512 בלוקים נוספים של DATA, כלומר יכיל את הערכיים 1025-1536.\n6. מצביע עקיף כפול יצביע לבלוק 1537 (הבלוק הפנוי הבא), בבלוק זה:\n   ו. נכנסים מצביעים ל-512 בלוקים נוספים של מצביעים אך אין מקום לכולם, ננצל רק ב-125 מצביעים, כלומר יכיל את הערכים 1538-1662\n   ii. בבלוקים העקיפים 1538-1661 (כולם מלבד האחרון) ננצל את כל 512 המצביעים עבור הבלוקים הפנויים הבאים (1663 והלאה עד 65,150, סה\"כ 63,488 בלוקים של DATA).\nעד כה השתמשנו ב-65,151 בלוקים (מה-extents: 1024, מהמצביע העקיף: 1+512, מהמצביע העקיף הכפול: 512*1+125+124). נותר לנו בלוק עקיף 1662 (המצביע ה-125 בבלוק העקיף הכפול), ומבחינת בלוקים זמינים נותרו לנו עוד 385 בלוקים של DATA (עד שנגיע למקסימום של 65536).\n. בבלוק 1662 ננצל 385 מצביעים (מתוך 512) עבור 385 הבלוקים שנותרו – מצביעים אל בלוקים 65,535 65,151 עד\nניצלנו את בלוקים 0-65,535, סה\"כ 65,536 בלוקים בהתאם למקסימום ולא ניתן לנצל עוד בלוקים של DATA.\nגודל מקסימלי: 67081216 Bytes (65409 KB)\nנימוק וערכי מצביעים: Total data blocks = 1024 (from 4 extents) + 512 (from 1 indirect block) + (124 * 512) (from 124 full level-2 indirect blocks) + 385 (from 1 partial level-2 indirect block) = 65409 data blocks. Total metadata blocks = 1 (single indirect) + 1 (double indirect level 1) + 125 (double indirect level 2) = 127 metadata blocks. Total blocks (data + metadata) = 65409 + 127 = 65536 blocks, which is the maximum addressable with 2B pointers. Max size = 65409 * 1024B = 67081216 Bytes."}, "difficulty_estimation": "Hard"}]}, {"filename": "os24AA.json", "metadata": {"course_name": "מערכות הפעלה", "year": "תשפ\"ד", "semester": "סמסטר א'", "moed": "מועד א'", "exam_date": "04.03.2024", "source_file": "os24AA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["File Systems"], "content": {"text": "איזה מפריטי המידע הבאים אינו נשמר ב-inode במערכת UNIX?", "code_snippet": null, "options": ["א. שם הקובץ.", "ב. גודל הקובץ בבתים.", "ג. זמן שינוי אחרון (last modification time).", "ד. מספר ה-links שמצביעים לקובץ (link count).", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. לקובץ אין שם ב-inode, אלא רק כחלק מה-hard link המתאים בתיקייה כלשהי."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Memory Management", "Virtual Memory"], "content": {"text": "מה תפקידו של ה-MMU?", "code_snippet": null, "options": ["א. סיוע בתרגום כתובות וירטואליות.", "ב. העתקת מידע מ/אל התקני קלט/פלט.", "ג. ביצוע החלפת הקשר (context switch).", "ד. סיוע למתזמן (scheduler) בקבלת החלטה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. כפי שנלמד, ה-MMU הוא רכיב חומרה המתרגם כתובת וירטואלית לכתובת פיזית."}, "difficulty_estimation": "Easy"}, {"id": 3, "type": "MultipleChoice", "topic": ["Synchronization", "Mutexes", "Semaphores", "Concurrency"], "content": {"text": "נתונה הטענה: על מנת להשתמש נכונה במשתנה תנאי תמיד יש צורך להשתמש גם במנעול.", "code_snippet": null, "options": ["א. הטענה נכונה.", "ב. הטענה לא נכונה.", "ג. הטענה לא נכונה, אלא להיפך: על מנת להשתמש נכונה במנעול תמיד יש צורך להשתמש גם במשתנה תנאי.", "ד. הטענה לא נכונה, על מנת להשתמש נכונה במשתנה תנאי תמיד יש צורך להשתמש במשתנה עזר רגיל ולא במנעול.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. כדי להימנע מ-lost signal, תמיד יש צורך להשתמש במנעול עם משתנה תנאי וזה גם חלק מהממשק המובנה של משתני תנאי."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["I/O", "Disk Scheduling"], "content": {"text": "נתונה הטענה: בהינתן שני דיסקים קשיחים כלשהם, הדיסק עם מהירות הסיבוב (RPM) הגבוהה יותר יבצע קריאות מבלוק רנדומלי מהר יותר.", "code_snippet": null, "options": ["א. הטענה נכונה.", "ב. הטענה נכונה רק אם מהירות הסיבוב של הדיסק המהיר יותר היא לפחות 7200.", "ג. הטענה נכונה רק אם מהירות הסיבוב של הדיסק המהיר יותר היא לכל היותר 7200.", "ד. הטענה לא נכונה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. מהירות הקריאה של דיסק תלויה בעוד פרמטרים מלבד מהירות הסיבוב, כמו זמן ה-seek וקצב ההעברה."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Virtual Memory", "Paging", "Page Replacement"], "content": {"text": "נתון כי במערכת הפעלה א' כתובת וירטואלית מכילה 32 ביטים ואילו במערכת הפעלה ב' כתובת וירטואלית מכילה 40 ביטים. איזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["א. במערכת הפעלה א' יש יותר דפים בזיכרון הוירטואלי של כל תהליך.", "ב. במערכת הפעלה ב' יש יותר דפים בזיכרון הוירטואלי של כל תהליך.", "ג. במערכת הפעלה א' יבוצעו יותר פסיקות דף (page faults).", "ד. במערכת הפעלה ב' יבוצעו יותר פסיקות דף (page faults)", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. גודל הכתובת הוירטואלית אינו מעיד על גודל הדף או כמות הדפים במערכת ולכן לא ניתן לדעת באיזו מערכת הפעלה יש יותר דפים בזיכרון הוירטואלי, ואינו מעיד על גודל הזיכרון והשימוש בו הפיזי ולכן לא ניתן לדעת היכן יבוצעו יותר פסיקות דף."}, "difficulty_estimation": "Hard"}, {"id": 6, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Concurrency", "Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה התוכנית הבאה: תזכורת: באופרטור &&, אם האופרנד הראשון הוא FALSE, לא נבדק/מבוצע האופרנד השני.", "code_snippet": "int main(int argc, char *argv[])\n{\n    char *str = \"hello\";\n\n    if (fork() && fork()) {\n        wait(NULL);\n        printf(\"1: %s\\n\", str);\n        wait(NULL);\n        printf(\"1: %s\\n\", str);\n    }\n    else {\n        wait(NULL);\n        printf(\"0: %s\\n\", str);\n        str = \"goodbye\";\n        wait(NULL);\n        printf(\"0: %s\\n\", str);\n    }\n}"}, "sub_questions": [{"id": "6.1", "text": "מהם כל הפלטים האפשריים של התוכנית, בהנחה שכל הקריאות ל-fork הצליחו? יש להסביר כל פלט באופן מפורט.", "code_snippet": null, "options": null}, {"id": "6.2", "text": "הנתונים להלן רלוונטיים לשני הסעיפים הבאים: נתונה מערכת עם זיכרון פיזי של 16GB בה כתובת וירטואלית מכילה 32 ביטים. המערכת משתמש בטבלת דפים לינארית. כל כניסה בטבלת הדפים היא בגודל 32 ביטים, כאשר 25 ביטים משמשים לאחסון מספר המסגרת. נתון תהליך במערכת אשר בטבלת הדפים שלו: דף 0 ממופה למסגרת 4, דף 1 למסגרת 5, דף 2 למסגרת 6 ודף 3 למסגרת 7. כל שאר הדפים בשימוש אך לא נוכחים (0=valid=1, present). יש לפרט ולנמק את כל החישובים. מה גודל טבלת הדפים של התהליך (בבתים)? גודל הטבלה:", "code_snippet": null, "options": null}, {"id": "6.3", "text": "התהליך הנתון ניגש לכתובת 0BBB ואז לכתוב 1FFF (הכתובות בבסיס 16). עבור כל גישה, האם תתרחש פסיקת דף (page fault)? אם כן יש להסביר, אחרת יש לפרט את הכתובת הפיזית אליה ניגשים. :0BBB פסיקת דף / כתובת פיזית: :1FFF פסיקת דף / כתובת פיזית:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "6.1: 1. יש 5 פלטים אפשריים:\n0: hello\n0: goodbye\n0: hello\n0: goodbye\n1: hello\n1: hello\n\n0: hello\n0: hello\n0: goodbye\n0: goodbye\n1: hello\n1: hello\n\n0: hello\n0: goodbye\n1: hello\n0: hello\n0: goodbye\n1: hello\n\n0: hello\n0: hello\n1: hello\n0: goodbye\n0: goodbye\n1: hello\n\n0: hello\n0: goodbye\n0: hello\n1: hello\n0: goodbye\n1: hello\n\n6.2: כתובת פיזית מורכבת מ-34 ביטים. מספר מסגרת הוא 25 ביטים לכן נשארו 9 ביטים להיסט וגודל דף הוא 512B. כתובת וירטואלית היא 32 ביטים לכן נשארו 23 ביטים למספר הדף ולכל תהליך יש 8M דפים. כל רשומה בטבלה בגודל 4B (32 ביטים) ויש בטבלה 8M רשומות – סה\"כ 32MB\n\n6.3: 0BBB: ההיסט הוא 9 ביטים לכן מספר הדף שניגש אליו (הביטים שנשארו) הוא 5. דף מספר 5 לא ממופה לכן תתרחש פסיקת דף.\n1FFF: מספר הדף הוא 15. דף מספר 15 לא ממופה לכן תתרחש פסיקת דף."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "Open", "topic": ["Threads", "Synchronization", "Semaphores", "Concurrency"], "content": {"text": "במסעדת מזון מהיר מקומית יש 3 סוגי עובדים: קופאים הלוקחים את הזמנות הלקוחות, טבחים המכינים את האוכל במטבח, עובדי הגשה המוסרים את האוכל המוכן ללקוחות.\nלצורך מחשוב המסעדה הוחלט לייצג כל עובד ע\"י חוט, ונתונות הפונקציות הבאות:\n- take_order() – חוסמת את החוט הקורא עד שמגיעה הזמנה חדשה, אז היא חוזרת. פונקציה זו אינה בטוחה לשימוש במקביל (כלומר, אסור לקרוא לה בו-זמנית מחוטים שונים).\n- cook_order() – מכינה את האוכל להזמנה הבאה לפי הסדר, וחוסמת את החוט הקורא עד שהאוכל להזמנה מוכן, אז היא חוזרת. פונקציה זו בטוחה לשימוש במקביל, אך אסור לקרוא לה אם אין הזמנה שממתינה להכנה.\n- serve_order() – מגישה את ההזמנה הבאה לפי הסדר, וחוסמת את החוט הקורא עד שהאוכל המוכן הוגש, אז היא חוזרת. פונקציה זו בטוחה לשימוש במקביל, אך אסור לקרוא לה אם אין הזמנה מוכנה הממתינה להגשה.\nשימו לב: פונקציות אלו נתונות ויש להשתמש בהן במימוש הקוד למסעדה (אין צורך לממש אותן).\nרצף הפעולות התקין הוא: קופאי קורא ל-take_order לקבלת הזמנה וכאשר הקריאה חוזרת הוא מיידע שיש הזמנה ממתינה, אז טבח קורא ל-cook_order להכנת הזמנה וכאשר הקריאה חוזרת הוא מיידע שיש הזמנה מוכנה, אז עובד הגשה קורא ל-serve_order להגשת ההזמנה.\nשימו לב: יתכנו כמה עובדים מכל סוג, ומספר העובדים אינו ידוע מראש.\nבשאלה זו יש לכתוב קוד לכל עובד (הפונקציה הראשית של החוט) כך שהמסעדה תעבוד באופן תקין.\nלצורך הפתרון ניתן להשתמש בסמפורים בלבד (כלומר, לא ניתן להשתמש בפעולות מעבד אטומיות או באובייקטי סנכרון אחרים מלבד סמפורים) וניתן להניח כי הסמפורים הוגנים (הראשון שהמתין יהיה הראשון שיחזור).\nיש לתאר בקצרה ובבירור את הפתרון ולכתוב קוד ברור.\nתיאור הפתרון:\nמשתנים גלובליים (יש לכתוב ערכי אתחול בהערה):", "code_snippet": "void* cashier (void *arg) {\n}\nvoid* cook(void *arg) {\n}\nvoid* serve_worker (void *arg) {\n}"}, "sub_questions": null, "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "sem_t mutex; // init to 1\nsem_t orders, cooked; // init to 0\n\nvoid* cashier (void *arg) {\n    while (1) {\n        sem_wait(&mutex);\n        take_order(); // receive order exclusively\n        sem_post(&mutex);\n        sem_post(&orders); // order received, ready to cook\n    }\n}\n\nvoid* cook(void* arg) {\n    while (1) {\n        sem_wait(&orders);\n        cook_order();\n        sem_post(&cooked); // order cooked, ready to serve\n    }\n}\n\nvoid* serve_worker(void* arg) {\n    while (1) {\n        sem_wait(&cooked);\n        serve_order();\n    }\n}"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Security"], "content": {"text": "נתונה מערכת קבצים VSFS המשתמשת ב-journaling, עם הנתונים הבאים:\n- גודל בלוק הוא 4KB.\n- גודל inode הוא 256 בתים.\n- בכל inode יש 6 מצביעים ישירים, 2 מצביעים עקיפים, 1 עקיף כפול, 1 עקיף משולש.\n- המערכת אינה משתמשת ב-metadata journaling, כלומר גם ה-DATA של כל פעולה נכתב אל ה-journal.\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null}, "sub_questions": [{"id": "8.1", "text": "משתמש יצר קובץ חדש (ריק) בנתיב: home/mta/a.txt/ פרטו את כל הגישות לדיסק (כולל ה-journal) כדי לבצע את הפעולה במלואה, לפי הסדר בו נדרש שיבוצעו, במקרה המינימלי המוביל למספר הגישות הנמוך ביותר. לכל גישה יש לציין אם זו קריאה או כתיבה, לאן ניגשים ומדוע. יש לציין גם היכן אנו ממתינים לכתיבות שיסתיימו (fsync). אין צורך לציין מספרי בלוקים אלא רק סוג בלוק שנקרא או נכתב.", "code_snippet": null, "options": null}, {"id": "8.2", "text": "מבין הגישות בסעיף הקודם (שאלה 8.1), מה הגישה הראשונה אחריה נוכל להבטיח בוודאות שהפעולה תתבצע בהצלחה גם אם המערכת תקרוס? יש לנמק את התשובה.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "8.1: 1. במקרה המינימלי, כל ה-inodes שנצטרך נמצאים באותו בלוק וגם כל ה-bitmaps. שלבים a-d נדרשים כדי למצוא את הנתונים של התיקייה אליה נוסיף את a.txt. שלבים f-j הם השימוש ב-journal ללא metadata journaling. שאלות שהניחו קיומו של cache גם קיבלו את מלוא הנקודות. 1. נקרא את הבלוק המכיל את 2 inode (יחד עם כל שאר ה-inodes הדרושים). 2. נקרא את בלוק הנתונים של התיקייה / 3. נקרא את בלוק הנתונים של התיקייה home/ (ה-inode כבר זמין) 4. נקרא את בלוק הנתונים של התיקייה home/mta/ 5. נקרא inode bitmap למציאת inode פנוי (באותו בלוק של 2) 6. נכתוב טרנזקציה ללוג בלי TxE – פרטי inode של הקובץ החדש + inode bitmap מעודכן + פרטי inode מעודכנים של home/mta + inode עבור home/mta + בלוק נתונים חדש של home/mta fsync .7 8. נסגור את הטרנזקציה עם כתיבת TxE fsync .9 10. נכתוב inode bitmap מעודכן 11. נכתוב inode של התיקייה home/mta/ יחד עם ה-inode של הקובץ 12. נכתוב בלוק נתונים חדש עבור home/mta/ (עם רשומה של הקובץ שהתווסף) טעות נפוצה, שגם גררה הורדת ניקוד משמעותית, הייתה לכתוב טרנזקציה ללוג כבר בשלב a אבל כמובן שלא ניתן לעשות זאת לפני שיודעים את הפרטים אותם נרצה לכתוב לטרנזקציה.\n\n8.2: אחרי סגירת הטרנזקציה בשלב 8."}, "difficulty_estimation": "Hard"}, {"id": 9, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתונה מערכת עם מנגנון 5-RAID בעל 6 דיסקים קשיחים (ממוספרים 1-6), כאשר בלוק ה-stripe- parity הראשון נמצא בדיסק 6, ב-stripe השני בדיסק 5, וכן הלאה באופן מעגלי. הבלוקים ממוספרים החל מ-0, כלומר מספר הבלוק הלוגי הראשון במערך (RAID) הוא 0 ומספר הבלוק הפיזי הראשון בכל דיסק הוא 0. לפי כך, ה-stripe הראשון מכיל את הבלוקים הלוגיים 0-4. בוצעה גישה לבלוק לוגי 535 של המערכת (RAID). לאיזה דיסק ולאיזה בלוק בדיסק זה תתבצע הגישה בפועל? בלוק בפועל:", "code_snippet": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "בכל שורה יש 5 בלוקים של מידע (ועוד בלוק parity), כלומר בלוק 535 הוא בשורה 107, והוא בלוק המידע הראשון בשורה זו. ה-parity בשורה 107 הוא בדיסק הראשון, כלומר בלוק המידע הראשון הוא בדיסק השני. לכן הגישה שנבצע היא לבלוק 107 בדיסק השני."}, "difficulty_estimation": "Medium"}]}, {"filename": "os24AB.json", "metadata": {"course_name": "Operating Systems", "year": "2024", "semester": "Semester A", "moed": "Moed B", "exam_date": "22.03.2024", "source_file": "os24AB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Virtual Memory", "Memory Management", "Paging"], "content": {"text": "מה הוא ה-swap space?", "code_snippet": null, "options": ["א. מקום בדיסק המשמש לשמירת קבצים.", "ב. מקום בזיכרון הפיזי המשמש להחלפת תהליכים.", "ג. מקום במחסנית (stack) המשמש להחלפת משתנים.", "ד. מקום בקרנל המשמש כזיכרון מטמון לתרגום כתובות וירטואליות.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. כפי שנלמד, אזור ההחלפה (swap space) הוא אזור בדיסק המשמש לאחסון זיכרון של תהליכים."}, "difficulty_estimation": "Easy"}, {"id": 2, "type": "MultipleChoice", "topic": ["Paging", "Virtual Memory", "Memory Management"], "content": {"text": "אחת מהבעיות של טבלאות דפדוף לינאריות היא כמות הזיכרון בו משתמשות הטבלאות.\nמה יכול לעזור להתמודד עם בעיה זו?", "code_snippet": null, "options": ["א. TLB", "ב. הגדלת גודל הדף.", "ג. זיכרון משני (HDD).", "ד. זיכרון מטמון (cache).", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. אם נגדיל את גודל הדף יהיו פחות רשומות בטבלת הדפים, ולכן כל טבלה תשתמש בפחות זיכרון."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency", "Mutexes", "Threads"], "content": {"text": "נתונה הטענה: תמיד נעדיף מנעול שלא מבצע spinning.", "code_snippet": null, "options": ["א. הטענה נכונה.", "ב. הטענה נכונה רק במחשב עם מעבד יחיד.", "ג. הטענה נכונה רק כאשר במחשב יש מספר מעבדים.", "ד. הטענה לא נכונה: תמיד נעדיף מנעול שכן מבצע spinning.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. במחשב עם מעבד יחיד ה-spinning על מנעול תפוס הוא תמיד מיותר. הטענה לא תמיד נכונה עם יותר מעבדים, לדוגמה אם הקטע הקריטי קצר מאוד אז יתכן שעדיף להמתין."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Synchronization"], "content": {"text": "להלן קוד עבור שני חוטי חישוב (threads) שירוצו בו זמנית (concurrently) במערכת עם מעבד יחיד, בה כל המשתנים משותפים לשני חוטי החישוב. נתון שהמשתנה x מאותחל ל-0.\nהקוד רלוונטי ל-2 השאלות הבאות (שאלות 4-5):\n\nמהו הערך המקסימלי עבור x בסיום ריצת שני חוטי החישוב?", "code_snippet": "Thread 1\nfor (j=1; j<=4; ++j)\nx = x + 1;\n\nThread 2\nfor (i=1; i<=6; ++i)\nx = x + 1;", "options": ["א. 5", "ב. 8", "ג. 9", "ד. 10", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. הערך המקסימלי מתקבל כאשר 2 החוטים מקדמים את המשתנה ללא הפרעות, מספר כולל של 10 פעמים."}, "difficulty_estimation": "Easy"}, {"id": 5, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Synchronization", "Atomic Operations"], "content": {"text": "מהו הערך המינימלי עבור x בסיום ריצת שני חוטי החישוב?", "code_snippet": null, "options": ["א. 1", "ב. 2", "ג. 4", "ד. 6", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. הערך המינימלי בקוד מהסוג הזה הוא תמיד 2 (הסבר מלא במבחן os23AB)."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Virtual Memory", "Paging", "Memory Management"], "content": {"text": "נתונה מערכת בה כתובת וירטואלית מכילה 32 ביטים, כתובת פיזית מכילה 40 ביטים, וגודל דף הוא 4KB. כל כניסה בטבלת הדפים תופסת 4 בתים.\nבמערכת זו נתון תהליך אשר משתמש ב-128KB של נתונים החל מכתובת 0, כך שכל גישה לכתובות גדולות או שוות ל-128K תגרום לשגיאה.\nשימו לב: נתונים אלו רלוונטיים לכל הסעיפים א'-ג'. הנתונים הכתובים בסעיפים עצמם מתווספים לנתונים אלו אך ספציפיים לאותו סעיף ואינם תקפים לשאר הסעיפים.\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "נתון שהתהליך משתמש בטבלת דפים לינארית. כמה זיכרון בבתים תתפוס טבלת הדפים של התהליך, ומהו מספר הכניסות בטבלה שהן valid?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "נתון שהתהליך משתמש בטבלת דפים היררכית, כאשר גודל כל חלק/טבלה בטבלת הדפים הוא דף. כמה רמות יהיו בטבלת הדפים, כמה זיכרון בבתים יתפסו טבלאות הדפים של התהליך (הסכום הכולל בכל רמות יחד), ומה מספר הכניסות בטבלאות שהן valid (הסכום הכולל בכל הרמות יחד?)", "code_snippet": null, "options": null}, {"id": "6.3", "text": "נתון תהליך אחר אשר משתמש בטבלת דפים היררכית כאשר גודל כל חלק/טבלה בטבלת הדפים הוא דף, ולהלן פירוט הכתובות בזיכרון בהן משתמש התהליך:\n- code segment בגודל 48KB המתחיל בכתובת 0x1000000.\n- data segment בגודל 600KB המתחיל בכתובת 0x8000000.\n- stack segment בגודל 64KB המתחיל בכתובת 0xF0000000 (וגדל לכתובות הגבוהות יותר).\nכל גישה לכתובת אחרת, שאינה בסגמנטים אלו, תגרום לשגיאה.\nתזכורת: התחילית 0x מציינת מספר בבסיס 16.\nכמה זיכרון בבתים יתפסו טבלאות הדפים של התהליך (הסכום הכולל בכל הרמות יחד), ומה מספר הכניסות בטבלאות שהן valid (הסכום הכולל בכל הרמות יחד)?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. גודל דף הוא 4KB כלומר שיש 12 ביטים להיסט, מה שמשאיר 20 ביטים ל-VPN בכתובת הוירטואלית. לכן לכל תהליך יש 2^20 דפים בזיכרון הוירטואלי.\nבטבלה הלינארית יש 2^20 רשומות שכל אחת בגודל 4 בתים, לכן סה\"כ 4MB=2^22.\nהתהליך משתמש ב-128KB זיכרון החל מכתובת 0, לכן אלו בדיוק 128/4=32 דפים, לכן 32 כניסות יהיו valid.\n\n2. כל דף בגודל 4KB וכל כניסה בטבלה היא 4 בתים, לכן יש 1024 כניסות בכל דף של הטבלה – נדרש לכך 10 ביטים. כמו בסעיף א' יש 20 ביטים ל-VPN כלומר 2 רמות לטבלת דפים היררכית (10+10).\nכמו בסעיף א' התהליך עדיין משתמש רק ב-32 דפים החל מדף 0, עם 1024 כניסות בכל דף כל 32 הכניסות עבור דפים אלו נכנסות בטבלה הראשונה, לכן גודל הטבלה הוא 2 דפים = 8KB.\nברמה העליונה משתמשים רק בכניסה אחת, ברמה התחתונה יש את המיפויים לדפים עצמם עם 32 כניסות – לכן סה\"כ 33 כניסות יהיו valid.\n\n3. כמו בסעיף הקודם טבלת הדפים ב-2 רמות.\nלכל 48K הכתובות בסגמנט ה-code יש את אותם 10 ביטים שמאליים, כלומר כולן נכנסות באותה טבלה ברמה התחתונה. בטבלה זו יהיו 48K/4K=12 רשומות valid.\nלכל 600K הכתובות בסגמנט ה-data יש את אותם 10 ביטים שמאליים ששונים מאלו של ה-code, לכן כולן באותה טבלה (נפרדת מהקודמת), יהיו בה 600K/4K=150 רשומות valid.\nלכל 64K הכתובות ב-stack גם אותם 10 ביטים שמאליים ששונים מה-code,data, לכן כולן באותה טבלה (נפרדת מ-2 הקודמות) ויהיו בה 64K/4K=16 רשומות valid.\nסה\"כ נתפוס דף אחד עבור הרמה העליונה ועוד 3 דפים עבור הרמה התחתונה – גודל הטבלה 4 דפים או 16KB.\nברמה העליונה יהיו 3 כניסות שהן valid לכל אחת מתת הטבלאות, ויחד עם הרמות התחתונות סה\"כ 181 כניסות valid."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Concurrency", "Synchronization", "Mutexes", "Condition Variables", "Atomic Operations"], "content": {"text": "בסניף בנק מקומי הוחלט לפתח ארנק דיגיטלי לצורך מחשוב העברת הכספים בין חשבונות. הארנק הדיגיטלי מחזיק את סכום הכסף של כל לקוח בסניף, ומאפשר העברת כספים בין לקוח ללקוח.\nנתון כי יש N לקוחות (N קבוע וידוע מראש), והמערך הגלובלי balance המוגדר מטה מייצג את היתרה של כל הלקוחות, כך שתא 1 במערך מכיל את היתרה (סכום הכסף) של לקוח 1.\nלקוחות בארנק הדיגיטלי אינם יכולים להיכנס למינוס, כלומר שהארנק צריך לוודא שהמאזן של כל לקוח לעולם אינו שלילי.\nהארנק הדיגיטלי תומך בפעולות הבאות:\n- int getBalance(int c)\nמחזירה את היתרה הנוכחית של לקוח c.\n- int transfer (int c1, int c2, int amount)\nמעבירה את הסכום amount מהלקוח c1 אל הלקוח c2. פעולה זו היא blocking, כלומר במידה ואין ללקוח c1 מספיק כסף בחשבון הפעולה תחסום את החוט הקורא עד שיהיה ניתן לבצע את הפעולה בהצלחה. הפעולה מחזירה את היתרה של הלקוח c1 מיד לאחר ביצוע ההעברה.\nשימו לב: מובטח כי כל הפרמטרים תקינים (מזהי לקוחות בין 0 ל-1-N, סכומים גדולים מ-0). עליכם לממש את שתי הפעולות לעיל כאשר כל פעולה צריכה להתבצע באופן אטומי. בנוסף, חוטים שונים יכולים לקרוא לפעולות במקביל ובכל זמן וכמובן שעל הפתרון להיות יעיל ככל האפשר.\nמגבלות: לצורך הפתרון ניתן להשתמש במנעולים ומשתני תנאי בלבד (כלומר, לא ניתן להשתמש בסמפורים, פעולות מעבד אטומיות, או אובייקטי סנכרון אחרים מלבד מנעולים ומשתני תנאי).\nיש לתאר בקצרה ובבירור את הפתרון ולכתוב קוד ברור.\nתיאור הפתרון:\nמשתנים גלובליים (יש לכתוב ערכי אתחול בהערה):", "code_snippet": "#define N ??\nint balance[N]; // balance for all clients\n\nint getBalance(int c) {\n}\nint transfer (int c1, int c2, int amount) {\n}"}, "sub_questions": null, "points": 25, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "#define N ??\nint balance[N]; // balance for all clients\npthread_mutex_t locks[N]; // lock for each client\n\nint getBalance(int c) {\n    return balance[c]; // no need to grab lock\n}\n\nint transfer (int c1, int c2, int amount) {\n    int res = -1;\n    // spinning, waiting for enough balance for c1\n    while (res == -1) {\n        // global ordering is needed to prevent deadlock\n        pthread_mutex_lock(&locks[MIN(c1,c2)]);\n        pthread_mutex_lock(&locks[MAX(c1,c2)]);\n\n        if (balance[c1] >= amount) {\n            balance[c1] -= amount;\n            balance[c2] += amount;\n            res = balance[c1];\n        }\n        pthread_mutex_unlock(&locks[c1]);\n        pthread_mutex_unlock(&locks[c2]);\n    }\n    return res;\n}"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Security"], "content": {"text": "במערכת קבצים VSFS המשתמשת ב-journaling כפי שנלמד (כולל metadata journaling) יש בעיה: בעדכון נתונים של בלוק DATA קיים, קריסה בתרחישים מסוימים עדיין עלולה לגרום לשיבוש מערכת הקבצים.\nלהלן רצף הפעולות על הדיסק הנדרש למחיקת קובץ מתיקייה, כאשר לקובץ יש לפחות קישור אחד נוסף (hard-link), לתיקייה יש בלוק DATA יחיד, ומספרי ה-inode של התיקייה והקובץ ידועים מראש:\n1. קריאת בלוק ה-inode המכיל את ה-inode של התיקייה\n2. קריאת בלוק ה-inode המכיל את ה-inode של הקובץ\n3. קריאת בלוק ה-DATA הראשון (והיחיד) של התיקייה\n4. כתיבת טרנזקציה ללוג עם inode + TxB התיקייה + inode קובץ, ללא TxE\n5. כתיבה לבלוק ה-DATA של התיקייה (עדכון ללא הרשומה של הקובץ)\n6. fsync\n7. כתיבת TxE לטרנזקציה\n8. fsync\n9. עדכון ה-inode של התיקייה (כתיבה לבלוק המכיל את ה-inode של התיקייה)\n10. עדכון ה-inode של הקובץ (כתיבה לבלוק המכיל אותו)", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "באיזה שלב תיתכן קריסה שתגרום לבעיה במערכת הקבצים? יש לציין את השלב 1-10, ולאחר מכן לצרף הסבר ברור ותמציתי מדוע קריסה אחרי שלב זה היא בעייתית.", "code_snippet": null, "options": null}, {"id": "8.2", "text": "הדגימו שני תרחישים של כתיבה לקובץ אשר לא גורמים להוספת בלוק DATA חדש אל הקובץ, כאשר באחד מהם תיתכן קריסה שתגרום לבעיה במערכת הקבצים ובשני לא תיתכן קריסה בשום שלב שתגרום לבעיה במערכת הקבצים.\nאין צורף לתאר את רצף הפעולות המלא לכל תרחיש, אלא רק לתאר את התרחיש והיכן המקרה הבעייתי או מדוע אף קריסה לא תגרום לבעיה.\nמבין הגישות בסעיף הקודם (שאלה 8.1), מה הגישה הראשונה אחריה נוכל להבטיח בוודאות שהפעולה תתבצע בהצלחה גם אם המערכת תקרוס? יש לנמק את התשובה.", "code_snippet": null, "options": null}, {"id": "8.3", "text": "הציעו פתרון לבעיה. הפתרון עדיין צריך לבצע metadata journaling, כלומר שה-DATA אינו נכתב ללוג אלא נכתב פעם אחת בלבד לכל הפעולה (למיקומו הסופי בדיסק), אך קריסה בכל שלב של כל פעולה לא תביא לבעיה במערכת הקבצים.\nיש לתאר את הפתרון בקצרה ובבירור, להסביר מה הוא כולל ואיזה פעולות נוספות על הדיסק הוא גורר (או עלול לגרור), ולתת הסבר תמציתי מדוע הוא מטפל בבעיה.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. אחרי שלב 5 או 6, אם נקרוס התיקייה לא תכיל את הקישור (hard-link) לקובץ אך זמן העדכון וגודל התיקייה לא השתנה ומס' הקישורים ב-inode של הקובץ לא עודכן.\n\n2. תרחיש בעייתי: שכתוב/עדכון נתונים קיימים בקובץ. אם נקרוס לאחר שכתוב הנתונים ולפני סגירת הטרנזקציה, נתוני הקובץ שונו אך ה-inode של הקובץ לא עודכן (עם זמן שינוי אחרון).\nתרחיש לא בעייתי: הוספת נתונים לקובץ (בין אם נדרש בלוק DATA חדש ובין שאינם גוררים בלוק DATA חדש). אם נקרוס לפני סגירת הטרנזקציה נתעלם מהנתונים שנוספו (כי ה-inode לא יעודכן ולכן גודל הקובץ ו/או המצביעים לא השתנו ונתעלם מהנתונים שנוספו), אם נקרוס אחרי סגירת הטרנזקציה אין בעיה.\n\n3. בכל פעם שמעדכנים נתונים בבלוק קיים לא נכתוב אל הבלוק הקיים אלא נקצה בלוק חדש ונכתוב אליו את הנתונים המעודכנים, וכחלק מהטרנזקציה נתפוס בלוק חדש ונשחרר את הקיים. עדכון כזה עלול לגרור עדכונים של בלוקים נוספים של DATA – בלוקים של מצביעים, אותם נעדכן באותו אופן."}, "difficulty_estimation": "Hard"}, {"id": 9, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתונה מערכת עם מנגנון 4-RAID, גודל chunk של בלוק אחד ו-4 דיסקים קשיחים (ממוספרים 1-4), שכל אחד מהם בעל הנתונים הבאים:\n- מהירות סיבוב: 7500 RPM\n- זמן seek ממוצע: 10ms\n- בכל רצועה (track) בדיסק יש 8 בלוקים\n- מהירות העברת המידע תוכננה כך שנוכל להעביר את המידע ברצועה אחת תוך כדי זמן סיבוב אחד בדיוק.\nמשתמש ביצע פעולת כתיבה אחת לבלוקים הלוגיים 100-102 (הבלוקים הלוגיים ממוספרים החל מ-0), ונתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nמהו הזמן הקצר ביותר בו הפעולה יכולה להתבצע?\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.", "code_snippet": null, "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "זמן הסיבוב הוא 8ms, עם 8 בלוקים ברצועה זמן הפעולה (קריאה/כתיבה) לבלוק הוא 1ms.\nנניח שדיסק ה-parity הוא דיסק 4 (זה לא משנה לתוצאה).\nבלוקים לוגיים 100-101 נמצאים באותו stripe בדיסקים פיזיים 2-3, ובלוק לוגי 102 נמצא ב-stripe הבא בדיסק פיזי 1.\nלביצוע הפעולה נדרש לקרוא בלוק אחד מכל דיסק 1-3 ואז לכתוב לאותו בלוק. בנוסף נדרש לקרוא 2 בלוקים מדיסק הזוגיות (אחד בכל stripe) ואז לכתוב לשניהם. דיסק הזוגיות הוא צוואר הבקבוק ולכן יכתיב את הביצועים.\nבמקרה האידיאלי הראש הקורא-כותב יהיה בדיוק במקום בתחילת הפעולה ולא יהיה בכלל זמן seek או המתנה לסיבוב.\nבדיסקים 1-3 לקרוא בלוק 1 לוקח 1ms, להמתין לסיבוב עד לאותו בלוק זה 7ms (דילוג על 7 הבלוקים הנותרים ברצועה שזה גם השלמת זמן הסיבוב שהוא כזכור 8ms), ואז כתיבה לאותו בלוק עוד 1ms – סה\"כ 9 מילישניות.\nבדיסק הזוגיות נדרש לקרוא 2 בלוקים רצופים ב-2ms, להמתין לסיבוב 6ms (דילוג על 6 הבלוקים הנותרים ברצועה), ואז כתיבה לאותם 2 בלוקים עוד 2ms – סה\"כ 10 מילישניות.\nמאחר שכל הדיסקים יכולים לפעול במקביל, הזמן הכולל המינימלי הוא 10ms."}, "difficulty_estimation": "Hard"}]}, {"filename": "os24AC.json", "metadata": {"course_name": "Operating Systems", "year": "2024", "semester": "Semester A", "moed": "Moed C", "exam_date": "30.04.2024", "source_file": "os24AC.pdf"}, "questions": [{"id": 1, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Concurrency"], "content": {"text": "נתונה התוכנית הבאה:", "code_snippet": "int main (int argc, char *argv[])\n{\nint N = 2;\nchar* args[] = {\"echo\", \"Done\", NULL};\npid_t pid;\n\nfor (int i = 0; i < N; ++i)\n{\nprintf (\"%d %d\\n\", getpid(), i);\nif (!fork())\nprintf (\"1: %d [%d]\\n\", getpid(), getppid());\nelse if (!fork())\nprintf (\"2: %d [%d]\\n\", getpid(), getppid());\nelse\nbreak; // exit for-loop\n}\nwait(NULL);\nwait(NULL);\nprintf (\"pid = %d\", getpid());\nexecvp(args[0], args);\nprintf(\"BYE BYE\\n\");\nreturn 0;\n}"}, "sub_questions": [{"id": "1.1", "text": "כתבו פלט אפשרי של התוכנית בהנחה שכל הקריאות ל-fork הצליחו.\nהניחו שמזהה התהליך הראשי הוא 100, וכל תהליך שנוצר מקבל מזהה עוקב (101, 102, וכן הלאה).", "code_snippet": null, "options": null}, {"id": "1.2", "text": "כמה תהליכים נוצרו במהלך ריצת התוכנית, כולל התהליך הראשי?", "code_snippet": null, "options": null}, {"id": "1.3", "text": "נניח שהערך של N אינו ידוע (אך לכל הפחות 0). כמה תהליכים נוצרו במהלך ריצת התוכנית כולל התהליך הראשי, כפונקציה של N?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1.1. 100 0\n1: 101 [100]\n101 1\n1: 102 [101]\npid = 102 Done\n2: 103 [101]\npid = 103 Done\npid = 101 Done\n2: 103 [100]\n103 1\n1: 104 [103]\npid = 104 Done\n2: 105 [103]\npid = 105 Done\npid = 103 Done\npid = 100 Done\n\n1.2. נוצרו 7 תהליכים.\nהתהליך הראשי יוצר 2 בנים, וכל אחד מהם יוצר 2 בנים.\n\n1.3. באיטרציה הראשונה התהליך הראשי יוצר 2 בנים.\nבכל איטרציה, כל התהליכים שנוצרו באיטרציה הקודמת (ורק הם) יוצרים 2 בנים כל אחד.\n1+2+4+.... = 2N+1-1"}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "Open", "topic": ["Scheduling", "Deadlocks", "Synchronization", "Semaphores"], "content": {"text": "מצב של priority inversion מתרחש כאשר אלגוריתם התזמון גורם לקיפאון (deadlock) בגלל שתהליך ממתין המתנה פעילה למשאב (busy-wait) המוחזק ע\"י תהליך אחר שלעולם אינו מתוזמן.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "2.1", "text": "באילו מאלגוריתמי התזמון הבאים אפשרי להגיע למצב של priority inversion?", "code_snippet": null, "options": ["First Come First Served (FCFS)", "overlap עם SRTF", "Round-Robin (RR)", "עם כל השיפורים Multi-Level Feedback Queue (MLFQ)"]}, {"id": "2.2", "text": "נתונים קטעי הקוד הבאים ל-3 חוטים של אותו תהליך:\nThread 1\nwhile (1) {\nsem_wait(&U);\nprintf(\"3\");\nsem_post(&T);\n}\nThread 2\nwhile (1) {\nsem_wait(&S);\nprintf(\"2\");\nsem_post(&U);\n}\nThread 3\nwhile (1) {\nsem_wait(&T);\nprintf(\"1\");\nsem_post(&S);\n}\nאין חוטים נוספים בתהליך, ו-S,T,U סמפורים. נתון שהסמפור S אותחל לערך 1 (ערך האתחול של T,U לא ידוע). האם קיימת ריצה שתוביל לקיפאון?", "code_snippet": "Thread 1\nwhile (1) {\nsem_wait(&U);\nprintf(\"3\");\nsem_post(&T);\n}\nThread 2\nwhile (1) {\nsem_wait(&S);\nprintf(\"2\");\nsem_post(&U);\n}\nThread 3\nwhile (1) {\nsem_wait(&T);\nprintf(\"1\");\nsem_post(&S);\n}", "options": ["קיימת", "לא קיימת"]}, {"id": "2.3", "text": "האם קיימים 3 ערכי אתחול עבור הסמפורים S T U כך שהפלט שיודפס למסך יהיה תמיד לפי הסדר 1 ואז 2 ואז 3 שוב (123123123...)? אם כן, יש לציין את 3 הערכים ולהסביר, אחרת יש להסביר מדוע לא.", "code_snippet": null, "options": ["קיימים", "לא קיימים"]}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "2.1. FCFS – לא אפשרי. תהליך רץ מהתחלה ועד הסוף, לא יתכן שתהליך ממתין למשאב של תהליך אחר (התהליך האחר עוד לא רץ ולכן לא מחזיק במשאב, או הסתיים ולכן שחרר את המשאב).\nSRTF – אפשרי. תהליך ארוך עלול להחזיק במשאב שתהליך קצר ממתין לו, בזמן שתהליכים קצרים אחרים כל הזמן מגיעים ולכן התהליך הארוך לא מתוזמן.\nRR – לא אפשרי. כל תהליך יקבל זמן ריצה בסופו של דבר.\nMLFQ – לא אפשרי. בגלל priority boost, כל תהליך יקבל זמן ריצה בסופו של דבר.\n\n2.2. לא. חוט 2 יכול לבצע לפחות איטרציה אחת של הלולאה, מה שמאפשר לחוט 1 לבצע לפחות איטרציה של הלולאה, מה שמאפשר לחוט 3 לבצע, וחזרה לחוט 1 וכו'.\n\n2.3. קיימים: S=0,T=1,U=0 יבטיח את הפלט הנדרש."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "Open", "topic": ["File Systems", "Memory Management", "I/O"], "content": {"text": "נתונה מערכת קבצים VSFS עם הנתונים הבאים:\n- גודל בלוק הוא 512 בתים.\n- גודל מצביע הוא 8 בתים.\n- גודל inode הוא 512 בתים.\n- בכל inode יש 10 מצביעים ישירים, מצביע עקיף אחד, מצביע עקיף כפול אחד, ומצביע עקיף משולש אחד.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "3.1", "text": "משתמש יצר קובץ חדש בגודל 50KB. לכמה בלוקים בדיסק יש לכתוב כדי להשלים את הפעולה, במקרה המינימלי?", "code_snippet": null, "options": null}, {"id": "3.2", "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה בלוקים של DATA הוא יתפוס?", "code_snippet": null, "options": null}, {"id": "3.3", "text": "סטודנט טען שעבור קריאה של 4 קבצים שונים בגודל 25KB כל אחד נדרשות פחות קריאות של בלוקים בדיסק מאשר עבור קריאה של קובץ אחד בגודל 100KB. האם הוא צודק?", "code_snippet": null, "options": ["הסטודנט צודק", "הסטודנט טועה"]}], "points": null, "solution": {"is_present_in_file": true, "correct_option": "הסטודנט טועה", "explanation": "3.1. 107.\nבכל בלוק עקיף יש 64 מצביעים.\nכתיבה ל-inode bitmap, כתיבה ל-data bitmap (כל הביטים יהיו באותו בלוק), כתיבה ל-inode (אותו בלוק עם התיקייה המכילה את הקובץ), כתיבה ל-10 בלוקים בהצבעה ישירה, כתיבה לבלוק עקיף + 64 בלוקים של DATA שמצביע אליהם, כתיבה לבלוק עקיף כפול + בלוק עקיף יחיד שהכפול מצביע אליו + 26 בלוקים של DATA שמצביע אליהם, כתיבה לבלוק DATA של התיקייה לעדכון שלו עם רשומה נוספת עבור הקובץ החדש.\n\n3.2. (10 + 1+64 + 1+64+64^2 + 1+64+64^2+64^3)*512B.\n10 מצביעים ישירים – 10 בלוקים של DATA.\nמצביע עקיף – 1 בלוק מצביעים + 64 בלוקים של DATA.\nמצביע עקיף כפול – 1+64 בלוקים של מצביעים + 64^2 בלוקים של DATA.\nמצביע עקיף משולש – 1+64+64^2 בלוקים של מצביעים + 64^3 בלוקים של DATA.\n\n3.3. הסטודנט טועה.\nלכל קובץ קטן נדרש לגשת ל-52 בלוקים: קריאת inode + 10 בלוקים של DATA מהמצביעים הישירים + בלוק עקיף + 40 בלוקים של DATA מהמצביע העקיף. סה\"כ 208 בלוקים עבור 4 הקבצים.\nעבור הקובץ הגדול נדרשות 205 גישות: קריאת inode + 10 בלוקים של DATA מהמצביעים הישירים + בלוק עקיף + 64 בלוקים של DATA מהמצביע העקיף + בלוק עקיף כפול + 2 בלוקים של מצביעים עקיפים מהבלוק העקיף הכפול + 64 בלוקים של DATA מהבלוק הראשון + 62 בלוקים של DATA מהבלוק השני."}, "difficulty_estimation": "Hard"}, {"id": 4, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems", "Security"], "content": {"text": "נתונה מערכת עם מנגנון 5-RAID, גודל chunk של בלוק אחד ו-5 דיסקים קשיחים (ממוספרים 1-5), כאשר בלוק ה-parity ב-stripe הראשון נמצא בדיסק 5, השני בדיסק 4, וכן הלאה באופן מעגלי.\nלכל אחד מהדיסקים הקשיחים יש את הנתונים הזהים הבאים:\nמהירות סיבוב: 6000 RPM\nזמן seek ממוצע: 15ms\nבכל רצועה (track) בדיסק יש 5 בלוקים.\nמהירות העברת המידע תוכננה כך שנוכל להעביר את המידע ברצועה אחת תוך כדי זמן סיבוב אחד בדיוק.\nהבלוקים ממוספרים החל מ-0, כלומר מספר הבלוק הלוגי הראשון במערך (RAID) הוא 0 ומספר הבלוק הפיזי הראשון בכל דיסק הוא 0. לפי כך, ה-stripe הראשון מכיל את הבלוקים הלוגיים 0-3.\nנתון שדיסק מספר 2 התקלקל ולאחר מכן משתמש ביצע פעולת קריאה לבלוקים הלוגיים 20-22, ונתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nהפעולה בוצעה בהצלחה ע\"י שימוש בשאר הדיסקים בהתאם לאופן הפעולה של 5-RAID.\nמהו הזמן הקצר ביותר בו הפעולה יכולה להתבצע? יש להזניח את זמן ביצוע החישובים במידה ונדרשים חישובים כלשהם.\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.", "code_snippet": null, "options": null}, "sub_questions": null, "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "זמן הסיבוב הוא 10ms.\nבכל רצועה יש 5 בלוקים לכן הזמן לקריאת בלוק בודד הוא 2ms.\nבלוקים לוגיים 20-22 נמצאים באותו stripe בדיסקים שונים. בלוק 22 נמצא בדיסק 2 שהתקלקל, כדי לקרוא אותו נצטרך לקרוא את כל שאר הנתונים ב-stripe ולבצע XOR – כלומר נצטרך את בלוקים 20,21,23 ואת ה-parity.\nבזמן הקצר ביותר, בכל הדיסקים הראש הקורא-כותב נמצא כבר במיקום ולא תהיה המתנה לסיבוב, נקרא את כל הבלוקים במקביל – זמן הפעולה יהיה זמן הקריאה של בלוק אחד: 2ms."}, "difficulty_estimation": "Hard"}]}, {"filename": "os24BA.json", "metadata": {"course_name": "Operating Systems", "year": "2024", "semester": "Semester B", "moed": "Moed A", "exam_date": "07.07.2024", "source_file": "os24BA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Deadlocks", "Synchronization"], "content": {"text": "כיצד ניתן למנוע קיפאון במערכת המשתמשת במנעולים להגנה על גישה למשאבים שונים?", "code_snippet": null, "options": ["תמיד לתפוס את המנעולים בסדר קבוע.", "כאשר נדרש לתפוס מספר מנעולים, נתפוס אותם \"בבת אחת\" (נוודא שחוט אחר לא מנסה לתפוס מנעולים במקביל אלינו).", "במידה ולא הצלחנו לתפוס מנעול, נשחרר את כל המנעולים שאנו מחזיקים וננסה מחדש.", "להימנע לחלוטין משימוש במנעולים ומניעה הדדית.", "כל התשובות נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. כל סעיף מייצג את אחת הטכניקות שנלמדו למניעת קיפאון ולכן כל התשובות נכונות."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling", "Processes"], "content": {"text": "נתונה מערכת הפעלה ללא תמיכה בפסיקת שעון. איזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["לא ניתן לטפל בפסיקות.", "לא ניתן לבצע context switch.", "תהליכים לעולם לא יהיו במצב READY", "תהליכים לא יכולים לבצע קריאות מערכת.", "כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. פסיקת שעון נועדה כדי לעצור תהליכים בכל פרק זמן קבוע ולהחזיר את השליטה לקרנל. ללא פסיקת שעון מערכת ההפעלה תמשיך לעבוד כרגיל מלבד מנגנון זה לא נוכל לוודא שהשליטה חוזרת בוודאות לקרנל (וההשלכות של כך)."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["Paging", "Virtual Memory", "Memory Management"], "content": {"text": "במערכת עם טבלת דפים היררכית, תהליך ניגש לדף שהטבלה המכילה את המיפוי שלו לא הוקצתה (תת-הטבלה המתאימה ברמה התחתונה של טבלת הדפים לא קיימת). איזו טענה נכונה?", "code_snippet": null, "options": ["התרגום יתבצע באופן תקין אך יתרחש page fault", "התרגום יתבצע באופן תקין ולא יתרחש page fault.", "לא ניתן לבצע את התרגום הגישה תגרום לשגיאת זיכרון בתהליך.", "לא ניתן לבצע את התרגום הגישה תגרום לשגיאה בקרנל (תקיעת/קריסת המחשב).", "כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. אם לא הוקצתה הטבלה המתאימה, זה אומר שכל הרשומות בה הן 0=V, כלומר מייצגות זיכרון שאינו בשימוש ע\"י התהליך וכל גישה לכתובת כזו תגרום לשגיאה בתהליך."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתון קטע הקוד הבא, של תוכנית בשם myexec:\n\nPID: 300\nהריצו את קטע הקוד, ושורת הפלט הראשונה שהתקבלה היא:\nניתן להניח שכל קריאות המערכת הצליחו, לא נוצרו תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.\nאיזו טענה נכונה?", "code_snippet": "int main()\n{\nchar* args[] = {\"myexec\", NULL};\nprintf(\"PID: %d\\n\", getpid());\nexecvp(args[0], args);\n}", "options": ["לא יהיה פלט נוסף לתוכנית.", "המשך הפלט יהיה \"300 :PID\" אינסוף פעמים (עד לעצירת התוכנית).", "המשך הפלט יהיה \"301 :PID\", לאחר מכן \"302 :PID\", וכן הלאה (עד לעצירת התוכנית).", "התוכנית תקרוס בשלב מסוים בגלל יצירה של יותר מדי תהליכים.", "כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. הקריאה ל-execvp מריצה שוב את ה-main באותו תהליך (קריאת execvp אינה יוצרת תהליך חדש), ולכן הקוד מייצג מעין לולאה אינסופית."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "נתונה מערכת קבצים VSFS המשתמשת ב-journaling. איזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["קובץ לא יכול להכיל יותר נתונים מהמקום הפנוי ב-journal.", "קריאה מקובץ באופן סדרתי מתורגמת לגישה סדרתית לדיסק.", "שימוש ב-metadata journaling תמיד יהיה מהיר יותר מאשר journaling רגיל.", "אם מובטח שסדר הכתיבות בדיסק הוא לפי הסדר בו הן נשלחו, לא נצטרך fsync.", "כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. השימוש ב-fsync הוא כדי להבטיח שאנו לא מבצעים כתיבה כלשהי לפני שבוצעו הכתיבות שקדמו לה. אם מובטח שהכתיבות מתבצעות לפי הסדר, אין צורך ב-fsync."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Paging", "Virtual Memory", "Memory Management", "Page Replacement"], "content": {"text": "נתונה מערכת עם גודל דף של 1KB, בה ידוע שהזיכרון הוירטואלי גדול פי 2 מהזיכרון הפיזי.\nכל תהליך במערכת משתמש בטבלת דפים לינארית, כאשר כל כניסה בטבלת הדפים היא בגודל 16 ביטים.\nנתון תהליך במערכת אשר אלו 10 הרשומות PTE הראשונות בטבלת הדפים שלו:\n\nכל שורה בטבלה מייצגת PTE, כאשר נתון: P=Present, V=Valid, A=Access (Reference), D=Dirty.\nיש לפרט ולנמק את כל החישובים.", "code_snippet": "PFN VPAD ריפוד\n00000 1 0 0 0 0000000\n00000 0 0 0 0 0000000\n11101 1 1 1 0000000\n00000 0 0 0 0 0000000\n00010 1 1 1 1 0000000\n00000 1 0 0 0 0000000\n01011 1 1 1 0000000\n00000 1 1 0 0 0000000\n11111 1 1 0 0 0000000\n00000 1 1 0 0 0000000\n... רשומות נוספות ...", "options": null}, "sub_questions": [{"id": "6.1", "text": "כמה כניסות יש בטבלת הדפים המלאה? מה גודל הטבלה המלאה בבתים?\nמספר כניסות:\nגודל הטבלה:\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "התהליך הנתון ניגש לכתובת 0x1960 (הכתובת 1960 בבסיס 16.\nהאם תתרחש פסיקת דף? אם כן, יש להסביר מדוע, אחרת יש לפרט את הכתובת הפיזית אליה ניגש.\nכתובת פיזית:\nנימוק:\nתתרחש פסיקת דף", "code_snippet": null, "options": null}, {"id": "6.3", "text": "נתון שעבור כל הדפים שאינם מופיעים בטבלה מתקיים 0=V=1,P, והתהליך ניגש לדפים הבאים (משמאל לימין, כלומר קודם 2 ואז 7 וכן הלאלה):\n2, 7, 8, 4, 15, 16, 17, 2, 4\nכמה page faults יתרחשו במידה ואלגוריתם החלפת הדפים הוא LRU?\nיש להניח שכל page fault מפנה רק את המסגרות בשימוש ע\"י התהליך הנתון, וטוען רק אליהן.\npage faults מספר\nנימוק:\nלא ניתן לדעת", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "שאלה 6\n1. נתון גודל דף 1KB לכן ההיסט הוא 10 ביטים, לפי הטבלה ה-PFN הוא ביטים, כלומר שהזיכרון הפיזי מורכב מ-15 ביטים – 32KB. לפי הנתון שהזיכרון הוירטואלי כפול מהפיזי נקבל 64KB.\n2. ההיסט הוא 10 ביטים (מתוך 16) לכן נפריד למספר דף (6 ביטים) והיסט. מספר הדף שמתקבל הוא 110 בבינארי כלומר דף 6. לפי הטבלה דף 6 קיים בזיכרון במסגרת 11, לכן נתרגם מספר דף למספר מסגרת (ההיסט נשאר זהה) ונקבל את הכתובת הפיזית 0101100000 01011 כתובת פיזית 2D60.\n3. ב-4 הגישות הראשונות ניגשים לדפים עבורם 1=P לכן אין page fault\n3 הגישות הבאות הן לדפים 15,16,17, שלא בטבלה ולפי הנתון בשאלה 0=P עבורם לכן 3 הגישות יגרמו page fault. בהתחלה היו 6 מסגרות בשימוש, בעקבות 3 הגישות האלו יפונו 3 מהן שהן המסגרות המכילות את 2 הדפים שלא ניגשנו אליהם עדיין והמסגרת המכילה את דף 2 (אלו הגישות הכי רחוקות בעבר לפי LRU).\nבגישה הנוסף לדף 2 נקבל page fault נוסף ונפנה את המסגרת שתופס דף 7. הגישה האחרונה לדף 4 לא תגרום page fault כי הדף עדיין בזיכרון.\nסה\"כ page faults 4"}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Concurrency", "Atomic Operations", "Producer-Consumer"], "content": {"text": "נתונה מערכת המשתמשת בפתרון של בעיית יצרן-צרכן. במערכת מוגדר טיפוס מיוחד Item ובנוסף מוגדרים 3 סמפורים:\nmutex, full, empty. הקבוע N מגדיר את כמות המדפים במחסן.\nכמו-כן נתונות הפונקציות הבאות:\nItem produce_item() – מייצרת מוצר חדש, ובטוחה לשימוש במקביל.\nvoid consume_item(Item) – צורכת מוצר קיים, ובטוחה לשימוש במקביל (על מוצרים שונים). אסור לקרוא לפונקציה זו יותר מפעם אחת לאותו מוצר.\nvoid add_item(Item) – מקבלת מוצר (שאינו קיים במחסן) ומוסיפה אותו אל המחסן. פונקציה זו אינה בטוחה לשימוש במקביל (כלומר, אסור לקרוא לה בו-זמנית מחוטים שונים או עם פונקציות אחרות הניגשות למחסן).\nItem del_item() – מוציאה מוצר אחד מהמחסן ומחזירה אותו. פונקציה זו אינה בטוחה לשימוש במקביל.\nשימו לב: פונקציות אלו נתונות ויש להשתמש בהן (אין צורך לממש אותן).\nיש לתאר בקצרה ובבירור כל פתרון ולכתוב קוד ברור.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "7.1", "text": "ממשו את הפתרון של בעיית יצרן-צרכן כפי שנלמד בכיתה, עם שימוש ב-3 הסמפורים שהוגדרו בלבד (ללא פעולות אטומיות או אובייקטי סנכרון אחרים):\nvoid produce()\nvoid consume()\nמייצרת מוצר יחיד ומוסיפה אותו אל המחסן.\nמוציאה מוצר יחיד מהמחסן וצורכת אותו.\nיש לציין גם את ערכי האתחול של 3 הסמפורים.\nערכי אתחול:\nempty=__\nfull=__\nmutex=__", "code_snippet": "void produce() {\n\n}\nvoid consume() {\n\n}", "options": null}, {"id": "7.2", "text": "במערכת הנ\"ל עלתה דרישה למימוש פעולה חדשה אשר מייצרת ומוסיפה אל המחסן כמה מוצרים בבת אחת (באופן אטומי, כלומר כולם מתווספים בבת אחת). להלן הקוד שנכתב למימוש הפעולה:\n\nשימו לב: עבור הארגומנט א מובטח שמתקיים x >= N.\nהקוד המתואר לפעולה produce_several אינו תקין. תארו מה הבעיה וכיצד היא יכולה להתרחש.\nהבעיה:\nנימוק:", "code_snippet": "1 void produce_several(int x) {\n2 Item arr[x]; // assume this is allowed\n3 for (int i = 0; i < x; ++i)\n4 arr[i] = produce_item();\n5 for (int i = 0; i < x; ++i)\n6 sem_wait(&empty);\n7 sem_wait(&mutex);\n8 for (int i = 0; i < x; ++i)\n9 add_item(arr[i]);\n10 sem_post(&mutex);\n11 for (int i = 0; i < x; ++i)\n12 sem_post(&full);\n13 }", "options": null}, {"id": "7.3", "text": "הקריאה sem_trywait מקבלת כארגומנט סמפור ומנסה להוריד את ערכו ב-1. אם ערך הסמפור גדול מ-0, הקריאה מורידה את ערכו ב-1 באופן אטומי ומחזירה 0, אחרת הקריאה חוזרת מיד ללא המתנה ומחזירה 1- (בניגוד ל-sem_wait אשר ממתינה עד אשר ניתן להוריד את ערך הסמפור).\nתקנו את הפעולה produce_several כך שתעבוד באופן תקין.\nיש לשנות את שורות 5-6 בלבד. ניתן להיעזר בקריאה sem_trywait, אך ללא פעולות אטומיות או אובייקטי סנכרון נוספים.\nתיאור הפתרון:\n(במקום שורות 5-6)", "code_snippet": "void produce_several(int x) {\n\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "שאלה 7\n.1\nvoid produce() {\nItem item = produce_item();\nsem_wait(&empty);\nsem_wait(&mutex);\nadd_item(item);\nsem_post(&mutex);\nsem_post(&full);\n}\nvoid consume() {\nsem_wait(&full);\nsem_wait(&mutex);\nItem item = del_item();\nsem_post(&mutex);\nsem_post(&full);\nconsume_item(item);\n}\n(Initial values: empty = N, full = 0, mutex = 1)\n2. הבעיה: קיפאון.\nאם יש מקום אחד פנוי במחסן וקוראים לפעולה עם 2=x אז הפעולה חסומה, ופעולת produce אחרת גם תהיה חסומה מאחר ש-produce_several כבר הקצתה לעצמה את המקום הפנוי היחיד במחסן (בלי להשלים את הביצוע).\n.3\nvoid produce_several (int x) {\nItem arr[x]; // assume this is allowed\nfor (int i = 0; i < x; ++i)\narr[i] = produce_item();\n// for livelock: sem_wait(&mutex);\nfor (int i = 0; i < x; ++i)\nif (sem_trywait(&empty)) { // if failed\nfor (int k = 0; k < i; ++k)\nsem_post(&empty);\ni=-1;\n// for livelock: sem_post(&mutex);\n// for livelock: sem_wait(&mutex);\n}\n// for livelock: sem_post(&mutex);\nsem_wait(&mutex);\nfor (int i = 0; i < x; ++i)\nadd_item(arr[i]);\nsem_post(&mutex);\nfor (int i = 0; i < x; ++i)\nsem_post(&full);\n}"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתון דיסק קשיח עם הנתונים הבאים:\nגודל סקטור: 512B.\nגודל בלוק: 8 סקטורים.\n8 משטחים (4 platters דו-צדדיים).\nצפיפות הסקטורים בכל רצועה היא בהתאם ל-2 אזורים: A, B. בכל אזור יש 200 רצועות.\nבאזור A יש 1024 בלוקים לרצועה, באזור B יש 256 בלוקים לרצועה.\nשימו לב: נתונים אלו רלוונטיים לכל סעיפי השאלה. הנתונים הכתובים בסעיפים עצמם מתווספים לנתונים אלו אך ספציפיים לאותו סעיף ואינם תקפים לשאר הסעיפים.\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "מה שטח האחסון הכולל בדיסק (כמה בתים של נתונים ניתן לאחסן בדיסק כולו)?\nשטח אחסון:\nנימוק:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "משתמש הריץ מספר בדיקות על הדיסק לבדיקת קצב ההעברה של הדיסק:\nפעולות קריאה של 2MB רצופים מתבצעות בזמן ממוצע של 50ms.\nפעולות קריאה של 1MB רצופים מתבצעות בזמן ממוצע של 40ms.\nמה קצב ההעברה המקסימלי (transfer rate) של הדיסק?\nקצב העברה: MB/s\nנימוק:", "code_snippet": null, "options": null}, {"id": "8.3", "text": "נניח שנוספו הנתונים הבאים על הדיסק הקשיח:\nמהירות סיבוב:6,000RPM\nזמן ה-seek הממוצע הוא 16ms, ובין שתי רצועות סמוכות הוא 1ms.\nנתון שיפור track skew: בקריאת סקטורים עוקבים ברצועות סמוכות אין המתנה לסיבוב.\nמהירות העברת המידע בדיסק (transfer rate) תוכננה כך שנוכל להעביר את המידע ברצועה אחת ב-A תוך כדי זמן סיבוב אחד בדיוק.\nמשתמש ביצע פעולה המתורגמת לקריאה של 50 רצועות שלמות ורצופות באזור B. מה קצב ההעברה בפועל?\nקצב בפועל: MB/s\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "שאלה 8\n1. באזור A – 1024 בלוקים כפול 200 רצועות כפול 8 משטחים כפול 4KB לבלוק.\nבאזורB – 256 בלוקים כפול 200 רצועות כפול 8 משטחים כפול 4KB לבלוק.\nסה\"כ נקבל: 8000MB = (1024+256)*200*8*4096 /1024/1024.\n2. נסתכל על ההפרש בין הפעולות, ונגלה כי קצב ההעברה המקסימלי של הדיסק הוא 1MB ב-10ms.\nנמיר לשניות ונקבל קצב העברה של 100MB/s\n3. זמן הסיבוב הוא 10ms כלומר שזמן ההמתנה לסיבוב הוא 5ms.\nלחישוב קצב ההעברה של הדיסק: ברצועה אחת של A יש 4MB = 1024*4KB של נתונים. כלומר שקצב ההעברה הוא 4MB בסיבוב (10ms), אחרי המרה לשניות נקבל קצב העברה מקסימלי של MB/s 400.\nברצועה אחת של B יש 1MB = 256*4KB של נתונים, כלומר שהפעולה הנדרשת היא 50MB, וזמן ההעברה שלה הוא שמינית שניה (בשנייה מעבירים 400MB), כלומר 125ms, לזה נדרש להוסיף את זמני המיקום השונים.\nזמן ה-seek הוא 16ms אבל צריך לעבור בין 49 רצועות נוספות עם 1ms לכל מעבר – סה\"כ 65ms.\nהזמן הכולל של הפעולה: seek 65ms + wait 5ms + transfer 125ms = 195ms.\nכלומר, לוקח 195ms להעביר 50MB, נעביר ליחידות המתאימות ונקבל קצב בפועל של 256.4MB/s\nיש 2 דרכים נוספות לחשב את הזמנים הנדרשים בשאלה:\nΟ אם הרצועות שקוראים באזור B מתפזרות בין המשטחים השונים, נצטרך לעבור בין רצועות רק 6 פעמים במקום 49 ולכן זמן ה-seek הכולל יהיה 22ms.\nΟ בשאלה נתון קצב ההעברה של הדיסק כולו לפי חישוב באזור A. מאחר שיש באזור B פחות נתונים ניתן לדייק יותר ולחשב קצב ההעברה לפי זמן הסיבוב באזור B (כלומר: העברה של 1MB ב-10ms, נקבל קצב העברה מקסימלי באזור B של 100MB/s במקום 400, ולכן זמן ההעברה יהיה 500ms במקום 125ms)."}, "difficulty_estimation": "Hard"}, {"id": 9, "type": "Open", "topic": ["File Systems", "I/O", "Security"], "content": {"text": "נתונה מערכת עם מנגנון 10-RAID עם 3 עותקים (כלומר – 1-RAID עם mirroring level של 3) בו זמינים 9 דיסקים קשיחים (ממוספרים 1-9), שלכל אחד מהם נפח (שטח אחסון) של 8TB.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "9.1", "text": "מה שטח האסון הכולל הזמין למשתמש?\nשטח אחסון:\nנימוק:", "code_snippet": null, "options": null}, {"id": "9.2", "text": "מה המספר המקסימלי של דיסקים שיכולים להתקלקל כך שלא נאבד שום מידע?\nמספר מקסימלי:\nנימוק:", "code_snippet": null, "options": null}, {"id": "9.3", "text": "מה המספר המינימלי של דיסקים שנדרש שיתקלקלו כך שנאבד שום מידע?\nמספר מינימלי:\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "שאלה 9\n1. זמינים 9 דיסקים של 8TB כל אחד, אך כל נתון משוכפל 3 פעמים –\n9*8TB/3 = 24TB\n2. במערך יש 3 קבוצות 0-RAID, בכל אחת יש 3 דיסקים משוכפלים (1-RAID).\nאם יתקלקלו 2 דיסקים מכל קבוצה לא נאבד מידע, אך בדיסק השביעי בהכרח נאבד מידע, כלומר מקסימום 6 דיסקים.\n3. רק כשנאבד את כל הדיסקים מאותה קבוצת מידע נאבד מידע, כלומר מינימום 3 דיסקים."}, "difficulty_estimation": "Medium"}]}, {"filename": "os24BB.json", "metadata": {"course_name": "Operating Systems", "year": "2024", "semester": "Semester B", "moed": "Moed B", "exam_date": "30.07.2024", "source_file": "os24BB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["I/O", "Disk Scheduling"], "content": {"text": "מה תפקידו של ה-servo burst?", "code_snippet": null, "options": ["א. לתקן שגיאות מיקום של הראש הקורא-כותב.", "ב. לקשר בין קובץ לבין מיקום ה-DATA שלו בדיסק.", "ג. לפרט את מיקומי האזורים השונים של מערכת הקבצים.", "ד. ליידע באיזה משטח (surface) נמצא כרגע הראש הקורא-כותב.", "ה. לאפשר לראש הקורא-כותב לדעת את כמות הסקטורים ברצועה."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א' ה-servo burst הוא רצף נתונים מיוחד בדיסק שעוזר לראש הקורא-כותב לוודא את המיקום שלו ולתקן שגיאות מיקום שהצטברו כתוצאה מהתנועה."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["File Systems", "Memory Management"], "content": {"text": "נתונה מערכת קבצים VSFS המשתמשת ב-free list למציאת שטח פנוי. איזו טענה נכונה לגבי מערכת קבצים זו, בהשוואה לשימוש ב-bitmap?", "code_snippet": null, "options": ["א. ניתן לנצל יותר שטח בדיסק.", "ב. מציאת שטח זיכרון פנוי רצוף תהיה קלה יותר.", "ג. נוכל להשתמש באותו בלוק DATA עבור קבצים שונים.", "ד. נוכל לנצל פחות זיכרון בכל בלוק DATA בשימוש, בגלל הצורך לשמור מצביע לבלוק הבא.", "ה. כל התשובות נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. השימוש ב-free list אומר שלא נדרש שטח ייעודי בדיסק ולכן ניתן לנצל יותר שטח בדיסק במקום ה-bitmap. השימוש במצביעים בתוך הבלוקים מבוצע רק בבלוקים שאינם בשימוש – ולכן לא מבזבז נפח כלל."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["Concurrency", "Synchronization", "Threads", "Processes"], "content": {"text": "מה זה מרוץ / מצב מרוץ (race condition)?", "code_snippet": null, "options": ["א. קוד שרץ במקביל בחוטים שונים.", "ב. קוד שנכונות התוצאה שלו תלויה במתזמן.", "ג. קוד בו מספר חוטים ניגשים לאותו משאב משותף.", "ד. קוד קריטי שמחייב שימוש במנעול עבור מניעה הדדית.", "ה. כל התשובות נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. מרוץ הוא קטע קוד אשר נכונות התוצאה שלו תלויה בתזמון החוטים/תהליכים."}, "difficulty_estimation": "Easy"}, {"id": 4, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "IPC"], "content": {"text": "נתון קטע הקוד הבא, של תוכנית בשם execme:\nהריצו את קטע הקוד, והתהליך שנוצר קיבל את מזהה התהליך 300.\nניתן להניח שכל קריאות המערכת הצליחו, לא נוצרו תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.\nאיזו טענה בהכרח נכונה?", "code_snippet": "int main()\n{\nchar* args[] = {\"execme\", NULL};\nif (!fork()) {\nexecvp(args[0], args);\nprintf(\"PID: %d\\n\", getpid());\n}\n}", "options": ["א. לא יהיה פלט לתוכנית.", "ב. הפלט יהיה \"300 :PID\" אינסוף פעמים (עד לעצירת התוכנית).", "ג. הפלט יהיה \"301 :PID\", לאחר מכן \"302 :PID\", וכן הלאה (עד לעצירת התוכנית).", "ד. התוכנית תקרוס בשלב מסוים בגלל יצירה של יותר מדי תהליכים.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. תוכנית זו קוראת לעצמה במעין לולאה אינסופית, כך שבכל פעם נוצר תהליך בן שקורא לתוכנית מהתחלה ותהליך האב מסיים. קריאת execvp לא חוזרת ולכן התוכנית תמשיך לרוץ אך לא תדפיס אף פלט."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Threads", "Concurrency", "Memory Management", "Atomic Operations"], "content": {"text": "נתון תהליך מרובה חוטים אשר משתמש במשתנה משותף. איזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["א. כל כתיבה למשתנה תגרור הודעה לגביו ב-bus.", "ב. לכל מעבד תמיד יהיה עותק משלו של המשתנה (ב-cache של המעבד).", "ג. בכל רגע נתון יהיה רק עותק אחד של המשתנה (ב-cache של אחד המעבדים).", "ד. אם הגישה למשתנה היא לקריאה בלבד, לעולם לא תעבור הודעה לגביו ב-bus.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. כאשר ניגשים למשתנה משותף, תמיד יתכן שתעבור לגביו הודעה ב-bus (אפילו אם הגישה רק לקריאה – כדי לקבל את ערכו ולהכניס ל-cache). כתיבה למשתנה לא תמיד גוררת הודעה ב-bus, אלא רק אם נדרשת לנו גישה אקסקלוסיבית אל המשתנה (הודעת invalidate). משתנה משותף יכול להיות ב-cache של כל מעבד (או אף מעבד)."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה מערכת בה כל תהליך משתמש בטבלת דפים היררכית עם 3 רמות, כאשר לכל טבלה מוקצה מסגרת (גודל כל חלק/טבלה בטבלת הדפים הוא דף) וכל כניסה בטבלת הדפים היא בגודל 16 ביטים.\nנתון תהליך אשר זה החלק הראשון ברמה התחתונה של טבלת הדפים שלו (זו תת-הטבלה PT0 המלאה, המכילה את המיפויים עבור דפים 0 והלאה):\nPFN\nVPAD\nריפוד\n00000000 0\n000\n0000\n00100010 1\n000\n0000\n00011101 1\n1\n11\n0000\n000000000\n000\n0000\n00000010 1\n1\n11\n0000\n00000000 1 0\n00\n0000\n00001011 1\n1\n11\n0000\n00000000 1\n1\n00\n0000\n00011111 1\n1\n00\n0000\n00000000 1\n1\n00\n0000\n11010110 1 0\n00\n0000\n01100110 1\n1\n11\n0000\n01111111 1\n1\n1\n1\n0000\n11100000 1\n1\n11\n0000\n00000000 0\n000\n0000\n00001111 1\n1\n10 0000\n.P=Present, V=Valid, A=Access (Reference)D=Dirty :כאשר נתון ,PTE כל שורה בטבלה מייצגת\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "מה גודל הזיכרון הפיזי המקסימלי במערכת?\nזיכרון פיזי:\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "מה גודל הזיכרון הוירטואלי של תהליך?\nזיכרון וירטואלי:\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.3", "text": "מלבד הנתון בטבלה הנ\"ל, ידוע שהתהליך משתמש ב-15 דפים נוספים כאשר 3 מהם רצופים בזיכרון הוירטואלי של התהליך (עבור כולם: 0=P).\nכמה זיכרון פיזי תתפוס טבלת הדפים כולה של התהליך (הסכום הכולל בכל הרמות יחד) במקרה המינימלי ובמקרה המקסימלי, ומה מספר הכניסות שהן valid (הסכום הכולל בכל הרמות יחד) בכל אחד מהמקרים? יש לכלול בתשובות גם את החלק הטבלה הנתון בשאלה.\nגודל מינימלי:\nנימוק:\nמספר כניסות valid:\nגודל מקסימלי:\nנימוק:\nמספר כניסות valid:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. הטבלה היא בגודל דף – יש בה 16 רשומות של 16 ביטים, כלומר גודל דף הוא 32B.\nה-PFN הוא 8 ביטים לפי הטבלה כלומר שיש 256 מסגרות בזיכרון הפיזי, כל אחת בגודל 32B לכן גודל הזיכרון פיזי הוא 8KB.\n2. ידוע שיש 3 רמות ולפי הטבלה הנתונה יש 16 רשומות בכל טבלה (בכל רמה).\nטבלה אחת ברמה העליונה, 16 טבלאות ברמה האמצעית, 16^2 טבלאות ברמה התחתונה.\nבכל טבלה 16 רשומות לכן לתהליך יש סה\"כ 16^3 דפים בזיכרון הוירטואלי, גודל דף 32B ולכן גודל הזיכרון הוירטואלי הוא 128KB\n3. במקרה המינימלי כל 15 הדפים הנוספים נמצאים באותה טבלה ברמה התחתונה, כלומר חלק אחד של הטבלה עם 15 רשומות שהן valid.\nטבלה זו שונה מהטבלה הנתונה אבל ההצבעה אליה (ברמה האמצעית) יכולה להיות באותה טבלה.\nכלומר: טבלה אחת ברמה העליונה (עם רשומה אחת valid), טבלה אחת ברמה האמצעית (עם 2 רשומות valid),\n2 טבלאות ברמה התחתונה (עם 13 + 15 דפים בשימוש – רשומות valid).\nסה\"כ גודל הטבלה 4 מסגרות (128B) וכמות valid כוללת: 31 רשומות.\nבמקרה המקסימלי נרצה לשים כל דף נוסף בתת-טבלה נפרדת – ברמה התחתונה וגם האמצעית, אבל 3 הדפים הרצופים יכולים להיות רק ב-2 טבלאות נפרדות ולא 3: בסוף של טבלה אחת והתחלה של הבאה. כלומר 15 הדפים הנוספים יהיו ב-14 חלקים נפרדים.\nטבלה אחת ברמה העליונה (15 רשומות valid) + 15 טבלאות ברמה האמצעית (רשומה אחת valid בכל אחת) +\n15 טבלאות ברמה התחתונה (הנתונה עם 13 רשומות valid + 15 הדפים הנוספים).\nסה\"כ גודל הטבלה 31 מסגרות (992B) וכמות valid כוללת: 58 רשומות."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Concurrency", "Deadlocks", "Atomic Operations"], "content": {"text": "נתונה מערכת המשתמשת בפתרון של מנעול קוראים-כותבים.\n.numReaders, numWriters :int במערכת מוגדרים 2 משתנים משותפים מטיפוס\n.readlock, writelock :בנוסף מוגדרים 2 סמפורים\nהמשתנים המשותפים מאותחלים ל-0 והסמפורים מאותחלים ל-1.\nלהלן המימוש של מנעול קוראים-כותבים כפי שנלמד (עם שימוש בסמפורים בינאריים במקום מנעולים):\nיש לתאר בקצרה ובבירור כל פתרון ולכתוב קוד ברור.", "code_snippet": "void acquire_writelock() {\nsem_wait(&writelock);\n}\nvoid release_writelock() {\nsem_post(&writelock);\n}\nvoid acquire_readlock() {\nsem_wait(&readlock);\nif (++numReaders == 1)\nsem_wait(&writelock);\nsem_post(&readlock);\n}\nvoid release_readlock() {\nsem_wait(&readlock);\nif (--numReaders == 0)\nsem_post(&writelock);\nsem_post(&readlock);\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "במימוש הנלמד של מנעול קוראים-כותבים יש עדיפות לקוראים שגורמת לבעיה של הרעבת כותבים: חוט המנסה לתפוס את המנעול לכתיבה עלול להיות חסום לזמן לא מוגבל בזמן שחוטים אחרים תופסים ומשחררים את המנעול בהצלחה.\nתארו ריצה ברורה (עם מס' חוטים כרצונכם) המדגימה את הבעיה.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "במערכת הנ\"ל עלתה דרישה לתקן את המימוש כך שתינתן עדיפות לכותבים: אם חוט מעוניין לתפוס את המנעול לכתיבה, חוטים המעוניינים לתפוס את המנעול לקריאה לא יוכלו לעקוף אותו. כלומר, חוט המנסה לתפוס את המנעול לקריאה לא יצליח לתפוס אותו כל עוד קיים חוט המנסה לתפוס את המנעול לכתיבה.\nלהלן הקוד שנכתב למימוש מנעול קוראים-כותבים עם עדיפות לכותבים:\nהקוד המתואר אינו תקין. תארו מה הבעיה וכיצד היא יכולה להתרחש.\nהבעיה:\nנימוק:", "code_snippet": "void acquire_writelock() {\nsem_wait(&readlock);\n++numWriters;\nsem_post(&readlock);\nsem_wait(&writelock);\n}\nvoid release_writelock() {\nsem_post(&writelock);\nsem_wait(&readlock);\n--numWriters;\nsem_post(&readlock);\n}\nvoid acquire_readlock() {\nsem_wait(&readlock);\nwhile (numWriters > 0);\nif (++numReaders == 1)\nsem_wait(&writelock);\nsem_post(&readlock);\n}\nvoid release_readlock() {\nsem_wait(&readlock);\nif (--numReaders == 0)\nsem_post(&writelock);\nsem_post(&readlock);\n}", "options": null}, {"id": "7.3", "text": "תקנו את מימוש המנעול כך שיעבוד באופן תקין ותינתן עדיפות לכותבים.\nניתן להיעזר בפעולה האטומית fetch_and_add, אך ללא פעולות אטומיות או אובייקטי סנכרון נוספים. אין להגדיר משתנים משותפים/גלובליים נוספים, מכל סוג.\nתיאור הפתרון:", "code_snippet": "void acquire_writelock() {\n\n}\nvoid release_writelock() {\n\n}\nvoid acquire_readlock() {\n\n}\nvoid release_readlock() {\n\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. חוט 1: קורא ותופס את המנעול בהצלחה (מוריד את writelock ל-0).\nחוט 2: כותב וממתין על writelock שיגדל ל-1.\nחוט 3: קורא ותופס את המנעול בהצלחה (מדלג על writelock בגלל חוט 1).\nחוט 1: משחרר את המנעול (מדלג על writelock בגלל חוט 3).\nחוט 1: קורא ותופס את המנעול בהצלחה (מדלג על writelock בגלל חוט 3).\nחוט 3: משחרר את המנעול (מדלג על writelock בגלל חוט 1).\nכך ניתן להמשיך עד אינסוף וחוט 2 לעולם לא יצליח לתפוס את המנעול.\n2. הבעיה: קיפאון.\nחוט 1: כותב ומגדיל את numWriters, תופס את המנעול בהצלחה.\nחוט 2: קורא ותופס את readlock, חסום בלולאה.\nחוט 1: מנסה לשחרר את המנעול אך חסום בהמתנה ל-readlock.\nלא ניתן יותר להשתמש במנעול ע\"י אף חוט.\n3. שינוי 1: נגדיל ונקטין את numWriters באופן אטומי בלי להשתמש ב-readlock, וכך קורא שממתין בלולאה לא יחסום חוטים כותבים.\nשינוי 2: קוראים ימתינו בלולאה לפני תפיסת readlock, כך גם קורא שממתין בלולאה לא יחסום חוטים כותבים שמנסים לתפוס או לשחרר את המנעול.\nשינוי 2 מספיק גם בנפרד כדי לענות על הדרישות.\nvoid acquire_writelock() {\nfetch&add(&numWriters, 1);\nsem_wait(&writelock);\n}\nvoid release_writelock() {\nsem_post(&writelock);\nfetch&add(&numWriters, -1);\n}\nvoid acquire_readlock() {\nwhile (numWriters > 0);\nsem_wait(&readlock);\nif (++numReaders == 1)\nsem_wait(&writelock);\nsem_post(&readlock);\n}\nvoid release_readlock() {\nsem_wait(&readlock);\nif (--numReaders == 0)\nsem_post(&writelock);\nsem_post(&readlock);\n}"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O"], "content": {"text": "נתונה מערכת קבצים VSFS המשתמשת ב-journaling, עם הנתונים הבאים:\n- גודל בלוק הוא 2KB.\n- גודל inode הוא 256B.\n- גודל מצביע הוא 4B.\n- בכל inode יש: 10 מצביעים ישירים, 2 מצביעים עקיפים, מצביע אחד עקיף כפול.\n- המערכת משתמשת ב-metadata journaling, עם journal בגודל של 250 בלוקים.\nשימו לב: נתונים אלו רלוונטיים לכל סעיפי השאלה. הנתונים הכתובים בסעיפים עצמם מתווספים לנתונים אלו אך ספציפיים לאותו סעיף ואינם תקפים לשאר הסעיפים.\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "נתון דיסק קשיח בגודל 100MB שעליו נמצאת מערכת הקבצים הנ\"ל, כאשר 99MB מהדיסק הוגדרו בתור ה-data region של מערכת הקבצים.\nמה המספר המקסימלי של קבצים שניתן להחזיק במערכת הקבצים בדיסק זה?\nמספר קבצים מקסימלי:\nנימוק:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "משתמש יצר קובץ חדש (ריק) בתיקייה שמספר ה-inode שלה ידוע מראש. נתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה (מלבד מספר ה-inode של התיקייה).\nלכמה בלוקים נדרש לכתוב במקרה המינימלי כדי להשלים את הפעולה?\nיש לפרט את הכתיבות לפי הסדר בו הן מתבצעות, ובנוסף לציין היכן יש להמתין לכתיבות שיסתיימו (fsync) ומה השלב הראשון אחריו נוכל להבטיח בוודאות שהפעולה תתבצע בהצלחה גם אם המערכת תקרוס.\nמספר כתיבות מינימלי:\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. בדיסק כולו יש 100MB שהם 51,200 בלוקים (לפי גודל בלוק 2KB).\nמתוכם 99MB שמורים ל-DATA – 50688 בלוקים.\nבכל בלוק יש 8*2048 = 16,384 ביטים, כלומר ה-data bitmap הוא בגודל 4 בלוקים (50688/16384). בנוסף נדרש בלוק 1 עבור superblock, ועוד 250 בלוקים עבור ה-journal.\nסה\"כ עד כה ניצלנו 1+25+4+50688 = 50,943 בלוקים. נשארו 257 בלוקים עבור inode וגם inode bitmap.\nבכל בלוק נכנסים 2048/256 = 8 inodes. אפשר לנצל 256 בלוקים ל-inodes בהם יהיו 2048 inodes, ובלוק אחד מספיק ל-inode bitmap של כולם.\nכלומר, במערכת יש לכל היותר inodes 2048 ולכן מקסימום 2048 קבצים.\nתשובה שגויה הייתה להתייחס לכמות הקבצים בגודל המקסימלי שנכנסים ב-DATA הזמין, אך קובץ לא חייב להיות בגודל המקסימלי (ויכול גם להיות ריק).\n2. הפעולה דורשת לעדכן את הנתונים הבאים: inode של התיקייה, inode bitmap עבור הקובץ החדש, inode של הקובץ החדש, בלוק data של התיקייה.\nבמקרה המינימלי 2 ה-inodes באותו בלוק וניתן לעדכן אותם בכתיבה אחת, ובלוק ה-data של התיקייה מכיל מקום פנוי לרשומה נוספת.\nהפעולות לפי הסדר:\nΟ כתיבת TXE.\nΟ כתיבת inode bitmap אל ה-journal.\nΟ כתיבת inode מעודכנים (תיקייה + קובץ חדש) אל ה-journal.\nΟ עדכון בלוק ה-data של התיקייה, הוספת רשומה של הקובץ החדש (אין צורך לכתוב לבלוק חדש מאחר וזו הוספה של נתונים בלבד ולא שכתוב).\nΟ .fsync\nΟ כתיבת TXE.\nΟ fsync (אחרי שלב זה הפעולה תתבצע בוודאות).\nΟ עדכון inode bitmap במערכת הקבצים עצמה.\nΟ עדכון בלוק inode במערכת הקבצים עצמה.\nסה\"כ 7 פעולות כתיבה."}, "difficulty_estimation": "Hard"}, {"id": 9, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתונה מערכת עם מנגנון 1-RAID עם 2 עותקים (כלומר – mirroring level של 2) בו זמינים 5 דיסקים קשיחים הממוספרים 1-9, שלכל אחד מהם נפח (שטח אחסון) של 2TB.\nכמו-כן ידוע שהזמן הקצר ביותר בו יכולה להתבצע פעולה על בלוק בודד בדיסק הוא 10ms.\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "9.1", "text": "מה הזמן הקצר ביותר שתיקח פעולת קריאה של 10 בלוקים לוגיים רצופים?\nהזמן הקצר ביותר: ms\nנימוק:", "code_snippet": null, "options": null}, {"id": "9.2", "text": "מה הזמן הקצר ביותר שתיקח פעולת כתיבה אל 20 בלוקים לוגיים רצופים?\nהזמן הקצר ביותר: ms\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. בגלל ה-mirroring, תמיד נוכל לסדר 10 בלוקים לוגיים רצופים כך שנדרש לקרוא 2 בלוקים מכל דיסק, לכן הזמן הקצר ביותר הוא קריאה של 2 בלוקים מכל אחד מ-5 הדיסקים. לכל דיסק 20ms והקריאות יכולות להתבצע במקביל לכן סה\"כ 20ms.\nכל בלוק יש לכתוב ל-2 דיסקים שונים (בגלל ה-mirroring). מאחר שהבלוקים רצופים ובגלל החלוקה ב-striping נקבל כתיבה של 40 בלוקים סה\"כ שמתחלקת שווה בשווה בין הדיסקים. כלומר 8 בלוקים בכל דיסק (מינימום 80ms).\nהכתיבות רצופות בכל דיסק ומתבצעות במקביל בין הדיסקים לכן 80ms."}, "difficulty_estimation": "Medium"}]}, {"filename": "os24SA.json", "metadata": {"course_name": "Operating Systems", "year": "2024", "semester": "Summer", "moed": "Moed A", "exam_date": "10.10.2024", "source_file": "os24SA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Atomic Operations", "Synchronization", "Concurrency"], "content": {"text": "נתון מעבד התומך בפעולה האטומית CAS, הניתנת להפעלה ע\"י קריאה לפונקציה:\nסטודנט כתב את הפונקציה הבאה לדימוי פעולת המעבד האטומית F&A באמצעות פעולת CAS:", "code_snippet": "BOOL compareAndSet (int* ptr, int expected, int new);\nint fetchAndAddWithCAS(int* val) {\nint tmp;\ndo {\ntmp = *val;\n} while (!compareAndSet(val, tmp, tmp+1));\nreturn tmp;\n}", "options": ["א. המימוש תקין, ושקול לשימוש ב-F&A.", "ב. המימוש תקין, אך יפגין ביצועים פחות טובים משימוש ב-F&A.", "ג. המימוש לא תקין, שימוש בו עלול לגרום לקיפאון.", "ד. המימוש לא תקין, שימוש בו עלול לגרום להרעבה.", "ה. המימוש לא תקין, הערך של val לא תמיד יקודם באופן נכון."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. חוט מסוים עלול להיכשל בקריאת ה-CAS שוב ושוב, ובכך להיות מורעב."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Threads", "Memory Management", "Processes"], "content": {"text": "נתונים 2 חוטים A,B של אותו תהליך, ושניהם עוד לא הסתיימו. איזו טענה נכונה?", "code_snippet": null, "options": ["א. החוט A לעולם לא יכול לגשת למשתנים המקומיים של B.", "ב. החוט A יכול לגשת למשתנים המקומיים של B רק בתיווך מערכת ההפעלה (עם קריאת מערכת).", "ג. החוט A יכול לגשת למשתנים המקומיים של B רק אם B הגדיר אותם באופן מיוחד.", "ד. החוט A תמיד יכול לגשת למשתנים המקומיים של B.", "ה. החוט A תמיד יכול לגשת למשתנים המקומיים של B, גם אם החוטים לא היו באותו תהליך."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. כפי שנלמד, חוטים של אותו תהליך (בלבד) יכולים לגשת למחסנית אחד של השני ולכל הזיכרון של התהליך."}, "difficulty_estimation": "Easy"}, {"id": 3, "type": "MultipleChoice", "topic": ["Signals", "IPC", "System Calls"], "content": {"text": "מהו סיגנל (signal)?", "code_snippet": null, "options": ["א. מנגנון למניעת זומבים במערכת.", "ב. פסיקה שתהליך יכול לגרום במעבד.", "ג. מנגנון לשליחת הודעות מתהליך אל מערכת ההפעלה.", "ד. מנגנון לשליחת הודעות בין תהליכים ללא התערבות מערכת ההפעלה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. סיגנל הוא מנגנון לשליחת הודעות בין תהליכים, או ממערכת ההפעלה אל תהליכים, בתיווך מערכת ההפעלה."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["File Systems"], "content": {"text": "נתונה מערכת קבצים VSFS עם תיקייה d1 בה קיימת הרשומה הבאה: | 20 | a.txt | כלומר, בתיקייה d1 קיימת רשומה בה השם הוא a.txt ומספר ה-inode הוא 20. איזה מהתרחישים הבאים אינו אפשרי?", "code_snippet": null, "options": ["א. באותה תיקייה d1 קיימת גם הרשומה | 30 | a.txt |.", "ב. באותה תיקייה d1 קיימת גם הרשומה | 20 | b.txt |.", "ג. בתיקייה אחרת d2 קיימת הרשומה | 30 | a.txt |.", "ד. בתיקייה אחרת d2 קיימת הרשומה | 20 | a.txt |.", "ה. בתיקייה אחרת d2 קיימת הרשומה | 20 | b.txt |."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. לא יתכנו 2 קבצים עם אותו שם באותה תיקייה. כל שאר האפשרויות תקינות."}, "difficulty_estimation": "Easy"}, {"id": 5, "type": "MultipleChoice", "topic": ["File Systems", "System Calls"], "content": {"text": "במערכת קבצים VSFS, באיזו פעולה לא נדרש לגשת אל ה-inode של הקובץ?", "code_snippet": null, "options": ["א. פתיחת קובץ.", "ב. קריאת מקובץ.", "ג. כתיבה לקובץ.", "ד. סגירת קובץ.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. בסגירת קובץ נדרש רק למחוק את אובייקט ה-FD שנוצר עבורו, ואין בהכרח צורך בגישה ל-inode (או בכלל אל הדיסק)."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Concurrency", "Memory Management"], "content": {"text": "נתונה התוכנית הבאה בשם prog1:\nהריצו את התוכנית, והתהליך שנוצר קיבל את מזהה התהליך 42.\nידוע שהתוכנית prog2 אינה מדפיסה פלט או יוצרת תהליכים חדשים. ניתן להניח שכל קריאות המערכת הצליחו, לא נוצרים תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.", "code_snippet": "1 int main()\n2 {\n3 pid_t pid = getpid();\n4 \n5 if (fork() && !fork()) {\n6 if (!fork() || fork()) {\n7 fork();\n8 }\n9 }\n10 \n11 while (wait(NULL) != -1);\n12 if (pid != getpid()) {\n13 char* args[] = { \"prog2\", NULL };\n14 printf(\"%d [%d]\\n\", getpid(), getppid());\n15 execvp(args[0], args);\n16 }\n17 printf(\"Done: %d\\n\", getpid());\n18 }", "options": null}, "sub_questions": [{"id": "6.1", "text": "כתבו פלט אפשרי של התוכנית, וציירו את עץ התהליכים שנוצר בעקבות הריצה שמובילה לפלט זה (יש לציין לכל תהליך בעץ את מזהה התהליך שלו).\nכמה תהליכים נוצרו בתוכנית, כולל התהליך הראשי?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "נניח שהכניסו את שורה 11 להערה (לולאת ה-while). ידוע שהקוד של כל אחת מהתוכניות prog,prog2 נכנס בדף אחד, ושהמערכת משתמשת בטבלת דפים לינארי בגודל מקסימלי של 2 דפים.\nנתון כי מיד לאחר הרצת שורה 3, במערכת ההפעלה תפוסות 30 מסגרות עבור זיכרון של מרחב המשתמש (user space).\nכעת בדקו את מצב המערכת בנקודת זמן בריצה בה כל התהליכים אשר מריצים את שורה 15 (קריאת ה-execvp) כבר ביצעו אותה בהצלחה אך אף תהליך לא הריץ אף פקודה של התוכנית prog2, וכל שאר התהליכים (שאינם נכנסים לתנאי בשורה (12) עוד לא הסתיימו.\nכלומר: כל התהליכים כבר נוצרו, אף תהליך עוד לא הסתיים, וכל תהליך שקרא ל-execvp במהלך הריצה שלו כבר ביצע את הקריאה בהצלחה (אך עוד לא הריץ אף שורת קוד מתוך prog2).\nכמה מסגרות יהיו תפוסות במערכת עבור זיכרון המשתמש (user space) במקרה המינימלי והמקסימלי?\nיש להניח שלא נעשה שימוש ב-swapping, ואף תהליך אחר במערכת לא מבצע הקצאה, שחרור, או גישה לזיכרון.", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. נוצרים 7 תהליכים.\nבשורה 5 תהליך 42 יוצר את 43 ו-44. רק תהליך 44 נכנס אל התנאי.\nבשורה 6 תהליך 44 יוצר את 45 ו-46. תהליך 45 נכנס אל התנאי מיד ותהליך 44 נכנס גם, אחרי ביצוע ה-fork השני.\nתהליכים 44,45 יוצרים בשורה 7 את הבנים 47,48.\nכל תהליך מדפיס את הפלט רק לאחר שחיכה שהבנים שלו יסתיימו:\n48 [45]\n47 [44]\n46 [44]\n45 [44]\n44 [42]\n43 [42]\nDone: 42\n\n2. מינימום 30 מסגרות, אם התוכנית prog2 כבר רצה בתהליך אחר במערכת, והמחסנית של כל התהליכים החדשים ריקה או עוד לא נוצרה (טבלת הדפים היא חלק מהקרנל ולא זיכרון המשתמש). התקבלה גם תשובה של 36 מסגרות, עם נימוק שמחסנית ריקה תקבל דף.\nמקסימום 37 מסרות, מסגרת אחת עבור הקוד של התוכנית prog2 (לכל התהליכים יחד), ועוד מסגרת אחת לכל מחסנית עבור 6 התהליכים שקראו ל-execvp (מלבד הראשי)."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Mutexes", "Concurrency", "Threads"], "content": {"text": "נתונה מערכת ללא תמיכה בפעולת המעבד האטומית F&A, בה המנעול המובנה אינו הוגן. כלומר, מימוש המנעול הזמין ע\"י מערכת ההפעלה מקיים מניעה הדדית וחופש מקיפאון אך עלול לגרום להרעבה.\nמתכנת כלשהו החליט לממש מנעול בהשראת Ticket Lock המשתמש בפקודת ++ במקום F&A החסרה.\nמאחר שפקודת ++ אינה אטומית וחוטים שונים עלולים לקבל את אותו מספר בתור, הקוד משתמש במנעול המובנה במערכת כדי להבטיח מניעה הדדית ביניהם. בנוסף, במידה וחוט הבחין שהתור התקדם מעבר למספר החוט שקיבל (כפי שעלול לקרות), החוט מחזיר את התור אחורה. להלן המימוש:\nשימו לב: השדה unfair הוא המנעול המובנה במערכת שאינו הוגן. הפרמטר myturn של unlock הוא ערך ההחזר של lock (המספר שקיבל החוט שתפס את המנעול).", "code_snippet": "typedef struct {\nint ticket; // init to 0\nint turn; // init to 0\nmutex_t unfair;\n} Lock1;\n\nint lock(Lock1* lock) {\nint myturn = lock->ticket++;\nwhile (lock->turn != myturn) {\nif (lock->turn > myturn)\nlock->turn = myturn;\nmutex_lock(&lock->unfair);\n}\nreturn myturn;\n}\n\nvoid unlock(Lock1* lock, int myturn) {\nlock->turn = myturn + 1;\nmutex_unlock(&lock->unfair);\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "האם המנעול שמתואר בקוד הנ\"ל מקיים מניעה הדדית? כן / לא הוכחה:", "code_snippet": null, "options": null}, {"id": "7.2", "text": "האם המנעול שמתואר בקוד הנ\"ל מקיים חופש מקיפאון? כן / לא הוכחה:", "code_snippet": null, "options": null}, {"id": "7.3", "text": "האם המנעול שמתואר בקוד הנ\"ל מקיים הוגנות (bounded waiting)? כן / לא הוכחה:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. המנעול מקיים מניעה הדדית.\nכל חוט תופס את המנעול unfair לפני הכניסה לקטע הקריטי ומשחרר אותו רק ביציאה מהקטע הקריטי, לכן אם יש 2 חוטים בקטע הקריטי בו-זמנית שניהם מחזיקים במנעול unfair בסתירה לכך שמנעול זה מקיים מניעה הדדית.\n\n2. המנעול לא מקיים חופש מקיפאון. דוגמה נגדית:\nחוט 1: מנסה לתפוס את המנעול, קורא 0=ticket ועוד לא מקדם ל-1.\nחוט 2: תופס את המנעול – קורא 0=ticket וגם מקדם ל-1. משחרר את המנעול ואז 1=turn.\nחוט 3: תופס את המנעול – קורא 1=ticket וגם מקדם ל-2. משחרר את המנעול ואז 2=turn.\nחוט 1: חוזר לרוץ, מעדכן 1=ticket, רואה שהתור התקדם ולכן מעדכן 0=turn, תופס את המנעול ואז משחרר אותו ומעדכן 1=turn.\nכל חוט שינסה לתפוס את המנעול חסום: יקבל מספר של 2 ומעלה אבל התור 1 ולא יקודם לערך הזה לעולם.\n\n3. המנעול לא מקיים הוגנות. דוגמה נגדית:\nחוט 1: מנסה לתפוס את המנעול, קורא 0=ticket ועוד לא מקדם ל-1.\nחוט 2: תופס את המנעול – קורא 0=ticket וגם מקדם ל-1, משחרר את המנעול ואז 1=turn.\nחוט 1: ממשיך לרוץ, מקדם את ticket ל-1 ורואה שה-turn התקדם לכן עומד לעדכן 0=turn אבל עוד לא עושה זאת.\nחוט 2: תופס את המנעול – קורא 1=ticket וגם מקדם ל-2, משחרר את המנעול ונעצר בדיוק לפני ההשמה של 2 turn אל\nחוט 1: מעדכן 0=turn.\nחוט 2: מעדכן 2=turn.\nחוט 1: חוזר בלולאה ורואה שה-turn התקדם לכן עומד לעדכן 0=turn אבל עוד לא עושה זאת.\nחוט 2: תופס שוב את המנעול – קורא 2=ticket וגם מקדם ל-3, משחרר את המנעול ונעצר בדיוק לפני ההשמה של turn 3 אל\nחוט 1: מעדכן 0=turn.\nחוט 2: מעדכן 3=turn.\nוחוזר חלילה."}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "Memory Management", "Copy-on-Write"], "content": {"text": "ב-VSFS קיים שדרוג של copy-on-write, אשר מאפשר להתייחס לאותו בלוק מידע (DATA) מכמה מקומות שונים (לדוגמה, להצביע אליו מכמה inodes שונים).\nלצורך השדרוג, נקצה אזור חדש בדיסק (סט בלוקים) שיכיל מספר עבור כל בלוק DATA, המייצג כמה הפניות יש אל אותו בלוק. נניח שכמות ההפניות המקסימלית לכל בלוק היא 65,535.\nבהעתקת קובץ בתוך מערכת הקבצים, לא נשכפל את המידע והמצביעים אלא רק ניצור inode חדש בו ערכי המצביעים זהים לקובץ המקור. במחיקה של קובץ (לחלוטין, כלומר לא נותרו hard links אל הקובץ) נחסיר 1 מכמות ההפניות של כל הבלוקים של הקובץ. בעדכון נתוני קובץ, נשכפל את הבלוקים ששונו ונעדכן את מספר ההפניות בהתאם (יחד עם עדכון המצביעים עבור ה-inode בו בוצע העדכון).\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "נתונה מערכת קבצים עם גודל בלוק של 4KB.\nבמערכת VSFS סטנדרטית (ללא השדרוג) נתון שיש מקום ל-2,000,000 בלוקים של DATA. לכמה בלוקים של DATA יהיה מקום עם השדרוג הנתון?\nכלומר, נתון דיסק קשיח ועליו מערכת קבצים VSFS סטנדרטית (ללא השדרוג) עם data region המכיל 2,000,000 בלוקים של DATA. ביצעו את השדרוג הנתון למערכת הקבצים, ללא שינוי שאר נתוני מערכת הקבצים מלבד שינוי גודל ה-data region לטובת הקצאת האזור החדש בדיסק (כלומר, ללא שינוי גודל בלוק, גודל inode, כמות inodes, וכו'). לכמה בלוקים של DATA יהיה מקום בדיסק לאחר השדרוג?", "code_snippet": null, "options": null}, {"id": "8.2", "text": "נתונה מערכת קבצים VSFS עם שדרוג copy-on-write, בה כל inode מכיל 8 מצביעים ישירים, 2 מצביעים עקיפים, ו-2 מצביעים עקיפים כפולים. גודל מצביע הוא 4B.\nמשתמש ביצע פעולת כתיבה של בית בודד (1B) לקובץ כלשהו, כאשר הנתון היחיד שידוע מראש הוא מספר ה-inode אליו מבוצעת הכתיבה (אף cache אינו מכיל מידע רלוונטי לביצוע הפעולה).\nמה המספר המקסימלי של בלוקים של DATA שצריך לכתוב אליהם כדי להשלים את הפעולה?\nיש לתאר את הפעולה שמביאה למספר המקסימלי, ואת כל בלוקי ה-DATA אליהם נדרש לכתוב. ניתן להניח כל תרחיש שיוביל למספר המקסימלי, כל עוד הוא עומד בנתונים ובמגבלות שצוינו. אין לתאר פעולות קריאה.", "code_snippet": null, "options": null}, {"id": "8.3", "text": "סטודנט טען כי עם השדרוג של copy-on-write, אין צורך ביותר מ-hard-link אחד לכל inode מאחר וניתן לשתף מידע בין קבצים עם השדרוג הנתון וזה יהיה שקול לשימוש ב-hard-links\nהאם טענת הסטודנט נכונה?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. ה-data region מכיל 2 מיליון בלוקים, כעת צריך באותה כמות בלוקים גם להכיל את האיזור החדש של מספר ההפניות.\nכל הפניה לבלוק דורשת 2 בתים (16 ביטים לייצוג מספר 0-65,535), לכן בכל בלוק 4KB נכנסות 2048 הפניות.\nכלומר, אם יש X בלוקים של DATA לאחר השינוי, נצטרך X/2048 בלוקים של הפניות (מעוגל מעלה). סה\"כ הבלוקים צריך להיות עדיין 2 מיליון, כלומר שאנחנו מחפשים X מקסימלי שמקיים את המשוואה:\nX+X/2048 <= 2,000,000\nהתשובה היא X=1999023\n\n2. מקסימום 3 בלוקים של DATA.\nהפעולה שמביאה למקסימום היא כתיבה לבלוק קיים אשר גורם לשכפול מקסימלי (שלו ושל המצביעים בדרך).\nלדוגמה, כתיבה לבית האחרון של קובץ בגודל המקסימלי אשר חולק את הבלוק הזה עם קובץ אחר, וגם את הבלוקים של המצביעים.\nבלוק ה-DATA האחרון נגיש מה-inode דרך מצביע עקיף כפול, לכן נדרש לכתוב אל:\n- בלוק חדש עבור שכפול ה-DATA אליו כתבנו (כי הוא משותף).\n- בלוק חדש עבור שכפול בלוק המצביעים המצביע אל בלוק ה-DATA.\n- בלוק חדש עבור שכפול בלוק המצביעים העקיפים המצביעים אל בלוק המצביעים.\nנדרש לעדכן גם את ה-inode, מספר הפניות ו-inode bitmap, אך אלו לא בלוקים של DATA ולכן לא נדרשו בשאלה.\n\n3. הסטודנט טועה.\nאמנם קבצים שונים יכולים לחלוק מידע, אך אם נשנה קובץ אחד זה לא ישפיע על האחרים, בניגוד ל-hard-link שמייצג שמות שונים לאותו קובץ (ולא רק אותו תוכן ברגע נתון)."}, "difficulty_estimation": "Hard"}, {"id": 9, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems", "RAID"], "content": {"text": "נתונות 2 מערכות עם מנגנון RAID, בכל אחת מהן זמינים 4 דיסקים קשיחים (ממוספרים 1-4) בעלי מאפיינים זהים. כלומר, כל 8 הדיסקים בעלי מאפיינים זהים לחלוטין.\nהשתמשו ב-2 מערכות אלו באותו אופן בדיוק ביצעו את אותן פעולות (קריאה וכתיבה) לאותם בלוקים לוגיים ב-2 המערכות לאורך זמן.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "9.1", "text": "נתון שבמערכת הראשונה יש מנגנון 5-RAID ובמערכת השניה מנגנון 4-RAID.\nמשתמש ביצע פעולת כתיבה אחת זהה ב-2 המערכות: כתיבה לבלוקים של 2 שורות רצופות (stripes). בנוסף, המשתמש ביצע פעולת קריאה אחת זהה ב-2 המערכות: קריאת הבלוקים של 2 שורות רצופות.\nב-2 המקרים המשתמש הופתע לגלות שזמני הפעולות של המערכת השניה (4-RAID) היו קצרים יותר. כיצד זה יתכן?", "code_snippet": null, "options": null}, {"id": "9.2", "text": "נתון שבמערכת הראשונה יש מנגנון 0-RAID ובמערכת השניה מנגנון 1-RAID עם mirroring level של 2.\nבו-זמנית, קרסו 2 הדיסקים הקשיחים הממוספרים 1-2 ב-2 המערכות יחד. המשתמש הופתע לגלות שרק במערכת השניה (1-RAID) אבדו נתונים, בעוד במערכת הראשונה (0-RAID) לא אבד אף נתון. כיצד זה יתכן?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. אמנם הפעולות זהות אך זה לא אומר שמיקום הראש הקורא-כותב או זמן הסיבוב זהים. הסבר אפשרי הוא שבמהלך הפעולה, זמן ההמתנה לסיבוב במערכת השניה היה קצר יותר ולכן הפעולה הסתיימה מהר יותר.\n\n2. אמנם 1-RAID מספק גיבוי אך אם נפלו 2 דיסקים אז נאבדו הנתונים.\nיתכן שהמשתמש אחסן נתונים רק באותם דיסקים שלא התקלקלו במערכת הראשונה (לדוגמה, בלוק לוגי 3 נמצא בדיסק 3 במערכת הראשונה אבל בדיסקים 1-2 במערכת השניה, ולכן אם אוחסנו בו נתונים הם יתאימו לתרחיש המתואר)."}, "difficulty_estimation": "Medium"}]}, {"filename": "os24SB.json", "metadata": {"course_name": "Operating Systems", "year": "2024", "semester": "Summer", "moed": "Moed B", "exam_date": "04.11.2024", "source_file": "os24SB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Concurrency", "Atomic Operations", "Synchronization"], "content": {"text": "נתון מעבד התומך בפעולה האטומית F&A, הניתנת להפעלה ע\"י קריאה לפונקציה:\nint fetchAndAdd(int* ptr);\nסטודנט כתב את הפונקציה הבאה לדימוי פעולת המעבד האטומית CAS באמצעות פעולת F&A:\nint compareAndSetWithFA(int* val, int expected, int new) {\nstatic int ticket = 0;\nstatic int turn = 0;\n// static vars are shared among threads (like global)\nint res = 0;\nint myturn = fetchAndAdd(&ticket);\nwhile (myturn != turn);\nif (*val == expected) {\n*val = new;\nres = 1;\n}\n++turn;\nreturn res;\n}", "code_snippet": "int fetchAndAdd(int* ptr);\nint compareAndSetWithFA(int* val, int expected, int new) {\nstatic int ticket = 0;\nstatic int turn = 0;\n// static vars are shared among threads (like global)\nint res = 0;\nint myturn = fetchAndAdd(&ticket);\nwhile (myturn != turn);\nif (*val == expected) {\n*val = new;\nres = 1;\n}\n++turn;\nreturn res;\n}", "options": ["א. המימוש תקין, ושקול לשימוש ב-CAS.", "ב. המימוש תקין, אך יפגין ביצועים פחות טובים משימוש ב-CAS.", "ג. המימוש לא תקין, שימוש בו עלול לגרום לקיפאון.", "ד. המימוש לא תקין, שימוש בו עלול לגרום להרעבה.", "ה. המימוש לא תקין, הערך של val לא תמיד יעודכן באופן נכון."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. המימוש מכיל מנעול ticket-lock מובנה כדי להבטיח נכונות ולכן יעבוד באופן תקין, אך המנעול יפגע בביצועים כי הפעולה לא מתבצעת במקביל (אפילו לא כשניגשים לערכים שונים בזיכרון), ולא באופן אטומי במעבד."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Threads", "Processes", "Context Switching"], "content": {"text": "נתונים 2 חוטים A,B של 2 תהליכים שונים במערכת, ושניהם עוד לא הסתיימו. איזו טענה נכונה?", "code_snippet": null, "options": ["א. החוט A יכול למנוע החלפת הקשר ע\"י ביטול הפסיקות במערכת.", "ב. החלפת הקשר בין A ל-B יכולה להתבצע רק בעקבות קריאת מערכת.", "ג. החלפת הקשר בין A ל-B יכולה להתבצע רק בעקבות פסיקת שעון.", "ד. החלפת הקשר בין A ל-B לרוב תהיה איטית יותר מאשר אם היו באותו תהליך.", "ה. החלפת הקשר בין A ל-B לרוב תהיה מהירה יותר מאשר אם היו באותו תהליך."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. החלפת הקשר בין חוטים באותו תהליך היא מהירה יותר מאשר בין חוטים בתהליכים שונים."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["System Calls", "I/O", "Processes"], "content": {"text": "מהי פסיקה(interrupt)", "code_snippet": null, "options": ["א. מנגנון לעצירת תהליכים כל פרק זמן קבוע.", "ב. קטע קוד שמריץ תהליך לטיפול באירוע כלשהו.", "ג. הודעה שנשלחת ממערכת ההפעלה אל תהליך.", "ד. הודעה שנשלחת בין תהליכים בתיווך מערכת ההפעלה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. פסיקה היא הודעה שנשלחת אל המעבד/קרנל מרכיבי חומרה או תהליכים (באמצעות trap). פסיקת השעון משמשת לעצירת תהליכים כל פרק זמן קבוע, אך זה השימוש בסוג אחד של פסיקה ולא ההגדרה של פסיקה."}, "difficulty_estimation": "Easy"}, {"id": 4, "type": "MultipleChoice", "topic": ["File Systems"], "content": {"text": "נתונה מערכת קבצים VSFS עם 2 קבצי משתמש A, B ששניהם hard links לאותו inode, ושני קבצי משתמש C,D ששניהם symbolic links – הקובץ C הוא קישור סימבולי אל A, והקובץ D הוא קישור סימבולי אל B.\nא. אם נמחק את A, משתמש יוכל עדיין לפתוח את C מכיוון שעדיין קיים B.\nב. לא יתכן ש-A,B באותה תיקייה מאחר שהם קישורים לאותו inode.\nג. לא יתכן ש-C,D באותה תיקייה מאחר שהם קישורים לאותו inode.\nד. ה-inode של C זהה ל-inode של D.\nה. כל התשובות האחרות אינן נכונות.", "code_snippet": null, "options": ["א. אם נמחק את A, משתמש יוכל עדיין לפתוח את C מכיוון שעדיין קיים B.", "ב. לא יתכן ש-A,B באותה תיקייה מאחר שהם קישורים לאותו inode.", "ג. לא יתכן ש-C,D באותה תיקייה מאחר שהם קישורים לאותו inode.", "ד. ה-inode של C זהה ל-inode של D.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. כל האפשרויות המתוארות אפשריות."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["System Calls", "Processes", "Security"], "content": {"text": "נתונה הטענה: שינוי ערכי האוגרים במעבד מתבצע רק במצב קרנל (kernel mode).\nא. הטענה נכונה: ערכי האוגרים נשמרים ב-PCB וזה מבנה נתונים של הקרנל.\nב. הטענה נכונה: האוגרים נמצאים במעבד ורק לקרנל יש גישה לחומרה.\nג. הטענה לא נכונה: תהליך תמיד יכול לשנות את חלק מערכי האוגרים במעבד (ב-user mode)\nד. הטענה לא נכונה: תהליך יכול לקבל הרשאה זמנית לשנות ערכים של חלק מהאוגרים (ב-user mode).\nה. כל התשובות האחרות אינן נכונות.", "code_snippet": null, "options": ["א. הטענה נכונה: ערכי האוגרים נשמרים ב-PCB וזה מבנה נתונים של הקרנל.", "ב. הטענה נכונה: האוגרים נמצאים במעבד ורק לקרנל יש גישה לחומרה.", "ג. הטענה לא נכונה: תהליך תמיד יכול לשנות את חלק מערכי האוגרים במעבד (ב-user mode)", "ד. הטענה לא נכונה: תהליך יכול לקבל הרשאה זמנית לשנות ערכים של חלק מהאוגרים (ב-user mode).", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. הגישה לאוגרים מתבצעת באופן ישיר כחלק מפעולת המעבד הסטנדרטית גם ב-user mode (זו המשמעות של direct execution, גם עבור limited direct execution). תהליך ניגש לאוגרים במעבד בכל ריצה סטנדרטית."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Scheduling", "Synchronization", "Deadlocks"], "content": {"text": "נתון אלגוריתם חדש בשם RMLFQ, המבוסס על MLFQ מלבד השינויים הבאים:\n- תהליך חדש מתווסף לתור בעדיפות הנמוכה ביותר במקום הגבוהה ביותר.\n- תהליך שלא ניצל את כל הקוונטה עולה תור אחד בעדיפות. תהליכים עדיין יורדים בעדיפות לפי אותה חוקיות.\n- priority boost, כל התהליכים יורדים לתור בעדיפות הנמוכה ביותר, במקום לעלות לגבוהה ביותר.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "היפוך עדיפויות (priority inversion) הוא מצב בו אלגוריתם התזמון גורם לקיפאון של תהליך כלשהו בגלל שהתהליך ממתין למשאב המוחזק ע\"י תהליך אחר שאינו מתוזמן עוד לעולם.\nבאילו מאלגוריתם התזמון הבאים אפשרי להגיע למצב של היפוך עדיפויות?\n:FCFS\nנימוק:\n:overlap ללא SRTF\nנימוק:\n:RMLFQ\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "בתזמון תהליכים, הרעבה מוגדרת כמצב בו יתכן שתהליך מסוים לעולם לא יסתיים.\nעבור כל אחד מהאלגוריתמים הבאים, האם מתאפשרת הרעבה? יש לתת דוגמה קצרה היכן שכן, או הוכחה היכן שלא.\n:FCFS\nנימוק:\noverlap ללא SRTF\nנימוק:\n:RMLFQ\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.3", "text": "בתזמון תהליכים, אפקט השיירה מוגדר כמצב בו יתכן שתהליכים קצרים יתעכבו זמן רב עקב תהליך ארוך.\nעבור כל אחד מהאלגוריתמים הבאים, האם יתכן אפקט השיירה? יש לתת דוגמה קצרה היכן שכן, או הוכחה היכן שלא.\n:FCFS\nנימוק:\noverlap ללא SRTF\nנימוק:\n:RMLFQ\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. FCFS – לא אפשרי. תהליך צריך להיות מתוזמן כדי להחזיק במשאב, ותהליך מתוזמן מתחילתו ועד סופו, אז לא יכול להיות שתהליך אחר ממתין למשאב.\nSRTF – אפשרי. תהליך ארוך שמחזיק במשאב עלול להיקטע עי תהליכים קצרים שמגיעים כל הזמן ולעולם לא לרוץ כדי לשחרר את המשאב.\nRMLFQ – לא אפשרי. לאחר priority boost כל התהליכים באותה עדיפות (נמוכה), כולם יתוזמנו כולל התהליך שמחזיק במשאב שבסופו של דבר ישחרר אותו. תהליכים חדשים מגיעים בעדיפות הכי נמוכה ולכן יקבלו קוונטה רק אחרי התהליך שמחזיק במשאב.\n2. FCFS – אין הרעבה. כל תהליך מתוזמן בתורו ולפני התהליכים שהגיעו אחריו.\nSRTF – יש הרעבה. תהליך ארוך עלול להיות מורעב ע\"י תהליכים קצרים שמגיעים כל הזמן.\nRMLFQ – אין הרעבה. כל תהליך ירוץ בסופו של דבר בגלל ה-priority boost, מאחר שתהליכים חדשים מגיעים בעדיפות נמוכה הם ירוצו רק אחרי קוונטה של כל שאר התהליכים.\n3. FCFS – יתכן אפקט השיירה. כל תהליך מחכה לתהליכים שהגיעו לפניו, גם תהליך קצר שלפניו תהליך ארוך מאוד.\nSRTF – לא יתכן אפקט השיירה. תהליך קצר תמיד יתוזמן לפני תהליך ארוך.\nRMLFQ – לא יתכן אפקט השיירה. אחרי priority boost כל התהליכים יקבלו קוונטה, תהליכים ארוכים יישארו בעדיפות נמוכה ולא ירוצו לפני תהליכים קצרים."}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Mutexes", "Concurrency"], "content": {"text": "נתונה מערכת בה המנעול המובנה אינו הוגן, כלומר, מימוש המנעול הזמין ע\"י מערכת ההפעלה מקיים מניעה הדדית וחופש מקיפאון אך עלול לגרום להרעבה.\nמתכנת כלשהו החליט לממש מנעול ל-N חוטים (כאשר N ידוע מראש) בהשראת מנעול הדגלים, בו לכל חוט יש דגל (תא במערך) ומזהה 1 (בין 0 עד 1-N).\nכאשר חוט מעוניין במנעול הוא מרים את הדגל ע\"י כתיבה של 1 או 2 לסירוגין בתא המתאים i במערך – פעם ראשונה 1, פעם שניה 2, פעם שלישית 1, וכן הלאה. כל ערך אחר מציין שהדגל למטה.\nכדי להימנע מקיפאון והרעבה, ננסה להבטיח שחוט לא יעקוף חוט אחר יותר מפעם אחת באופן הבא: אם הדגל 1 ניתנת עדיפות לחוטים עם מזהה נמוך יותר, ואם הדגל 2 ניתנת עדיפות לחוטים עם מזהה גבוה יותר. להלן מימוש חלקי:\n#define N ??\ntypedef struct {\nint flags[N]; // init to -2\nmutex_t unfair;\n} Lock2;\nvoid unlock(Lock2* lock, int i) {\nlock->flags[i] = -(lock->flags[i]);\nmutex_unlock(&lock->unfair);\n}\nvoid lock(Lock2* lock, int i) {\nlock->flags[i] = 3 + lock->flags[i];\nif (lock->flags[i] == 1) {\nfor (int k = 0; k < i; ++k)\nAAA;\n}\nelse {//lock->flags[i] == 2\nfor (int k = N-1; k > i; --k)\nBBB;\n}\nmutex_lock(&lock->unfair);\n}\nשימו לב: השדה unfair הוא המנעול המובנה במערכת שאינו הוגן. הפרמטר i הוא מזהה החוט שתופס/משחרר את המנעול. תוכן השורות המסומנות AAA,BBB מפורט בסעיפים הבאים, בנפרד לכל סעיף.", "code_snippet": "#define N ??\ntypedef struct {\nint flags[N]; // init to -2\nmutex_t unfair;\n} Lock2;\nvoid unlock(Lock2* lock, int i) {\nlock->flags[i] = -(lock->flags[i]);\nmutex_unlock(&lock->unfair);\n}\nvoid lock(Lock2* lock, int i) {\nlock->flags[i] = 3 + lock->flags[i];\nif (lock->flags[i] == 1) {\nfor (int k = 0; k < i; ++k)\nAAA;\n}\nelse {//lock->flags[i] == 2\nfor (int k = N-1; k > i; --k)\nBBB;\n}\nmutex_lock(&lock->unfair);\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "הוכיחו שהמנעול המתואר בקוד הנ\"ל מקיים מניעה הדדית ללא תלות בתוכן השורות AAA,BBB, אם ידוע שבשורות אלו לא מבוצעת פקודת return.\nהוכחה:", "code_snippet": null, "options": null}, {"id": "7.2", "text": "נתון מימוש של המנעול המתואר בקוד הנ\"ל עם הערכים הבאים עבור השורות החסרות:\nAAA: while (lock->flags[k] == 1);\nAAA: while (lock->flags[k] == 2);\nידוע שהמימוש בסעיף זה מקיים רק אחת מהתכונות: חופש מקיפאון, הוגנות.\nאיזו תכונה לא מקיים מימוש המנעול בסעיף זה?\nחופש מקיפאון / הוגנות\nהוכחה:", "code_snippet": "AAA: while (lock->flags[k] == 1);\nAAA: while (lock->flags[k] == 2);", "options": null}, {"id": "7.3", "text": "נתון מימוש של המנעול המתואר בקוד הנ\"ל עם הערכים הבאים עבור השורות החסרות:\nAAA: while (lock->flags[k] > 0);\nAAA: while (lock->flags[k] > 0);\n-ידוע שהמימוש בסעיף זה מקיים רק אחת מהתכונות: חופש מקיפאון, הוגנות.\nאיזו תכונה לא מקיים מימוש המנעול בסעיף זה?\nחופש מקיפאון / הוגנות\nהוכחה:", "code_snippet": "AAA: while (lock->flags[k] > 0);\nAAA: while (lock->flags[k] > 0);", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. ללא קשר לשורות AAA,BBB, כל חוט תופס את המנעול unfair לפני הכניסה לקטע הקריטי ומשחרר אותו רק ביציאה מהקטע הקריטי, לכן אם יש 2 חוטים בקטע הקריטי בו-זמנית שניהם מחזיקים במנעול unfair בסתירה לכך שמנעול זה מקיים מניעה הדדית.\n2. המנעול לא מקיים הוגנות. חוט 0 מנסה לתפוס את המנעול, מעדכן [0]flags ל-1 ומצליח ונכנס לקטע הקריטי. חוט 1 מנסה לתפוס את המנעול, מעדכן [1]flags ל-1 וממתין בלולאה על [0]flags. חוט 0 משחרר את המנעול ומנסה לתפוס שוב, מעדכן [0]flags ל-2 לכן לא ממתין ונכנס לקטע הקריטי, אז משחרר את המנעול ומנסה לתפוס שוב – ומעדכן [0]flags ל-1. חוט 1 חוזר לרוץ, עדיין חסום בלולאה וממתין לחוט 0 כי [0]flags כרגע 1. חוט 0 שוב משחרר את המנעול, תופס, משחרר, תופס. חוט 1 ממשיך בלולאה וחסום. חוזר חלילה עד אינסוף. המנעול כן מקיים חופש מקיפאון (לא נדרש להוכיח): נניח בשלילה שיש קיפאון, מאחר שהמנעול המובנה מקיים חופש מקיפאון אז החוטים בהכרח חסומים באחת מהלולאות (ולא בגישה למנעול המובנה). נניח בשלילה שיש חוט אחד או יותר שחסומים כאשר ערך הדגל שלהם הוא 1. נסתכל על החוט עם המזהה הכי קטן מביניהם – לא יתכן שהוא חסום כי אין חוט עם מזהה קטן ממנו עבורו הדגל הוא 1, לכן לא יתכן אף חוט חסום שהרים דגל עם 1. באותו אופן נניח בשלילה שיש חוטים חסומים עם דגל של 2. נסתכל על החוט עם המזהה הכי גדול מביניהם – לא יתכן שהוא חסום כי אין חוט עם מזהה גדול ממנו עבורו הדגל הוא 2, לכן לא יתכן חוט חסום שהרים דגל עם 2. אלו 2 הערכים היחידים שאפשריים לחוטים שמעוניינים במנעול, לכן הגענו לסתירה.\n3. המנעול לא מקיים חופש מקיפאון. חוט 0 מנסה לתפוס את המנעול, מעדכן [0]flags ל-1, תופס את המנעול ומשחרר אותו. חוט 0 שוב מנסה לתפוס את המנעול, מעדכן [0]flags ל-2 ומתעכב. חוט 1 מנסה לתפוס את המנעול, מעדכן [1]flags ל-1, חסום בהמתנה על [0]flags. חוט 0 חוזר לרוץ, עובר על מערך הדגלים וחסום בהמתנה על [1]flags. אף חוט לא יכול להתקדם – קיפאון. המנעול כן מקיים הוגנות (לא נדרש להוכיח): נניח בשלילה שיש הרעבה, אז קיים חוט שלא מצליח לתפוס את המנעול לעולם בזמן שחוטים אחרים מצליחים מספר לא מוגבל של פעמים. נניח חוט עם מזהה X לא מצליח, נסתכל על חוט כלשהו עם מזהה Y שמצליח לתפוס את המנעול פעמיים (בהכרח יש כזה), ללא הגבלת הכלליות נניח Y>X. בהכרח באחת הפעמים חוט Y מרים דגל עם הערך 1, ולכן חסום על התא של X עד ש-X יתפוס את המנעול בהצלחה, בסתירה לכך ש-Y הצליח לתפוס את המנעול פעמיים."}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Disk Scheduling"], "content": {"text": "נתונה מערכת קבצים VSFS בה גודל בלוק הוא 4KB, גודל מצביע הוא 4B, ובכל inode יש 4 מצביעים: 2 מצביעים ישירים, מצביע אחד עקיף, ומצביע אחד עקיף כפול. יש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "משתמש טוען כי בקובץ מסוים, הגישה לבית במיקום A בקובץ מהירה יותר מאשר הגישה לבית במיקום 1+A, והגישה לבית במיקום B בקובץ זהה למהירות הגישה לבית במיקום 1+A אבל מהירה יותר מהגישה לבית במיקום 1+B. האם הטענה של המשתמש נכונה? אם כן, יש לציין ערכים אפשריים עבור A,B, אחרת יש להוכיח מדוע הטענה לא אפשרית.\nהמשתמש צודק: / המשתמש טועה\nA= B=\nנימוק:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "משתמש החליט כי זמן הגישה הממוצע לבית אקראי אחד בקובץ בגודל 8MB הוא איטי מדי, ולכן רצה לחלק את המידע בקובץ לכמה קבצים נפרדים כך שזמן הגישה הממוצע לבית אקראי אחד יהיה המהיר ביותר. האם קיימת חלוקה כזו? אם כן, יש לפרט לכמה קבצים נדרש לחלק את הקובץ הגדול במינימום, אחרת יש להסביר מדוע לא.\nהחלוקה אפשרית: מינימום ____ קבצים / החלוקה לא אפשרית\nנימוק:", "code_snippet": null, "options": null}, {"id": "8.3", "text": "נתון דיסק קשיח כלשהו בו ידוע שזמן המיקום (הסכום של seek + wait) הוא 20ms\nמשתמש הריץ מספר בדיקות על הדיסק וגילה את הנתונים הבאים:\n- פעולות קריאה/כתיבה של 48MB רצופים מתבצעות בזמן ממוצע של 820ms.\n- פעולות קריאה/כתיבה של X MB רצופים מתבצעות בזמן ממוצע של 320ms.\n- פעולות קריאה/כתיבה חוזרות של X MB באותו מיקום שוב ושוב (ללא אף פעולה אחרת בין לבין) מתבצעות בזמן ממוצע של 310ms\nמה הערך של X, ומהם נתוני הדיסק המלאים?\nהערך של X הוא: ____ MB\nקצב העברה מקסימלי: ____ MB/s\nזמן ה-seek הוא: ____ ms\nקצב RPM הוא: ____\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. הבית A הוא הבית האחרון בבלוק ה-DATA הנגיש מהמצביע הישיר האחרון, כך שהגישה לבית אחד אחריו (1+A) דורשת מעבר דרך בלוק עקיף. יש 2 מצביעים ישירים לכן 2-1*A=4KB\nהבית B הוא הבית האחרון בבלוק ה-DATA האחרון שנגיש דרך מצביע עקיף, כך שגישה אליו זהה ל-1+A בממוצע (שניהם עוברים דרך אותה כמות בלוקים/קריאות), אבל גישה לבית אחד אחריו (1+B) דורש גישה דרך בלוק עקיף כפול.\nאחרי 2 הבלוקים הישירים יש 1024 בלוקים הנגישים ממצביע עקיף לכן B=4KB*1026-1.\nA=8191\nB=4202495\n2. החלוקה אפשרית.\nבקובץ בגודל 8MB רוב הגישות לבית אחד אקראי יהיו דרך מצביע עקיף או מצביע עקיף כפול. הזמן הממוצע הטוב ביותר יהיה אם כל הגישות יהיו דרך מצביעים ישירים בלבד.\nלכן נרצה ליצור הרבה קבצים קטנים כאשר כל אחד מהם משתמש רק במצביעים ישירים. מספר הקבצים המינימלי יתקבל כאשר כל קובץ יהיה בגודל המקסימלי המשתמש במצביעים ישירים בלבד – כלומר 2 בלוקים.\nקובץ בגודל 8MB מכיל 2048 בלוקים של 8MB/4KB) DATA), בכל קובץ קטן נרצה 2 בלוקים לכן המינימום הוא 1024 קבצים.\n3. לפי הנתון הראשון, העברה של 48MB (ללא זמן מיקום) לוקחת 800ms.\nנחשב קצב העברה לפי 48MB ב-800ms ונקבל קצב העברה מקסימלי של MB/s 60.\nלפי הנתון השני, העברה של X MB (ללא זמן מיקום) לוקחת 300ms.\nנקבל שקצב ההעברה הוא XMB ב-300ms וזה זהה לקצב ההעברה המקסימלי שחישבנו (MB/s 60), מתוצאת השוויון נקבל X=18MB\nלפי הנתון השלישי, פעולות לאותו מקום שוב ושוב מתבצעות בזמן ממוצע הקצר יותר ב-10ms.\nכאשר מבצעים פעולה שוב ושוב חוסכים את זמן ה-seek מכיוון שמובטח שהראש הקורא-כותב כבר נמצא ברצועה הנכונה, כלומר שזמן ההמתנה לסיבוב הוא 10ms. סיבוב מלא הוא 20ms וזה מתאים לקצב סיבוב של 3000 RPM.\nזה מותיר אותנו עם זמן 10ms seek"}, "difficulty_estimation": "Hard"}, {"id": 9, "type": "Open", "topic": ["File Systems", "I/O", "Networking"], "content": {"text": "נתונות 2 מערכות עם מנגנון RAID, בכל אחת מהן זמינים 2 דיסקים קשיחים (ממוספרים 1-2) בעלי מאפיינים זהים. כלומר, כל 4 הדיסקים בעלי מאפיינים זהים לחלוטין. בשאלות על ביצועים יש להתייחס לממוצע הכללי (ולא לפעולה ספציפית).", "code_snippet": null, "options": null}, "sub_questions": [{"id": "9.1", "text": "נתון שבמערכת הראשונה יש מנגנון 4-RAID ובמערכת השניה מנגנון 5-RAID. סטודנט א' טען: אין הבדל בין המערכות. הדיסקים במערכת הראשונה יכילו את אותם נתונים כמו במערכת השניה, ולא יהיה הבדל ביצועים ביניהן. סטודנט ב' טען בתגובה: יתכן הבדל בין המערכות (בנתונים ו/או בביצועים), מאחר שבלוק ה-parity נמצא בדיסק קבוע במערכת הראשונה ומתחלף בין הדיסקים במערכת השניה. מי מהסטודנטים צודק?\nסטודנט א' / סטודנט ב'\nנימוק:", "code_snippet": null, "options": null}, {"id": "9.2", "text": "נתון שבמערכת הראשונה יש מנגנון 4-RAID ובמערכת השניה מנגנון 0-RAID. סטודנט א' טען: במערכת השניה נקבל ביצועים טובים יותר גם בקריאה וגם בכתיבה. סטודנט ב' טען: במערכת השניה נקבל ביצועים טובים יותר בקריאה או בכתיבה אך לא בשניהם. סטודנט ג' טען: במערכת השניה לא נקבל ביצועים טובים יותר בקריאה ולא בכתיבה. מי מהסטודנטים צודק?\nסטודנט א' / סטודנט ב' / סטודנט ג'\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. סטודנט א'. עם 2 דיסקים, ה-parity הוא פשוט עותק של הנתונים כמו שהם, כלומר שהנתונים יהיו זהים לחלוטין בין 2 הדיסקים (כמו 1-RAID) ואין כל הבדל בין המערכות.\n2. סטודנט ב'. במערכת השניה נקבל ביצועים טובים יותר בכתיבה, כי נוכל לכתוב ל-2 הדיסקים במקביל ולקצר בחצי את זמן הכתיבה (ב-4-RAID נצטרך לכתוב כל נתון פעמיים בגלל ה-parity). בפעולות קריאה נקבל ביצועים זהים כי נוכל לנצל את 2 הדיסקים במקביל ב-2 המערכות."}, "difficulty_estimation": "Medium"}]}, {"filename": "os24SC.json", "metadata": {"course_name": "Operating Systems", "year": "2024", "semester": "Summer", "moed": "Moed C", "exam_date": "02.12.2024", "source_file": "os24SC.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Atomic Operations", "Synchronization", "Concurrency"], "content": {"text": "נתון מעבד התומך בפעולה האטומית TAS, הניתנת להפעלה ע\"י קריאה לפונקציה: סטודנט כתב את הפונקציה הבאה לקידום ב-1 באופן אטומי (ללא ערך החזר) באמצעות פעולת TAS:", "code_snippet": "int testAndSet(int* ptr, int val);\nint incrementWithTAS(int* val) {\n// repeat until old val is different than new val\n// i.e., until *this thread* increments val\nwhile (*val != testAndSet (val, *val+1));\n}", "options": ["א. המימוש תקין, הערך של val תמיד יקודם באופן נכון.", "ב. המימוש תקין, אך יפגין ביצועים פחות טובים משימוש ב-F&A.", "ג. המימוש לא תקין, שימוש בו עלול לגרום לקיפאון.", "ד. המימוש לא תקין, שימוש בו עלול לגרום להרעבה.", "ה. המימוש לא תקין, הערך של val לא תמיד יקודם באופן נכון."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. חוט כלשהו יכול לקרוא ערך של val (בקריאה של val*) ואז להתעכב זמן רב עד ביצוע הפעולה בזמן שחוטים אחרים קידמו את הערך, וכך להחזיר את הערך של val לערך קודם באופן לא נכון. פעולת TAS תמיד מבצעת את הכתיבה בהצלחה, והחלק האטומי בה הוא רק החלק שמחזיר לנו את הערך שהיה שם קודם."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Threads", "Processes"], "content": {"text": "נתון תהליך מרובה חוטים כלשהו. איזו טענה בהכרח נכונה לגבי החוטים של תהליך זה?", "code_snippet": null, "options": ["א. אם החוט הראשי מסתיים, כל שאר החוטים יעצרו מיד.", "ב. אם החוט הראשי מסתיים, שאר החוטים ימשיכו לרוץ עד שיסתיימו גם.", "ג. אם החוט הראשי מסתיים, חלק מהחוטים יעצרו מיד ואחרים ימשיכו לרוץ.", "ד. אם החוט הראשי מסתיים, התהליך יסתיים מיד אך יתכן ששאר החוטים ימשיכו לרוץ.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. כאשר החוט הראשי מסתיים, תלוי איך יסתיים יתכן שכל שאר החוטים יעצרו מיד ויתכן שכולם ימשיכו לרוץ עד שיסתיימו."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["Processes", "CPU Scheduling", "System Calls"], "content": {"text": "מה זו החלפת הקשר (context switch)?", "code_snippet": null, "options": ["א. מנגנון לעצירת תהליכים כל פרק זמן קבוע.", "ב. מנגנון להחזרת השליטה למערכת ההפעלה.", "ג. מנגנון המאפשר לשנות את התהליך הנוכחי שמריץ המעבד.", "ד. פסיקה שמתרחשת כל זמן קבוע לצורך החלפה בין תהליכים.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. החלפת הקשר זה המנגנון המאפשר החלפה של התהליך הנוכחי שרץ על גבי המעבד."}, "difficulty_estimation": "Easy"}, {"id": 4, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "סטודנט טען כי ניתן לשפר את ביצועי VSFS באופן הבא: אם בכתיבה לקובץ אנו יודעים בוודאות שלא נעשה שינוי בקובץ (לדוגמה, כי יש לנו את ה-DATA העדכני ב-cache מפעולה קודמת), כלומר שתוכן הקובץ זהה לחלוטין לפני ואחרי פעולת הכתיבה, אז אין צורך לבצע כתיבות לדיסק עבור הפעולה.", "code_snippet": null, "options": ["א. הסטודנט צודק, וזה ישפר את ביצועי מערכת הקבצים.", "ב. הסטודנט צודק, אך לא תהיה לזה השפעה על ביצועי מערכת הקבצים (או השפעה זניחה).", "ג. הסטודנט טועה, יש מידע נוסף שנדרש לכתוב לדיסק מלבד ה-DATA.", "ד. הסטודנט טועה, נהיה חייבים לכתוב את ה-DATA אפילו אם הוא זהה ל-DATA הקיים.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. אם לא נעשה שינוי ב-DATA אין טעם לכתוב ערך זהה, אך נדרש לעדכן את ה-inode עם זמן השינוי האחרון של הקובץ."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Synchronization", "Mutexes", "Concurrency"], "content": {"text": "נתון מנעול Alock עם מערך בגודל N. איזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["א. אם קיימים N חוטים בתהליך, חוט שתפס את המנעול יצליח לתפוס אותו שוב רק אחרי שכל 1-N החוטים האחרים תפסו ושחררו אותו.", "ב. אם יש 1+N חוטים המנסים לתפוס את המנעול, המנעול יקיים מניעה הדדית.", "ג. אם יש 1+N חוטים המנסים לתפוס את המנעול, המנעול יקיים חופש מקיפאון.", "ד. אם יש 1+N חוטים המנסים לתפוס את המנעול, המנעול יקיים הוגנות.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. אם יש 1+N חוטים ורק N תאים במערך, המנעול לא יקיים אף אחת מהתכונות."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Memory Management", "Paging", "Virtual Memory"], "content": {"text": "נתונה מערכת בה אין טבלאות דפים, ובמקום זאת יש ל-MMU (בזיכרון של הרכיב עצמו) טבלת תרגום כתובות אחת ויחידה לכל התהליכים והמסגרות. טבלת מיפוי זו היא טבלה הפוכה: האינדקס לטבלה הוא מספר מסגרת, ותוכן כל תא בטבלה הוא מזהה תהליך, מספר הדף של התהליך – אשר ממופה למסגרת המתאימה לאינדקס של התא, ביטים של סטטוס וריפוד (אם נדרש). יש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "נתונה מערכת עם טבלת דפים הפוכה בה גודל דף הוא 8KB, התומכת בזיכרון פיזי מקסימלי של 4GB. גודל הטבלה ההפוכה הוא 4MB, כאשר בכל רשומה בטבלה (PTE) חצי מהביטים משמשים למספר הדף והחצי השני משמשים למזהה התהליך, ביטים של סטטוס, וריפוד. מה גודל הזיכרון הוירטואלי של תהליך במערכת? זיכרון וירטואלי: נימוק:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "נתונה מערכת עם טבלת דפים הפוכה בה גודל דף הוא 8KB והזיכרון הוירטואלי הוא 1GB. גודל הטבלה ההפוכה הוא 16MB, כאשר גודל כל רשומה בטבלה (PTE) הוא 4B. ידוע כי הזיכרון של הקרנל תופס 2 מסגרות במינימום. כמה תהליכים עם זיכרון מקסימלי ניתן להריץ במערכת זו? מספר תהליכים: נימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "6.1: 1. זיכרון פיזי 4GB וגודף דף 8KB אומר שיש 512K מסגרות בזיכרון הפיזי. הטבלה הפוכה לכן יש בה רשומה אחת לכל מסגרת, כלומר 512K רשומות בטבלה. גודל הטבלה הוא 4MB עם 512K רשומות, כלומר שגודל כל רשומה הוא 8B. לפי הנתון חצי מהרשומה משמש למספר הדף, כלומר שמספר הדף הוא 4B = 32 ביטים, לכן לכל תהליך יש 2^32 = 4G דפים. גודל דף הוא 8KB, לכן גודל הזיכרון הוירטואלי הוא 32TB = 4G*8KB.\n6.2: 2. גודל הטבלה ההפוכה 16MB וגודל רשומה 4B כלומר שיש 4M רשומות בטבלה, ולכן 4M מסגרות בזיכרון הפיזי. גודל דף 8KB עם זיכרון וירטואלי 1GB, כלומר לכל תהליך יש 128K דפים (בזיכרון מקסימלי משתמש בכולם). ב-4M רשומות/מסגרות ניתן להכניס 32 תהליכים, אך צריך זיכרון גם לקרנל – לפי הנתון הקרנל תופס מינימום 2 מסגרות כלומר במקסימום נוכל להריץ 31 תהליכים."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Concurrency", "Atomic Operations", "Mutexes"], "content": {"text": "מנעול חד-פעמי הוא מנעול אשר ניתן לנעול פעם אחת בלבד: ברגע שחוט תופס את המנעול בהצלחה, אף חוט אחר לא יכול לתפוס יותר את המנעול לכל אורך התוכנית. פונקציית הנעילה של מנעול חד-פעמי מחזירה 0 לחוטים אשר נכשלו בתפיסת המנעול מבלי לחסום אותם (כלומר, ללא המתנה בדומה לקריאת trylock), ומחזירה 1 לחוט שהצליח. הבהרה: במנעול חד-פעמי, ברגע שחוט מסוים קיבל 1 מפונקציית הנעילה (תפס את המנעול בהצלחה), כל קריאה עתידית בכל חוט תחזיר 0, אפילו אם המנעול פנוי מאחר שהוא חד-פעמי. במנעול חד-פעמי ל-N חוטים מובטח שפונקציית הנעילה של כל מנעול לא נקראת יותר מ-N פעמים בכל ריצת התוכנית. נניח שלרשותנו עומדת פקודת חומרה אטומית ששמה Flip, אשר מבצעת היפוך לוגי לערך כלשהו (כמו אופרטור NOT בוליאני) ומחזירה את ערכו לפני ההיפוך. את הפקודה ניתן לתאר כך: הבהרה: תיאור הפעולה הוא קוד C לצורך הסבר בלבד. פעולת המעבד מבצעת זאת באופן אטומי ולא בכמה פעולות. בכל שאלה זו אין להשתמש באובייקטי סנכרון או פעולות מעבד אטומיות מלבד Flip, ויש לדאוג למניעה הדדית וחופש מקיפאון.", "code_snippet": "int flip(int* val) {\n*val = !*val;\nreturn !*val;\n}", "options": null}, "sub_questions": [{"id": "7.1", "text": "ממשו מנעול חד-פעמי ל-2 חוטים המשתמש בתא זיכרון יחיד (משתנה אחד x המתקבל כפרמטר). יש לממש את הפונקציות הבאות:", "code_snippet": "void init2(int* x) {\n}\nint lock2(int* x) {\n}", "options": null}, {"id": "7.2", "text": "ממשו מנעול חד-פעמי ל-3 חוטים המשתמש ב-2 תאי זיכרון (2 משתנים x,y המתקבלים כפרמטר). יש לממש את הפונקציות הבאות:", "code_snippet": "void init3(int* x, int* y) {\n}\nint lock3(int* x, int y) {\n}", "options": null}, {"id": "7.3", "text": "ממשו מנעול חד-פעמי ל-N חוטים (כאשר N פרמטר בפונקציית האתחול). יש להגדיר את מבנה המנעול (struct CALock) ולממש את הפונקציות הבאות:", "code_snippet": "typedef struct _fliplock {\n} FlipLock;\nvoid init(FlipLock *lock, int N) {\n}\nint lock(FlipLock *lock) {\n}\nvoid destroy (FlipLock *lock) {\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "7.1: 1. נשתמש ב-flip כדי להבדיל בין החוט הראשון שמנסה לתפוס את המנעול לחוט השני. עבור הראשון נחזיר ערך כך שיתפוס בהצלחה את המנעול, ועבור השני לא (ולא להיפך – אחרת יהיה קיפאון אם השני לא ינסה לתפוס את המנעול).\nCode:\nvoid init2(int* x) {\n*x = 1;\n}\nint lock2(int* x) {\nreturn flip(x);\n}\n\n7.2: 2. אם נשתמש באותה שיטה מהסעיף הקודם, החוט הראשון והחוט השלישי יקבלו את אותו ערך. לא ניתן להכריע לטובת החוט השני זה יגרום לקיפאון כי לא מובטח ש-2 חוטים ינסו לתפוס את המנעול. לכן נצטרך להיעזר במשתנה הנוסף. נשתמש ב-ע כדי \"לפסול\" את החוט השני (רק הראשון והשלישי שיבצעו עליו flip יקבלו חזרה 1), ואז נשתמש ב-א כמו בסעיף הקודם כדי להכריע בין 2 החוטים שנשארו.\nCode:\nvoid init3(int* x, int *y) {\n*x = *y = 1;\n}\nint lock3(int* x, int *y) {\nif (flip(y))\nreturn flip(x);\nelse\nreturn 0;\n}\n\n7.3: 3. בדומה לסעיף הקודם, נשתמש בסדרה של משתנים כדי לפסול חלק מהחוטים כל פעם. כל חוט שיקבל 1 מ-flip ימשיך \"להתחרות\" באמצעות המשתנה הבא, ולכל חוט שיקבל 0 (בשלב כלשהו) נחזיר 0 כך שנכשל בתפיסת המנעול. כל פעם ימשיכו חצי מהחוטים (מעוגל מעלה) עד שלבסוף רק חוט אחד \"יזכה\" במנעול.\nCode:\ntypedef struct _fliplock {\nint *arr;\nint size;\n} FlipLock;\nvoid init(FlipLock *lock, int N) {\nlock->size = log2(N)+1; // rounded up\nlock->arr = (int*) calloc(lock->size, sizeof(int));\n}\nint lock(FlipLock *lock) {\nfor (int i = 0; i < lock->size; ++i) {\nif (flip(lock->arr[i]))\nreturn 0;\n}\nreturn 1;\n}\nvoid destroy (FlipLock *lock) {\nfree(lock->arr);\n}"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתונה מערכת עם workload אקראי של 1MB וסדרתי של 50MB. יש לפרט ולנמק את כל החישובים.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "פרטו נתונים של 3 דיסקים קשיחים לבחירתכם כך שיתקיימו התנאים הבאים:\n- דיסק קשיח א' הוא המהיר ביותר בתרחיש הסדרתי.\n- דיסק קשיח ב' הוא המהיר ביותר בתרחיש האקראי.\n- דיסק קשיח ג' אינו האיטי ביותר באף אחד מהתרחישים.\nלכל דיסק יש לפרט קצב העברה מקסימלי, זמן seek, ו-RPM.", "code_snippet": null, "options": ["קצב העברה א': MB/s", "קצב העברה ב': MB/s", "קצב העברה ג': MB/s", "זמן seek א': ms", "זמן seek ב': ms", "זמן seek ג': ms", "קצב RPM א':", "קצב RPM ב':", "קצב RPM ג':", "נימוק:"]}, {"id": "8.2", "text": "משתמש ביצע ניסוי על דיסק כלשהו, והופתע לגלות שהקצב הממוצע בתרחיש הסדרתי (של 50MB) זהה לקצב הממוצע בתרחיש האקראי (של 1MB), עבור אותו דיסק. מה יכולים להיות מאפייני הדיסק כדי להסביר את תוצאה זו?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "8.1: 1. נבחר לכל הדיסקים את אותו RPM כך שלא ישפיע על הביצועים. נרצה: דיסק א' עם קצב העברה מהיר ו-seek איטי, דיסק ב' עם קצב העברה איטי ו-seek מהיר, ודיסק ג' שהוא ממוצע. להלן בחירה אפשרית: דיסק א': 25MB/s, seek 1s דיסק ב': 1MB/s, seek 0.01s דיסק ג': 10MB/s, seek 0.55s כאמור, לא משנה ה-RPM שנבחר כל עוד הוא זהה לשלושתם, ואז זמן ההמתנה לסיבוב לא משפיע על ההבדל ביניהם. בתרחיש הסדרתי: דיסק א' 2 שניות, דיסק ב' 25.01 שניות, דיסק ג' 3 שניות. בתרחיש האקראי: דיסק א' 1.02 שניות, דיסק ב' 0.51 שניות, דיסק ג' 0.55 שניות.\n8.2: 2. יש כמה סיבות אפשריות לתופעה, אחת מהן היא שבדיסק אין track skew וכמות הנתונים הרצופים (בצילינדר) היא 512KB, לכן הגענו למהירות האופטימלית וקריאה של יותר נתונים ברצף גורמת לזמן המתנה ארוך לסיבוב (ועוד זמן seek קצר בין רצועות סמוכות)."}, "difficulty_estimation": "Medium"}]}, {"filename": "os25AA.json", "metadata": {"course_name": "Operating Systems", "year": "2025", "semester": "Semester A", "moed": "Moed A", "exam_date": "04.02.2025", "source_file": "os25AA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "בקורס למדנו מספר רמות של RAID.\nחוו דעתכם על הטענה הבאה: ככל שרמת ה-RAID גבוהה יותר כך הוא טוב יותר.", "code_snippet": null, "options": ["א. הטענה נכונה.", "ב. הטענה לא נכונה.", "ג. לא למדנו מספיק רמות RAID כדי לענות על הטענה.", "ד. 0-RAID לא מספק אמינות ולכן לא ניתן להשוות אותו לרמות האחרות.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. לכל רמת RAID יתרונות וחסרונות, ואין רמה שטובה יותר מרמה אחרת אלא זה תלוי בדרישות (מלבד 5-RAID שטובה יותר מ-4-RAID). הטענה לא נכונה גם אם מסתכלים על ביצועים בנפרד או על אמינות בנפרד."}}, {"id": 2, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling"], "content": {"text": "באלגוריתם התזמון MLFQ, זמן המחזור (turnaround time) הוא אופטימלי.", "code_snippet": null, "options": ["א. הטענה נכונה בתנאי שנקבע קוונטה קצרה מספיק.", "ב. הטענה נכונה בתנאי שנקבע קוונטה ארוכה מספיק.", "ג. הטענה לא נכונה.", "ד. MLFQ אינו אלגוריתם תזמון.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. זמן המחזור האופטימלי הוא באלגוריתם SRTF, באלגוריתם MLFQ יתכן זמן מחזור לא אופטימלי ללא קשר לקוונטה."}}, {"id": 3, "type": "MultipleChoice", "topic": ["Memory Management", "Paging", "Page Replacement", "Virtual Memory"], "content": {"text": "נתון תהליך שמערכת ההפעלה הקצתה לו שלוש מסגרות בלבד (לכל אורך הריצה שלו), אשר בהתחלה כולן פנויות (אף אחד מהדפים של התהליך אינו בזיכרון). התהליך פנה לדפים הבאים (משמאל לימין, כלומר קודם 0 ואז 1 וכן הלאה):\n0, 1, 3, 2, 4, 0, 4, 2, 1, 3, 3, 4\nכמה page faults יהיו אם אלגוריתם החלפת הדפים הוא האופטימלי (OPT)?", "code_snippet": null, "options": ["א. 6.", "ב. 7.", "ג. 8.", "ד. 9.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ב", "explanation": "ב'. 5 הגישות הראשונות הן החטאות (הגישה הראשונה לכל דף). לאחר מכן גישות 9 ו-10 יהיו החטאות (הגישות לדפים 1 .(3-1"}}, {"id": 4, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "נתון דיסק קשיח עם מערכת קבצים נפוצה כלשהי (שאינה VSFS) המחובר למחשב כלשהו. משתמש ניתק את הדיסק מהמחשב וחיבר אותו למחשב אחר בעל מערכת הפעלה שונה. במחשב האחר:", "code_snippet": null, "options": ["א. נוכל להשתמש בדיסק ולראות את הקבצים בו.", "ב. נוכל להשתמש בדיסק אך לא נראה את הקבצים שהיו בו לפני החלפת המחשב.", "ג. לא נוכל להשתמש בדיסק בלי למחוק קודם את כל הקבצים בתוכו.", "ד. לא נוכל להשתמש בדיסק בלי להחליף את מערכת הקבצים שלו למערכת קבצים אחרת (כמו VSFS).", "ה. לא נוכל להשתמש בדיסק כלל."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. מערכת קבצים אינה ספציפית למערכת הפעלה וגם לא הקבצים בה, בכל מערכת הפעלה נוכל להשתמש בדיסק ולראות את הקבצים בו בתנאי שמערכת הקבצים הזו נתמכת באותה מערכת ההפעלה."}}, {"id": 5, "type": "MultipleChoice", "topic": ["Concurrency", "Threads", "Processes"], "content": {"text": "איזו מהטענות הבאות נכונה לגבי מקביליות:", "code_snippet": null, "options": ["א. הגדלת מספר החוטים בתוכנית תמיד תשפר את הביצועים.", "ב. מקביליות מייתרת את הצורך בשימוש באובייקטי סנכרון כמו מנעולים וסמפורים.", "ג. מקביליות משפרת את הביצועים ע\"י הרצת מספר חוטים במקביל על אותו מעבד/ליבה.", "ד. שימוש במקביליות לא רלוונטי במערכות עם מעבד יחיד (עם ליבה אחת).", "ה. ניתן לנצל מקביליות לשיפור ביצועים גם עם מעבד יחיד (עם ליבה אחת)."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. בעזרת מקביליות (concurrency) ניתן לשפר ביצועים גם עם מעבד יחיד לדוגמה ע\"י חפיפה. הבלבול עם מקביליות parallelism לא משנה את התשובה, כפי שנלמד לדוגמה עם ריבוי תהליכים לשיפור זמן המחזור."}}, {"id": 6, "type": "Open", "topic": ["Memory Management", "Paging", "Virtual Memory"], "content": {"text": "נתונה מערכת עם גודל דף של 4KB וטבלת דפים היררכית. כל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת, 14 ביטים של סטטוס ו-20 ביטים של ריפוד. נתון שהגודל של PTE ו-PDE זהה, וכל טבלה/חלק מאוחסנים בדף אחד בדיוק (לא יותר ולא פחות).\nשימו לב: נתונים אלו רלוונטיים לכל סעיפי השאלה. הנתונים הכתובים בסעיפים עצמם מתווספים לנתונים אלו אך ספציפיים לאותו סעיף ואינם תקפים לשאר הסעיפים.\nיש לפרט ולנמק את כל החישובים בכל סעיף.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "נתון שטבלת הדפים של תהליך המשתמש בכל הדפים במרחב הכתובות שלו תופסת 1+512+5122 מסגרות בזיכרון הפיזי. כמה רמות יש בטבלת הדפים, מה מרחב הכתובות של תהליך, ומה גודל הזיכרון הפיזי המקסימלי?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "נתון תהליך אשר משתמש ב-30 דפים במרחב הכתובות שלו, המחולקים ל-4 סגמנטים נפרדים:\n- סגמנט קוד של 5 דפים רצופים.\n- סגמנט נתונים (data) של 5 דפים רצופים.\n- סגמנט ערימה (heap) של 10 דפים רצופים.\n- סגמנט מחסנית (stack) של 10 דפים רצופים.\nכל גישה לכתובת אחרת, שאינה בסגמנטים אלו, תגרום לשגיאה.\nכמו-כן נתון שהזיכרון שתופסת טבלת הדפים של תהליך זה הוא 100KB במקרה המקסימלי.\nכמה רמות יש בטבלת הדפים, ומהו מספר הכניסות בטבלה שהן valid (הסכום הכולל בכל הרמות יחד)?", "code_snippet": null, "options": null}, {"id": "6.3", "text": "נתון שטבלת הדפים במערכת היא ב-3 רמות, ונתון תהליך זהה לתהליך בסעיף הקודם (שאלה 6.2).\nכמה זיכרון תתפוס טבלת הדפים של התהליך במקרה המינימלי, ומה מספר הכניסות בטבלה שהן valid (הסכום הכולל בכל הרמות יחד)?", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. נניח שבכל טבלה נכנסות X רשומות PTE, בכל רמה של טבלה היררכית יש פי X יותר רשומות מאשר הרמה הקודמת. ברמה הראשונה תמיד יש טבלה אחת, ולכן לפי הנתון יש 512 רשומות בכל טבלה ו-3 רמות סה\"כ.\nברמה התחתונה ביותר יש 512^2 טבלאות שבכל אחת 512 רשומות, סה\"כ 512^3 דפים במרחב הכתובות, גודל כל דף 4KB כלומר שמרחב הכתובות הוא 2^39 בתים.\nגודל דף הוא 4KB ובכל טבלה 512 כניסות כלומר כל כניסה היא 8 בתים = 64 ביט. 34 ביט משמשים לסטטוס וריפוד כלומר מספר המסגרת PFN הוא 30 ביט, גודל מסגרת 4KB לכן הזיכרון הפיזי המקסימלי הוא 2^42 בתים.\n2. ברמה העליונה יש טבלה אחת. בכל סגמנט הדפים רצופים ולכן הרשומות המתאימות לדפים של כל סגמנט יתפזרו על פני 2 טבלאות במקסימום, סה\"כ 8 ברמה התחתונה. ל-2 טבלאות האלו יהיו במקרה המקסימלי 2 טבלאות (עם מצביע אחד כל אחת) ברמה מעל, וכן הלאה עד הרמה הראשונה שבה טבלה אחת. גודל הטבלה כולה 100KB שזה 25 דפים – ולכן יש 4 רמות (1 ברמה הראשונה, 8 ברמה 2 + 3 + 4.\nברמה התחתונה יש 30 כניסות valid (אחת לכל דף שהתהליך משתמש בו), ובכל רמה מעל יש 8 כניסות valid בהתאם לחלוקה שתוארה – סה\"כ 54 כניסות valid.\n3. במקרה המינימלי, כל הדפים ממופים לאותה טבלה ברמה התחתונה ולכן עבור 3 רמות יהיו בשימוש בדיוק 3 מסגרות - .12KB\nברמה התחתונה יהיו 30 כניסות valid (אחת לכל דף שהתהליך משתמש בו), ועוד כניסה אחת בכל רמה, סה\"כ 32 .valid כניסות"}}, {"id": 7, "type": "Open", "topic": ["Synchronization", "Concurrency", "Threads", "Semaphores", "Mutexes", "Deadlocks"], "content": {"text": "נתונה מערכת מרובת חוטים עבורה נדרש לנהל מחסן המשתמש בפתרון של בעיית יצרן-צרכן עם התוספת הבאה: כל מוצר נדרש לעבור עיבוד לפני שניתן לצרוך אותו.\nכלומר, פעולת היצרן מייצרת ומוסיפה למחסן מוצר שהוא לפני עיבוד. פעולת הצרכן נדרשת להוציא מהמחסן ולצרוך מוצר שהוא אחרי עיבוד. פעולה נוספת, חדשה, מעבדת מוצר במחסן. על הפתרון לתמוך ב-3 הפעולות הבאות:\n- ()void produce – מייצרת מוצר לא מעובד ומוסיפה אותו אל המחסן.\n- ()void process – מוציאה מוצר לא מעובד מהמחסן, מעבדת אותו, ומחזירה את המוצר המעובד אל המחסן.\n- ()void consume - מוציאה מוצר מעובד מהמחסן וצורכת אותו.\nשימו לב: עיבוד מוצר עלול לקחת זמן רב, ולכן בזמן העיבוד יש לדאוג שפעולת process אינה תופסת מקום במחסן (כלומר, הפעולה מפנה את המדף שתפס המוצר במחסן, ולאחר העיבוד מקצה עבורו מדף מחדש).\nבמערכת מוגדר טיפוס מיוחד Item המייצג מוצר (מעובד או לא מעובד), ומוגדר הקבוע N המייצג את המקום במחסן (כמות המדפים). כלומר, במחסן יש מקום ל-N מוצרים סך הכל (מעובדים ולא מעובדים יחדיו).\nבנוסף נתונות הפונקציות הבאות:\n- Item produce_item() – מייצרת מוצר לא מעובד חדש, ובטוחה לשימוש במקביל.\n- void consume_item(Item) – צורכת מוצר מעובד קיים, ובטוחה לשימוש במקביל (על מוצרים שונים).\n- void add_item(Item) – מקבלת מוצר שאינו קיים במחסן (מעובד או לא מעובד) ומוסיפה אותו אל המחסן. פונקציה זו אינה בטוחה לשימוש במקביל, ואסור לקרוא לה אם כמות המוצרים במחסן היא N.\n- Item del_item() – מוציאה מוצר אחד מהמחסן (מעובד או לא מעובד) ומחזירה אותו. פונקציה זו אינה בטוחה לשימוש במקביל, ואסור לקרוא לה אם כמות המוצרים במחסן היא 0.\n- Item process_item(Item) – מקבלת מוצר לא מעובד, מעבדת אותו, ומחזירה את המוצר המעובד. פונקציה זו בטוחה לשימוש במקביל. אסור לקרוא לה עם מוצר מעובד כפרמטר, או להשתמש במוצר המקורי (הפרמטר שהועבר) לאחר העיבוד, אלא רק בערך ההחזר.\n- BOOL is_processed(Item) – מקבלת מוצר (מעובד או לא מעובד) ומחזירה TRUE אם המוצר מעובד, או FALSE אם המוצר לא מעובד.\nשימו לב: פונקציות אלו נתונות ויש להשתמש בהן (אין צורך לממש אותן). ניתן להניח שהמחסן מתנהג כמו תור FIFO (כלומר, המוצר שהתווסף ראשון ע\"י add_item הוא הראשון שיוחזר ע\"י del_item).", "code_snippet": null, "options": null}, "sub_questions": [{"id": "7.1", "text": "לפי הגדרת המחסן, בכל מימוש יתכן תרחיש דומה לקיפאון בו קיים חוט (אחד או יותר) אשר ביצע עיבוד למוצר וקיים חוט (אחד או יותר) אשר מעוניין לצרוך מוצר מעובד, אך לא ניתן לצרוך את המוצר.\nתארו תרחיש (שאינו תלוי במימוש) אשר מוביל לבעיה זו.", "code_snippet": null, "options": null}, {"id": "7.2", "text": "ממשו את פעולות המחסן בהתאם לדרישות, תוך שימוש באובייקטי סנכרון בלבד (מנעולים, סמפורים, ומשתני תנאי). יש לדאוג לפתרון יעיל ככל האפשר ולהימנע מ-spinning. שימו לב: אין צורך לפתור את הבעיה המתוארת בסעיף הקודם, המימוש אינו תלוי במענה עליו (ניתן לממש באופן מלא גם ללא מציאת הבעיה). תיאור הפתרון: משתנים גלובליים (יש לציין ערכי אתחול בהערה, אין צורך לדאוג לפעולות אתחול והקצאות דינמיות/שחרור זיכרון):", "code_snippet": "void produce() {\n}\nvoid consume() {\n}\nvoid process() {\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. חוט 1 יבצע ()produce עד שהמחסן מלא (N פעמים). חוט 2 יבצע ()process, יוציא מוצר לא מעובד מהמחסן ויתחיל לעבד אותו. חוט 1 יבצע ()produce נוסף לפני שחוט 2 מסיים לעבד, המחסן שוב מלא. חוט 2 יסיים את העיבוד, לא ניתן להוסיף חזרה כי המחסן מלא. חוט 3 יבצע ()consume, אין מוצרים מעובדים במחסן שניתן לצרוך.\n2. את הסמפור full (כמות המוצרים) נפריד ל-2 משאבים נפרדים: מוצרים מעובדים ולא מעובדים. בהוצאת מוצר נוסיף ונסיר מוצרים מהמחסן עד שנגיע למוצר מתאים:\n```c\nsem_t empty;   // # free spots, init to N\nsem_t unprocd; // # unprocessed items, init to 0\nsem_t procd;   // # processed items, init to 0\nsem_t mutex;   // protect access to warehouse, init to 1\n\nvoid produce() {\n    Item i = produce_item();\n    sem_wait(&empty);\n    sem_wait(&mutex);\n    add_item(i);\n    sem_post(&mutex);\n    sem_post(&unprocd);\n}\n\nvoid consume() {\n    sem_wait(&procd);\n    sem_wait(&mutex);\n    Item i = del_item();\n    while (!is_processed(i)) {\n        add_item(i);\n        i = del_item();\n    }\n    sem_post(&mutex);\n    sem_post(&empty);\n    consume_item(i);\n}\n\nvoid process() {\n    sem_wait(&unprocd);\n    sem_wait(&mutex);\n    Item i = del_item();\n    while (is_processed(i)) {\n        add_item(i);\n        i = del_item();\n    }\n    sem_post(&mutex);\n    sem_post(&empty);\n    i = process_item(i);\n    sem_wait(&empty);\n    sem_wait(&mutex);\n    add_item(i);\n    sem_post(&mutex);\n    sem_post(&procd);\n}\n```"}}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Memory Management"], "content": {"text": "נתון כונן SSD בו גודל דף הוא 6KB וגודל בלוק הוא 6MB.\nעל הכונן קיימת מערכת קבצים VSFS בה גודל מצביע הוא 4 בתים, ובכל inode יש 10 מצביעים ישירים, מצביע אחד עקיף, מצביע אחד עקיף כפול, ומצביע אחד עקיף משולש.\nשימו לב: כל התייחסות של מערכת הקבצים אל בלוק בדיסק קשיח יש להחליף עם דף בכונן SSD (ולא בלוק SSD).\nלדוגמה, ה-inode מכיל מצביעים לדפים (ישירים, עקיפים, וכו').\nיש לפרט ולנמק את כל החישובים בכל סעיף.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה דפים של DATA הוא יתפוס בכונן?", "code_snippet": null, "options": null}, {"id": "8.2", "text": "נניח שמעוניינים לקרוא מקובץ מסוים שמאוחסן במערכת הקבצים את הדף שמספרו 17,425 (דפי הקובץ ממוספרים החל מ-0), כאשר מספר ה-inode ידוע מראש, ואף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nהניחו שטבלאות המיפוי (log table + data table) זמינות בזיכרון של הכונן, וזמן הגישה אליהן זניח.\nיש לפרט בקיצור ובצורה מדויקת איך המערכת מאתרת את הדף המבוקש על הכונן, ואת כל פעולות הקריאה וכתיבה של דפים שיש לבצע כדי להשלים את הפעולה.", "code_snippet": null, "options": null}, {"id": "8.3", "text": "סטודנט טען שכתיבה של קובץ גדול בבת אחת תהיה מהירה משמעותית מאשר כתיבה של הקובץ בחלקים, דף אחד שלם של נתונים (6KB) בכל פעם. האם טענת הסטודנט נכונה?", "code_snippet": null, "options": ["הסטודנט צודק", "הסטודנט טועה"]}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. בכל דף עקיף נכנסים 6KB/4B = 1536 מצביעים.\nמצביעים ישירים 10 דפים.\nמצביע עקיף – 1536 דפים. עקיף כפול – 1536^2 דפים. עקיף משולש – 1536^3 דפים.\nסה\"כ: (10+1536+1536^2+1536^3)*6KB.\nבשביל דפים שיתפוס בכונן צריך להוסיף דפי מצביעים:\nמצביע עקיף – 1 דפים. עקיף כפול – 1+1536 דפים. עקיף משולש – 1+1536+1536^2.\nסה\"כ: 1+1536+1536^2+1536^3 + 1+1536+1+1536^2 + 10 דפים\n2. צריך לדלג על 10 הדפים הישירים, על 1536 הדפים שמוצבעים ע\"י המצביע העקיף מדרגה ראשונה ועל עוד 15360 דפים שמוצבעים ע\"י 10 מצביעים עקיפים מדרגה ראשונה שנמצאים בדף המצביעים מדרגה שניה. נותר לדלג על עוד 519 דפים – כלומר לגשת למצביע ה-11 מדרגה ראשונה שנמצא בדף המצביעים מדרגה שניה וממנו לגשת למצביע ה-520 בדף המצביעים הישירים.\nכלומר, יש להביא מהדיסק את: הדף שמכיל את ה-inode הרלוונטי, דף המצביעים מדרגה שניה הראשון, דף המצביעים מדרגה ראשונה שכתובתו היא ה-11 בדף המצביעים מדרגה שניה, דף הנתונים שכתובתו היא ה-520 בדף המצביעים מדרגה ראשונה.\nבכל גישה לדיסק יבוצע ראשית חיפוש בטבלת המיפוי log-table ואם הדף לא נמצא שם יבוצע חיפוש בטבלת המיפוי data-table.\nבנוסף יבוצע עדכון של זמן הגישה האחרון ב-inode הרלוונטי.\nטעויות נפוצות היו לא לפרט לאיזה מצביע ולאיזה דף יש לגשת, או לא לפרט כיצד מבוצע החיפוש של כל דף בכונן ה-SSD (באמצעות טבלאות המיפוי).\n3. הסטודנט טועה.\nכל עוד כותבים דף שלם בכל פעם, אין הבדל משמעותי אם נכתוב הכל בבת אחת או בחלקים בגלל שה-FTL הוא log .structured"}}]}, {"filename": "os25AB.json", "metadata": {"course_name": "Operating Systems", "year": "2025", "semester": "Semester A", "moed": "Moed B", "exam_date": "25.02.2025", "source_file": "os25AB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Memory Management", "I/O", "File Systems"], "content": {"text": "נתונים שני כונני SSD ריקים בעלי נתונים טכניים זהים, וביצעו עליהם בדיוק את אותן פעולות. כלומר, ב-2 הכוננים בוצעו אותן פעולות קריאה/כתיבה עם אותם נתונים לאותם דפים לוגיים ובאותו סדר.\nאיזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["א. מיפוי הדפים הלוגיים לפיזיים יהיה זהה בין הכוננים, ודפים אלו יכילו את אותם נתונים.", "ב. מיפוי הדפים הלוגיים לפיזיים עלול להיות שונה בין הכוננים, אך דפים אלו יכילו את אותם נתונים.", "ג. מיפוי הדפים הלוגיים לפיזיים יהיה זהה בין הכוננים, אך יתכן שחלק מדפים אלו (או כולם) יכילו נתונים שונים.", "ד. מיפוי הדפים הלוגיים לפיזיים עלול להיות שונה בין הכוננים, ויתכן שחלק מדפים אלו (או כולם) יכילו נתונים שונים.", "ה. לא ניתן לבצע את אותן פעולות על 2 הכוננים."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. בגלל שהשחיקה אקראית, יתכן שאותם דפים לוגיים יהיו ממופים לדפים פיזיים שונים בכונן (גם עם אותן גישות). בגלל הפרעות קריאה/כתיבה (read disturbs / program disturbs) יתכן שדפים אלו גם ישתבשו ויכילו נתונים שונים (בכונני SSD זה מטופל ע\"י מנגנונים לזיהוי ותיקון שגיאות)."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Virtual Memory", "Paging", "Page Replacement"], "content": {"text": "נתון תהליך שמערכת ההפעלה הקצתה לו שלוש מסגרות בלבד (לכל אורך הריצה שלו), אשר בהתחלה כולן פנויות (אף אחד מהדפים של התהליך אינו בזיכרון). התהליך פנה לדפים הבאים (משמאל לימין, כלומר קודם 0 ואז 1 וכן הלאה):\n0, 1, 3, 2, 4, 0, 4, 2, 1, 3, 3, 4\nכמה page faults יהיו אם אלגוריתם החלפת הדפים הוא MRU (Most Recently Used) (הפוך ל-LRU)?", "code_snippet": null, "options": ["א. 6", "ב. 7", "ג. 8", "ד. 9", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. 5 הגישות הראשונות הן החטאות (הגישה הראשונה לכל דף). לאחר מכן גישות 8,10,2 יהיו החטאות (הגישות לדפים 4-1,3,2)."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["I/O", "System Calls"], "content": {"text": "מה תפקידו של ה-DMA?", "code_snippet": null, "options": ["א. סיוע בתרגום כתובות וירטואליות.", "ב. ביצוע החלפת הקשר (context switch)", "ג. העברת מידע בין התקני קלט-פלט והזיכרון.", "ד. סיוע למתזמן (scheduler) בקבלת החלטה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. כפי שנלמד, ה-DMA משמש להעברת מידע בין התקני קלט-פלט והזיכרון במקום שהמעבד יעסוק בכך."}, "difficulty_estimation": "Easy"}, {"id": 4, "type": "CodeAnalysis", "topic": ["Processes", "System Calls"], "content": {"text": "נתונה התוכנית הבאה:\nתזכורת: באופרטור &&, אם האופרנד הראשון הוא FALSE, לא נבדק/מבוצע האופרנד השני.\nכמה תהליכים נוצרו במהלך הרצת התוכנית, כולל התהליך הראשי?", "code_snippet": "int main()\n{\n    for (int i = 0; i < 3; ++i) {\n        if (!fork() && !fork()) {\n            break;\n        }\n    }\n}", "options": ["א. 7", "ב. 8", "ג. 15", "ד. 18", "ה. 31"]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. בכל איטרציה של הלולאה, התנאי גורם ליצירת 2 תהליכים חדשים. באיטרציה הראשונה התהליך הראשי יוצר 2 תהליכי בנים, אחד מסיים ואחד ממשיך הלאה. הראשי והבן שהמשיך הלאה יוצרים כל אחד 2 תהליכי בנים, מתוכם 2 ממשיכים הלאה בנוסף לתהליך הראשי והבן מהאיטרציה הראשונה, סה\"כ נוצרו 7. לאיטרציה השלישית מגיעים 4 תהליכים שכל אחד יוצר 2 תהליכי בנים ל-8 תהליכים נוספים, סה\"כ 15."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Synchronization", "Threads", "Mutexes", "Atomic Operations"], "content": {"text": "נתונה מערכת עם 1+N חוטים בה נעשה שימוש במנעול ALock) Anderson) עם מערך בגודל N.\nא. המנעול עובד באופן תקין.\nב. המנעול מקיים מניעה הדדית.\nג. המנעול מקיים חופש מקיפאון והוגנות.\nד. נקבל שגיאת קומפילציה או ריצה: לא ניתן לממש מנעול עם מערך בגודל N במערכת עם 1+N חוטים.\nה. כל התשובות האחרות אינן נכונות.", "code_snippet": null, "options": ["א. המנעול עובד באופן תקין.", "ב. המנעול מקיים מניעה הדדית.", "ג. המנעול מקיים חופש מקיפאון והוגנות.", "ד. נקבל שגיאת קומפילציה או ריצה: לא ניתן לממש מנעול עם מערך בגודל N במערכת עם 1+N חוטים.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. אם נשתמש במנעול אנדרסון עם מערך בגודל N במערכת בה יש 1+N חוטים, המנעול לא יקיים אף אחת מהתכונות."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Virtual Memory", "Paging", "Memory Management", "Page Replacement"], "content": {"text": "נתבונן בקטע הקוד הבא שבו מוכפלות 2 מטריצות (המערך c מכיל בהתחלה רק אפסים):", "code_snippet": "int a[1024][1024], b[1024][1024], c[1024][1024];\n\nvoid multiply() {\n    for (int i = 0; i < 1024; i++)\n        for (int j = 0; j < 1024; j++)\n            for (int k = 0; k < 1024; k++)\n                c[i][j] += a[i][k] * b[k][j];\n}", "options": null}, "sub_questions": [{"id": "6.1", "text": "נתונות ההנחות הבאות:\n- גודל דף הוא 4KB.\n- הקוד של הפונקציה multiply מאוחסן בדף אחד.\n- במהלך הפעלת הפונקציה, המחסנית כולה מאוחסנת בדף אחד.\n- משתנה מטיפוס int תופס 4 בתים.\n- ב-TLB יש 8 כניסות, ואלגוריתם פינוי הדפים בו הוא LRU.\n- ה-TLB ריק בתחילת הפונקציה.\n- כל אחד מהמערכים a, b, c מתחיל בדיוק בתחילת הדף בו הוא נמצא.\nשימו לב: בשפת C, מערך דו-ממדי (כמו a) מאוחסן בזיכרון \"לפי שורות\", קודם איברי השורה הראשונה ואז איברי השורה השניה וכן הלאה. כלומר, קודם a[0][0] ואז a[0][1]...a[0][1023] ואז a[1][0]...a[1][1023] וכן הלאה עד השורה האחרונה a[1023][0]...a[1023][1023].\nכמה החטאות TLB (TLB misses) יהיו בזמן ביצוע הקוד?", "code_snippet": null, "options": null}, {"id": "6.2", "text": "הציעו שינוי לקוד אשר יביא את מספר ההחטאות למינימום (כך שהמטריצה c עדיין תכיל בסוף הריצה את אותה תוצאה).\nאין צורך לממש את השינוי, אלא רק לפרט אותו באופן ברור.\nכמה החטאות TLB (TLB misses) יהיו בזמן ביצוע הקוד עם השינוי?", "code_snippet": null, "options": null}], "points": 15, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "שאלה 6\n1. אחרי שהדפים בהם נמצאים הקוד והמחסנים יובאו ל-TLB הם יישארו שם באופן קבוע כי ניגשים אליהם לעיתים קרובות ופינוי הדפים מה-TLB נעשה לפי LRU. לכן עבור כל אחד משני הדפים (של הקוד ושל המחסנית) תהיה רק החטאה אחת – בפעם הראשונה שיגשו אליהם, בסה\"כ 2 החטאות.\nהקוד ניגש למערך a \"לפי שורות\" כלומר קודם לכל איברי השורה הראשונה של a, לאחר מכן לכל איברי השורה השניה של a וכן הלאה. בין כל 2 גישות לדף המכיל שורה של a תהיה גישה רק לארבעה דפים אחרים – דף המכיל איבר של b, דף המכיל איבר של c, הדף המכיל את הקוד והדף עם המחסנית.\nלכן, ברגע שדף המכיל שורה של a יובא ל-TLB הוא לא יפונה משם בזמן שהקוד משתמש בו כי הוא יישאר בין 5 הדפים שהם most recently used וב-TLB יש מקום ל-8 דפים. לכן יהיה צורך להביא כל דף של a (כל שורה של a נכנסת בדיוק בדף אחד) רק פעם אחת ל-TLB. איברי a מאוחסנים ב-1024 דפים כך שהגישות ל-a יגרמו ל-1024 החטאות.\nדבר דומה נכון גם עבור הגישות לדפים של c – 1024 החטאות נוספות.\nבכל איטרציה של הלולאה החיצונית, הקוד ניגש ל-b \"לפי עמודות\", כלומר קודם לכל איברי העמודה הראשונה, אחרי זה לאיברי העמודה השניה וכן הלאה. הבעיה היא שאיברים עוקבים באותה עמודה נמצאים בדפים שונים (עמודה אחת מתפרשת על פני כל הדפים של b).\nכתוצאה מכך כל הגישות ל-b יסבלו מהחטאות, ויש 1024^3 גישות כאלו.\nסה\"כ קיבלנו 2+1024+1024+1024^3 החטאות.\n\n2. נשמור את איברי המערך b בצורה הפוכה (מטריצה משוחלפת).\nכעת ניגש ל-b \"לפי שורות\", כלומר שעבור כל שורה של c נקבל 1024 החטאות בגישה ל-b, סה\"כ 1024^2 החטאות בגישה ל-b, ונקבל מספר החטאות כולל של: 2+1024+1024+1024^2\nהיפוך המטריצה b גורר 1024^2 החטאות נוספות, אך לא נדרש לפרט את זה בתשובה."}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Semaphores", "Mutexes", "Concurrency", "Atomic Operations", "Threads"], "content": {"text": "בשאלה זו יש לממש את אובייקט הסנכרון סמפור (Semaphore). כלומר, יש להגדיר את שדות האובייקט ולממש את הפעולות: sem_wait, sem_post. בכל סעיף יש לספק מימוש נפרד, בהתאם למגבלות המפורטות באותו סעיף.\nיש לדאוג למימוש יעיל ככל האפשר (ללא spinning) המקיים הוגנות וחופש מקיפאון.\nניתן להשתמש בקריאת המערכת ()yield.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "7.1", "text": "בסעיף זה יש לממש סמפור באמצעות מנעולים ומשתני תנאי בלבד: pthread_mutex_t, pthread_cond_t.\nתיאור הפתרון:\nהגדרת הסמפור (יש לציין ערכי אתחול בהערה, אין צורך לדאוג לפעולות אתחול והקצאות דינמיות/שחרור זיכרון):", "code_snippet": "typedef struct _sem_t1 {\n} sem_t1;\n\nvoid sem_wait(sem_t1 *sem) {\n}\n\nvoid sem_post(osem_t1 *sem) {\n}", "options": null}, {"id": "7.2", "text": "בסעיף זה יש לממש סמפור באמצעות פעולות מעבד אטומיות בלבד: testAndSet, compareAndSet, fetchAndAdd, fetchAndSub.\nתיאור הפתרון:\nהגדרת הסמפור (יש לציין ערכי אתחול בהערה, אין צורך לדאוג לפעולות אתחול והקצאות דינמיות/שחרור זיכרון):", "code_snippet": "typedef struct _sem_t2 {\n} sem_t2;\n\nvoid sem_wait(sem_t2 *sem) {\n}\n\nvoid sem_post(sem_t2 *sem) {\n}", "options": null}], "points": 10, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "שאלה 7\n1. עם מנעולים ומשתנאי תנאי, נגן על הסמפור באמצעות מנעול ונשתמש במשתנה תנאי להמתנה:\ntypedef struct _sem_t1 {\n    pthread_mutex_t lock;\n    pthread_cond_t cond;\n    int counter; // init to semaphore init value\n} sem_t1;\n\nvoid sem_wait(sem_t1 *sem) {\n    pthread_mutex_lock(&sem->lock);\n    while (sem->counter == 0) {\n        pthread_cond_wait(&sem->cond, &sem->lock);\n    }\n    --sem->counter;\n    pthread_mutex_unlock(&sem->lock);\n}\n\nvoid sem_post(sem_t1 *sem) {\n    pthread_mutex_lock(&sem->lock);\n    ++sem->counter;\n    pthread_cond_signal(&sem->cond);\n    pthread_mutex_unlock(&sem->lock);\n}\n\n2. עם פעולות מעבד אטומיות, נממש מעין ticket-lock לגישה לערך הסמפור:\ntypedef struct _sem_t2 {\n    int ticket; // init to 0\n    int turn; // init to 0\n    int counter; // init to semaphore init value\n} sem_t2;\n\nvoid sem_wait(sem_t2 *sem) {\n    int myticket = fetchAndAdd(&sem->ticket);\n    while (myticket != sem->turn)\n        yield();\n    while (sem->counter == 0)\n        yield();\n    fetchAndSub(&sem->counter);\n    fetchAndAdd(&sem->turn);\n}\n\nvoid sem_post(sem_t2 *sem) {\n    fetchAndAdd(&sem->counter);\n}\n\nמימוש אפשרי נוסף דומה למנעול-N (מתוך מבחן 22BC). קריאה ל-wait שקולה להמתנה לתור (כניסה לקטע הקריטי),\nוקריאה ל-post שקולה ליציאה מהקטע הקריטי (המאפשרת לחוט נוסף לבצע wait בהצלחה):\ntypedef struct _sem_t2 {\n    int ticket; // init to 0\n    int turn; // init to semaphore init value\n} sem_t2;\n\nvoid sem_wait(sem_t2 *sem) {\n    int myticket = fetchAndAdd(&sem->ticket);\n    while (myticket > sem->turn)\n        yield();\n}\n\nvoid sem_post(sem_t2 *sem) {\n    fetchAndAdd(&sem->turn);\n}"}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O", "Disk Scheduling"], "content": {"text": "נתון דיסק קשיח ועליו מערכת קבצים VSFS עם שדרוג: בכל inode יש מקום ל-256 בתים של נתונים של הקובץ.\nבתים אלו נשמרים בשדה בתוך ה-inode עצמו, ולא בתוך בלוק DATA כמו שאר נתוני הקובץ. רק כאשר גודל הקובץ חורג מכמות זו, מערכת הקבצים תשתמש במצביעים עבור המשך נתוני הקובץ.\nכמו-כן נתון:\n- מהירות הסיבוב של הדיסק (RPM) היא 7500.\n- זמן ה-seek הממוצע של הדיסק הוא 15ms.\n- קצב ההעברה המקסימלי של הדיסק הוא MB/s 1.\n- גודל בלוק הוא 4KB וגודל מצביע הוא 8 בתים.\n- גודל inode הוא 512 בתים (כולל 256 הבתים של הנתונים).\n- בכל inode יש 9 מצביעים ישירים, 3 מצביעים עקיפים, ומצביע עקיף כפול אחד.\n- בנתונים (DATA) של תיקייה קיימת טבלה עם 2 עמודות, גודל כל שורה בטבלה הוא מספר התווים בשם הקובץ (בית אחד לכל תו) + בית אחד נוסף.\n- גודל הנתונים של קישור סימבולי הוא בית אחד לכל תו.\nיש לפרט ולנמק את כל החישובים בכל סעיף.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "מה הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה, וכמה בלוקים של DATA הוא יתפוס?", "code_snippet": null, "options": null}, {"id": "8.2", "text": "משתמש ביצע פעולת קריאה של 116KB מתוך הקובץ: home/mta/os/symlink/\n/usr/tmp/data/myfile :ידוע שקובץ זה הוא קישור סימבולי אל הקובץ\nפעולת הקריאה היא מתחילת הקובץ, ונתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nמה הזמן המינימלי שתיקח פעולה זו?\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.", "code_snippet": null, "options": null}, {"id": "8.3", "text": "סטודנט טען כי מספר הקבצים המקסימלי שנוכל לגשת אליהם במערכת קבצים זו הוא חסום וקטן מאוד, למרות שאין מידע על טבלת ה-inodes (ואפילו אם הטבלה תהיה גדולה).\nהאם טענת הסטודנט נכונה? אם כן, יש לציין איזה נתון מגביל את מספר הקבצים הנגישים המקסימלי ומה המספר. אחרת, יש לציין איזה נתון חסר כדי שנוכל לחשב את מספר זה, ומהו המספר (כפונקציה של הנתון החסר).", "code_snippet": null, "options": null}], "points": 5, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "שאלה 8\n1. בכל בלוק עקיף נכנסים 4096/8 = 512 מצביעים.\nלפי המצביעים ב-inode נקבל 512^2 + 512*3 + 9 בלוקים עם נתוני הקובץ, לזה נוסיף את 256 הבתים בתוך ה-inode עצמו.\nבשביל כמות הבלוקים נוסיף את הבלוקים של המצביעים – 3 עקיפים, ואחד עקיף כפול שמוביל לעוד 512 עקיפים,\nסה\"כ: 1+512+512^2 + 512*3+3 + 9 בלוקים\n\n2. כדי לבצע את הקריאה נצטרך לקרוא תחילה inode + DATA של 4 תיקיות ואז של הקובץ symlink עצמו ( + inode DATA). לאחר מכן נצטרך לקרוא עוד 3 תיקיות של הנתיב השני ואז את הקובץ myfile עצמו.\nסה\"כ 9 פעמים inode + DATA. בכל בלוק יש inodes 8, במקרה המינימלי ה-DATA הנדרש יהיה בתוך 256 הבתים של כל ה-inodes וכולם ישבו ב-2 בלוקים רציפים.\nלאחר מכן נצטרך לקרוא את נתוני הקובץ עצמם. 116KB זה 29 בלוקים (גם אחרי הפחתה של 256 בתים), כלומר שנצטרך להשתמש במצביע עקיף אחד – סה\"כ 30 בלוקים לקריאה. במקרה המינימלי כל הבלוקים האלו נמצאים באופן רציף ומיד אחרי 2 הבלוקים של ה-inodes שקראנו קודם. כלומר, ההעברה כולה היא קריאה רציפה של 32 בלוקים.\nבמקרה המינימלי לא יהיה זמן seek והמתנה לסיבוב, כלומר שזמן הפעולה הוא קריאת הבלוקים בלבד. בנוסף במקרה המינימלי כל הבלוקים יושבים ברצף (2 הבלוקים של inodes ומיד אחריהם כל ה-DATA), כך שזמן הפעולה הוא ההעברה של 32 בלוקים.\nלפי קצב העברה של 1MB/s, להעביר 32 בלוקים (128KB) זה בדיוק שמינית שניה, כלומר 125 מילישניות.\nהפעולה גם מעדכנת את זמן הגישה ב-inode (תוספת של 3.9ms), אך זה לא נדרש בבדיקה ובמקרה המינימלי.\nהתייחסות לכמות הנתונים שנקראו בפועל מכל בלוק היא לא נכונה, כי ההנחה שהפעולה רציפה אומרת שנקרא את כל הנתונים לאורך הדרך (אי אפשר \"לקפוץ\").\n\n3. הסטודנט צודק.\nמאחר שכל רשומה בתיקייה מכילה רק 8 ביטים בנוסף לשם הקובץ, ניתן לגשת רק למספרי inode הניתנים לייצוג ע\"י 8 ביטים, כלומר רק ל-256 קבצים."}, "difficulty_estimation": "Hard"}]}, {"filename": "os25AC.json", "metadata": {"course_name": "Operating Systems", "year": "2025", "semester": "Semester A", "moed": "Moed C", "exam_date": "26.03.2025", "source_file": "os25AC.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Synchronization", "Deadlocks", "Concurrency"], "content": {"text": "איזו טענה נכונה?", "code_snippet": null, "options": ["א. בכל מנעול בו מתאפשר קיפאון, בהכרח תיתכן גם הרעבה.", "ב. בכל מנעול בו מתאפשרת הרעבה, בהכרח יתכן גם קיפאון.", "ג. קיים מנעול בו מתאפשרים גם קיפאון וגם הרעבה, אך לא בכל מנעול בו מתאפשר אחד בהכרח יתכן גם השני.", "ד. לא קיים מנעול בו מתאפשרים גם קיפאון וגם הרעבה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ג", "explanation": "ג'. ראינו מנעולים שלא מקיימים חופש מקיפאון וכן מקיימים הוגנות, וגם להיפך, אך לא כל המנעולים כאלו."}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Virtual Memory", "Paging", "Memory Management"], "content": {"text": "אם נגדיל את ה-TLB:", "code_snippet": null, "options": ["א. בהכרח נגדיל את ה-hit ratio.", "ב. לא יתכן שנקטין את ה-hit ratio.", "ג. נתפוס יותר מקום בזיכרון הפיזי (RAM) עבור הרשומות הנוספות.", "ד. נתפוס פחות מקום בזיכרון הפיזי (RAM) בגלל שהרשומות יעברו ל-TLB.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. הגדלת ה-TLB יכולה להקטין את ה-hit ratio (אך לא בהכרח תעשה זאת). אין קשר בין גודל ה-TLB לבין כמות הזיכרון שנתפוס ב-RAM, ה-TLB רק חוסך גישות לטבלאות הדפים."}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["File Systems", "I/O", "Disk Scheduling"], "content": {"text": "נתון כונן SSD ובו קובץ שניגשים אליו פעמים רבות לקריאה בלבד. איזו טענה נכונה?", "code_snippet": null, "options": ["א. הגישות יגרמו לכך שיהיו יותר הפרעות בדיסק וסיכוי לשינוי הנתונים.", "ב. הגישות יגרמו לכך שיהיו פחות הפרעות בדיסק וסיכוי לשינוי הנתונים.", "ג. הגישות יאיצו את שחיקת הדיסק.", "ד. הגישות יאטו את שחיקת הדיסק.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "א", "explanation": "א'. בביצוע גישות רבות לאותם מיקומים בכונן SSD יש הפרעות קריאה, אשר עלולות לשנות ביטים סמוכים."}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Synchronization", "Deadlocks", "I/O", "Disk Scheduling"], "content": {"text": "איזו טענה נכונה?", "code_snippet": null, "options": ["א. בשימוש במנעולים המקיימים חופש מקיפאון, לא ניתן להגיע לקיפאון.", "ב. בשימוש במנעולים המקיימים הוגנות, לא ניתן להגיע להרעבה.", "ג. שימוש ב-DMA חוסך את זמן העברת הנתונים מ/אל ההתקן בלבד.", "ד. בתזמון SCAN לעומת C-SCAN אין הבדל במרחק (הנמדד בסקטורים) שיעבור הראש הקורא-כותב, אלא רק בסדר הטיפול בבקשות.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ה", "explanation": "ה'. הקיפאון הקלאסי מתאפשר גם במנעולים המקיימים חופש מקיפאון, וראינו את אותו דבר גם עבור הרעבה (לדוגמה, במימוש מנעול קוראים-כותבים מתאפשרת הרעבה גם בשימוש במנעולים הוגנים). שימוש ב-DMA חוסך גם את זמן הטיפול בפסיקות של פעולה גדולה (אשר מחלקים לחלקים), ובתזמון SCAN ניתן לעבור מרחק קצר יותר בהתאם לסדר הטיפול (ראו מבחן 22BB)."}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Virtual Memory", "Paging", "Memory Management"], "content": {"text": "נתונה מערכת בה כל המסגרות בזיכרון תפוסות ושטח ההחלפה (swap) מלא לחלוטין. איזו טענה בהכרח נכונה לגבי מערכת זו?", "code_snippet": null, "options": ["א. לא ניתן לטפל באף page fault", "ב. לא ניתן להקצות זיכרון חדש לתהליכים.", "ג. אם מתקיים 1=Dirty עבור כל המסגרות בזיכרון, לא נוכל לבצע page out.", "ד. אם מתקיים 0=Dirty עבור מסגרת כלשהי בזיכרון, נוכל לבצע page in.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": true, "correct_option": "ד", "explanation": "ד'. נוכל לטפל ב-page fault מאחר ויתכן וניתן לפנות דף שנמצא כבר בדיסק (נכון גם אם 1=Dirty עבורו), ובהתאם נוכל להקצות זיכרון חדש ע\"י פינוי שדף שכזה. אם מתקיים 0=Dirty לדף במסגרת כלשהי אז בהכרח נוכל לפנות את מסגרת זו ולכן נוכל לבצע page in לדף חדש."}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "CodeAnalysis", "topic": ["Processes", "System Calls", "Concurrency"], "content": {"text": "נתונה התוכנית הבאה:\nתזכורת: באופרטורים &&, ||, אם התוצאה ידועה לפי האופרנד הראשון, לא נבדק/מבוצע האופרנד השני. ניתן להניח שכל הקריאות ל-fork הצליחו, והקובץ echo קיים במערכת.", "code_snippet": "int main() {\n  int r1 = !fork() || fork();\n  if (r1) {\n    char* args[3] = {\"echo\", \"r1: TRUE\", NULL};\n    execvp(args[0], args);\n    printf(\"r1: TRUE\\n\");\n  } else {\n    printf(\"r1: FALSE\\n\");\n  }\n  wait(NULL);\n\n  int r2 = !fork() && fork();\n  if (r2) {\n    char* args[3] = {\"echo\", \"r2: TRUE\", NULL};\n    execvp(args[0], args);\n  }\n  else {\n    printf(\"r2: FALSE\\n\");\n  }\n  if (r1 || r2)\n    printf(\"END\\n\");\n}"}, "sub_questions": [{"id": "6.1", "text": "כתבו פלט אפשרי של התוכנית הנתונה בהנחה שכל קריאות המערכת הצליחו, וציירו את עץ התהליכים שנוצר בעקבות הריצה שמובילה לפלט זה (יש לציין לכל תהליך בעץ את מזהה התהליך שלו). כמה תהליכים נוצרו במערכת, כולל התהליך הראשי?\nמספר תהליכים:\nפלט אפשרי ונימוק:\nעץ התהליכים:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "האם יתכנו זומבים בשלב כלשהו במהלך הריצה? אם כן, יש לציין את כל תהליכי הזומבים האפשריים בכל שלב, אחרת להסביר מדוע לא. יתכנו זומבים / לא יתכנו זומבים", "code_snippet": null, "options": null}, {"id": "6.3", "text": "נניח שלא נתונה ההנחה שהקובץ echo קיים במערכת, אלא נתון שלא קיים הקובץ echo במערכת. האם מספר התהליכים בתשובה לסעיף הראשון (שאלה 6.1) ישתנה? אם כן, יש לציין את התשובה לאחר השינוי, אחרת להסביר מדוע אין שינוי. התשובה תשתנה: / התשובה לא תשתנה", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. נניח שהתהליך המקורי הוא 100. בשורה 2 נוצרים 2 תהליכי בנים חדשים – 101, 102. עבור תהליך האב 100 ותהליך הבן הראשון שנוצר 101 מתקיים התנאי בשורה 3, הקריאה ל-execvp בשורה 5 לא חוזרת. תהליך הבן השני שנוצר 102 מגיע ל-wait בשורה 10 ואין לו בנים, לכן מיד ימשיך הלאה. בשורה 12 נוצרים 2 תהליכים חדשים תחת 102: תהליך הבן שלו 103 ותהליך נכד 104. התנאי בשורה 13 מתקיים עבור תהליך 103 בלבד, שמגיע ל-execvp בשורה 15 ולא ממשיך הלאה. אף אחד לא ידפיס את הפלט בשורה 20 (עבור 2 התהליכים שנותרו 102,104, מתקיים 0==r1==r2). סה\"כ נוצרו 5 תהליכים.\nפלט:\nr1: TRUE\nr1: TRUE\nr1: FALSE\nr2: TRUE\nr2: FALSE\nr2: FALSE\n\n2. כל תהליך יכול להיות זומבי מלבד התהליך הראשי (שלא ידוע לגביו). אין אף מנגנון שמכתיב סדר בין התהליכים. בכל נקודה בריצה, כל תהליך בן שמסתיים לפני תהליך האב שלו יהפוך לזומבי עד שתהליך האב יסתיים גם.\n\n3. אם echo לא קיים אז כל הקריאות ל-execvp יכשלו והתהליכים ימשיכו הלאה לפקודה הבאה במקום לא לחזור מהקריאה. 2 התהליכים 101, 100, שהגיעו לשורה 5 ימשיכו לשורה 12 (תהליך 100 ימתין עד שאחד מתהליכי הבנים שלו יסתיים), כך שכל אחד מהם מייצר 2 תהליכים נוספים שלא נוצרו קודם (בן ונכד לכל אחד). נוספו 4 תהליכים שלא היו קודם, סה\"כ 9 תהליכים."}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "Open", "topic": ["Synchronization", "Threads", "Concurrency"], "content": {"text": "Barrier הוא אובייקט סנכרון ל-N חוטים (N פרמטר אתחול) עם פעולה אחת: checkin, אשר נועדה לסנכרון שלב הביצוע של N החוטים. בקריאה לפעולה checkin, כל חוט הקורא לפעולה ממתין עד שכל N החוטים ביצעו קריאה לפעולה. רק כאשר כל N החוטים ביצעו קריאה ל-checkin, הקריאה חוזרת עבור כולם והם ממשיכים לפקודה הבאה. במילים אחרות, חוט שקורא ל-checkin חסום (הקריאה לא חוזרת) עד ש-N חוטים (כולל אותו) קוראים ל-checkin. החוט ה-N שמבצע קריאה ל-checkin (ה\"אחרון\") משחרר מחסימה את כל החוטים, שממשיכים לרוץ מהפקודה הבאה. שימו לב: הפעולה checkin אינה חד-פעמית. לאחר חזרה מקריאה ל-checkin ניתן לקרוא שוב לפעולה ולחכות שוב – עד אשר כל החוטים גם יקראו שוב ל-checkin, וכן הלאה. בשאלה זו ניתן להתעלם מגבולות int ולהניח שהייצוג אינסופי (אין overflow), וניתן להשתמש ב-spinning.", "code_snippet": "typedef struct {\n  int N;\n  int *arr;\n} Barrier;\n\nvoid init(Barrier *bar, int N) {\n  bar->N = N;\n  bar->arr = (int*) calloc(sizeof(int), N);\n}\n\nvoid destroy (Barrier *bar) {\n  free(bar->arr);\n}"}, "sub_questions": [{"id": "7.1", "text": "נתונה מערכת עם N חוטים בה לכל חוט יש מזהה i (בין 0 ל-N-1) אשר מועבר כפרמטר לפעולת checkin, ונתון מימוש Barrier המשתמש במערך בגודל N. השלימו את המימוש ע\"י כתיבת הקוד של הפעולה checkin, ללא שימוש בפעולות אטומיות או אובייקטי סנכרון אחרים. אין להוסיף שדות למבנה או לשנות את הקוד הנתון מלבד היכן שנדרש.\nvoid checkin (Barrier *bar, int i) {\n}", "code_snippet": "void checkin (Barrier *bar, int i) {\n}", "options": null}, {"id": "7.2", "text": "נתונה אותה מערכת מהסעיף הקודם עם אותו מימוש חלקי ל-Barrier, אך עם מגבלה חדשה: כל תא במערך arr הוא טרינארי, כלומר שהוא יכול להכיל אחד משלושת הערכים 0, 1, 2 בלבד. תארו את השינוי הנדרש ל-Barrier בהשוואה לסעיף הקודם, והשלימו את המימוש המעודכן של checkin עם המגבלה הנתונה, ללא שימוש בפעולות אטומיות או אובייקטי סנכרון אחרים. אין להוסיף שדות למבנה או לשנות את הקוד הנתון מלבד היכן שנדרש. שימו לב: ערך טרינארי אומר שבמידה ונגדיל תא המכיל את הערך 2, התא יעודכן אל הערך 0. לא ניתן לעדכן ערכים גדולים מ-2 או קטנים מ-0 אל תוך אף תא במערך arr.\nvoid checkin (Barrier *bar, int i) {\n}", "code_snippet": "void checkin (Barrier *bar, int i) {\n}", "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. התשובה זהה לשאלה 7 במבחן 22AB.\n\n2. למעשה אין צורך בשינוי בקוד מלבד תנאי ה-while, שצריך לעדכן כך שכל חוט מחכה לערך זהה לתא שלו או זה שאחריו (אם אחרי ההגדלה הערך הוא 0 - נחכה שאחרים יהיו 0 או 1, אם 1 – נחכה שאחרים יהיו 1 או 2, ואם 2 – נחכה שאחרים יהיו 2 או 0). במימוש מהסעיף הקודם, לא יתכן שאף חוט \"ישיג\" חוט אחר ביותר מ-1 ולכן ערך טרינארי הוא למעשה מספיק. במידה והערך של החוט הנוכחי הוא 0 לפני קידום התא, אז לפי התנאי בפסקה הקודמת כל חוט אחר שמשתמש ב-Barrier מכיל בתא שלו 0 (עוד לא קידם את המונה) או 1 (קידם את המונה וממתין לפחות לחוט הנוכחי). אם החוט הנוכחי קידם את הערך בתא שלו ל-1 אז לכל חוט אחר יתכן שיש בתא: 0 (אם עוד לא קרא ל-checkin) 1 (אם כבר קרא ל-checkin ואז נוכל להתקדם), 2 (אם כבר קרא ל-checkin והתקדם בעצמו וקרא ל-checkin שוב, ועכשיו בהכרח חסום עד שהחוט הנוכחי יקרא ל-checkin שוב)."}, "difficulty_estimation": "Medium"}, {"id": 8, "type": "Open", "topic": ["I/O", "Disk Scheduling", "File Systems"], "content": {"text": "נתונה מערכת עם workload אקראי של 512KB וסדרתי של 100MB. בנוסף נתונים שלושה דיסקים קשיחים עם הנתונים הבאים:\nRPM\nSEEK TIME\nTRANSFER RATE\nGHOST\n7200\n10ms\n200 MB/s\nFUSION\n15000\n10ms\n150 MB/s\nSENSOR\n5400\n5ms\n100 MB/s\nיש לפרט ולנמק את כל החישובים.", "code_snippet": null}, "sub_questions": [{"id": "8.1", "text": "איזה דיסק קשיח נעדיף עבור ה-workload האקראי, ואיזה נעדיף עבור הסדרתי?\nעבור האקראי:\nעבור הסדרתי:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "עבור ה-workload הסדרתי, מה אחוז הביצועים שנגיע אליו עבור כל אחד מהדיסקים הקשיחים? כלומר, מה היחס (באחוזים) בין המהירות בפועל לבין המהירות המקסימלית של כל דיסק.\n:GHOST\n:FUSION\n:SENSOR", "code_snippet": null, "options": null}, {"id": "8.3", "text": "לשיפור ביצועים ב-workload האקראי, הוחלט להשתמש במערך 4-RAID של דיסקים קשיחים מסוג FUSION. מה המספר המינימלי של דיסקים שנצטרך כדי לשפר את הביצועים על פני שימוש בדיסק אחד ללא RAID? יש לתת תשובה נפרדת לפעולות קריאה וכתיבה.\nקריאה: כמות דיסקים:\nכתיבה: כמות דיסקים:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": true, "correct_option": null, "explanation": "1. RPM 5400 הוא זמן סיבוב של 10ms ← זמן המתנה לסיבוב של 5.5ms. RPM של 7200 - זמן המתנה לסיבוב של 4.2ms. RPM של 15000 ← זמן המתנה לסיבוב של 2ms. זמן המיקום (seek+wait) לכל דיסק הוא: SENSOR 10.5ms FUSION 12ms GHOST 14.2ms זמן ההעברה ב-ms של 1MB לכל דיסק הוא 1000 חלקי קצב ההעברה המקסימלי של הדיסק: SENSOR 10ms FUSION 6.66ms GHOST 5ms בתרחיש האקראי של 512KB ייקח חצי מזה לזמן ההעברה, לכן סה\"כ הזמנים לפעולה לכל דיסק הם: SENSOR 15.5ms FUSION 15.33ms GHOST 16.7ms נעדיף את הקצר ביותר שהוא FUSION. בתרחיש הסדרתי של 100MB ייקח פי 100 מזמן ההעברה ל-1MB, לכן סה\"כ הזמנים לכל דיסק הם: SENSOR 1010.5ms FUSION 678ms GHOST 514.2ms נעדיף את הקצר ביותר שהוא GHOST.\n\n2. לפי הנתונים מעלה, זה הקצב שנגיע אליו בתרחיש הסדרתי עבור כל דיסק: GHOST 194.5 MB/s FUSION 147.5 MB/s SENSOR 99 MB/s באחוזים מהקצב המקסימלי נקבל: GHOST 97.25% FUSION 98.33% SENSOR 99%\n\n3. לפי הנתונים מעלה, זה הקצב שנגיע אליו בתרחיש האקראי עבור כל דיסק: GHOST 29.94 MB/s FUSION 32.6 MB/s SENSOR 32.2 MB/s כלומר עלינו להגיע לקצב גבוה יותר מ-MB/s 32.6 כדי שמערך ה-RAID ישפר. בתרחיש אקראי של קריאות הביצועים של 4-RAID עם N דיסקים הם N-1)*R) כאשר R קצב ההעברה בתרחיש האקראי, במקרה שלנו 32.6=R ולכן 3=N. בתרחיש אקראי של כתיבות הביצועים של 4-RAID הם 2/R ללא תלות בכמות הדיסקים, לכן לא נוכל לשפר את הביצועים על פני אף אחד מהדיסקים הקיימים."}, "difficulty_estimation": "Medium"}]}, {"filename": "os25BA.json", "metadata": {"course_name": "Operating Systems", "year": "2025", "semester": "Semester B", "moed": "Moed A", "exam_date": "15.07.2025", "source_file": "os25BA.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Scheduling", "Processes", "CPU Scheduling"], "content": {"text": "נתונה מערכת עם אלגוריתם תזמון מבוסס RR מלבד ההבדל הבא: משימה חדשה מתחילה לרוץ מיד כשנוצרה. משימה שסיימה את הקוונטה שלה עדיין חוזרת לסוף התור, ויש להניח שלא נוצרות 2 משימות חדשות בו-זמנית.\nאיזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["א. זמן התגובה של האלגוריתם הוא אופטימלי.", "ב. זמן המחזור של האלגוריתם תמיד עדיף או שווה לזה של RR סטנדרטי.", "ג. לכל 1<N, אם מספר המשימות בתור בכל רגע נתון הוא לא יותר מ-N, לא תיתכן הרעבה.", "ד. לכל 1<N, אם מספר המשימות בתור בכל רגע נתון הוא לא יותר מ-N, בהכרח תתרחש הרעבה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "נתון שרת עם 6 דיסקים קשיחים בעלי נתונים זהים, בגודל 2TB כל אחד.\nאיזה מהמנגנונים הבאים יאפשר להתמודד עם קלקול של דיסק אחד לפחות? מבין אלו, יש לבחור את המנגנון המספק את שטח האחסון המקסימלי.", "code_snippet": null, "options": ["א. RAID-0", "ב. 2 של mirroring level עם RAID-1.", "ג. 3 של mirroring level עם RAID-1", "ד. RAID-5.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["System Calls", "Memory Management", "Processes"], "content": {"text": "איזו מהטענות הבאות נכונה לגבי מודול גרעין:", "code_snippet": null, "options": ["א. המודול רץ עם מרחב זיכרון משלו ונפרד מה-kernel space.", "ב. אין בעיה לגשת ישירות לזיכרון ב-user space באופן חופשי.", "ג. ניתן לבצע קריאות מערכת כרגיל כי הן רצות ב-kernel mode.", "ד. לאחר שנטען, לא ניתן להסיר מודול גרעין מבלי להפעיל מחדש את המערכת.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Synchronization", "Threads", "Concurrency", "Mutexes"], "content": {"text": "נתונה מערכת עם N חוטים המשתמשת במנעול מסוג ticket lock, וידוע שבנקודת זמן מסוימת בריצה הערך הנוכחי של turn הוא X.\nמה הערך המקסימלי האפשרי של ticket באותה נקודת זמן?", "code_snippet": null, "options": ["א. X", "ב. X+1", "ג. X+N-1", "ד. X+N", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Processes", "System Calls", "Memory Management"], "content": {"text": "נתונה מערכת בה רץ תהליך משתמש יחיד שקורא ל-fork בלולאה. לאחר יצירת 100 תהליכים (כולל התהליך הראשי), הקריאות ל-fork נכשלות ולא נוצרים עוד תהליכים.\nאיזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["א. הגענו לניצול מקסימלי של זיכרון המשתמש ולכן לא ניתן ליצור עוד תהליכים.", "ב. הגענו לניצול מקסימלי של זיכרון הקרנל ולכן לא ניתן ליצור עוד תהליכים.", "ג. אם נעצור את התהליך הראשי, נוכל להריץ בהצלחה כל תוכנית אחרת במקומו.", "ד. אם נחכה פרק זמן מסוים, נוכל ליצור תהליכים חדשים (הקריאות ל-fork שוב יצליחו).", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "Open", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה מערכת בה כתובת וירטואלית מורכבת מהחלקים הבאים: היסט של 10 ביטים, PDI0 של 4 ביטים, PDI1 של 8 ביטים, ו-PTI של 8 ביטים.\nכל כניסה בטבלת הדפים (PTE) מכילה מספר מסגרת, 4 ביטים של סטטוס ו-4 ביטים של ריפוד. נתון שהגודל של PTE ו-PDE זהה, וכל טבלה/חלק מאוחסנים בדף אחד.\nיש לפרט ולנמק את החישובים בכל סעיף.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "6.1", "text": "כמה זיכרון פיזי יכול להיתפס בעקבות הרצת תהליך יחיד, במקרה המקסימלי?\nכמות זיכרון מקסימלית:\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "מה גודל הזיכרון הפיזי המקסימלי במערכת?\nזיכרון פיזי מקסימלי:\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.3", "text": "נתון שבמערכת זו זמין הזיכרון הפיזי המקסימלי.\nמה המספר המינימלי של תהליכים שיש להריץ, כך שהזיכרון הפיזי כולו יהיה תפוס?\nניתן להגדיר תהליכים כרצונכם. יש להניח שלא נעשה שימוש ב-swapping, ואין לקרנל שימוש בזיכרון נוסף מלבד זה הנדרש עבור התהליכים שהוגדרו.\nמספר תהליכים מינימלי:\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Hard"}, {"id": 7, "type": "CodeAnalysis", "topic": ["Synchronization", "Threads", "Concurrency", "Mutexes", "Semaphores"], "content": {"text": "נתונה מערכת מרובת חוטים המנהלת N משאבים אקסקלוסיביים, כלומר שמותר לגשת רק לאחד מהמשאבים בכל רגע נתון (אך ניתן לגשת לאותו משאב ע\"י מספר חוטים במקביל).\nהמשאבים ממוספרים 1-N...0. חוט אשר מעוניין לגשת למשאב 1 קורא לפעולה (enter(i לפני הגישה למשאב, ולפעולה (exit(i לאחר סיום השימוש במשאב. הקריאה (enter(i צריכה לחסום את החוט הקורא עד אשר הוא רשאי לגשת למשאב 1 (ואז הקריאה חוזרת).\nבשאלה זו יש לכתוב אובייקט סנכרון עבור מערכת זו (מימוש לפעולות enter, exit) כך שחוטים שונים יוכלו לקרוא לפעולות אלו במקביל והמערכת תעבוד באופן תקין:\n- מניעה הדדית: בכל רגע נתון, לא נעשית גישה ליותר ממשאב אחד.\n- חופש מקיפאון: אם חוט מנסה לגשת למשאב 1 ואין חוט הניגש למשאב שונה מ-1, החוט יצליח לגשת אל i.\nלצורך המימוש ניתן להשתמש במנעולים ומשתני תנאי בלבד. אין להשתמש בפקודות מכונה אטומיות או אובייקטי סנכרון אחרים. יש להימנע מ-spinning על-ידי שימוש נכון במשתני תנאי.\nשימו לב: פתרון המאפשר רק לחוט אחד לגשת למשאב כלשהו בכל רגע נתון אינו עומד בדרישות, ולא יקבל ניקוד.\nתיאור הפתרון:\nמשתנים גלובליים (יש לציין ערכי אתחול בהערה):", "code_snippet": "#define N ??\n// number of resources\nvoid enter(int i) {\n}\nvoid exit(int i) {\n}"}, "sub_questions": null, "points": 25, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Hard"}, {"id": 8, "type": "Open", "topic": ["File Systems", "I/O"], "content": {"text": "נתונה מערכת קבצים VSFS ללא מספרי inode וללא inode table, ובהתאם גם ללא inode bitmap. במקום זאת, כל רשומה של תיקייה מכילה את ה-inode עצמו במקום מספר ה-inode.\nכלומר, הנתונים של כל תיקייה הם טבלה שכל רשומה אינה מכילה מספר inode אלא את מבנה ה-inode של קובץ המוכל בתוך אותה תיקייה, בנוסף לשאר הפרטים המוכלים בכל רשומה של תיקייה (שם הקובץ).\nאת ה-inode של תיקיית השורש מחזיקים בתוך ה-superblock.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "סטודנט טוען שבמערכת זו לא ניתן לייצר hard link נוסף לקובץ קיים. האם טענת הסטודנט נכונה?\nהסטודנט צודק / הסטודנט טועה נימוק:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "סטודנט טוען שבמערכת זו לא ניתן לייצר symbolic link לקובץ קיים. האם טענת הסטודנט נכונה?\nהסטודנט צודק / הסטודנט טועה נימוק:", "code_snippet": null, "options": null}, {"id": "8.3", "text": "נתון שגודל בלוק הוא 1KB, גודל inode הוא 256B, וכל inode מכיל 8 מצביעים ישירים, 4 מצביעים עקיפים, 2 מצביעים עקיפים כפולים, ומצביע עקיף משולש אחד. גודל מצביע הוא 4B.\nמשתמש ביצע פעולה כתיבה המוסיפה 4KB אל הקובץ: home/os/exam/25ba/\nידוע שקובץ זה הוא בגודל 1030KB, ונתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nמה המספר המינימלי של בלוקים שנדרש לקרוא מהם כדי להשלים את הפעולה?\nיש לתאר את כל הבלוקים שנדרש לקרוא ולכתוב במקרה זה לפי סדר הגישה אליהם, ולנמק כל גישה. ניתן להניח כל תרחיש שיוביל למספר המינימלי, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.\nיש לפרט בקצרה ובבירור מדוע תרחיש זה הוא המינימלי.\nמספר בלוקים לקריאה:\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Hard"}]}, {"filename": "os25BB.json", "metadata": {"course_name": "מערכות הפעלה", "year": "2025", "semester": "סמסטר ב'", "moed": "מועד ב'", "exam_date": "04.08.2025", "source_file": "os25BB.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling", "Processes"], "content": {"text": "נתונה מערכת עם אלגוריתם תזמון מבוסס RR מלבד ההבדל הבא: משימה חדשה מתווספת לתחילת התור במקום לסופו, ומתחילה לרוץ לאחר סיום הקוונטה הנוכחית. משימה שסיימה את הקוונטה שלה עדיין חוזרת לסוף התור, ויש להניח שלא נוצרות 2 משימות חדשות בו-זמנית.\nאיזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["א. זמן התגובה של האלגוריתם הוא אופטימלי.", "ב. זמן המחזור של האלגוריתם תמיד עדיף או שווה לזה של RR סטנדרטי.", "ג. לכל 1<N, אם מספר המשימות בתור בכל רגע נתון הוא בדיוק N, בהכרח תתרחש הרעבה.", "ד. לכל 1<N, אם מספר המשימות בתור בכל רגע נתון הוא בדיוק N, לא תיתכן הרעבה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["File Systems", "I/O"], "content": {"text": "נתון שרת עם 6 דיסקים קשיחים בעלי נתונים זהים, בגודל 2TB כל אחד.\nאיזה מהמנגנונים הבאים יאפשר להתמודד עם קלקול של יותר מדיסק אחד? מבין אלו, יש לבחור את המנגנון המספק את שטח האחסון המקסימלי.", "code_snippet": null, "options": ["א. RAID-0", "ב. RAID-1 עם mirroring level של 2", "ג. RAID-1 עם mirroring level של 3", "ד. RAID-5.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "MultipleChoice", "topic": ["I/O", "System Calls", "File Systems"], "content": {"text": "ברצוננו לפתח מנהל התקן (דרייבר) שבו נשמר ערך פרטי לכל גישה להתקן, שאינו משותף עם שאר הגישות לאותו התקן.\nמה הדרך הנכונה ביותר לעשות זאת?", "code_snippet": null, "options": ["א. נגדיר פרמטר למודול, כך שיהיה ניתן להתקין אותו עם ערך שונה לפי הנדרש.", "ב. נגדיר מערך גלובלי וניגש אליו לפי ה-MINOR של ההתקן עליו מבוצעת הפעולה.", "ג. ארגומנט הקובץ (struct file) מאפשר לשמור ערך פרטי לכל גישה שונה להתקן.", "ד. ארגומנט ההיסט (offset) בפעולות קריאה/כתיבה מאפשר לנו לשמור ערך פרטי הנפרד מגישות אחרות להתקן.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 4, "type": "MultipleChoice", "topic": ["Synchronization", "Concurrency", "Atomic Operations", "Mutexes"], "content": {"text": "נתונה מערכת עם N חוטים המשתמשת במנעול מסוג ticket lock, וידוע שבנקודת זמן מסוימת בריצה הערך הנוכחי של ticket הוא X.\nמה הערך המקסימלי האפשרי של turn באותה נקודת זמן?", "code_snippet": null, "options": ["א. X", "ב. X-1", "ג. X-N", "ד. X-N+1", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 5, "type": "MultipleChoice", "topic": ["Memory Management", "Virtual Memory", "Paging"], "content": {"text": "נתונה מערכת עם טבלת דפים לינארית בה כל רשומה (PTE) מכילה 3 ביטים של סטטוס. כתובת פיזית מורכבת מהיסט של 13 ביטים ומספר מסגרת של 23 ביטים.\nבמערכת זו רצים 2 תהליכים A,B, וידוע שטבלת הדפים של תהליך A היא בגודל 4 מסגרות בדיוק.\nמהו מרחב הכתובות של תהליך B?", "code_snippet": null, "options": ["א. 8KB", "ב. 8MB", "ג. 64MB", "ד. אין מספיק נתונים כדי לחשב את התשובה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 6, "type": "CodeAnalysis", "topic": ["Processes", "IPC", "System Calls", "Memory Management", "Paging"], "content": {"text": "נתונה התוכנית הבאה:\nהריצו את התוכנית, והתהליך שנוצר קיבל את מזהה התהליך 42.\nבמערכת זו נתון גם:\n- גודל דף הוא 1KB.\n- טבלת הדפים של כל תהליך תמיד תופסת דף אחד בדיוק.\n- תהליך 42 משתמש ב:\n  Ο 2 דפים של TEXT.\n  Ο 2 דפים של DATA.\n  Ο דף אחד של מחסנית.\n  Ο דף אחד של ערימה.\n- כל pipe משתמש בחוצץ (buffer) בגודל דף אחד.\nיש להניח שכל קריאות המערכת שיכולות להצליח הצליחו, לא נוצרים תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.\nתזכורת: כל הדפסה לפלט הסטנדרטי מתבצעת מיד, ללא חוצץ (buffer) הדפסה או המתנה לירידת שורה.", "code_snippet": "1 char buf[1024]; // 1024 bytes\n2 \n3 int main() {\n4   int rc;\n5   int pipefd[2]; // 0-read end, 1-write end\n6   pipe (pipefd);\n7 \n8   if (fork() > 0) {\n9     close(pipefd[0]);\n10 \n11    for (int i = 0; i < 3; ++i) {\n12      buf[0] = 'A'+i; // i=0->'A', i=1->'B', etc.\n13 \n14      // write 1024 bytes into pipe\n15      write(pipefd [1], buf, 1024);\n16      printf(\"%c\", buf[0]);\n17    }\n18    close(pipefd[1]);\n19    wait(NULL);\n20  }\n21  else {\n22    close(pipefd[1]);\n23 \n24    // read 1024 bytes from pipe\n25    while ((rc = read(pipefd[0], buf, 1024)) != 0)\n26      printf(\"%c\", buf[0]);\n27  }\n28}"}, "sub_questions": [{"id": "6.1", "text": "כתבו את כל הפלטים האפשריים של התוכנית.\nיש להסביר כל פלט באופן מפורט.\nמספר פלטים אפשריים:\nפירוט הפלטים ונימוק:", "code_snippet": null, "options": null}, {"id": "6.2", "text": "איזו תופעה תתרחש אם נמחק (או נכניס להערה) את שורה 18 של התוכנית?\nיש לפרט את התופעה במלואה ולהסביר מדוע השינוי גורם לה.\nהתופעה:\nנימוק:", "code_snippet": null, "options": null}, {"id": "6.3", "text": "מה המספר המקסימלי של מסגרות של מרחב המשתמש (user space) שיכולות להיות בשימוש ע\"י תהליכים 42 ו-43 במהלך ריצת התוכנית הנתונה?\nיש לפרט את הריצה והנקודה בריצה שמובילה למקסימום זה, ולפרט את כל המסגרות הרלוונטיות שיהיו בשימוש.\nניתן להניח כל תרחיש שיוביל למספר המקסימלי, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.\nמספר מסגרות מקסימלי:\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 7, "type": "Open", "topic": ["Synchronization", "Concurrency", "Threads", "Atomic Operations", "Semaphores"], "content": {"text": "בסניף קופת חולים מקומי יש N חדרים אליהם מטופלים יכולים להיכנס.\nכל מטופל שמגיע ממתין לתורו. כאשר מגיע תורו, המטופל נכנס לחדר המתאים עד לסיום הטיפול. אין הבדל בין החדרים וכל מטופל יכול לקבל טיפול בכל חדר, אך בכל חדר יש לטפל במטופל אחד בלבד בכל רגע נתון.\nלצורך מחשוב הסניף הוחלט לייצג כל מטופל ע\"י חוט. מטופל המגיע לסניף קורא לפעולה ()enter על-מנת להמתין לתורו, ולפעולה (leave(i לאחר שסיים את הטיפול בחדר בֿ, ואז החדר i פנוי. הקריאה ()enter צריכה לחסום את המטופל עד שהגיע תורו, ולהחזיר את מספר החדר אליו על המטופל להיכנס (0 עד 1-N).\nבשאלה זו יש לכתוב אובייקט סנכרון עבור מערכת זו (מימוש לפעולות enter, leave) כך שלקוחות שונים יוכלו לקרוא לפעולות אלו במקביל וקופת החולים תעבוד באופן תקין:\n- בכל רגע נתון, בכל חדר יש לכל היותר מטופל אחד.\n- אם יש חדר פנוי ויש מטופלים ממתינים, מטופל כלשהו יכנס לחדר הפנוי.\n- מטופלים יכנסו לחדרים באופן הוגן. כלומר, לא יתכן מצב שבו מטופל ממתין לצמיתות בזמן שמטופלים אחרים נכנסים ויוצאים מחדרי הטיפול ללא הגבלה.\nניתן להניח שימוש נכון באובייקט הסנכרון, כך שכל מטופל קורא לפעולות אלו לפי הסדר ומעביר את הארגומנט הנכון.\nלצורך המימוש ניתן להשתמש בפעולות האטומיות F&A, CAS בלבד. אין להשתמש באובייקטי סנכרון או פקודות מכונה אטומיות אחרות. יש להימנע מ-spinning ע\"י שימוש נכון בקריאה ()pthread_yield.\nעבור הפתרון הוגדר הקבוע N והמשתנים הגלובליים הבאים:\nאין להוסיף משתנים גלובליים או סטטיים, או לשנות את הגדרות וערכי אתחול אלו.\nשימו לב: פתרון המאפשר רק למטופל אחד לקבל טיפול בכל רגע נתון אינו עומד בדרישות, ולא יקבל ניקוד.\nתיאור הפתרון:", "code_snippet": "int r[N] = {0}; // init all to 0\nint next = 0, turn = 0;\n\nint enter() {\n}\nvoid leave(int i) {\n}"}, "sub_questions": null, "points": 25, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 8, "type": "Open", "topic": ["File Systems", "Security", "Atomic Operations"], "content": {"text": "שאלה זו מתייחסת למערכת קבצים VSFS עם journaling (ללא metadata journaling).\nמספר סטודנטים התווכחו לגבי הצורך להשתמש בטרנזקציות עבור פעולות מסוימות במערכת זו:\n- סטודנט א' טוען: עבור כל פעולה במערכת הקבצים הדורשת כתיבה אל בלוק אחד בלבד, אין צורך ליצור טרנזקציה ואפשר לבצע את הכתיבה ישירות במערכת הקבצים ועדיין להתמודד בהצלחה עם קריסה.\n- סטודנט ב' טוען: סטודנט א' צודק, אך גם עבור פעולות הדורשות כתיבה אל 2 בלוקים אין צורך ליצור טרנזקציה, בתנאי שלפחות אחד הבלוקים הוא בלוק שנמצא ב-DATA region.\n- סטודנט ג' טוען: סטודנט ב' צודק, אך הטענה נכונה עבור כל פעולה הדורשת כתיבה אל 2 בלוקים לכל היותר, גם אם כל הבלוקים הנכתבים אינם נמצאים ב-DATA region.\n- סטודנט ד' טוען: הסטודנטים האחרים טועים, כדי להתמודד עם קריסות יש ליצור טרנזקציה עבור כל פעולה הדורשת כתיבה אל בלוק כלשהו.\nשימו לב: בבלוקים של כל פעולה הכוונה היא לבלוקים הנדרשים עבור הפעולה עצמה ב-VSFS ללא כתיבת הטרנזקציה הנדרשת עבור אותה פעולה. בכל הפעולות אין מגבלה על כמות הבלוקים אותם נדרש לקרוא עבור הפעולה.", "code_snippet": null, "options": null}, "sub_questions": [{"id": "8.1", "text": "תארו פעולה במערכת קבצים VSFS (ללא journaling) אשר דורשת כתיבה אל בלוק אחד בלבד.\nיש לפרט את כל הבלוקים אליהם נדרש לגשת עבור הפעולה, לקריאה ולכתיבה, לפי סדר הגישה הנדרש.\nניתן להניח כל תרחיש שיביא לפעולה זו, אך נתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nהפעולה:\nפירוט הפעולה:", "code_snippet": null, "options": null}, {"id": "8.2", "text": "תארו פעולה במערכת קבצים VSFS (ללא journaling) אשר דורשת כתיבה אל 2 בלוקים בדיוק, כאשר לפחות אחד מהם הוא בלוק שנמצא ב-DATA region.\nיש לפרט את כל הבלוקים אליהם נדרש לגשת עבור הפעולה, לקריאה ולכתיבה, לפי סדר הגישה הנדרש.\nניתן להניח כל תרחיש שיביא לפעולה זו, אך נתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nהפעולה:\nפירוט הפעולה:", "code_snippet": null, "options": null}, {"id": "8.3", "text": "מי מהסטודנטים צודק? יש לבחור בטענה הנכונה ביותר, ולהסביר בבירור מדוע הטענה נכונה והאחרות שגויות.\nסטודנט א' / סטודנט ב' / סטודנט ג' / סטודנט ד'\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}]}, {"filename": "os25BC.json", "metadata": {"course_name": "Operating Systems", "year": "2025", "semester": "Semester B", "moed": "Moed C", "exam_date": "04.09.2025", "source_file": "os25BC.pdf"}, "questions": [{"id": 1, "type": "MultipleChoice", "topic": ["Scheduling", "CPU Scheduling", "Concurrency"], "content": {"text": "נתונה מערכת עם אלגוריתם תזמון מבוסס RR מלבד ההבדל הבא: משימה חדשה מתחילה לרוץ מיד כשנוצרה. משימה שסיימה את הקוונטה שלה עדיין חוזרת לסוף התור, ויש להניח שלא נוצרות 2 משימות חדשות בו-זמנית.\nבנוסף, נתון שלא ניתן לעצור משימה במהלך הקוונטה הראשונה שלה. כלומר, משימה תסיים את הקוונטה הראשונה שלה גם אם מגיעה משימה חדשה, כאשר המשימה החדשה תתחיל מיד בסיום הקוונטה הנוכחית. בכל מקרה אחר, המשימה החדשה תתחיל לרוץ מיד כשנוצרה.\nאיזו טענה בהכרח נכונה?", "code_snippet": null, "options": ["א. זמן התגובה של האלגוריתם הוא אופטימלי.", "ב. זמן המחזור של האלגוריתם תמיד עדיף או שווה לזה של RR סטנדרטי.", "ג. לכל 1<N, אם מספר המשימות בתור בכל רגע נתון הוא לא יותר מ-N, לא תיתכן הרעבה.", "ד. לכל 1<N, אם מספר המשימות בתור בכל רגע נתון הוא לא יותר מ-N, בהכרח תתרחש הרעבה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 2, "type": "MultipleChoice", "topic": ["Memory Management", "Paging", "Virtual Memory"], "content": {"text": "נתונה מערכת עם טבלת דפים היררכית בה כל רשומה (PTE) מכילה 3 ביטים של סטטוס. כתובת פיזית מורכבת מהיסט 13 ביטים ומספר מסגרת של 23 ביטים.\nבמערכת זו רצים 2 תהליכים A,B, וידוע שטבלת הדפים של תהליך A היא בגודל 4 מסגרות בדיוק.\nמהו מרחב הכתובות של תהליך B?", "code_snippet": null, "options": ["א. 8KB", "ב. 8MB", "ג. 64MB", "ד. אין מספיק נתונים כדי לחשב את התשובה.", "ה. כל התשובות האחרות אינן נכונות."]}, "sub_questions": null, "points": 5, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Medium"}, {"id": 3, "type": "CodeAnalysis", "topic": ["Processes", "IPC", "System Calls", "Concurrency"], "content": {"text": "נתונה התוכנית הבאה:\nהריצו את התוכנית, והתהליך שנוצר קיבל את מזהה התהליך 42.\nיש להניח שכל קריאות המערכת שיכולות להצליח הצליחו, לא נוצרים תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו.\nתזכורת: כל הדפסה לפלט הסטנדרטי מתבצעת מיד, ללא חוצץ (buffer) הדפסה או המתנה לירידת שורה.", "code_snippet": "1 void foo(int p_read [2], int p_write[2]) {\n2   unsigned int num;\n3   int ret;\n4   close(p_read[1]);\n5   close(p_write[0]);\n6\n7   while (1) {\n8     ret = read(p_read [0], &num, sizeof(int));\n9     if (ret == 0)\n10      exit(0);\n11    printf(\"%d \", num);\n12    if (num == 1)\n13      exit(0);\n14    usleep(50 * 1000); // sleep for 50*1000ms\n15    num = (num%2 == 0) ? num/2 : num*3+1;\n16    write(p_write [1], &num, sizeof(int));\n17  }\n18}\n19\n20 int main() {\n21  int pipe1[2], pipe2[2];\n22  const int NUM = 3;\n23  pipe (pipe1);\n24  pipe(pipe2);\n25  if (!fork())\n26    foo(pipe1, pipe2);\n27  if (!fork())\n28    foo(pipe2, pipe1);\n29  write(pipe1[1], &NUM, sizeof(int));\n30  // while (wait(NULL) > 0); // commented out!\n31  exit(0);\n32}"}, "sub_questions": [{"id": "3.1", "text": "כתבו את כל הפלטים האפשריים של התוכנית.\nיש להסביר כל פלט באופן מפורט.\nמספר פלטים אפשריים:\nפירוט הפלטים ונימוק:", "code_snippet": null, "options": null}, {"id": "3.2", "text": "איזו תופעה תתרחש אם נוציא את שורה 30 מהערה? יש לפרט את התופעה במלואה ולהסביר מדוע השינוי גורם לה. שימו לב: שינוי זה הוא לקוד הנתון בלבד, ללא שינויים המתוארים בסעיפים אחרים.\nהתופעה:\nנימוק:", "code_snippet": null, "options": null}, {"id": "3.3", "text": "אם נכניס את שורה 14 להערה, האם עלול להיווצר מרוץ (race condition)? שימו לב: שינוי זה הוא לקוד הנתון בלבד, ללא שינויים המתוארים בסעיפים אחרים.\nמצב מרוץ: יתכן / לא יתכן\nנימוק:", "code_snippet": null, "options": null}], "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Hard"}, {"id": 4, "type": "CodeAnalysis", "topic": ["Synchronization", "Atomic Operations", "Mutexes", "Concurrency"], "content": {"text": "במנעול TTAS הנלמד בשיעור מימשנו את הפעולות lock, unlock בלבד. לעומת זאת, במנעול המובנה של לינוקס זמינות גם הפעולות trylock, timedlock. בשאלה זו יש לממש מנעול TTAS התומך גם בפעולות trylock,timedlock. יש לשמור על כל התכונות של מנעול TTAS כפי שנלמד (מניעה הדדית, חופש מקיפאון, הוגנות, ביצועים). פעולות אלו צריכות להחזיר 0 בהצלחה (תפיסת המנעול), או מספר אחר בכישלון / timeout. לצורך המימוש ניתן להשתמש בפעולה האטומית TAS בלבד. אין להשתמש באובייקטי סנכרון או פקודות מכונה אטומיות אחרות. יש להימנע מ-spinning ע\"י שימוש נכון בקריאה ()pthread_yield עבור המימוש של הפעולה timedlock ניתן להשתמש בפונקציה ()time אשר מחזירה מספר (int) הולך וגדל המייצג את הזמן הנוכחי. הפרמטר לפעולה הוא הזמן עד אליו יש לנסות לתפוס את המנעול. שימו לב: פתרון אשר אינו שומר על כל התכונות של מנעול TTAS (כולל הביצועים) אינו עומד בדרישות, ולא יקבל ניקוד.\nתיאור הפתרון:\nהגדרת מבנה המנעול (יש לציין ערכי אתחול בהערה):", "code_snippet": null}, "sub_questions": [{"id": "4.1", "text": "Implement the TTASLock functions.", "code_snippet": "typedef struct {\n} TTASLock;\n\nvoid lock(TTASLock *lock) {\n}\nint trylock (TTASLock *lock) {\n}\nint timedlock (TTASLock *lock, int limit) {\n}\nvoid unlock(TTASLock *lock) {\n}", "options": null}, {"id": "4.2", "text": "נתון קטע הקוד הבא למימוש מנעול ל-N חוטים. הפרמטר me מייצג מזהה ייחודי לכל חוט (בין 0 ל-1-N):", "code_snippet": "typedef struct {\nint turn;\nint busy;\n} FlakyLock;\nvoid init(FlakyLock *lock) {\nlock->busy = 0;\n}\nvoid lock(FlakyLock *lock, int me) {\ndo {\ndo {\nlock->turn = me;\n} while (lock->busy);\nlock->busy = 1;\n} while (lock->turn != me);\n}\nvoid unlock (FlakyLock *lock) {\nlock->busy = 0;\n}", "options": null}, {"id": "4.2.1", "text": "האם המנעול מקיים מניעה הדדית:?", "code_snippet": null, "options": ["כן", "לא"]}, {"id": "4.2.2", "text": "האם המנעול מקיים חופש מקיפאון?", "code_snippet": null, "options": ["כן", "לא"]}, {"id": "4.2.3", "text": "האם המנעול מקיים הוגנות?", "code_snippet": null, "options": ["כן", "לא"]}], "points": 15, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Hard"}, {"id": 5, "type": "Open", "topic": ["File Systems", "I/O", "Disk Scheduling"], "content": {"text": "נתון דיסק קשיח עם הנתונים הבאים: מהירות סיבוב: RPM 10,000. גודל מצביע: 4 בתים, גודל סקטור: 1024 בתים, גודל בלוק: 4KB. 8 משטחים (4 platters דו-צדדיים). צפיפות הסקטורים בכל רצועה היא בהתאם ל-2 אזורים: A, B. בכל אזור יש 500 רצועות. באזור A יש 4000 סקטורים לרצועה, באזור B יש 2000 סקטורים לרצועה. זמן ה-seek הממוצע הוא 8ms, ובין 2 רצועות סמוכות הוא 2ms. נתון שיפור track skew: בקריאת סקטורים עוקבים ברצועות סמוכות אין המתנה לסיבוב. על גבי כל הדיסק הנתון קיימת מערכת קבצים VSFS, עם סופר-בלוק בבלוק 0 ושאר מערכת הקבצים מבלוק 1 והלאה. סדר האזורים במערכת הקבצים הוא הסטנדרטי, כפי שנלמד בשיעור. כל הבלוקים של הדיסק בשימוש ע\"י מערכת הקבצים. כמו-כן נתון שגודל inode הוא 512 בתים, וכל inode מכיל 6 מצביעים ישירים, 3 מצביעים עקיפים, ו-2 מצביעים עקיפים כפולים. יש לפרט ולנמק את הפעולות והחישובים בכל סעיף.", "code_snippet": null}, "sub_questions": [{"id": "5.1", "text": "לגבי כל אחד מהנתונים הבאים, ציינו האם ניתן לדעת את הערך המקסימלי שלו. אם כן, יש לפרט מה הערך המקסימלי, אחרת יש לפרט מה הנתון החסר כדי לדעת אותו.", "code_snippet": null, "options": null}, {"id": "5.1.1", "text": "בלוק ה-inode הראשון:", "code_snippet": null, "options": null}, {"id": "5.1.2", "text": "בלוק ה-data הראשון:", "code_snippet": null, "options": null}, {"id": "5.1.3", "text": "בלוקה-inode bitmap הראשון:", "code_snippet": null, "options": null}, {"id": "5.1.4", "text": "בלוקה-data bitmap הראשון:", "code_snippet": null, "options": null}, {"id": "5.2", "text": "במערכת הנתונה קיים קובץ בגודל 20MB. מה הזמן המינימלי הנדרש לקריאת כל הקובץ? ניתן להניח כל תרחיש שיביא לזמן המינימלי, אך נתון שהקובץ כבר נפתח ומלבד לכך אף cache אינו מכיל מידע רלוונטי לביצוע הפעולה. יש לפרט את הפעולה באופן מלא, כולל כל הבלוקים שניגשים אליהם לקריאה ולכתיבה.\nזמן מינימלי:\nנימוק:", "code_snippet": null, "options": null}, {"id": "5.3", "text": "בסעיף זה (בלבד), שודרגה מערכת הקבצים כך שתעבוד עם metadata journaling. בשיעור נלמד שכאשר משתמשים ב-metadata journaling, אם פעולה דורשת כתיבת נתונים לבלוק DATA קיים, יש צורך לשכפל את הבלוק עם השינויים ולא לעדכן את הבלוק הקיים, על-מנת להמשיך להתמודד עם קריסות באופן תקין. מספר סטודנטים התווכחו לגבי הצורך לשכפל את בלוק ה-DATA עבור פעולות מסוימות במערכת זו: - סטודנט א' טוען: כאשר מוסיפים נתונים אל סוף קובץ קיים, ניתן לכתוב את הנתונים בשלב כתיבת ה-DATA כרגיל מבלי לשכפל את הבלוק (אפילו אם הבלוק האחרון של הקובץ לא מנוצל במלואו לפני הפעולה). - סטודנט ב' טוען: סטודנט א' צודק רק עבור פעולות בהן הכתיבה לא מוסיפה בלוק DATA חדש אל הקובץ. - סטודנט ג' טוען: סטודנט א' צודק, אך הטענה נכונה לכל כתיבה המוסיפה נתונים אל קובץ קיים, לאו דווקא בסופו. - סטודנט ד' טוען: הסטודנטים האחרים טועים, כדי להתמודד עם קריסות יש לשכפל את בלוק ה-DATA עם השינויים בכל טרנזקציה הכוללת כתיבה לבלוק DATA קיים. מי מהסטודנטים צודק? יש לבחור בטענה הנכונה ביותר, ולהסביר בבירור מדוע הטענה נכונה והאחרות שגויות.\nסטודנט א' / סטודנט ב' / סטודנט ג' / סטודנט ד'\nנימוק:", "code_snippet": null, "options": ["סטודנט א'", "סטודנט ב'", "סטודנט ג'", "סטודנט ד'"]}], "points": null, "solution": {"is_present_in_file": false, "correct_option": null, "explanation": null}, "difficulty_estimation": "Hard"}]}]