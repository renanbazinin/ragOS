{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:50:16",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3433,
      "output_tokens": 3884,
      "total_tokens": 12671
    }
  },
  "question": {
    "id": 11,
    "type": "Open",
    "topic": [
      "Producer-Consumer",
      "Synchronization",
      "Semaphores",
      "Concurrency",
      "Deadlock"
    ],
    "content": {
      "text": "במפעל לייצור מכוניות, תהליך ההרכבה מתבצע במספר שלבים, כאשר כל שלב מטופל על ידי סוגים שונים של עובדים (חוטים). קיימים שלושה סוגי \"מאגרים\" (buffers) מוגבלי גודל, המאפשרים תיאום בין העובדים:\n\n1.  **מאגר מנועים (Engine Buffer)**: מכיל מנועים שיוצרו ומוכנים להרכבה.\n2.  **מאגר שלדות (Chassis Buffer)**: מכיל שלדות שיוצרו ומוכנות להרכבה.\n3.  **מאגר שלדות-מנוע מורכבות (Car Frame Buffer)**: מכיל שלדות עם מנוע שהורכב עליהן, מוכנות לשלב הגימור.\n\nארבעה סוגי עובדים פועלים במפעל:\n\n*   **יצרני מנועים (Engine Producers)**: מייצרים מנועים ומכניסים אותם למאגר המנועים.\n*   **יצרני שלדות (Chassis Producers)**: מייצרים שלדות ומכניסים אותן למאגר השלדות.\n*   **עובדי הרכבה (Assembly Workers)**: לוקחים מנוע אחד ממאגר המנועים ושלדה אחת ממאגר השלדות, מרכיבים אותם יחד ליצירת \"שלדת-מנוע מורכבת\", ומכניסים אותה למאגר שלדות-מנוע מורכבות.\n*   **עובדי גימור (Finishing Workers)**: לוקחים \"שלדת-מנוע מורכבת\" ממאגר שלדות-מנוע מורכבות ומבצעים עליה את עבודת הגימור הסופית.\n\nיש לממש את הפונקציות הראשיות (main functions) של החוטים עבור כל אחד מארבעת סוגי העובדים, תוך שימוש בסמפורים בלבד (semaphores). יש להקפיד על סנכרון נכון המונע תנאי מירוץ (race conditions), קיפאון (deadlock) והרעבה (starvation). ניתן להניח שהסמפורים הוגנים (fair).\n\nלצורך הפתרון, נתונות הפונקציות הדמה הבאות (אין צורך לממש אותן):\n`void* produce_engine();` - מייצר מנוע חדש.\n`void* produce_chassis();` - מייצר שלדה חדשה.\n`void* assemble_car_frame(void* engine, void* chassis);` - מרכיב מנוע ושלדה ל\"שלדת-מנוע מורכבת\".\n`void finish_car_frame(void* car_frame);` - מבצע גימור סופי על \"שלדת-מנוע מורכבת\".\n\nיש לתאר בקצרה ובבירור את הפתרון, לכלול את הגדרת המשתנים הגלובליים (עם ערכי אתחול בהערה), ולכתוב קוד ברור.\n\nתיאור הפתרון:\nמשתנים גלובליים (יש לכתוב ערכי אתחול בהערה):",
      "code_snippet": "void* engine_producer_thread(void* arg) {\n    // Implement here\n}\n\nvoid* chassis_producer_thread(void* arg) {\n    // Implement here\n}\n\nvoid* assembly_worker_thread(void* arg) {\n    // Implement here\n}\n\nvoid* finishing_worker_thread(void* arg) {\n    // Implement here\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון משתמש בשלושה מאגרים מעגליים מוגבלי גודל, אחד לכל סוג של פריט (מנועים, שלדות, ושלדות-מנוע מורכבות). לכל מאגר יש שלושה סמפורים:\n1.  `_mutex`: סמפור בינארי (מוטקס), מאותחל ל-1, המבטיח גישה הדדית בלעדית (mutual exclusion) למאגר עצמו בזמן הכנסה או הוצאה של פריטים.\n2.  `_empty_slots`: סמפור סופר (counting semaphore), מאותחל לגודל המאגר (BUFFER_SIZE), המייצג את מספר המקומות הפנויים במאגר. יורד על ידי יצרנים, עולה על ידי צרכנים.\n3.  `_full_slots`: סמפור סופר, מאותחל ל-0, המייצג את מספר הפריטים המלאים במאגר. עולה על ידי יצרנים, יורד על ידי צרכנים.\n\n**לגבי סוגי העובדים:**\n\n*   **יצרני מנועים ויצרני שלדות**: פועלים כיצרנים קלאסיים. הם ממתינים למקום פנוי במאגר שלהם (`_empty_slots`), לוקחים מוטקס (`_mutex`), מכניסים פריט, משחררים מוטקס, ומסמנים שיש פריט מלא (`_full_slots`).\n*   **עובדי גימור**: פועלים כצרכנים קלאסיים. הם ממתינים לפריט מלא במאגר שלדות-מנוע מורכבות (`car_frame_full_slots`), לוקחים מוטקס (`car_frame_mutex`), מוציאים פריט, משחררים מוטקס, ומסמנים שיש מקום פנוי (`car_frame_empty_slots`).\n*   **עובדי הרכבה**: אלו הם ה\"מתווכים\" בבעיה. הם צרכנים של מנועים ושלדות, ויצרנים של שלדות-מנוע מורכבות. כדי למנוע קיפאון (deadlock) בין עובדי ההרכבה עצמם, חשוב שכל עובדי ההרכבה ירכשו את המשאבים הנכנסים (מנוע ושלדה) באותו סדר עקבי (למשל, תמיד קודם מנוע ואז שלדה). לאחר רכישת המשאבים הנכנסים, הם ניגשים למאגרים הרלוונטיים (מנועים ושלדות) תחת מוטקס כדי להוציא את הפריטים. לאחר ההרכבה, הם פועלים כיצרנים של שלדות-מנוע מורכבות, ממתינים למקום פנוי במאגר זה, לוקחים מוטקס, מכניסים את הפריט המורכב, משחררים מוטקס, ומסמנים שיש פריט מלא.",
      "code_snippet": "#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define BUFFER_SIZE 5 // Example size for all buffers\n\n// Dummy functions (as given in the question)\nvoid* produce_engine() { /* Simulate work */ return (void*)1; }\nvoid* produce_chassis() { /* Simulate work */ return (void*)2; }\nvoid* assemble_car_frame(void* engine, void* chassis) { /* Simulate work */ return (void*)3; }\nvoid finish_car_frame(void* car_frame) { /* Simulate work */ }\n\n// --- Global Variables (with initialization comments) ---\n\n// Engine Buffer\nvoid* engine_buffer[BUFFER_SIZE];\nint engine_in = 0, engine_out = 0;\nsem_t engine_mutex;         // init to 1\nsem_t engine_empty_slots;   // init to BUFFER_SIZE\nsem_t engine_full_slots;    // init to 0\n\n// Chassis Buffer\nvoid* chassis_buffer[BUFFER_SIZE];\nint chassis_in = 0, chassis_out = 0;\nsem_t chassis_mutex;        // init to 1\nsem_t chassis_empty_slots;  // init to BUFFER_SIZE\nsem_t chassis_full_slots;   // init to 0\n\n// Car Frame Buffer\nvoid* car_frame_buffer[BUFFER_SIZE];\nint car_frame_in = 0, car_frame_out = 0;\nsem_t car_frame_mutex;      // init to 1\nsem_t car_frame_empty_slots;// init to BUFFER_SIZE\nsem_t car_frame_full_slots; // init to 0\n\n// --- Thread Functions ---\n\nvoid* engine_producer_thread(void* arg) {\n    while (1) {\n        void* engine = produce_engine(); // Produce an engine\n\n        sem_wait(&engine_empty_slots); // Wait for an empty slot in engine buffer\n        sem_wait(&engine_mutex);       // Acquire mutex for engine buffer access\n\n        // Add engine to buffer\n        engine_buffer[engine_in] = engine;\n        engine_in = (engine_in + 1) % BUFFER_SIZE;\n\n        sem_post(&engine_mutex);       // Release mutex for engine buffer\n        sem_post(&engine_full_slots);  // Signal a full slot in engine buffer\n    }\n    return NULL;\n}\n\nvoid* chassis_producer_thread(void* arg) {\n    while (1) {\n        void* chassis = produce_chassis(); // Produce a chassis\n\n        sem_wait(&chassis_empty_slots); // Wait for an empty slot in chassis buffer\n        sem_wait(&chassis_mutex);       // Acquire mutex for chassis buffer access\n\n        // Add chassis to buffer\n        chassis_buffer[chassis_in] = chassis;\n        chassis_in = (chassis_in + 1) % BUFFER_SIZE;\n\n        sem_post(&chassis_mutex);       // Release mutex for chassis buffer\n        sem_post(&chassis_full_slots);  // Signal a full slot in chassis buffer\n    }\n    return NULL;\n}\n\nvoid* assembly_worker_thread(void* arg) {\n    while (1) {\n        // --- Acquire input resources (Engines and Chassis) ---\n        // Crucial for deadlock avoidance: acquire in a consistent order across all assembly workers\n        sem_wait(&engine_full_slots);  // Wait for an engine to be available\n        sem_wait(&chassis_full_slots); // Wait for a chassis to be available\n\n        // --- Consume engine from engine buffer ---\n        sem_wait(&engine_mutex); // Acquire mutex for engine buffer\n        void* engine = engine_buffer[engine_out];\n        engine_out = (engine_out + 1) % BUFFER_SIZE;\n        sem_post(&engine_mutex); // Release mutex for engine buffer\n        sem_post(&engine_empty_slots); // Signal an empty slot in engine buffer\n\n        // --- Consume chassis from chassis buffer ---\n        sem_wait(&chassis_mutex); // Acquire mutex for chassis buffer\n        void* chassis = chassis_buffer[chassis_out];\n        chassis_out = (chassis_out + 1) % BUFFER_SIZE;\n        sem_post(&chassis_mutex); // Release mutex for chassis buffer\n        sem_post(&chassis_empty_slots); // Signal an empty slot in chassis buffer\n\n        // --- Assemble car frame ---\n        void* car_frame = assemble_car_frame(engine, chassis);\n\n        // --- Produce car frame into car frame buffer ---\n        sem_wait(&car_frame_empty_slots); // Wait for an empty slot in car frame buffer\n        sem_wait(&car_frame_mutex);        // Acquire mutex for car frame buffer access\n\n        // Add car frame to buffer\n        car_frame_buffer[car_frame_in] = car_frame;\n        car_frame_in = (car_frame_in + 1) % BUFFER_SIZE;\n\n        sem_post(&car_frame_mutex);        // Release mutex for car frame buffer\n        sem_post(&car_frame_full_slots);   // Signal a full slot in car frame buffer\n    }\n    return NULL;\n}\n\nvoid* finishing_worker_thread(void* arg) {\n    while (1) {\n        sem_wait(&car_frame_full_slots); // Wait for a car frame to be available\n        sem_wait(&car_frame_mutex);       // Acquire mutex for car frame buffer access\n\n        // Take car frame from buffer\n        void* car_frame = car_frame_buffer[car_frame_out];\n        car_frame_out = (car_frame_out + 1) % BUFFER_SIZE;\n\n        sem_post(&car_frame_mutex);       // Release mutex for car frame buffer\n        sem_post(&car_frame_empty_slots); // Signal an empty slot in car frame buffer\n\n        finish_car_frame(car_frame); // Perform final finishing work\n    }\n    return NULL;\n}\n\n/*\n// Example main function for testing (not required for the answer):\nint main() {\n    // Initialize semaphores\n    sem_init(&engine_mutex, 0, 1);\n    sem_init(&engine_empty_slots, 0, BUFFER_SIZE);\n    sem_init(&engine_full_slots, 0, 0);\n\n    sem_init(&chassis_mutex, 0, 1);\n    sem_init(&chassis_empty_slots, 0, BUFFER_SIZE);\n    sem_init(&chassis_full_slots, 0, 0);\n\n    sem_init(&car_frame_mutex, 0, 1);\n    sem_init(&car_frame_empty_slots, 0, BUFFER_SIZE);\n    sem_init(&car_frame_full_slots, 0, 0);\n\n    pthread_t ep_threads[2], cp_threads[2], aw_threads[3], fw_threads[2];\n    int i;\n\n    // Create threads\n    for (i = 0; i < 2; i++) pthread_create(&ep_threads[i], NULL, engine_producer_thread, NULL);\n    for (i = 0; i < 2; i++) pthread_create(&cp_threads[i], NULL, chassis_producer_thread, NULL);\n    for (i = 0; i < 3; i++) pthread_create(&aw_threads[i], NULL, assembly_worker_thread, NULL);\n    for (i = 0; i < 2; i++) pthread_create(&fw_threads[i], NULL, finishing_worker_thread, NULL);\n\n    // Join threads (in a real scenario, these would run indefinitely)\n    for (i = 0; i < 2; i++) pthread_join(ep_threads[i], NULL);\n    for (i = 0; i < 2; i++) pthread_join(cp_threads[i], NULL);\n    for (i = 0; i < 3; i++) pthread_join(aw_threads[i], NULL);\n    for (i = 0; i < 2; i++) pthread_join(fw_threads[i], NULL);\n\n    // Destroy semaphores\n    sem_destroy(&engine_mutex);\n    sem_destroy(&engine_empty_slots);\n    sem_destroy(&engine_full_slots);\n\n    sem_destroy(&chassis_mutex);\n    sem_destroy(&chassis_empty_slots);\n    sem_destroy(&chassis_full_slots);\n\n    sem_destroy(&car_frame_mutex);\n    sem_destroy(&car_frame_empty_slots);\n    sem_destroy(&car_frame_full_slots);\n\n    return 0;\n}\n*/"
    },
    "difficulty_estimation": "Hard"
  }
}