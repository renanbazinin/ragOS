{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 23:16:20",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3180,
      "output_tokens": 2073,
      "total_tokens": 7914
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Paging",
      "Memory Management",
      "Spatial Locality",
      "Page Faults"
    ],
    "content": {
      "text": "נתונה פיסת הקוד הבאה:\nהתוכנית מריצה שתי לולאות הניגשות למערך דו-ממדי בגודל 1024x1024 שלמים (integers). כל הגישות הן לכתיבה.\nבמערכת זו נתון גם:\n- גודל דף זיכרון הוא 4KB.\n- גודל שלם (int) הוא 4 בתים.\n- כל הדפים של המערך אינם טעונים לזיכרון הפיזי בתחילת ריצת התוכנית (כלומר, כל גישה לדף בפעם הראשונה תגרום ל-page fault).\n- ה-TLB מספיק גדול כדי להחזיק את כל הערכים הדרושים לדף בודד, ואין צורך להתחשב בביצועי ה-TLB.\n\nשאלה:\nהשוו את מספר ה-page faults שייגרמו על ידי 'לולאה 1' (גישה לפי שורות) לעומת 'לולאה 2' (גישה לפי עמודות). הסבירו מדוע קיים הבדל, אם קיים, וחשבו את מספר ה-page faults עבור כל לולאה בנפרד.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ROWS 1024\n#define COLS 1024\n\nint main() {\n    int (*arr)[COLS] = (int (*)[COLS])malloc(ROWS * COLS * sizeof(int));\n    if (arr == NULL) {\n        perror(\"malloc failed\");\n        return 1;\n    }\n\n    // Loop 1: Row-major access\n    printf(\"Accessing array in row-major order...\\n\");\n    for (int i = 0; i < ROWS; ++i) {\n        for (int j = 0; j < COLS; ++j) {\n            arr[i][j] = i * COLS + j; // Write access\n        }\n    }\n\n    // Loop 2: Column-major access\n    printf(\"Accessing array in column-major order...\\n\");\n    for (int j = 0; j < COLS; ++j) {\n        for (int i = 0; i < ROWS; ++i) {\n            arr[i][j] = i * COLS + j; // Write access\n        }\n    }\n\n    free(arr);\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "הסבר:\n*   **גודל המערך:** המערך הוא בגודל `1024 * 1024` שלמים. כל שלם הוא 4 בתים. לכן, הגודל הכולל של המערך הוא `1024 * 1024 * 4` בתים = `4,194,304` בתים = `4` מגה-בייט.\n*   **גודל דף:** 4 קילובייט (`4096` בתים).\n*   **מספר שלמים לדף:** `4096` בתים / `4` בתים/שלם = `1024` שלמים.\n*   **מספר הדפים הכולל למערך:** `4` מגה-בייט / `4` קילובייט/דף = `1024` דפים.\n\n**לולאה 1 (גישה לפי שורות - Row-major access):**\n`for (int i = 0; i < ROWS; ++i) { for (int j = 0; j < COLS; ++j) { arr[i][j] = ...; } }`\n*   בלולאה זו, הגישה לאלמנטים מתבצעת בסדר: `arr[0][0], arr[0][1], ..., arr[0][1023], arr[1][0], ...`.\n*   מכיוון שכל שורה מכילה `1024` שלמים, וכל דף זיכרון יכול להכיל בדיוק `1024` שלמים, כל שורה במערך תופסת דף זיכרון אחד בדיוק.\n*   כאשר ניגשים לאלמנט `arr[i][0]` בפעם הראשונה, הדף המכיל את השורה `i` עדיין אינו בזיכרון הפיזי, ולכן תתרחש `page fault`. דף זה ייטען לזיכרון הפיזי.\n*   כל הגישות הבאות לאלמנטים באותה שורה (`arr[i][1]` עד `arr[i][1023]`) יתבצעו לדף שכבר נמצא בזיכרון, ולכן לא יגרמו ל-`page fault` נוסף עבור שורה זו.\n*   דפוס זה חוזר על עצמו עבור כל אחת מ-`ROWS` השורות (1024 שורות).\n*   לכן, תתרחש `page fault` אחת לכל שורה.\n*   **מספר ה-page faults הכולל עבור לולאה 1 = `ROWS` = `1024` page faults.**\n\n**לולאה 2 (גישה לפי עמודות - Column-major access):**\n`for (int j = 0; j < COLS; ++j) { for (int i = 0; i < ROWS; ++i) { arr[i][j] = ...; } }`\n*   בלולאה זו, הגישה לאלמנטים מתבצעת בסדר: `arr[0][0], arr[1][0], ..., arr[1023][0], arr[0][1], ...`.\n*   `arr[0][0]` נמצא בדף 0.\n*   `arr[1][0]` נמצא בדף 1 (שורה 1 היא דף נפרד).\n*   `arr[2][0]` נמצא בדף 2 (שורה 2 היא דף נפרד).\n*   וכך הלאה, עד `arr[1023][0]` שנמצא בדף 1023.\n*   בכל פעם שניגשים ל-`arr[i][j]` (עבור `j` קבוע ו-`i` משתנה), הגישה היא לדף זיכרון שונה מהגישה הקודמת `arr[i-1][j]`, מכיוון שכל שורה היא דף נפרד.\n*   לכן, כמעט כל גישה לאלמנט `arr[i][j]` תגרום ל-`page fault` מכיוון שהדף המכיל אותו לא יהיה טעון בזיכרון הפיזי (אלא אם כן הוא נטען כבר בגישה קודמת לאותה עמודה, אבל במקרה זה, הגישה הראשונה לכל אלמנט תגרום ל-page fault).\n*   מספר הגישות הכולל למערך הוא `ROWS * COLS` = `1024 * 1024`.\n*   **מספר ה-page faults הכולל עבור לולאה 2 = `1024 * 1024` = `1,048,576` page faults.**\n\n**מסקנה:**\nלולאה 1 (גישה לפי שורות) גורמת ל-`1024` page faults מכיוון שהיא מפגינה לוקליות מרחבית (spatial locality) מצוינת. ברגע שדף נטען לזיכרון, כל הגישות הבאות לאותה שורה (שהיא הדף כולו) הן מהירות.\nלולאה 2 (גישה לפי עמודות) גורמת ל-`1,048,576` page faults מכיוון שהיא מפגינה לוקליות מרחבית ירודה מאוד. כל גישה עוקבת קופצת לדף זיכרון חדש, מה שמוביל ל-page fault כמעט עבור כל גישת זיכרון. הבדל דרמטי זה מדגיש את החשיבות של תבניות גישת זיכרון לביצועים במערכות זיכרון מבוססות דפדוף.",
      "code_snippet": null
    },
    "difficulty_estimation": "Medium"
  }
}