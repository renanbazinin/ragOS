{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:23:15",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3498,
      "output_tokens": 2979,
      "total_tokens": 10934
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "System Calls"
    ],
    "content": {
      "text": "נתונה תוכנית C המדמה פעולת pipeline פשוטה בין שני תהליכי ילד באמצעות system calls. התוכנית יוצרת צינור (pipe), מפצלת לשני תהליכי ילד, ומנתבת את הפלט של תהליך אחד לקלט של האחר. תהליך הילד הראשון מריץ את הפקודה `ls -1` ותהליך הילד השני מריץ את הפקודה `grep .c`.\n\nקרא בעיון את קטע הקוד המצורף וענה על השאלות הבאות:\n\n1.  תאר בפירוט את רצף האירועים במערכת ההפעלה מרגע הרצת תוכנית האב ועד לסיומה, תוך התייחסות לשינויים במצב התהליכים (process states), ניהול מתארי קבצים (file descriptors), ותקשורת בין-תהליכית.\n2.  האם ישנם מצבים בהם התוכנית עלולה להיתקע (deadlock) או להציג התנהגות בלתי צפויה? אם כן, הסבר מדוע וכיצד ניתן למנוע זאת. אם לא, נמק מדוע.\n3.  מה יהיה הפלט הסופי של התוכנית לקונסולת ההורה (stdout של ההורה) לאחר שכל התהליכים יסתיימו בהצלחה? הסבר את תשובתך. (הנח שהתיקייה הנוכחית מכילה קבצים כמו `main.c`, `test.txt`, `utils.h`, `data.csv`).",
      "code_snippet": "#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <string.h>\n\nint main() {\n    int pipefd[2];\n    pid_t pid1, pid2;\n\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Fork first child (for 'ls')\n    pid1 = fork();\n    if (pid1 == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid1 == 0) { // Child 1: 'ls'\n        close(pipefd[0]); // Close unused read end\n\n        // Redirect stdout to pipe write end\n        if (dup2(pipefd[1], STDOUT_FILENO) == -1) {\n            perror(\"dup2 child 1\");\n            exit(EXIT_FAILURE);\n        }\n        close(pipefd[1]); // Close original pipe write end\n\n        char *args[] = {\"/bin/ls\", \"-1\", NULL};\n        execve(args[0], args, NULL);\n        perror(\"execve ls\"); // Should not reach here if execve succeeds\n        exit(EXIT_FAILURE);\n    }\n\n    // Fork second child (for 'grep')\n    pid2 = fork();\n    if (pid2 == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid2 == 0) { // Child 2: 'grep .c'\n        close(pipefd[1]); // Close unused write end\n\n        // Redirect stdin to pipe read end\n        if (dup2(pipefd[0], STDIN_FILENO) == -1) {\n            perror(\"dup2 child 2\");\n            exit(EXIT_FAILURE);\n        }\n        close(pipefd[0]); // Close original pipe read end\n\n        char *args[] = {\"/bin/grep\", \".c\", NULL};\n        execve(args[0], args, NULL);\n        perror(\"execve grep\"); // Should not reach here\n        exit(EXIT_FAILURE);\n    }\n\n    // Parent process\n    close(pipefd[0]); // Close both pipe ends in parent\n    close(pipefd[1]);\n\n    // Wait for both children\n    waitpid(pid1, NULL, 0);\n    waitpid(pid2, NULL, 0);\n\n    printf(\"Parent finished.\\n\");\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסבר כללי:\nתוכנית האב יוצרת צינור (pipe) בעל שני מתארי קבצים: אחד לכתיבה (`pipefd[1]`) ואחד לקריאה (`pipefd[0]`).\nלאחר מכן, תוכנית האב מפצלת לשני תהליכי ילד.\n\n1.  **תיאור רצף האירועים:**\n    *   **הורה (Parent Process):**\n        *   מבצע `pipe()`: יוצר צינור ומקבל שני מתארי קבצים, `pipefd[0]` (קריאה) ו-`pipefd[1]` (כתיבה).\n        *   מבצע `fork()` (ל-`pid1`): יוצר את תהליך הילד הראשון.\n        *   מבצע `fork()` (ל-`pid2`): יוצר את תהליך הילד השני.\n        *   לאחר יצירת שני הילדים, ההורה סוגר את שני קצוות הצינור שברשותו (`close(pipefd[0])`, `close(pipefd[1])`). זה קריטי כדי למנוע deadlocks, כיוון שההורה אינו עתיד לקרוא או לכתוב לצינור.\n        *   ההורה ממתין לסיום שני תהליכי הילד באמצעות `waitpid(pid1, NULL, 0)` ו-`waitpid(pid2, NULL, 0)`.\n        *   לאחר ששני הילדים מסיימים, ההורה מדפיס \"Parent finished.\" ויוצא.\n\n    *   **ילד 1 (Child 1 - 'ls'):**\n        *   יורש את מתארי הקבצים של ההורה, כולל `pipefd[0]` ו-`pipefd[1]`.\n        *   סוגר את קצה הקריאה של הצינור (`close(pipefd[0])`), כיוון שהוא רק כותב לצינור.\n        *   מנתב מחדש את מתאר קובץ ה-`stdout` (שהוא 1) כך שיצביע על קצה הכתיבה של הצינור (`dup2(pipefd[1], STDOUT_FILENO)`). מעתה ואילך, כל מה שייכתב ל-`stdout` של ילד 1 ייכתב לצינור.\n        *   סוגר את מתאר קובץ הכתיבה המקורי של הצינור (`close(pipefd[1])`), כיוון שכעת `STDOUT_FILENO` מצביע עליו.\n        *   מבצע `execve(\"/bin/ls\", args, NULL)`: תהליך הילד מחליף את תמונת הזיכרון שלו בתוכנית `ls -1`. ה-`execve` שומר על מתארי הקבצים הפתוחים, ולכן `ls` יכתוב את רשימת הקבצים לצינור.\n        *   לאחר ש-`ls` מסיים לכתוב את רשימת הקבצים, הוא יוצא.\n\n    *   **ילד 2 (Child 2 - 'grep'):**\n        *   יורש את מתארי הקבצים של ההורה, כולל `pipefd[0]` ו-`pipefd[1]`.\n        *   סוגר את קצה הכתיבה של הצינור (`close(pipefd[1])`), כיוון שהוא רק קורא מהצינור.\n        *   מנתב מחדש את מתאר קובץ ה-`stdin` (שהוא 0) כך שיצביע על קצה הקריאה של הצינור (`dup2(pipefd[0], STDIN_FILENO)`). מעתה ואילך, כל מה שייקרא מ-`stdin` של ילד 2 ייקרא מהצינור.\n        *   סוגר את מתאר קובץ הקריאה המקורי של הצינור (`close(pipefd[0])`), כיוון שכעת `STDIN_FILENO` מצביע עליו.\n        *   מבצע `execve(\"/bin/grep\", args, NULL)`: תהליך הילד מחליף את תמונת הזיכרון שלו בתוכנית `grep .c`. ה-`execve` שומר על מתארי הקבצים הפתוחים, ולכן `grep` יקרא את הקלט שלו מהצינור.\n        *   `grep` יחפש שורות המכילות \".c\" בקלט שלו (שהוא הפלט של `ls`) וידפיס אותן ל-`stdout` שלו, שהוא עדיין מחובר לקונסולה המקורית.\n        *   לאחר ש-`grep` מסיים, הוא יוצא.\n\n2.  **מצבי deadlock / התנהגות בלתי צפויה:**\n    התוכנית כפי שהיא כתובה נכונה ולא אמורה להיכנס למצב deadlock. הסיבה לכך היא שכל קצוות הצינור שאינם בשימוש נסגרים בצורה נכונה:\n    *   ילד 1 סוגר את קצה הקריאה.\n    *   ילד 2 סוגר את קצה הכתיבה.\n    *   ההורה סוגר את שני הקצוות.\n    סגירת כל הקצוות הלא-רלוונטיים היא קריטית. אם ההורה, למשל, לא היה סוגר את קצה הקריאה של הצינור (`pipefd[0]`), אז `grep` (ילד 2) היה יכול להיתקע במצב של קריאה אינסופית מהצינור, כיוון שלמרות ש-`ls` (ילד 1) היה מסיים לכתוב וסוגר את קצה הכתיבה שלו, מערכת ההפעלה עדיין הייתה רואה מתאר קובץ פתוח לקריאה (אצל ההורה), ולא הייתה שולחת ל-`grep` אות EOF. במקרה כזה, `grep` היה ממתין לקלט נוסף שלעולם לא יגיע. התוכנית הנוכחית מטפלת בכך נכון.\n\n3.  **פלט סופי:**\n    הפלט הסופי של התוכנית לקונסולה (stdout של ההורה) יהיה רק השורה \"Parent finished.\", בתוספת הפלט של תהליך `grep`.\n    תהליך `grep` מדפיס את התוצאות שלו ל-`stdout` המקורי שלו (שהוא הקונסולה, שכן הוא לא ניתב אותו מחדש).\n    בהנחה שהתיקייה מכילה קבצים כמו `main.c`, `test.txt`, `utils.h`, `data.csv`, הפלט של `ls -1` לצינור יהיה:\n    ```\n    data.csv\n    main.c\n    test.txt\n    utils.h\n    ```\n    `grep .c` יקרא את זה וימצא את השורות המכילות \".c\".\n    לכן, הפלט לקונסולה יהיה בערך:\n    ```\n    main.c\n    utils.h\n    Parent finished.\n    ```\n    סדר ההדפסה בין הפלט של `grep` לבין \"Parent finished.\" אינו מובטח, כיוון שתהליך ההורה ידפיס את השורה שלו רק לאחר ששני הילדים יסתיימו, ו-`grep` מדפיס בזמן אמת. לרוב, `grep` יסיים לפני שההורה ידפיס את השורה שלו, אך זה תלוי בתזמון. אם `grep` מדפיס הרבה שורות, הפלט של ההורה יכול להופיע לאחר חלק או כל הפלט של `grep`."
    },
    "difficulty_estimation": "Hard"
  }
}