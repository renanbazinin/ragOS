{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Concurrency",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-08 00:37:09",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1926,
      "output_tokens": 607,
      "total_tokens": 4155
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Concurrency",
      "Synchronization",
      "Race Conditions"
    ],
    "content": {
      "text": "נתונה תוכנית שבה מספר תהליכונים (threads) מעדכנים מונה משותף (shared counter) ללא שימוש במנגנוני סנכרון. הסבירו איזו בעיה עלולה להתרחש וכיצד ניתן לפתור אותה באמצעות מנגנון סנכרון מתאים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הבעיה שעלולה להתרחש היא 'מצב מירוץ' (Race Condition). מצב מירוץ מתרחש כאשר מספר תהליכונים ניגשים לנתון משותף (כמו המונה במקרה זה) ומשנים אותו בו-זמנית, והתוצאה הסופית תלויה בסדר הלא-דטרמיניסטי שבו פעולות התהליכונים מתבצעות. לדוגמה, פעולת הקידום של המונה (קריאה, שינוי, כתיבה) אינה אטומית. תהליכון אחד עלול לקרוא את ערך המונה, ואז לפני שהוא מספיק לכתוב את הערך המעודכן, תהליכון אחר קורא את אותו ערך ישן, משנה אותו וכותב אותו בחזרה. כאשר התהליכון הראשון ימשיך לכתוב את ערכו המעודכן, הוא ידרוס את השינוי של השני, וכך קידום אחד 'יאבד'.\nכדי לפתור בעיה זו, יש להגן על הגישה למונה המשותף באמצעות מנגנון סנכרון, לדוגמה מנעול (mutex). מנעול מבטיח שרק תהליכון אחד יוכל להיכנס לקטע קריטי (Critical Section) – הקטע בתוכנית שבו הנתון המשותף מעודכן – בכל רגע נתון. תהליכון המבקש להיכנס לקטע קריטי בזמן שהמנעול תפוס על ידי תהליכון אחר, ייחסם עד שהמנעול ישוחרר. באופן זה, פעולת העדכון של המונה הופכת לאטומית, והתוצאה הסופית תהיה נכונה."
    },
    "difficulty_estimation": "Easy"
  }
}