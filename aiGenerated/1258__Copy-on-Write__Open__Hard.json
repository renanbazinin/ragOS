{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:02:43",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4965,
      "output_tokens": 2828,
      "total_tokens": 15206
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Copy-on-Write",
      "Processes"
    ],
    "content": {
      "text": "תהליך אב (Parent) מקצה בלוק זיכרון בגודל 400KB. לאחר מכן, הוא יוצר 3 תהליכי ילד (Child processes) באמצעות קריאת המערכת `fork()`. מערכת ההפעלה משתמשת במנגנון Copy-on-Write (CoW) עבור דפי זיכרון משותפים. גודל דף זיכרון הוא 4KB.\n\nלאחר ה-`fork()`:\n*   תהליך ילד מס' 1 כותב ל-10 הדפים הראשונים בבלוק הזיכרון שהוקצה (דפים 0-9).\n*   תהליך ילד מס' 2 כותב ל-10 הדפים שמתחילים מהדף החמישי בבלוק הזיכרון (דפים 5-14).\n*   תהליך ילד מס' 3 כותב ל-10 הדפים שמתחילים מהדף העשירי בבלוק הזיכרון (דפים 10-19).\n\nתהליך האב אינו מבצע שום כתיבה לבלוק זיכרון זה לאחר ה-`fork()`.\nיש לפרט ולנמק את כל החישובים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "כמה דפים פיזיים בסך הכל נצרכים על ידי כל התהליכים (האב והילדים) עבור בלוק זיכרון זה, לאחר שכל הכתיבות בוצעו?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "כמה Page Faults מסוג CoW בסך הכל התרחשו במהלך ביצוע כל הכתיבות על ידי תהליכי הילד?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "הסבר כיצד שימוש במנגנון CoW משפיע על זמן האתחול של תהליכים חדשים (לדוגמה, בזמן `fork()`) לעומת מצב שבו כל הזיכרון היה משוכפל באופן מיידי. מהן ההשלכות על צריכת זיכרון?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "חישובים מקדימים:\nגודל בלוק זיכרון: 400KB.\nגודל דף זיכרון: 4KB.\nמספר הדפים הראשוני שהוקצה לאב: 400KB / 4KB = 100 דפים (נסמן אותם P0 עד P99).\n\n1.1. כמה דפים פיזיים בסך הכל נצרכים על ידי כל התהליכים (האב והילדים) עבור בלוק זיכרון זה, לאחר שכל הכתיבות בוצעו?\nבתחילה, לאחר קריאת `fork()`, כל 100 הדפים של תהליך האב משותפים עם כל אחד מ-3 תהליכי הילד באמצעות מנגנון CoW. כלומר, בשלב זה נצרכים 100 דפים פיזיים בלבד.\n\nננתח את השפעת הכתיבות:\n*   **דפים P0-P4 (5 דפים):** נכתבו רק על ידי תהליך ילד מס' 1. לכן, עבור כל אחד מדפים אלה, תהליך האב וילדים 2 ו-3 ממשיכים להצביע לדף הפיזי המקורי, ואילו תהליך ילד מס' 1 מקבל עותק פיזי משלו. סה\"כ 2 דפים פיזיים לכל דף וירטואלי בקבוצה זו (דף מקורי + עותק של ילד 1). בסך הכל: 5 * 2 = 10 דפים פיזיים.\n\n*   **דפים P5-P9 (5 דפים):** נכתבו על ידי תהליך ילד מס' 1 וגם על ידי תהליך ילד מס' 2. עבור כל אחד מדפים אלה, תהליך האב וילד 3 ממשיכים להצביע לדף הפיזי המקורי. ילד מס' 1 מקבל עותק משלו, וילד מס' 2 מקבל עותק משלו. סה\"כ 3 דפים פיזיים לכל דף וירטואלי בקבוצה זו (דף מקורי + עותק של ילד 1 + עותק של ילד 2). בסך הכל: 5 * 3 = 15 דפים פיזיים.\n\n*   **דפים P10-P14 (5 דפים):** נכתבו על ידי תהליך ילד מס' 2 וגם על ידי תהליך ילד מס' 3. עבור כל אחד מדפים אלה, תהליך האב וילד 1 ממשיכים להצביע לדף הפיזי המקורי. ילד מס' 2 מקבל עותק משלו, וילד מס' 3 מקבל עותק משלו. סה\"כ 3 דפים פיזיים לכל דף וירטואלי בקבוצה זו (דף מקורי + עותק של ילד 2 + עותק של ילד 3). בסך הכל: 5 * 3 = 15 דפים פיזיים.\n\n*   **דפים P15-P19 (5 דפים):** נכתבו רק על ידי תהליך ילד מס' 3. לכן, עבור כל אחד מדפים אלה, תהליך האב וילדים 1 ו-2 ממשיכים להצביע לדף הפיזי המקורי, ואילו תהליך ילד מס' 3 מקבל עותק פיזי משלו. סה\"כ 2 דפים פיזיים לכל דף וירטואלי בקבוצה זו (דף מקורי + עותק של ילד 3). בסך הכל: 5 * 2 = 10 דפים פיזיים.\n\n*   **דפים P20-P99 (80 דפים):** לא נכתבו על ידי אף אחד מהתהליכים. לכן, הם נשארים משותפים (עותק פיזי יחיד) בין האב וכל הילדים. בסך הכל: 80 * 1 = 80 דפים פיזיים.\n\nסה\"כ דפים פיזיים נצרכים: 10 + 15 + 15 + 10 + 80 = 130 דפים פיזיים.\n\n1.2. כמה Page Faults מסוג CoW בסך הכל התרחשו במהלך ביצוע כל הכתיבות על ידי תהליכי הילד?\nPage Fault מסוג CoW מתרחש כאשר תהליך מנסה לכתוב לראשונה לדף זיכרון שמשותף עם תהליכים אחרים (ומסומן כ-CoW). כל כתיבה ראשונה של תהליך לדף כזה תגרום ל-fault ולשכפול הדף עבור אותו תהליך.\n\n*   **תהליך ילד מס' 1:** כותב ל-10 דפים (P0-P9). כל אחד מהם הוא דף משותף שזו הפעם הראשונה שילד 1 כותב אליו. לכן, יתקבלו 10 CoW faults.\n\n*   **תהליך ילד מס' 2:** כותב ל-10 דפים (P5-P14). כל אחד מהם הוא דף משותף (גם אם ילד 1 כבר יצר עותק משלו לדפים P5-P9, עבור ילד 2 אלו עדיין דפים משותפים עם האב וילד 3 עד לרגע הכתיבה). לכן, יתקבלו 10 CoW faults.\n\n*   **תהליך ילד מס' 3:** כותב ל-10 דפים (P10-P19). בדומה, כל אחד מהם הוא דף משותף. לכן, יתקבלו 10 CoW faults.\n\nסה\"כ CoW Page Faults: 10 + 10 + 10 = 30 faults.\n\n1.3. הסבר כיצד שימוש במנגנון CoW משפיע על זמן האתחול של תהליכים חדשים (לדוגמה, בזמן `fork()`) לעומת מצב שבו כל הזיכרון היה משוכפל באופן מיידי. מהן ההשלכות על צריכת זיכרון?\n\n**השפעה על זמן האתחול (`fork()`):**\nשימוש במנגנון CoW מפחית באופן משמעותי את זמן האתחול של תהליכים חדשים (במיוחד בקריאת `fork()`). במקום להעתיק את כל מרחב הכתובות של תהליך האב באופן מיידי (פעולה יקרה וגוזלת זמן רב עבור תהליכים גדולים), `fork()` עם CoW רק משכפל את טבלאות הדפים (או מבני נתונים דומים) ומסמן את הדפים הפיזיים של האב כקריאה-בלבד ומשותפים. העתקת הדפים הפיזיים עצמם נדחית לרגע שבו אחד התהליכים (האב או הילד) מנסה לכתוב לדף משותף. זה הופך את פעולת ה-`fork()` למהירה בהרבה, וזה קריטי במערכות הפעלה מודרניות שבהן תהליכים חדשים נוצרים לעיתים קרובות (לדוגמה, תהליך ילד שמיד מבצע `exec()`).\n\n**השלכות על צריכת זיכרון:**\n*   **צריכת זיכרון ראשונית (לאחר `fork()`):** צריכת הזיכרון הפיזי נמוכה בהרבה. במקום שכל תהליך ילד יקבל סט מלא של עותקים פיזיים של דפי האב, כל הילדים חולקים את אותם דפים פיזיים עם האב. הזיכרון הפיזי הכולל שנצרך על ידי האב וכל הילדים יחד כמעט זהה לזה שנצרך על ידי האב בלבד (בתוספת תקורה קטנה עבור טבלאות דפים חדשות).\n*   **צריכת זיכרון לאחר כתיבות:** ככל שהתהליכים (אב או ילדים) כותבים לדפים משותפים, כך נוצרים עותקים פיזיים חדשים של הדפים. במקרה הגרוע ביותר, אם כל תהליך ילד כותב לכל דף, וגם האב כותב לכל דף, צריכת הזיכרון יכולה להגיע ל- (N+1) * מספר הדפים המקורי (כאשר N הוא מספר הילדים). עם זאת, בתרחישים טיפוסיים, תהליכים בדרך כלל קוראים הרבה יותר משהם כותבים, או שהם משנים אזורים שונים בזיכרון, מה שמוביל לחיסכון משמעותי בזיכרון בהשוואה לשכפול מלא. CoW מספק איזון, ודוחה את הקצאת הזיכרון עד לרגע שבו היא הכרחית."
    },
    "difficulty_estimation": "Hard"
  }
}