{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:37:28",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1032,
      "output_tokens": 757,
      "total_tokens": 3642
    }
  },
  "question": {
    "id": 4,
    "type": "MultipleChoice",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Critical Section"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה שבה שני תהליכים, P1 ו-P2, מנסים לגשת למשאב משותף X. הם משתמשים בסמפור בינארי בשם `mutex` שאותחל ל-1. להלן קטעי הקוד המתארים את פעולתם:",
      "code_snippet": "sem_t mutex; // Global semaphore variable\n\nvoid init_sem() {\n    sem_init(&mutex, 0, 1); // Initialize mutex to 1 (binary semaphore)\n}\n\nvoid P1_task() {\n    sem_wait(&mutex); // Wait for the semaphore\n    // Critical Section: Access shared resource X\n    printf(\"Process P1 is accessing shared resource X.\\n\");\n    sem_post(&mutex); // Signal (release) the semaphore\n}\n\nvoid P2_task() {\n    sem_wait(&mutex); // Wait for the semaphore\n    // Critical Section: Access shared resource X\n    printf(\"Process P2 is accessing shared resource X.\\n\");\n    sem_post(&mutex); // Signal (release) the semaphore\n}\n\n// Assuming init_sem() is called once before P1_task and P2_task are run concurrently.",
      "options": [
        "א. שני התהליכים יכולים לגשת למשאב X בו-זמנית, מה שיוביל לתנאי מרוץ.",
        "ב. רק תהליך אחד יכול לגשת למשאב X בכל רגע נתון.",
        "ג. אחד התהליכים יגרום ל-deadlock עבור התהליך השני.",
        "ד. הגישה למשאב X אינה מובטחת, וקריאות `sem_wait` עשויות להיכשל.",
        "ה. הסמפור ימנע גישה למשאב X לצמיתות עבור אחד התהליכים עקב רעב (starvation)."
      ]
    },
    "sub_questions": null,
    "points": 5,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "ב. סמפור בינארי המאותחל ל-1 משמש כמנעול (mutex) להגנה על קטע קריטי. כאשר תהליך קורא ל-`sem_wait()` (או `P()`), הוא מקטין את ערך הסמפור. אם ערכו הופך ל-0, תהליכים אחרים שיקראו ל-`sem_wait()` יחסמו עד שהתהליך הנוכחי יקרא ל-`sem_post()` (או `V()`) וישחרר את הסמפור. לכן, רק תהליך אחד יכול להימצא בקטע הקריטי (הגישה למשאב X) בכל רגע נתון, ובכך נמנעים תנאי מרוץ ומובטחת הדדיות (mutual exclusion)."
    },
    "difficulty_estimation": "Medium"
  }
}