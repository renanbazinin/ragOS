{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores and Deadlocks",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 20:32:28",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1047,
      "output_tokens": 1230,
      "total_tokens": 3578
    }
  },
  "question": {
    "id": 5,
    "type": "MultipleChoice",
    "topic": [
      "Semaphores",
      "Deadlocks",
      "Concurrency"
    ],
    "content": {
      "text": "נתון קטע הקוד הבא המשתמש בסמפורים (POSIX semaphores) המאותחלים לערך 1 (כלומר, סמפורים בינאריים):\n\n```c\n#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n\nsem_t s1, s2;\n\nvoid* thread1_func(void* arg) {\n    printf(\"Thread 1: Trying to acquire s1\\n\");\n    sem_wait(&s1);\n    printf(\"Thread 1: Acquired s1, trying to acquire s2\\n\");\n    sem_wait(&s2);\n    printf(\"Thread 1: Acquired s2. Critical section.\\n\");\n    // Critical section\n    sem_post(&s2);\n    printf(\"Thread 1: Released s2\\n\");\n    sem_post(&s1);\n    printf(\"Thread 1: Released s1\\n\");\n    return NULL;\n}\n\nvoid* thread2_func(void* arg) {\n    printf(\"Thread 2: Trying to acquire s2\\n\");\n    sem_wait(&s2);\n    printf(\"Thread 2: Acquired s2, trying to acquire s1\\n\");\n    sem_wait(&s1);\n    printf(\"Thread 2: Acquired s1. Critical section.\\n\");\n    // Critical section\n    sem_post(&s1);\n    printf(\"Thread 2: Released s1\\n\");\n    sem_post(&s2);\n    printf(\"Thread 2: Released s2\\n\");\n    return NULL;\n}\n\n// main function would initialize semaphores and create threads\n// sem_init(&s1, 0, 1); sem_init(&s2, 0, 1);\n// pthread_create(&t1, NULL, thread1_func, NULL);\n// pthread_create(&t2, NULL, thread2_func, NULL);\n```\n\nבהנחה ששני התהליכים (thread1_func ו-thread2_func) מתחילים לרוץ במקביל, איזו מהטענות הבאות נכונה לגבי מצב קיפאון (deadlock)?",
      "code_snippet": null,
      "options": [
        "א. קיפאון אינו אפשרי מכיוון שכל תהליך משחרר את הסמפורים שרכש בסופו של דבר.",
        "ב. קיפאון אפשרי מכיוון ששני התהליכים מנסים לרכוש את הסמפורים בסדר הפוך, מה שיוצר תלות מעגלית.",
        "ג. קיפאון אינו אפשרי מכיוון שהסמפורים מאותחלים לערך 1, מה שמבטיח שכל תהליך יוכל לרכוש לפחות סמפור אחד.",
        "ד. קיפאון אפשרי רק אם אחד הסמפורים מאותחל לערך 0."
      ]
    },
    "sub_questions": null,
    "points": 5,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "התשובה הנכונה היא ב'. קיפאון אפשרי במקרה זה. תנאי הקיפאון של Coffman מתקיימים:\n1.  **הדרה הדדית (Mutual Exclusion)**: הסמפורים מספקים הדרה הדדית; רק תהליך אחד יכול להחזיק בסמפור בכל רגע נתון.\n2.  **החזקה והמתנה (Hold and Wait)**: תהליך 1 יכול לרכוש את `s1` ולהמתין ל-`s2`, בעוד שתהליך 2 יכול לרכוש את `s2` ולהמתין ל-`s1`. כל תהליך מחזיק במשאב אחד וממתין לאחר.\n3.  **אי-שלילה (No Preemption)**: לא ניתן לשלול סמפור מתהליך שמחזיק בו; תהליך חייב לשחרר אותו מרצון.\n4.  **המתנה מעגלית (Circular Wait)**: תהליך 1 ממתין לסמפור `s2` שמוחזק על ידי תהליך 2, ותהליך 2 ממתין לסמפור `s1` שמוחזק על ידי תהליך 1. זהו מעגל המתנה מובהק.\n\nסדר הרכישה ההפוך (thread1 רוכש s1 ואז s2, בעוד thread2 רוכש s2 ואז s1) הוא הגורם הישיר למעגל ההמתנה הזה, שיכול להוביל לקיפאון אם שניהם יצליחו לרכוש את הסמפור הראשון שלהם במקביל."
    },
    "difficulty_estimation": "Medium"
  }
}