{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Processes and Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:14:17",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3064,
      "output_tokens": 4166,
      "total_tokens": 16483
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Processes",
      "Memory Management",
      "Copy-on-Write",
      "System Calls"
    ],
    "content": {
      "text": "נתונות התוכניות הבאות, `prog1.c` ו-`prog2.c`:\nהריצו את התוכנית `prog1`. יש להניח שכל קריאות המערכת הצליחו, לא נוצרים תהליכים בקטעי קוד אחרים במערכת, וכל תהליך מקבל מזהה הגדול ב-1 מהתהליך שנוצר לפניו. המערכת משתמשת במנגנון Copy-on-Write (COW) עבור דפים ששונו לאחר fork.\n\nהנחות נוספות:\n* גודל דף זיכרון הוא 4KB.\n* קטע הקוד של `prog1` תופס דף אחד.\n* קטע הנתונים הגלובליים של `prog1` (כולל `global_data`) תופס דף אחד.\n* קטע הקוד של `prog2` תופס דף אחד.\n* קטע הנתונים הגלובליים של `prog2` (כולל `prog2_global_data`) תופס דף אחד.\n* מחסנית (stack) התחלתית לכל תהליך תופסת דף אחד.\n* קריאה ל-`malloc(4096)` מקצה דף זיכרון אחד מהערימה (heap).\n* קריאה ל-`malloc(2048)` מקצה דף זיכרון אחד מהערימה (heap) (מערכת ההפעלה מקצה בגודל דף מלא).\n* כל קריאות ה-`memset` מבטיחות כתיבה לדפי הזיכרון שהוקצו או שונו.\n* אין שימוש ב-swapping. אף תהליך אחר במערכת אינו מבצע הקצאה, שחרור או גישה לזיכרון.\n* ידוע כי מיד לפני הרצת התוכנית `prog1`, במערכת ההפעלה תפוסות 30 מסגרות עבור זיכרון של מרחב המשתמש (user space).\n\nבאיזו נקודת זמן אנו מתעניינים? מיד לאחר שכל התהליכים נוצרו, וכל תהליך שצריך להריץ `execvp` כבר ביצע זאת בהצלחה והחל לרוץ `prog2`, אך אף תהליך עוד לא הסתיים (לפני שקריאות ה-`wait` ב-`prog1` מסתיימות, ובעוד `prog2` מבצע `sleep(1)`).",
      "code_snippet": "// prog1.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <string.h>\n\n// Global data to ensure a data segment exists\nint global_data[1024]; // 4KB\n\nvoid allocate_some_memory() {\n    // Allocate some heap memory\n    char* heap_ptr = (char*)malloc(4096); // 1 page\n    if (heap_ptr) {\n        memset(heap_ptr, 0, 4096); // Trigger copy-on-write for this page if forked\n        printf(\"PID %d allocated and touched heap memory.\\n\", getpid());\n    } else {\n        printf(\"PID %d failed to allocate heap memory.\\n\", getpid());\n    }\n}\n\nint main() {\n    printf(\"Prog1: Initial PID %d, PPID %d\\n\", getpid(), getppid());\n    \n    // Touch global data to ensure it's loaded into a page and later triggers COW\n    global_data[0] = getpid(); \n\n    allocate_some_memory(); // P0 allocates 1 heap page\n\n    pid_t pid1 = fork();\n    if (pid1 == 0) { // Child 1\n        printf(\"Prog1 Child1: PID %d, PPID %d\\n\", getpid(), getppid());\n        global_data[1] = getpid(); // Child 1 modifies global data, triggering COW\n        allocate_some_memory(); // Child 1 allocates another heap page\n        \n        char* args[] = {\"./prog2\", NULL};\n        execvp(args[0], args);\n        perror(\"execvp failed\"); // Should not be reached\n        exit(1);\n    }\n\n    pid_t pid2 = fork();\n    if (pid2 == 0) { // Child 2\n        printf(\"Prog1 Child2: PID %d, PPID %d\\n\", getpid(), getppid());\n        global_data[2] = getpid(); // Child 2 modifies global data, triggering COW\n        // Child 2 does NOT exec, but continues running prog1\n        allocate_some_memory(); // Child 2 allocates another heap page\n        sleep(1); // Stay alive for the snapshot\n        exit(0);\n    }\n    \n    // Parent waits for children\n    waitpid(pid1, NULL, 0);\n    waitpid(pid2, NULL, 0);\n\n    printf(\"Prog1 Parent: PID %d exiting.\\n\", getpid());\n    return 0;\n}\n\n// prog2.c (Separate file, compiled as 'prog2')\n// #include <stdio.h>\n// #include <stdlib.h>\n// #include <unistd.h>\n// #include <string.h>\n\n// // Global data for prog2\n// char prog2_global_data[512]; // Small global data\n\n// int main() {\n//     printf(\"Prog2: PID %d, PPID %d\\n\", getpid(), getppid());\n//     prog2_global_data[0] = 'A'; // Touch global data\n    \n//     char* prog2_heap_ptr = (char*)malloc(2048); // Half a page, but allocates full page\n//     if (prog2_heap_ptr) {\n//         memset(prog2_heap_ptr, 0, 2048);\n//         printf(\"Prog2 PID %d allocated and touched its own heap.\\n\", getpid());\n//     }\n    \n//     sleep(1); // Stay alive for the snapshot\n//     return 0;\n// }"
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "כמה מסגרות זיכרון פיזיות (physical frames) יהיו תפוסות במערכת עבור זיכרון המשתמש (user space) בנקודת הזמן המתוארת? יש לציין את המקרה המינימלי והמקסימלי האפשריים, תוך התחשבות בכך שקטעי קוד ניתנים לשיתוף בין תהליכים שונים, במידה והם זהים ומערכת ההפעלה מאפשרת זאת (כמו במקרה של `execvp` לתוכנית שכבר נטענה). יש לפרט את החישוב לכל מקרה.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "ננתח את מצב הזיכרון בכל שלב, תוך התחשבות במנגנון Copy-on-Write (COW) ובשיתוף קודים של תוכניות:\n\n**הנחות בסיסיות לכל תהליך:**\n*   קוד `prog1`: דף 1.\n*   נתונים `prog1`: דף 1.\n*   מחסנית `prog1`: דף 1.\n*   ערימה `prog1` (מ-`malloc(4096)`): דף 1.\n*   קוד `prog2`: דף 1.\n*   נתונים `prog2`: דף 1.\n*   מחסנית `prog2`: דף 1.\n*   ערימה `prog2` (מ-`malloc(2048)`): דף 1.\n\n**מעקב אחר יצירת תהליכים ודפי זיכרון:**\n\n1.  **תהליך הורה (P0) מריץ את `prog1`:**\n    *   P0 מתחיל עם: קוד (1 דף), נתונים (1 דף), מחסנית (1 דף). סה\"כ 3 דפים ייחודיים.\n    *   `global_data[0] = getpid();` מבטיח כתיבה לדף הנתונים.\n    *   `allocate_some_memory();` ב-P0 מקצה דף ערימה נוסף (1 דף) וכותבת אליו.\n    *   **מצב P0:** קוד (P_Code1), נתונים (P_Data1), מחסנית (P_Stack1), ערימה (P_Heap1). סה\"כ 4 דפים ייחודיים.\n    *   סה\"כ מסגרות תפוסות במערכת: 30 (התחלתי) + 4 (של P0) = 34.\n\n2.  **`fork()` ראשון יוצר תהליך בן (C1):**\n    *   C1 מקבל מרחב כתובות שהוא עותק של P0. עקב COW:\n        *   קוד (P_Code1) וערימה (P_Heap1) משותפים עם P0.\n        *   מחסנית (P_Stack2) חדשה ל-C1.\n        *   נתונים (P_Data1) משותפים עם P0.\n    *   `global_data[1] = getpid();` ב-C1: כתיבה לדף הנתונים של C1 גורמת ל-COW. דף נתונים חדש (P_Data2) נוצר עבור C1.\n    *   `allocate_some_memory();` ב-C1: מקצה דף ערימה נוסף (P_Heap2) וכותבת אליו.\n    *   **מצב C1 לפני `execvp`:** קוד (P_Code1 משותף), נתונים (P_Data2), מחסנית (P_Stack2), ערימה (P_Heap1 משותף, P_Heap2).\n    *   סה\"כ דפים ייחודיים חדשים עד כה: P_Code1, P_Data1, P_Stack1, P_Heap1 (מ-P0), P_Stack2, P_Data2, P_Heap2 (מ-C1). סה\"כ 7 דפים ייחודיים.\n    *   סה\"כ מסגרות תפוסות במערכת: 30 + 7 = 37.\n\n3.  **`execvp(\"./prog2\", ...)` ב-C1:**\n    *   מרחב הכתובות של C1 מוחלף לחלוטין בזה של `prog2`.\n    *   `prog2` דורש: קוד (P_Code2), נתונים (P_Data3), מחסנית (P_Stack3).\n    *   `prog2_global_data[0] = 'A';` מבטיח כתיבה לדף הנתונים של `prog2` (P_Data3).\n    *   `malloc(2048)` ב-C1 (מריץ `prog2`): מקצה דף ערימה נוסף (P_Heap3) וכותבת אליו.\n    *   **מצב C1 (מריץ `prog2`):** קוד (P_Code2), נתונים (P_Data3), מחסנית (P_Stack3), ערימה (P_Heap3). סה\"כ 4 דפים ייחודיים ל-C1.\n    *   הדפים P_Data2, P_Stack2, P_Heap2 שהיו שייכים ל-C1 לפני `execvp` משוחררים.\n\n4.  **`fork()` שני יוצר תהליך בן (C2):**\n    *   P0 מבצע `fork()` נוסף. C2 מקבל מרחב כתובות שהוא עותק של P0 (שוב, P0 לא השתנה מאז ה-fork הראשון מבחינת הדפים שלו).\n        *   קוד (P_Code1) וערימה (P_Heap1) משותפים עם P0.\n        *   מחסנית (P_Stack4) חדשה ל-C2.\n        *   נתונים (P_Data1) משותפים עם P0.\n    *   `global_data[2] = getpid();` ב-C2: כתיבה לדף הנתונים של C2 גורמת ל-COW. דף נתונים חדש (P_Data4) נוצר עבור C2.\n    *   `allocate_some_memory();` ב-C2: מקצה דף ערימה נוסף (P_Heap4) וכותבת אליו.\n    *   **מצב C2 (מריץ `prog1`):** קוד (P_Code1 משותף), נתונים (P_Data4), מחסנית (P_Stack4), ערימה (P_Heap1 משותף, P_Heap4). סה\"כ 5 דפים ייחודיים ל-C2 (מתוכם 2 משותפים).\n\n**חישוב סה\"כ מסגרות פיזיות תפוסות בנקודת הזמן הנדרשת:**\nנחשב את כל הדפים הייחודיים במערכת בנקודת הזמן שבה P0, C1 (מריץ prog2) ו-C2 (מריץ prog1) כולם פעילים, וכל השינויים וההקצאות בוצעו כמפורט.\n\n**דפים ייחודיים שנוצרו/נשמרו:**\n*   **מ-P0:**\n    *   קוד `prog1`: P_Code1 (1 דף)\n    *   נתונים `prog1`: P_Data1 (1 דף)\n    *   מחסנית `prog1`: P_Stack1 (1 דף)\n    *   ערימה `prog1`: P_Heap1 (1 דף)\n*   **מ-C1 (מריץ `prog2`):**\n    *   קוד `prog2`: P_Code2 (1 דף)\n    *   נתונים `prog2`: P_Data3 (1 דף)\n    *   מחסנית `prog2`: P_Stack3 (1 דף)\n    *   ערימה `prog2`: P_Heap3 (1 דף)\n*   **מ-C2 (מריץ `prog1`):**\n    *   מחסנית `prog1`: P_Stack4 (1 דף)\n    *   נתונים `prog1`: P_Data4 (1 דף) (נוצר עקב COW)\n    *   ערימה `prog1`: P_Heap4 (1 דף)\n\n**סה\"כ דפים ייחודיים חדשים מהרצת `prog1`:**\n1 (P_Code1) + 1 (P_Data1) + 1 (P_Stack1) + 1 (P_Heap1) + \n1 (P_Code2) + 1 (P_Data3) + 1 (P_Stack3) + 1 (P_Heap3) + \n1 (P_Stack4) + 1 (P_Data4) + 1 (P_Heap4) = **11 דפים**.\n\n**המקרה המקסימלי:**\nאם קוד `prog2` (P_Code2) אינו קיים כבר בזיכרון הפיזי ונטען לראשונה, אז כל 11 הדפים הללו יהיו חדשים וייחודיים. \nסה\"כ מסגרות תפוסות: 30 (התחלתי) + 11 (חדשים) = **41 מסגרות**.\n\n**המקרה המינימלי:**\nאם קוד `prog2` (P_Code2) כבר קיים בזיכרון הפיזי (למשל, מריצה קודמת של `prog2` על ידי תהליך אחר, ומערכת ההפעלה משתפת קטעי קוד זהים), אז ה-1 דף עבור קוד `prog2` לא יצטרך להיטען למסגרת פיזית חדשה, אלא ישותף. כל שאר הדפים (נתונים, מחסנית, ערימה) יהיו ייחודיים לכל תהליך.\nבמקרה זה, נחסוך דף אחד.\nסה\"כ דפים ייחודיים חדשים: 11 - 1 = 10 דפים.\nסה\"כ מסגרות תפוסות: 30 (התחלתי) + 10 (חדשים) = **40 מסגרות**.\n\n**תשובה:**\n*   **מינימלי:** 40 מסגרות.\n*   **מקסימלי:** 41 מסגרות."
    },
    "difficulty_estimation": "Hard"
  }
}