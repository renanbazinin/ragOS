{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 21:06:51",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2768,
      "output_tokens": 2131,
      "total_tokens": 8009
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Processes",
      "CPU Scheduling",
      "Real-Time Scheduling",
      "Priority Scheduling"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת באלגוריתם תזמון Round-Robin (RR) סטנדרטי עם קוואנטום זמן קבוע. במערכת קיימים שני סוגים עיקריים של תהליכים:\n1.  **תהליכי משתמש אינטראקטיביים (I/O-bound)**: תהליכים אלו מבלים את רוב זמנם בהמתנה לפעולות קלט/פלט, אך דורשים היענות מהירה כאשר הם הופכים למוכנים לריצה.\n2.  **תהליכי אצווה (CPU-bound)**: תהליכים אלו מבצעים חישובים ארוכים וצורכים זמן מעבד רב.\n\nבנוסף, המערכת כוללת **תהליך דמון קריטי (Critical System Daemon)** בעל עדיפות גבוהה במיוחד. תהליך הדמון הוא CPU-bound ודורש ריצה קצרה (לדוגמה, 10ms) כל 100ms על מנת לבצע משימות חיוניות לתקינות המערכת (לדוגמה, ניטור או איסוף נתונים). אם תהליך הדמון לא יקבל זמן מעבד במועד, הדבר עלול לפגוע ביציבות המערכת.\n\n**שאלות:**\n1.  תארו את ההשפעות והבעיות האפשריות אם תהליך הדמון הקריטי משולב בתור ה-RR הרגיל, אך עם עדיפות גבוהה יותר (לדוגמה, על ידי קבלת קוואנטום גדול יותר או על ידי דחיפה לתחילת התור כאשר הוא הופך למוכן). התייחסו להשפעה על תהליכי המשתמש (האינטראקטיביים והאצווה).\n2.  הציעו שינוי או שיפור לאלגוריתם ה-RR הסטנדרטי כדי לאפשר את ריצתו היעילה והבטוחה של תהליך הדמון הקריטי, תוך שמירה על רמה סבירה של היענות והוגנות עבור תהליכי המשתמש. הסבירו מדוע הפתרון שהצעתם עדיף ומצמצם את הבעיות שתיארתם בסעיף הקודם.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **השפעות ובעיות אפשריות:**\n    אם תהליך הדמון הקריטי משולב בתור ה-RR הרגיל עם עדיפות גבוהה:\n    *   **קוואנטום גדול יותר:** אם הדמון מקבל קוואנטום גדול יותר מתהליכים אחרים, הוא יתפוס את המעבד לזמן רב יותר. מכיוון שהוא CPU-bound וצריך לרוץ כל 100ms, הדבר עלול לגרום לעיכובים משמעותיים בתהליכי המשתמש. תהליכים אינטראקטיביים יחוו חוסר היענות (latency גבוה), ותהליכי אצווה יתעכבו באופן משמעותי, מה שיפגע בתפוקה הכוללת.\n    *   **דחיפה לתחילת התור (Preemption/High Priority):** אם הדמון דוחף את עצמו לתחילת התור בכל פעם שהוא הופך למוכן (כל 100ms), הוא יקבל את המעבד באופן מיידי. מכיוון שהוא CPU-bound ורץ למשך 10ms, הוא למעשה \"גוזל\" 10% מזמן המעבד באופן קבוע. זה פוגע בהוגנות ובחלוקת המעבד לתהליכים האחרים. תהליכים אינטראקטיביים עלולים עדיין לחוות עיכובים אם הדמון רץ בדיוק כשהם הופכים למוכנים. תהליכי אצווה יתקדמו לאט יותר באופן עקבי. במקרה קיצוני, אם זמן הריצה של הדמון ארוך מספיק או תדירותו גבוהה מספיק, הוא עלול לגרום להרעבה (starvation) של תהליכים בעלי עדיפות נמוכה יותר, במיוחד אם הם מנסים לרוץ בתקופות בהן הדמון פעיל.\n\n2.  **הצעת שינוי לאלגוריתם ה-RR:**\n    הצעה לשינוי היא לשלב את תהליך הדמון הקריטי במנגנון תזמון מבוסס עדיפויות עם תמיכה בריצה תקופתית, תוך שמירה על RR עבור שאר התהליכים. ניתן להשתמש בגישה של Multi-Level Feedback Queue (MLFQ) אך עם התאמות ספציפיות לדמון:\n\n    1.  **קביעת תור עדיפות גבוהה במיוחד לדמון:**\n        *   ליצור תור נפרד, בעל העדיפות הגבוהה ביותר, המיועד אך ורק לתהליך הדמון הקריטי.\n        *   תהליך הדמון ירוץ בתור זה. כאשר הוא הופך למוכן, הוא דוחה (preempts) כל תהליך אחר שרץ במעבד (למעט אולי תהליכי מערכת קריטיים יותר, אם קיימים).\n        *   הקוואנטום של הדמון בתור זה יהיה קצר ומותאם בדיוק לזמן הריצה הנדרש שלו (לדוגמה, 10ms).\n        *   לאחר ריצת הקוואנטום שלו, הדמון יחזור למצב המתנה (waiting) עד לתקופה הבאה שלו (100ms).\n\n    2.  **תורים רגילים לתהליכי משתמש (MLFQ/RR):**\n        *   תהליכי המשתמש (אינטראקטיביים ואצווה) ימשיכו להיות מתוזמנים באמצעות אלגוריתם RR רגיל, או עדיף, באמצעות MLFQ עם מספר תורים:\n            *   **תור עליון (Priority 1):** לתהליכים אינטראקטיביים, עם קוואנטום קצר. תהליכים שמשתמשים בכל הקוואנטום יורדים לתור הבא.\n            *   **תור תחתון (Priority 2):** לתהליכי אצווה, עם קוואנטום ארוך יותר.\n        *   **Priority Boost:** יש ליישם מנגנון Priority Boost תקופתי (לדוגמה, כל מספר שניות) כדי למנוע הרעבה של תהליכי אצווה בתורים הנמוכים, ולהעלותם לתור העליון.\n\n    **מדוע פתרון זה עדיף:**\n\n    *   **הבטחת ריצת הדמון:** תהליך הדמון מקבל את העדיפות הגבוהה ביותר ותור ייעודי, מה שמבטיח שהוא ירוץ בזמן הנדרש ויתרום ליציבות המערכת. ה-preemption מבטיח היענות מיידית לדמון.\n    *   **מזעור הפרעה:** מכיוון שהקוואנטום של הדמון מוגבל בדיוק לזמן הריצה הנדרש (10ms), הוא גוזל רק את המינימום ההכרחי מזמן המעבד (10% במקרה זה). זה מקטין משמעותית את ההשפעה השלילית על תהליכי המשתמש בהשוואה לקוואנטום גדול יותר או ריצה בלתי מוגבלת.\n    *   **היענות לתהליכים אינטראקטיביים:** תהליכים אינטראקטיביים נשארים בתורים בעלי עדיפות גבוהה (או בתור ה-RR הראשי) ומקבלים קוואנטומים קצרים, מה שמשמר את ההיענות שלהם. ההפרעה של הדמון היא קצרה ותקופתית.\n    *   **הוגנות לתהליכי אצווה:** ה-MLFQ עם מנגנון ה-Priority Boost מבטיח שתהליכי אצווה לא יורעבו ויתקדמו בסופו של דבר, גם אם לאט יותר. חלוקת המעבד הנותרת (90%) מתבצעת באופן הוגן יחסית ביניהם."
    },
    "difficulty_estimation": "Medium"
  }
}