{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Synchronization",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 19:54:51",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3826,
      "output_tokens": 3699,
      "total_tokens": 26309
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Threads",
      "Synchronization",
      "Deadlock",
      "Condition Variables",
      "Race Conditions"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה, המנסה לתאם קידום של מונה משותף (counter) על ידי מספר חוטים. כל חוט מריץ את הפונקציה thread_func. הכלל הוא שרק חוטים עם מזהה זוגי (thread_id % 2 == 0) רשאים לקדם את המונה כאשר ערכו זוגי, ורק חוטים עם מזהה אי-זוגי (thread_id % 2 != 0) רשאים לקדם את המונה כאשר ערכו אי-זוגי. כל חוט מנסה לקדם את המונה N_INCREMENTS פעמים. ניתן להניח שפונקציית main יוצרת מספר T_THREADS של חוטים, ומעבירה לכל אחד מהם מזהה ייחודי (0 עד T_THREADS-1).",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <stdbool.h>\n\n#define T_THREADS 4 // ניתן לשנות ערך זה לבדיקה\n#define N_INCREMENTS 3 // כל חוט מנסה לקדם את המונה מספר פעמים זה\n\nint counter = 0;\npthread_mutex_t mutex;\npthread_cond_t cond_even;\npthread_cond_t cond_odd;\n\n// פונקציה שמדמה קבלת מזהה חוט (עוברת כארגומנט)\nvoid* thread_func(void* arg) {\n    int thread_id = (long)arg;\n\n    for (int i = 0; i < N_INCREMENTS; ++i) {\n        pthread_mutex_lock(&mutex);\n\n        // חוט זוגי ממתין אם המונה אי-זוגי. חוט אי-זוגי ממתין אם המונה זוגי.\n        while ( (thread_id % 2 == 0 && counter % 2 != 0) ||\n                (thread_id % 2 != 0 && counter % 2 != 1) ) {\n            if (thread_id % 2 == 0) {\n                pthread_cond_wait(&cond_even, &mutex);\n            } else {\n                pthread_cond_wait(&cond_odd, &mutex);\n            }\n        }\n\n        counter++;\n        printf(\"Thread %d incremented counter to %d\\n\", thread_id, counter);\n\n        // לאחר הקידום, זוגיות המונה השתנתה.\n        // יש לאותת לחוט מהסוג שיכול כעת להמשיך.\n        if (counter % 2 == 0) { // המונה כעת זוגי, חוט זוגי יכול להמשיך\n            pthread_cond_signal(&cond_even);\n        } else { // המונה כעת אי-זוגי, חוט אי-זוגי יכול להמשיך\n            pthread_cond_signal(&cond_odd);\n        }\n\n        pthread_mutex_unlock(&mutex);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[T_THREADS];\n    \n    pthread_mutex_init(&mutex, NULL);\n    pthread_cond_init(&cond_even, NULL);\n    pthread_cond_init(&cond_odd, NULL);\n\n    for (int i = 0; i < T_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, thread_func, (void*)(long)i);\n    }\n\n    for (int i = 0; i < T_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", counter);\n\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond_even);\n    pthread_cond_destroy(&cond_odd);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "התוכנית כפי שהיא אינה נכונה ועלולה להיתקע במצב של קיפאון (deadlock) או רעב (starvation). \n\n**הבעיה:**\nהבעיה העיקרית נובעת מהשימוש ב-`pthread_cond_signal`. פונקציה זו מעירה רק חוט אחד הממתין על משתנה התנאי. במערכת עם תלות בזוגיות המונה וזוגיות מזהה החוט, ישנם מספר תרחישים בהם חוטים עלולים להיתקע:\n1.  **התעוררות שגויה:** `pthread_cond_signal` מעירה חוט יחיד. ייתכן שהחוט שהתעורר אינו זה שיכול כעת להתקדם (לדוגמה, אם היו מספר חוטים זוגיים שממתינים, וחוט זוגי אחד התעורר אך הוא כבר סיים את כל הקידומים שלו, הוא יצא מהלולאה מבלי שהמונה יקודם שוב, והאות לחלופין לא נשלח). במקרה כזה, שאר החוטים הזוגיים יישארו רדומים.\n2.  **מצב קיפאון (Deadlock) ספציפי:** נניח `T_THREADS = 3` (חוטים 0, 1, 2) ו-`N_INCREMENTS = 2`. המונה הסופי המצופה הוא `3 * 2 = 6`. \n    *   המונה מתחיל ב-0 (זוגי). חוט 0 (זוגי) מקדם אותו ל-1. מאותת ל-`cond_odd`. (לחוט 0 נשאר קידום אחד).\n    *   חוט 1 (אי-זוגי) מתעורר ומקדם את המונה ל-2. מאותת ל-`cond_even`. (לחוט 1 נשאר קידום אחד).\n    *   חוט 2 (זוגי) מתעורר ומקדם את המונה ל-3. מאותת ל-`cond_odd`. (לחוט 2 נשאר קידום אחד).\n    *   חוט 1 (אי-זוגי) מתעורר ומקדם את המונה ל-4. מאותת ל-`cond_even`. (חוט 1 סיים את הקידומים שלו ויוצא).\n    *   חוט 0 (זוגי) מתעורר ומקדם את המונה ל-5. מאותת ל-`cond_odd`. (חוט 0 סיים את הקידומים שלו ויוצא).\n    *   בשלב זה, המונה הוא 5 (אי-זוגי). חוט 2 (זוגי) ממתין שערך המונה יהיה זוגי כדי שיוכל לקדם אותו. אך כל החוטים האי-זוגיים (רק חוט 1) כבר סיימו את עבודתם ויצאו. אין אף חוט אי-זוגי שיוכל לקדם את המונה ל-6 ולשנות את זוגיותו. לכן, חוט 2 ימתין ללא סוף, ויתרחש קיפאון.\n\n**התיקון:**\nכדי לתקן את הבעיות הללו, יש לבצע מספר שינויים:\n1.  **החלפת `pthread_cond_signal` ב-`pthread_cond_broadcast`:** שימוש ב-`broadcast` יבטיח שכל החוטים הממתינים על משתנה תנאי מסוים יתעוררו ויבדקו מחדש את התנאי שלהם. זה פותר את בעיית ההתעוררות השגויה ומבטיח שאם ישנם מספר חוטים רלוונטיים, כולם יקבלו הזדמנות לבדוק אם תורם הגיע.\n2.  **הוספת משתנה גלובלי למעקב אחר התקדמות כוללת ושימוש בו בתנאי ההמתנה:** כדי למנוע קיפאון כאשר כל החוטים מסוג מסוים סיימו את עבודתם אך המונה הכללי עדיין לא הגיע ליעדו, יש להוסיף משתנה גלובלי (`total_increments_done`) שיעקוב אחר מספר הקידומים הכולל שבוצעו. חוטים ימתינו רק אם תורם לא הגיע *וגם* המונה הכולל עדיין לא הגיע ליעד הסופי (`T_THREADS * N_INCREMENTS`).\n3.  **שידור כללי בסיום:** כאשר המונה הכולל מגיע ליעד הסופי, יש לשדר לשני משתני התנאי כדי להבטיח שכל החוטים שעדיין ממתינים (בגלל תנאי הזוגיות) יתעוררו ויגלו שהעבודה הסתיימה, ויצאו מהפונקציה.\n\n**קוד מתוקן:**\n\n```c\n#include <stdio.h>\n#include <pthread.h>\n#include <stdbool.h>\n\n#define T_THREADS 3 // ערך לדוגמה לתרחיש הקיפאון\n#define N_INCREMENTS 2 // ערך לדוגמה לתרחיש הקיפאון\n\nint counter = 0;\nint total_increments_done = 0; // חדש: מעקב אחר סך הקידומים שבוצעו\npthread_mutex_t mutex;\npthread_cond_t cond_even;\npthread_cond_t cond_odd;\n\nvoid* thread_func(void* arg) {\n    int thread_id = (long)arg;\n\n    for (int i = 0; i < N_INCREMENTS; ++i) {\n        pthread_mutex_lock(&mutex);\n\n        // חוט זוגי ממתין אם המונה אי-זוגי. חוט אי-זוגי ממתין אם המונה זוגי.\n        // הוספת תנאי יציאה: חוט ימתין רק אם תורו לא הגיע *וגם* העבודה הכוללת עדיין לא הסתיימה.\n        while ( ( (thread_id % 2 == 0 && counter % 2 != 0) || \n                  (thread_id % 2 != 0 && counter % 2 != 1) ) \n                && (total_increments_done < T_THREADS * N_INCREMENTS) ) {\n            if (thread_id % 2 == 0) {\n                pthread_cond_wait(&cond_even, &mutex);\n            } else {\n                pthread_cond_wait(&cond_odd, &mutex);\n            }\n        }\n\n        // לאחר שהתעוררנו או שלא המתנו, נבדוק שוב אם העבודה הכוללת הסתיימה.\n        // זה חשוב למקרה שחוט התעורר מ-broadcast וגילה שהיעד כבר הושג.\n        if (total_increments_done >= T_THREADS * N_INCREMENTS) {\n            pthread_mutex_unlock(&mutex);\n            return NULL; // יציאה מוקדמת אם היעד הכולל הושג\n        }\n\n        counter++;\n        total_increments_done++; // קידום המונה הכולל\n\n        printf(\"Thread %d incremented counter to %d (Total done: %d)\\n\", thread_id, counter, total_increments_done);\n\n        // שידור לכל החוטים הרלוונטיים (במקום signal)\n        if (counter % 2 == 0) { \n            pthread_cond_broadcast(&cond_even);\n        } else { \n            pthread_cond_broadcast(&cond_odd);\n        }\n        \n        // אם כל הקידומים בוצעו, יש לשדר לכל החוטים כדי שיצאו מההמתנה.\n        // זה חשוב כדי לשחרר חוטים שעדיין ממתינים עקב תנאי זוגיות שלא יתמלא יותר.\n        if (total_increments_done >= T_THREADS * N_INCREMENTS) {\n            pthread_cond_broadcast(&cond_even);\n            pthread_cond_broadcast(&cond_odd);\n        }\n\n        pthread_mutex_unlock(&mutex);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[T_THREADS];\n    \n    pthread_mutex_init(&mutex, NULL);\n    pthread_cond_init(&cond_even, NULL);\n    pthread_cond_init(&cond_odd, NULL);\n\n    for (int i = 0; i < T_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, thread_func, (void*)(long)i);\n    }\n\n    for (int i = 0; i < T_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", counter);\n\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond_even);\n    pthread_cond_destroy(&cond_odd);\n\n    return 0;\n}\n```\n\n**הסבר לתיקון:**\n*   **`total_increments_done`:** משתנה זה עוקב אחר מספר הקידומים הכלליים שבוצעו על ידי כל החוטים. המטרה הסופית היא להגיע ל-`T_THREADS * N_INCREMENTS` קידומים.\n*   **תנאי ה-`while`:** תנאי ההמתנה שונה כך שחוט ימתין רק אם תורו לא הגיע *וגם* אם המונה הכולל עדיין לא הגיע ליעד הסופי. ברגע שהמונה הכולל הגיע ליעד, חוטים לא ימתינו עוד, אלא יצאו מהלולאה (ומפונקציית `thread_func`).\n*   **`pthread_cond_broadcast`:** במקום `pthread_cond_signal`, אנו משתמשים ב-`pthread_cond_broadcast`. זה מבטיח שכל החוטים הממתינים על משתנה התנאי הרלוונטי יתעוררו ויבדקו מחדש את התנאי שלהם, כולל תנאי היציאה החדש. זה מונע מצב של חוטים רדומים כאשר תורם הגיע אך הם לא התעוררו.\n*   **שידור בסיום (`if (total_increments_done >= T_THREADS * N_INCREMENTS)`):** כאשר `total_increments_done` מגיע ליעד, מבוצע `broadcast` על שני משתני התנאי. זה מבטיח שגם חוטים שנותרו תקועים בהמתנה (כי תנאי הזוגיות שלהם לא התקיים, ואין יותר חוטים שיכולים לשנות את המונה) יתעוררו, יבדקו את `total_increments_done >= T_THREADS * N_INCREMENTS`, ויצאו מהפונקציה, ובכך נמנע קיפאון."
    },
    "difficulty_estimation": "Hard"
  }
}