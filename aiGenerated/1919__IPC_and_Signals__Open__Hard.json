{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:47:33",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 4665,
      "total_tokens": 19432
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Parent-Child Communication"
    ],
    "content": {
      "text": "תהליך אב יוצר N תהליכי בן (הגדירו N=5). כל תהליך בן מייצר מספר שלם אקראי (בין 1 ל-100), שולח אותו לתוכנית האב דרך צינור (pipe), ולאחר מכן נכנס ללולאה אינסופית בה הוא ממתין לאות. אם הבן מקבל את האות SIGUSR1, הוא מדפיס הודעה מתאימה וממשיך להמתין. אם הוא מקבל את האות SIGTERM, הוא מסיים את פעולתו.\n\nתהליך האב, לאחר יצירת כל הבנים, קורא את המספרים מכל הצינורות (אחד לכל בן). לאחר שקרא את כל המספרים, הוא ממיין אותם. על בסיס המספרים הממוינים, האב שולח את האות SIGTERM לכל הבנים ששלחו מספרים הגדולים מ-50, ואת האות SIGUSR1 לשאר הבנים. האב חייב גם לטפל באות SIGCHLD כדי לאסוף (reap) את הבנים שסיימו את פעולתם ולמנוע תהליכי זומבי.\n\nכתבו את קוד המקור המלא ב-C/C++ עבור תוכנית זו. הקוד צריך להיות עמיד בפני תקלות נפוצות בטיפול באותות וב-IPC, ובפרט להתייחס לנקודות הבאות:\n1.  טיפול נכון באותות (`SIGUSR1`, `SIGTERM`, `SIGCHLD`) באמצעות `sigaction`.\n2.  הבטחת קריאה וכתיבה בטוחות לצינורות, גם אם הן מופרעות על ידי אותות.\n3.  מניעת תהליכי זומבי.\n4.  הבטחת סנכרון נכון בין האב לבנים למניעת תנאי מרוץ (race conditions) במקרים בהם האב שולח אות לפני שהבן מוכן לקבל אותו (לדוגמה, הבן עדיין לא הגיע ללולאת ההמתנה).\n\nהסבירו בקצרה את עיקרי הפתרון והאתגרים שבו.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "הפתרון המוצע מדגים שימוש מתקדם במנגנוני IPC ואותות לסנכרון ותקשורת בין תהליכי אב ובן. להלן עיקרי הקוד והאתגרים שהוא פותר:\n\n**קוד המקור (C/C++):**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <errno.h>\n\n#define NUM_CHILDREN 5\n#define THRESHOLD 50\n\ntypedef struct {\n    pid_t pid;\n    int number;\n    int pipe_fd[2]; // for child to parent communication\n} child_info_t;\n\nchild_info_t children_info[NUM_CHILDREN];\nvolatile sig_atomic_t children_reaped = 0; // for parent to count reaped children\n\n// Signal handler for SIGCHLD in parent\nvoid sigchld_handler(int signum) {\n    int status;\n    pid_t p;\n    while ((p = waitpid(-1, &status, WNOHANG)) > 0) {\n        children_reaped++;\n        // printf(\"Parent: Reaped child %d\\n\", p); // Optional logging\n    }\n}\n\n// Signal handler for SIGUSR1 in child\nvoid sigusr1_handler(int signum) {\n    printf(\"Child %d (PID %d): Received SIGUSR1. Continuing to wait.\\n\", getpid(), getpid());\n}\n\n// Signal handler for SIGTERM in child\nvoid sigterm_handler(int signum) {\n    printf(\"Child %d (PID %d): Received SIGTERM. Exiting.\\n\", getpid(), getpid());\n    exit(0);\n}\n\n// Helper function to safely read/write, handling EINTR\nssize_t safe_write(int fd, const void *buf, size_t count) {\n    ssize_t res;\n    while ((res = write(fd, buf, count)) == -1 && errno == EINTR);\n    return res;\n}\n\nssize_t safe_read(int fd, void *buf, size_t count) {\n    ssize_t res;\n    while ((res = read(fd, buf, count)) == -1 && errno == EINTR);\n    return res;\n}\n\nvoid child_process(int child_idx, int write_fd) {\n    // Set up signal handlers for SIGUSR1 and SIGTERM\n    struct sigaction sa_usr1, sa_term;\n\n    sa_usr1.sa_handler = sigusr1_handler;\n    sigemptyset(&sa_usr1.sa_mask);\n    sa_usr1.sa_flags = SA_RESTART; // Restart interrupted syscalls\n    if (sigaction(SIGUSR1, &sa_usr1, NULL) == -1) {\n        perror(\"sigaction SIGUSR1 child\");\n        exit(1);\n    }\n\n    sa_term.sa_handler = sigterm_handler;\n    sigemptyset(&sa_term.sa_mask);\n    sa_term.sa_flags = SA_RESTART; // Restart interrupted syscalls\n    if (sigaction(SIGTERM, &sa_term, NULL) == -1) {\n        perror(\"sigaction SIGTERM child\");\n        exit(1);\n    }\n\n    // Block SIGUSR1 and SIGTERM temporarily while writing to pipe\n    // This prevents the parent from sending a signal before the child is ready to suspend.\n    sigset_t block_mask, old_mask;\n    sigemptyset(&block_mask);\n    sigaddset(&block_mask, SIGUSR1);\n    sigaddset(&block_mask, SIGTERM);\n    if (sigprocmask(SIG_BLOCK, &block_mask, &old_mask) == -1) {\n        perror(\"sigprocmask block child\");\n        exit(1);\n    }\n\n    // Generate random number\n    srand(time(NULL) ^ getpid()); // Seed with PID and time for better randomness\n    int num = rand() % 100 + 1; // Number between 1 and 100\n    printf(\"Child %d (PID %d): Generated number %d\\n\", child_idx, getpid(), num);\n\n    // Write number to parent via pipe\n    if (safe_write(write_fd, &num, sizeof(num)) != sizeof(num)) {\n        perror(\"Child: failed to write to pipe\");\n        exit(1);\n    }\n    close(write_fd); // Close write end in child after sending\n\n    // Unblock SIGUSR1 and SIGTERM, and then wait for signals using sigsuspend\n    printf(\"Child %d (PID %d): Sent number %d, now waiting for signal...\\n\", child_idx, getpid(), num);\n\n    sigset_t empty_mask;\n    sigemptyset(&empty_mask); // An empty mask means no signals are blocked when suspended\n\n    // Restore the original signal mask (unblocking SIGUSR1/SIGTERM) and then suspend\n    if (sigprocmask(SIG_SETMASK, &old_mask, NULL) == -1) { // Restore old mask BEFORE suspending\n        perror(\"sigprocmask unblock child before suspend\");\n        exit(1);\n    }\n\n    while(1) {\n        // sigsuspend atomically sets the process's signal mask to empty_mask and waits for a signal.\n        // Upon signal delivery and handler return, the original mask is restored.\n        // This ensures that SIGUSR1/SIGTERM are unblocked while waiting, and race conditions are avoided.\n        sigsuspend(&empty_mask);\n    }\n}\n\nint main() {\n    // Set up SIGCHLD handler in parent\n    struct sigaction sa_chld;\n    sa_chld.sa_handler = sigchld_handler;\n    sigemptyset(&sa_chld.sa_mask);\n    sa_chld.sa_flags = SA_RESTART | SA_NOCLDSTOP; // Restart interrupted syscalls, don't get signals for stopped children\n    if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {\n        perror(\"sigaction SIGCHLD parent\");\n        exit(1);\n    }\n\n    // Block SIGUSR1 and SIGTERM in parent (parent is not expected to handle these specific signals from children)\n    sigset_t parent_block_mask;\n    sigemptyset(&parent_block_mask);\n    sigaddset(&parent_block_mask, SIGUSR1);\n    sigaddset(&parent_block_mask, SIGTERM);\n    if (sigprocmask(SIG_BLOCK, &parent_block_mask, NULL) == -1) {\n        perror(\"sigprocmask block parent\");\n        exit(1);\n    }\n\n    // Create children and pipes\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (pipe(children_info[i].pipe_fd) == -1) {\n            perror(\"pipe\");\n            exit(1);\n        }\n\n        pid_t pid = fork();\n        if (pid == -1) {\n            perror(\"fork\");\n            exit(1);\n        }\n\n        if (pid == 0) { // Child process\n            close(children_info[i].pipe_fd[0]); // Close read end in child\n            // Close all other write ends that belong to other children's pipes\n            for (int j = 0; j < NUM_CHILDREN; ++j) {\n                if (j != i) { // This child doesn't need other children's pipes\n                    close(children_info[j].pipe_fd[0]); // Read end of other pipes\n                    close(children_info[j].pipe_fd[1]); // Write end of other pipes\n                }\n            }\n            child_process(i, children_info[i].pipe_fd[1]);\n            exit(0); // Should exit via sigterm_handler, but safety net\n        } else { // Parent process\n            children_info[i].pid = pid;\n            close(children_info[i].pipe_fd[1]); // Close write end in parent\n        }\n    }\n\n    // Parent reads numbers from children\n    printf(\"Parent (PID %d): Reading numbers from children...\\n\", getpid());\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (safe_read(children_info[i].pipe_fd[0], &(children_info[i].number), sizeof(int)) != sizeof(int)) {\n            perror(\"Parent: failed to read from pipe\");\n            children_info[i].number = -1; // Indicate failure\n        }\n        close(children_info[i].pipe_fd[0]); // Close read end after reading\n        printf(\"Parent: Received %d from child %d (PID %d)\\n\", children_info[i].number, i, children_info[i].pid);\n    }\n\n    // Sort children_info based on numbers (simple bubble sort for example)\n    for (int i = 0; i < NUM_CHILDREN - 1; ++i) {\n        for (int j = 0; j < NUM_CHILDREN - 1 - i; ++j) {\n            if (children_info[j].number > children_info[j+1].number) {\n                child_info_t temp = children_info[j];\n                children_info[j] = children_info[j+1];\n                children_info[j+1] = temp;\n            }\n        }\n    }\n\n    printf(\"Parent: Sorted numbers and PIDs:\\n\");\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        printf(\"  Child PID %d: Number %d\\n\", children_info[i].pid, children_info[i].number);\n    }\n\n    // Send signals based on threshold\n    printf(\"Parent: Sending signals to children...\\n\");\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (children_info[i].number > THRESHOLD) {\n            printf(\"Parent: Sending SIGTERM to child PID %d (number %d > %d)\\n\", children_info[i].pid, children_info[i].number, THRESHOLD);\n            kill(children_info[i].pid, SIGTERM);\n        } else {\n            printf(\"Parent: Sending SIGUSR1 to child PID %d (number %d <= %d)\\n\", children_info[i].pid, children_info[i].number, THRESHOLD);\n            kill(children_info[i].pid, SIGUSR1);\n        }\n    }\n\n    // Wait for all children to be reaped\n    printf(\"Parent: Waiting for all children to exit...\\n\");\n    while (children_reaped < NUM_CHILDREN) {\n        sleep(1); // Wait and let SIGCHLD handler do its work\n    }\n\n    printf(\"Parent: All children reaped. Parent exiting.\\n\");\n\n    return 0;\n}\n```\n\n**הסבר מפורט וניתוח אתגרים:**\n\n1.  **טיפול באותות באמצעות `sigaction`**: במקום הפונקציה הישנה `signal()`, נעשה שימוש ב-`sigaction()`. זוהי הדרך המודרנית והמומלצת לטפל באותות מכיוון שהיא מספקת שליטה רבה יותר על התנהגות האות. לדוגמה:\n    *   `sa_handler`: מציין את הפונקציה שתטפל באות.\n    *   `sigemptyset(&sa.sa_mask)`: מבטיח ששום אות לא יהיה חסום אוטומטית בזמן שהמטפל באות פועל (ניתן גם להוסיף אותות ספציפיים למסכה זו).\n    *   `SA_RESTART`: דגל זה גורם לקריאות מערכת איטיות (כמו `read`, `write`) שהופרעו על ידי אות, להתחיל מחדש באופן אוטומטי במקום להיכשל עם `EINTR`. זה משפר את עמידות הקוד.\n    *   `SA_NOCLDSTOP` (עבור `SIGCHLD`): מונע מהמערכת לשלוח `SIGCHLD` כאשר תהליך בן נעצר (לדוגמה, עם `SIGSTOP`), אלא רק כאשר הוא מסיים את פעולתו (exit).\n\n2.  **מניעת תנאי מרוץ וסנכרון (`sigprocmask`, `sigsuspend`)**:\n    *   **בצד הבן**: לפני שהבן כותב את המספר שלו לצינור, הוא חוסם באופן זמני את האותות `SIGUSR1` ו-`SIGTERM` באמצעות `sigprocmask(SIG_BLOCK, ...)`. זה מבטיח שהאב לא יוכל לשלוח אות לבן לפני שהבן סיים את פעולתו הקריטית של כתיבה לצינור. רק לאחר שהמספר נשלח והבן מוכן להיכנס למצב המתנה, הוא משחרר את חסימת האותות ומשתמש ב-`sigsuspend(&empty_mask)` כדי להמתין לאות. `sigsuspend` היא פונקציה אטומית: היא משנה את מסכת האותות של התהליך למסכה הריקה שניתנה לה (כלומר, מאפשרת קבלת כל האותות), ואז משעה את התהליך עד לקבלת אות. כשהאות מטופל והמטפל חוזר, `sigsuspend` משחזרת את מסכת האותות המקורית. זה מונע מצב שבו אות נשלח בדיוק בין שחרור החסימה לבין כניסה למצב המתנה (window of vulnerability).\n    *   **בצד האב**: האב חוסם את `SIGUSR1` ו-`SIGTERM` מכיוון שאינו מצפה לטפל בהם בעצמו. זהו נוהג מומלץ כדי למנוע קבלת אותות לא רצויים.\n\n3.  **טיפול ב-`EINTR` (קריאות מערכת שנקטעו)**: למרות השימוש ב-`SA_RESTART`, קריאות מערכת מסוימות (או גרסאות ישנות יותר של ספריות) עדיין עלולות להיקטע על ידי אות ולחזור עם `errno == EINTR`. הפונקציות `safe_read()` ו-`safe_write()` מטפלות במצב זה באופן מפורש על ידי ניסיון חוזר של הפעולה עד להשלמתה בהצלחה או לכישלון מסיבה אחרת.\n\n4.  **מניעת תהליכי זומבי (`SIGCHLD`, `waitpid`)**:\n    *   תהליך זומבי נוצר כאשר תהליך בן מסיים את פעולתו אך תהליך האב שלו לא קרא את סטטוס היציאה שלו באמצעות `wait()` או `waitpid()`. תהליכי זומבי צורכים משאבי מערכת (בעיקר ערך בטבלת התהליכים).\n    *   הפתרון מטפל בזה על ידי הגדרת מטפל לאות `SIGCHLD` בתהליך האב. מטפל זה מופעל בכל פעם שתהליך בן משנה סטטוס (לדוגמה, מסיים). בתוך המטפל, קריאה ל-`waitpid(-1, &status, WNOHANG)` בלולאה מבטיחה שכל הבנים שסיימו את פעולתם (גם אם מספר בנים סיימו בבת אחת) ייאספו (reaped) באופן מיידי, ובכך נמנעת יצירת תהליכי זומבי.\n\n5.  **סגירת קצוות צינורות מיותרים**: כל תהליך (אב ובן) סוגר את קצוות הצינורות שאינם רלוונטיים עבורו. הבן סוגר את קצה הקריאה של הצינור שלו ואת שני קצוות הצינורות של שאר הבנים. האב סוגר את קצה הכתיבה של כל הצינורות. זה חשוב כדי למנוע מצבי קיפאון (deadlocks) וכדי שהקריאה מהצינור תדע מתי לסיים (EOF) כאשר כל קצוות הכתיבה נסגרו."
    },
    "difficulty_estimation": "Hard"
  }
}