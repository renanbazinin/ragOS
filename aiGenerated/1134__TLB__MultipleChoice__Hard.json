{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "TLB",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:10:22",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 969,
      "output_tokens": 959,
      "total_tokens": 4456
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "TLB",
      "Virtual Memory",
      "Context Switching",
      "Performance"
    ],
    "content": {
      "text": "נתונה מערכת עם TLB חד-שכבתי (single-level TLB) שאינו תומך במזהי מרחב כתובות (ASIDs - Address Space Identifiers) ואינו כולל ביט 'גלובלי' (global bit) עבור כניסות ה-TLB. המערכת מבצעת מעברי הקשר תכופים בין שני תהליכים, P1 ו-P2. שני התהליכים משתמשים באותם דפי קוד של ספרייה משותפת ולקריאה בלבד, אך לכל אחד מהם יש דפי נתונים פרטיים משלו. איזו טענה מתארת בצורה המדויקת ביותר את התנהגות ה-TLB ואת השלכות הביצועים שלה במהלך מעברי הקשר אלה?",
      "code_snippet": null,
      "options": [
        "א. בכל מעבר הקשר (context switch), ה-TLB חייב להתרוקן באופן מלא (flush), מה שיוביל בהכרח ל-TLB misses עבור כל הגישות הראשונות לזיכרון לאחר המעבר, כולל עבור דפי הקוד המשותפים.",
        "ב. ה-TLB אינו חייב להתרוקן במעבר הקשר, אך עקב כך, גישות לדפי הנתונים הפרטיים של תהליך אחד עלולות להשתמש בערכי TLB שגויים השייכים לתהליך האחר, מה שיוביל לשגיאות גישה לזיכרון.",
        "ג. ניתן ליישם אופטימיזציה שבה מערכת ההפעלה מרוקנת רק את ערכי ה-TLB הקשורים לדפי הנתונים הפרטיים של התהליך הקודם, ומשאירה את הערכים של דפי הקוד המשותפים, ובכך משפרת את הביצועים.",
        "ד. מכיוון שדפי הקוד משותפים ולקריאה בלבד, ערכי ה-TLB המתאימים להם יישארו תקפים ב-TLB גם לאחר מעבר הקשר, ויספקו hits, בעוד שרק ערכי דפי הנתונים הפרטיים ידרשו flush או יגרמו ל-misses."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. במערכת TLB שאינה תומכת ב-ASIDs או בביט גלובלי, אין דרך חומרתית להבחין בין כניסות TLB השייכות לתהליכים שונים או לזהות כניסות שתקפות עבור כל התהליכים (כמו דפי קוד משותפים). לכן, בכל פעם שמתרחש מעבר הקשר (context switch) בין תהליכים, ה-TLB חייב להתרוקן במלואו (full flush) כדי למנוע מתהליך חדש להשתמש במיפויי כתובות שגויים השייכים לתהליך הקודם. ריקון מלא זה גורם לכך שכל גישה ראשונה לזיכרון לאחר המעבר, גם לדפים המשותפים ולדפים שנגשו אליהם רק לפני רגע, תגרום ל-TLB miss, מה שפוגע בביצועים. אפשרויות ב', ג' ו-ד' שגויות מכיוון שהן מניחות יכולות (כמו אי-צורך בריקון מלא, או ריקון סלקטיבי חכם, או זיהוי אוטומטי של דפים משותפים) שאינן קיימות במערכת TLB ללא ASIDs או ביט גלובלי."
    },
    "difficulty_estimation": "Hard"
  }
}