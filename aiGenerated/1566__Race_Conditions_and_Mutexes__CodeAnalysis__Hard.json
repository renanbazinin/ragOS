{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Race Conditions and Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 11:31:56",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 5488,
      "output_tokens": 3649,
      "total_tokens": 20666
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Race Conditions",
      "Mutexes",
      "Deadlock",
      "Concurrency"
    ],
    "content": {
      "text": "נתונים שני משתנים גלובליים `x` ו-`y` המאותחלים ל-0, ושני מנעולי `pthread_mutex_t` בשם `mutex_x` ו-`mutex_y` המגנים עליהם בהתאמה. שני חוטים מריצים במקביל את הפונקציות `thread_A_func` ו-`thread_B_func` המופיעות בקוד להלן. \n\n1. זהו את בעיית הסנכרון העיקרית הקיימת בקוד. תארו תרחיש ספציפי (רצף פעולות) המוביל לבעיה זו, והסבירו מדוע היא מתרחשת.\n2. פרטו את כל זוגות הערכים האפשריים עבור המשתנים `x` ו-`y` אשר יכולים להתקבל לאחר ששני החוטים מסיימים את הריצה שלהם *בהצלחה* (כלומר, ללא התרחשות בעיית הסנכרון שזיהיתם). לכל זוג ערכים יש לפרט בקצרה את סדר הריצה המוביל אליו.\n3. הציעו תיקון לקוד על מנת למנוע את בעיית הסנכרון, תוך שמירה על הלוגיקה והמטרה המקורית של הפעולות. אין צורך לשכתב את כל הקוד, אלא להדגים את השינויים הנדרשים.",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n\nint x = 0;\nint y = 0;\npthread_mutex_t mutex_x;\npthread_mutex_t mutex_y;\n\nvoid* thread_A_func(void* arg) {\n    // Operation 1 for Thread A\n    pthread_mutex_lock(&mutex_x);\n    x = x + 1;\n    pthread_mutex_lock(&mutex_y);\n    y = y + x;\n    pthread_mutex_unlock(&mutex_y);\n    pthread_mutex_unlock(&mutex_x);\n\n    // Operation 2 for Thread A\n    pthread_mutex_lock(&mutex_y);\n    y = y * 2;\n    pthread_mutex_lock(&mutex_x);\n    x = x + y;\n    pthread_mutex_unlock(&mutex_x);\n    pthread_mutex_unlock(&mutex_y);\n    return NULL;\n}\n\nvoid* thread_B_func(void* arg) {\n    // Operation 1 for Thread B\n    pthread_mutex_lock(&mutex_y);\n    y = y + 2;\n    pthread_mutex_lock(&mutex_x);\n    x = x + y;\n    pthread_mutex_unlock(&mutex_x);\n    pthread_mutex_unlock(&mutex_y);\n\n    // Operation 2 for Thread B\n    pthread_mutex_lock(&mutex_x);\n    x = x * 2;\n    pthread_mutex_lock(&mutex_y);\n    y = y + x;\n    pthread_mutex_unlock(&mutex_y);\n    pthread_mutex_unlock(&mutex_x);\n    return NULL;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. **זיהוי הבעיה ותיאור תרחיש:**\nהבעיה העיקרית היא **קיפאון (Deadlock)**.\n\n**תרחיש לדוגמה המוביל לקיפאון:**\n- חוט A מתחיל את `thread_A_func`. הוא נועל בהצלחה את `mutex_x` (שורה 1 בפונקציה שלו).\n- חוט A מבצע `x = x + 1;` (כעת `x=1`).\n- מתבצע מעבר הקשר (context switch) לחוט B.\n- חוט B מתחיל את `thread_B_func`. הוא נועל בהצלחה את `mutex_y` (שורה 1 בפונקציה שלו).\n- חוט B מבצע `y = y + 2;` (כעת `y=2`).\n- חוט B מנסה לנעול את `mutex_x` (שורה 3 בפונקציה שלו). `mutex_x` נעול על ידי חוט A, ולכן חוט B נחסם וממתין.\n- מתבצע מעבר הקשר חזרה לחוט A.\n- חוט A מנסה לנעול את `mutex_y` (שורה 3 בפונקציה שלו). `mutex_y` נעול על ידי חוט B, ולכן חוט A נחסם וממתין.\nבשלב זה, חוט A ממתין ל-`mutex_y` שמוחזק על ידי חוט B, וחוט B ממתין ל-`mutex_x` שמוחזק על ידי חוט A. נוצר מעגל המתנה הדדי, והחוטים נמצאים בקיפאון.\n\n2. **זוגות ערכים אפשריים בסיום מוצלח:**\nאם התוכנית מסתיימת בהצלחה (ללא קיפאון), קיימים 4 זוגות ערכים אפשריים עבור `x` ו-`y`. (הערכים ההתחלתיים: `x=0, y=0`)\n\n*   **זוג 1: (x=14, y=18)**\n    *   **תיאור הריצה:** חוט A מסיים את כל שתי הפעולות שלו (`Op1`, `Op2`), ולאחר מכן חוט B מסיים את כל שתי הפעולות שלו (`Op1`, `Op2`).\n    *   **חישוב:**\n        *   **לאחר A_Op1:** `x=0 -> x=1` (`x=1`). `y=0 -> y=0+1=1` (`y=1`). (מצב: `x=1, y=1`)\n        *   **לאחר A_Op2:** `y=1 -> y=1*2=2` (`y=2`). `x=1 -> x=1+2=3` (`x=3`). (מצב: `x=3, y=2`)\n        *   **לאחר B_Op1:** `y=2 -> y=2+2=4` (`y=4`). `x=3 -> x=3+4=7` (`x=7`). (מצב: `x=7, y=4`)\n        *   **לאחר B_Op2:** `x=7 -> x=7*2=14` (`x=14`). `y=4 -> y=4+14=18` (`y=18`).\n    *   **תוצאה סופית:** `x=14, y=18`\n\n*   **זוג 2: (x=27, y=22)**\n    *   **תיאור הריצה:** חוט B מסיים את כל שתי הפעולות שלו (`Op1`, `Op2`), ולאחר מכן חוט A מסיים את כל שתי הפעולות שלו (`Op1`, `Op2`).\n    *   **חישוב:**\n        *   **לאחר B_Op1:** `y=0 -> y=0+2=2` (`y=2`). `x=0 -> x=0+2=2` (`x=2`). (מצב: `x=2, y=2`)\n        *   **לאחר B_Op2:** `x=2 -> x=2*2=4` (`x=4`). `y=2 -> y=2+4=6` (`y=6`). (מצב: `x=4, y=6`)\n        *   **לאחר A_Op1:** `x=4 -> x=4+1=5` (`x=5`). `y=6 -> y=6+5=11` (`y=11`). (מצב: `x=5, y=11`)\n        *   **לאחר A_Op2:** `y=11 -> y=11*2=22` (`y=22`). `x=5 -> x=5+22=27` (`x=27`).\n    *   **תוצאה סופית:** `x=27, y=22`\n\n*   **זוג 3: (x=20, y=26)**\n    *   **תיאור הריצה:** חוט A מסיים את פעולה 1, לאחר מכן חוט B מסיים את פעולה 1, לאחר מכן חוט A מסיים את פעולה 2, ולאחר מכן חוט B מסיים את פעולה 2.\n    *   **חישוב:**\n        *   **לאחר A_Op1:** `x=1, y=1`. (מצב: `x=1, y=1`)\n        *   **לאחר B_Op1:** `y=1 -> y=1+2=3` (`y=3`). `x=1 -> x=1+3=4` (`x=4`). (מצב: `x=4, y=3`)\n        *   **לאחר A_Op2:** `y=3 -> y=3*2=6` (`y=6`). `x=4 -> x=4+6=10` (`x=10`). (מצב: `x=10, y=6`)\n        *   **לאחר B_Op2:** `x=10 -> x=10*2=20` (`x=20`). `y=6 -> y=6+20=26` (`y=26`).\n    *   **תוצאה סופית:** `x=20, y=26`\n\n*   **זוג 4: (x=28, y=22)**\n    *   **תיאור הריצה:** חוט B מסיים את פעולה 1, לאחר מכן חוט A מסיים את פעולה 1, לאחר מכן חוט B מסיים את פעולה 2, ולאחר מכן חוט A מסיים את פעולה 2.\n    *   **חישוב:**\n        *   **לאחר B_Op1:** `x=2, y=2`. (מצב: `x=2, y=2`)\n        *   **לאחר A_Op1:** `x=2 -> x=2+1=3` (`x=3`). `y=2 -> y=2+3=5` (`y=5`). (מצב: `x=3, y=5`)\n        *   **לאחר B_Op2:** `x=3 -> x=3*2=6` (`x=6`). `y=5 -> y=5+6=11` (`y=11`). (מצב: `x=6, y=11`)\n        *   **לאחר A_Op2:** `y=11 -> y=11*2=22` (`y=22`). `x=6 -> x=6+22=28` (`x=28`).\n    *   **תוצאה סופית:** `x=28, y=22`\n\n3. **תיקון הקוד למניעת קיפאון:**\nכדי למנוע קיפאון, יש להבטיח שכל החוטים תמיד ינעלו את המנעולים באותו סדר קנוני. נבחר לסדר את המנעולים לפי כתובתם בזיכרון (או לפי שם קבוע, למשל תמיד `mutex_x` ואז `mutex_y`).\n\n**שינויים מוצעים:**\n```c\n// ... (global variables x, y, mutex_x, mutex_y remain the same)\n\nvoid* thread_A_func(void* arg) {\n    // Operation 1 for Thread A - fixed locking order\n    pthread_mutex_lock(&mutex_x); // Always lock mutex_x first\n    pthread_mutex_lock(&mutex_y); // Then lock mutex_y\n    x = x + 1;\n    y = y + x;\n    pthread_mutex_unlock(&mutex_y);\n    pthread_mutex_unlock(&mutex_x);\n\n    // Operation 2 for Thread A - fixed locking order\n    pthread_mutex_lock(&mutex_x); // Always lock mutex_x first\n    pthread_mutex_lock(&mutex_y); // Then lock mutex_y\n    y = y * 2;\n    x = x + y;\n    pthread_mutex_unlock(&mutex_y);\n    pthread_mutex_unlock(&mutex_x);\n    return NULL;\n}\n\nvoid* thread_B_func(void* arg) {\n    // Operation 1 for Thread B - fixed locking order\n    pthread_mutex_lock(&mutex_x); // Always lock mutex_x first\n    pthread_mutex_lock(&mutex_y); // Then lock mutex_y\n    y = y + 2;\n    x = x + y;\n    pthread_mutex_unlock(&mutex_y);\n    pthread_mutex_unlock(&mutex_x);\n\n    // Operation 2 for Thread B - fixed locking order\n    pthread_mutex_lock(&mutex_x); // Always lock mutex_x first\n    pthread_mutex_lock(&mutex_y); // Then lock mutex_y\n    x = x * 2;\n    y = y + x;\n    pthread_mutex_unlock(&mutex_y);\n    pthread_mutex_unlock(&mutex_x);\n    return NULL;\n}\n```\n**הסבר לתיקון:**\nעל ידי אכיפת סדר קנוני (למשל, תמיד `mutex_x` ואז `mutex_y`), אנו מונעים את התנאי ההכרחי לקיפאון של \"החזק והמתן\" ו\"המתנה מעגלית\". כעת, אם חוט כלשהו מחזיק ב-`mutex_x` וממתין ל-`mutex_y`, שום חוט אחר לא יוכל לנעול את `mutex_y` ואז לנסות לנעול את `mutex_x`, מכיוון שהוא ינסה קודם כל לנעול את `mutex_x`. זה מבטיח שכל המנעולים יילקחו באותו סדר עקבי, ובכך נמנע קיפאון.\nחשוב לציין כי למרות התיקון, עדיין קיימות מספר ריצות אפשריות (אינטרליבינג) בין הפעולות המורכבות (Operation 1, Operation 2 של כל חוט), ולכן עדיין ייתכנו מספר זוגות ערכים סופיים שונים עבור `x` ו-`y`, כפי שפורט בסעיף הקודם. התיקון מונע קיפאון, אך אינו כופה סדר ביצוע סדרתי גמור של כל הפעולות."
    },
    "difficulty_estimation": "Hard"
  }
}