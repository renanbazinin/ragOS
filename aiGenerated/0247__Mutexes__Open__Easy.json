{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:14:10",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2084,
      "output_tokens": 1211,
      "total_tokens": 4499
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Mutexes",
      "Synchronization",
      "Race Conditions"
    ],
    "content": {
      "text": "הסבר בקצרה מהו Mutex ומדוע הוא נחוץ במערכות מרובות תהליכונים (multithreaded systems). לאחר מכן, נתון קטע קוד המכיל משתנה גלובלי משותף. הוסף לקטע הקוד שימוש ב-Mutex על מנת להבטיח גישה בטוחה למשתנה המשותף ולמנוע תנאי מרוץ (race conditions).",
      "code_snippet": "```c\n#include <stdio.h>\n#include <pthread.h>\n\nint global_counter = 0;\n\nvoid* increment_thread(void* arg) {\n    for (int i = 0; i < 100000; ++i) {\n        // קטע קריטי: הגדלת global_counter\n        global_counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2;\n\n    pthread_create(&tid1, NULL, increment_thread, NULL);\n    pthread_create(&tid2, NULL, increment_thread, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    printf(\"Final counter value: %d\\n\", global_counter);\n\n    return 0;\n}\n```",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "Mutex (קיצור של Mutual Exclusion) הוא מנגנון סנכרון המשמש להגנה על משאבים משותפים במערכות מרובות תהליכונים. מטרתו העיקרית היא למנוע תנאי מרוץ (race conditions) שבהם גישה סימולטנית למשאב משותף עלולה להוביל לתוצאות בלתי צפויות או שגויות. Mutex מבטיח שרק תהליכון אחד יוכל לגשת לקטע קריטי (critical section) של קוד בו מעורב המשאב המשותף בכל רגע נתון. כאשר תהליכון רוצה לגשת למשאב, הוא נועל את ה-mutex. אם ה-mutex כבר נעול על ידי תהליכון אחר, התהליכון המבקש ימתין עד שה-mutex ישוחרר. לאחר סיום השימוש במשאב, התהליכון משחרר את ה-mutex, ומאפשר לתהליכונים אחרים לגשת אליו.\n\nלהלן קטע הקוד המתוקן עם שימוש ב-Mutex:\n\n```c\n#include <stdio.h>\n#include <pthread.h>\n\nint global_counter = 0;\npthread_mutex_t counter_mutex; // הגדרת Mutex\n\nvoid* increment_thread(void* arg) {\n    for (int i = 0; i < 100000; ++i) {\n        pthread_mutex_lock(&counter_mutex); // נעילת Mutex לפני הכניסה לקטע הקריטי\n        global_counter++; // קטע קריטי\n        pthread_mutex_unlock(&counter_mutex); // שחרור Mutex לאחר היציאה מהקטע הקריטי\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2;\n\n    pthread_mutex_init(&counter_mutex, NULL); // אתחול Mutex\n\n    pthread_create(&tid1, NULL, increment_thread, NULL);\n    pthread_create(&tid2, NULL, increment_thread, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    pthread_mutex_destroy(&counter_mutex); // השמדת Mutex\n\n    printf(\"Final counter value: %d\\n\", global_counter);\n\n    return 0;\n}\n```\n\nבמימוש המתוקן, המשתנה `counter_mutex` מוגדר כ- `pthread_mutex_t`. לפני יצירת התהליכונים, ה-mutex מאותחל באמצעות `pthread_mutex_init`. בתוך הפונקציה `increment_thread`, קריאות ל-`pthread_mutex_lock` ו-`pthread_mutex_unlock` עוטפות את הקטע הקריטי (`global_counter++`). זה מבטיח שרק תהליכון אחד יכול לגשת ל-`global_counter` בכל רגע נתון, ובכך מונע תנאי מרוץ ומבטיח שהערך הסופי של המונה יהיה נכון (200000 במקרה זה). בסיום התוכנית, ה-mutex מושמד באמצעות `pthread_mutex_destroy`."
    },
    "difficulty_estimation": "Easy"
  }
}