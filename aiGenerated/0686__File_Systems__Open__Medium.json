{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 23:33:42",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2275,
      "output_tokens": 1844,
      "total_tokens": 7537
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "File Systems"
    ],
    "content": {
      "text": "משתמש חדש מתקין מערכת קבצים חדשה ומתכנן לאחסן בה שני סוגי קבצים עיקריים: אלפי קבצים קטנים מאוד (בגודל של מספר בתים בודדים) וקובץ אחד גדול מאוד (בגודל של מאות ג'יגה-בייט). הניחו שגודל הבלוק במערכת הקבצים הוא 4KB. נתחו והשוו את שיטות הקצאת הבלוקים הבאות (Contiguous, Linked, Indexed) בהתייחס לאופן שבו הן יתמודדו עם אתגרי אחסון אלו. התייחסו לשיקולים הבאים עבור כל שיטה:\n1. ניצול שטח דיסק (פנימי וחיצוני).\n2. ביצועי קריאה/כתיבה סדרתית.\n3. ביצועי קריאה/כתיבה אקראית.\n4. מורכבות ניהול ה-metadata.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "להלן ניתוח והשוואה של שיטות הקצאת הבלוקים השונות בהתייחס לתרחיש הנתון:\n\n**1. הקצאה רציפה (Contiguous Allocation):**\n*   **ניצול שטח דיסק:**\n    *   **קבצים קטנים:** סובלת מפרגמנטציה פנימית גבוהה (כל קובץ, גם אם הוא בגודל בתים בודדים, יתפוס בלוק שלם – 4KB). \n    *   **קובץ גדול:** סובלת קשות מפרגמנטציה חיצונית. קשה מאוד למצוא רצף של מאות ג'יגה-בייט של בלוקים פנויים על הדיסק, במיוחד לאחר שימוש מסוים במערכת הקבצים. אם נמצא רצף כזה, אין פרגמנטציה פנימית למעט הבלוק האחרון אם גודל הקובץ אינו כפולה של גודל הבלוק.\n*   **ביצועי קריאה/כתיבה סדרתית:** מצוינים. הבלוקים רציפים פיזית על הדיסק, ולכן ניתן לקרוא/לכתוב אותם ביעילות עם מינימום תזוזות ראש הקריאה/כתיבה (seek time).\n*   **ביצועי קריאה/כתיבה אקראית:** מצוינים. מיקום כל בלוק ניתן לחישוב ישירות (כתובת התחלה + היסט), מה שמאפשר גישה ישירה ומהירה לכל חלק בקובץ.\n*   **מורכבות ניהול ה-metadata:** פשוטה. נדרשים רק כתובת הבלוק הראשון ואורך הקובץ (בבלוקים).\n\n**2. הקצאה מקושרת (Linked Allocation):**\n*   **ניצול שטח דיסק:**\n    *   **קבצים קטנים וגדולים:** כמעט ללא פרגמנטציה חיצונית. פרגמנטציה פנימית מינימלית (רק בבלוק האחרון). עם זאת, לכל בלוק נדרש מצביע לבלוק הבא (או בתוך הבלוק עצמו או בטבלת FAT נפרדת), מה שמפחית את נפח האחסון הזמין לנתונים בתוך הבלוקים.\n*   **ביצועי קריאה/כתיבה סדרתית:** גרועים. כדי לקרוא את הבלוק הבא, יש לקרוא קודם את המצביע מתוך הבלוק הנוכחי, מה שגורם למספר רב של פעולות I/O ו-seekים עבור קריאת קובץ שלם.\n*   **ביצועי קריאה/כתיבה אקראית:** גרועים מאוד. כדי לגשת לבלוק ה-N בקובץ, יש צורך לעבור על N-1 מצביעים מההתחלה, מה שדורש N פעולות קריאה מהדיסק.\n*   **מורכבות ניהול ה-metadata:** עבור כל קובץ, נדרשים רק מצביע לבלוק הראשון ולבלוק האחרון. אך ניהול המצביעים בתוך הבלוקים או בטבלת FAT מוסיף מורכבות מערכתית.\n\n**3. הקצאה באמצעות אינדקס (Indexed Allocation):**\n*   **ניצול שטח דיסק:**\n    *   **קבצים קטנים:** פרגמנטציה פנימית מינימלית (רק בבלוק האחרון). עם זאת, עבור קבצים קטנים מאוד, שימוש בבלוק אינדקס שלם (4KB) כדי להצביע על בלוק אחד או פחות של נתונים מהווה תקורה משמעותית של שטח דיסק.\n    *   **קובץ גדול:** פרגמנטציה פנימית מינימלית. עבור קבצים גדולים מאוד, בלוק אינדקס יחיד לא יספיק, ויהיה צורך במבני אינדקס מרובי רמות, מה שמוסיף תקורה של שטח דיסק עבור בלוקי האינדקס הנוספים.\n*   **ביצועי קריאה/כתיבה סדרתית:** טובים. בלוק האינדקס נקרא פעם אחת (או חלקים ממנו), ולאחר מכן ניתן לגשת לבלוקי הנתונים ישירות. יעיל בהרבה משיטה מקושרת, וקרוב לביצועים של רציפה אם בלוקי הנתונים קרובים פיזית.\n*   **ביצועי קריאה/כתיבה אקראית:** טובים. קריאת בלוק האינדקס מאפשרת גישה ישירה לכל בלוק נתונים בקובץ, בדרך כלל עם 1-2 פעולות I/O לדיסק (אחת לבלוק האינדקס ואחת לבלוק הנתונים).\n*   **מורכבות ניהול ה-metadata:** מורכבת יותר. דורשת ניהול של בלוקי אינדקס, ופוטנציאלית מבני אינדקס מרובי רמות. האיינוד (inode) בדרך כלל מכיל מצביעים לבלוקי האינדקס.\n\n**סיכום עבור התרחיש הנתון:**\n*   **קבצים קטנים:** הקצאה מקושרת או אינדקסית עדיפות על פני רציפה מבחינת ניצול שטח (למרות תקורת המצביעים/אינדקס), אך אינדקסית עשויה לסבול מתקורה גבוהה מדי של בלוק אינדקס לקובץ קטן. הקצאה רציפה סובלת מפרגמנטציה פנימית גבוהה מאוד.\n*   **קובץ גדול:** הקצאה מקושרת ואינדקסית עדיפות על פני רציפה מבחינת ניצול שטח וגמישות, מכיוון שאינן סובלות מפרגמנטציה חיצונית. מבחינת ביצועים, אינדקסית מציעה איזון טוב בין גישה סדרתית לאקראית, בעוד שמקושרת גרועה לשניהם. רציפה מצוינת בביצועים אך בלתי מעשית לקובץ גדול מאוד על מערכת קבצים פעילה."
    },
    "difficulty_estimation": "Medium"
  }
}