{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 08:29:52",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2071,
      "output_tokens": 2056,
      "total_tokens": 7022
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "IPC",
      "Shared Memory",
      "Semaphores",
      "Synchronization"
    ],
    "content": {
      "text": "תהליך P1 ותהליך P2 צריכים לתקשר ביניהם באמצעות זיכרון משותף (Shared Memory). תהליך P1 כותב מערך שלם של 10 מספרים שלמים לזיכרון המשותף, ותהליך P2 קורא את המערך הזה. יש להבטיח ש-P2 יקרא את הנתונים רק לאחר ש-P1 סיים לכתוב את כולם, וכן ש-P1 לא יכתוב נתונים חדשים לפני ש-P2 סיים לקרוא את הנתונים הקודמים.\n\nא. הסבר כיצד ניתן לממש תקשורת זו באמצעות זיכרון משותף ומנגנוני סנכרון (לדוגמה, סמפורים). פרט את השלבים הנדרשים ליצירה, שימוש וסגירה של משאבי ה-IPC.\nב. הדגם, באמצעות קטע קוד ב-C/C++, את לוגיקת הסנכרון והגישה לזיכרון המשותף עבור תהליכים P1 ו-P2, בהנחה שמשאבי ה-IPC כבר נוצרו ומופו כראוי.",
      "code_snippet": "/* מבנה הנתונים בזיכרון המשותף */\ntypedef struct {\n    int data[10];\n} shared_data_t;\n\n/* פונקציה המדמה את תהליך P1 (הכותב) */\nvoid process_p1(sem_t *empty_sem, sem_t *full_sem, shared_data_t *shm_ptr) {\n    for (int i = 0; i < 5; ++i) { // לדוגמה: כתיבה של 5 בלוקים של נתונים\n        sem_wait(empty_sem); // המתן אם הזיכרון המשותף מלא (P2 עדיין לא קרא)\n\n        printf(\"P1: Writing data block %d\\n\", i);\n        for (int j = 0; j < 10; ++j) {\n            shm_ptr->data[j] = i * 100 + j; // כתיבת נתונים לזיכרון המשותף\n        }\n        \n        sem_post(full_sem); // סמן שהזיכרון המשותף מלא (הנתונים מוכנים לקריאה ע\"י P2)\n        sleep(1); // הדמיית עבודה\n    }\n}\n\n/* פונקציה המדמה את תהליך P2 (הקורא) */\nvoid process_p2(sem_t *empty_sem, sem_t *full_sem, shared_data_t *shm_ptr) {\n    for (int i = 0; i < 5; ++i) { // לדוגמה: קריאה של 5 בלוקים של נתונים\n        sem_wait(full_sem); // המתן אם הזיכרון המשותף ריק (P1 עדיין לא כתב)\n\n        printf(\"P2: Reading data block %d: [\", i);\n        for (int j = 0; j < 10; ++j) {\n            printf(\"%d \", shm_ptr->data[j]); // קריאת נתונים מהזיכרון המשותף\n        }\n        printf(\"]\\n\");\n\n        sem_post(empty_sem); // סמן שהזיכרון המשותף ריק (P2 סיים לקרוא)\n        sleep(2); // הדמיית עבודה\n    }\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. מימוש תקשורת באמצעות זיכרון משותף וסמפורים:\nכדי לממש תקשורת זו, נשתמש בזיכרון משותף לאחסון הנתונים ובשני סמפורים בינאריים לצורך סנכרון:\n1.  **יצירת זיכרון משותף**: נשתמש בממשק `shm_open` ליצירת אובייקט זיכרון משותף עם שם ייחודי (לדוגמה, `/my_shm`). לאחר מכן, `ftruncate` תשמש לקביעת גודל הזיכרון המשותף (מספיק למערך של 10 מספרים שלמים). לבסוף, `mmap` תשמש למיפוי הזיכרון המשותף למרחב הכתובות של שני התהליכים (P1 ו-P2).\n2.  **יצירת סמפורים**: ניצור שני סמפורים באמצעות `sem_open`:\n    *   `empty_sem`: סמפור זה מציין האם הזיכרון המשותף 'ריק' ו-P1 יכול לכתוב בו. הוא יאותחל לערך 1 (פנוי לכתיבה).\n    *   `full_sem`: סמפור זה מציין האם הזיכרון המשותף 'מלא' ו-P2 יכול לקרוא ממנו. הוא יאותחל לערך 0 (אין נתונים לקריאה).\n3.  **לוגיקת תהליך P1 (הכותב)**:\n    *   לפני כתיבה: P1 מבצע `sem_wait(empty_sem)`. פעולה זו מקטינה את הסמפור `empty_sem` ב-1. אם ערכו היה 0, P1 ימתין עד ש-P2 יסיים לקרוא וישחרר את הסמפור.\n    *   כתיבה: P1 כותב את מערך 10 המספרים השלמים לזיכרון המשותף.\n    *   לאחר כתיבה: P1 מבצע `sem_post(full_sem)`. פעולה זו מגדילה את הסמפור `full_sem` ב-1, ובכך מאותת ל-P2 שהנתונים מוכנים לקריאה.\n4.  **לוגיקת תהליך P2 (הקורא)**:\n    *   לפני קריאה: P2 מבצע `sem_wait(full_sem)`. פעולה זו מקטינה את הסמפור `full_sem` ב-1. אם ערכו היה 0, P2 ימתין עד ש-P1 יסיים לכתוב וישחרר את הסמפור.\n    *   קריאה: P2 קורא את מערך 10 המספרים השלמים מהזיכרון המשותף.\n    *   לאחר קריאה: P2 מבצע `sem_post(empty_sem)`. פעולה זו מגדילה את הסמפור `empty_sem` ב-1, ובכך מאותת ל-P1 שהזיכרון פנוי לכתיבת נתונים חדשים.\n5.  **סגירת משאבים**: לאחר סיום השימוש, יש לשחרר את המשאבים:\n    *   `munmap` לביטול מיפוי הזיכרון המשותף.\n    *   `close` לסגירת קובץ הזיכרון המשותף.\n    *   `shm_unlink` למחיקת אובייקט הזיכרון המשותף מהמערכת.\n    *   `sem_close` לסגירת הסמפורים.\n    *   `sem_unlink` למחיקת אובייקטי הסמפורים מהמערכת.\n\nב. קטע הקוד שצורף מדגים את לוגיקת הסנכרון והגישה לזיכרון המשותף עבור תהליכים P1 ו-P2. הפונקציות `process_p1` ו-`process_p2` מקבלות מצביעים לסמפורים ולזיכרון המשותף, ומבצעות את פעולות ה-`sem_wait`, כתיבה/קריאה, ו-`sem_post` בהתאם ללוגיקה שהוסברה בסעיף א'. הקוד מדגיש את השימוש בסמפורים כדי להבטיח ש-P1 כותב רק כאשר הזיכרון פנוי (לאחר ש-P2 קרא) ו-P2 קורא רק כאשר הזיכרון מכיל נתונים חדשים (לאחר ש-P1 כתב).",
      "difficulty_estimation": "Medium"
    }
  }
}