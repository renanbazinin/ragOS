{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 23:17:32",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3180,
      "output_tokens": 2084,
      "total_tokens": 15185
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Paging",
      "Memory Management",
      "Locality of Reference"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת בזיכרון וירטואלי עם מנגנון Paging.\nגודל דף הוא 4KB (קילו-בייטים). גודל שלם (int) הוא 4 בייטים.\nנתונה תוכנית C המבצעת הקצאת זיכרון עבור מערך דו-ממדי גדול ולאחר מכן ניגשת אליו בשתי דרכים שונות.\nיש להניח כי המערך מוקצה בזיכרון רציף ומתחיל בכתובת המיושרת לגבול דף (page boundary).\nכמו כן, יש להניח כי טבלת הדפים של התהליך ריקה לחלוטין בתחילת כל איטרציה של לולאת ה-`for` החיצונית של כל קטע קוד (Loop A ו-Loop B). כלומר, אם דף נגיש באיטרציה קודמת, הוא יחשב כ'לא נגיש' באיטרציה הבאה של הלולאה החיצונית.\nהתעלמו מ-TLB ומהשפעותיו, והתמקדו רק ב-page faults.\n\n```c\n#include <stdlib.h>\n\n#define ROWS 1024\n#define COLS 1024\n\nint main() {\n    int* arr = (int*)malloc(ROWS * COLS * sizeof(int)); // Allocate 4MB\n    if (arr == NULL) return 1;\n\n    // Loop A: Row-major access\n    for (int i = 0; i < ROWS; ++i) {\n        for (int j = 0; j < COLS; ++j) {\n            arr[i * COLS + j] = i + j;\n        }\n    }\n\n    // Loop B: Column-major access\n    for (int j = 0; j < COLS; ++j) {\n        for (int i = 0; i < ROWS; ++i) {\n            arr[i * COLS + j] = i - j;\n        }\n    }\n\n    free(arr);\n    return 0;\n}\n```\n\n1. כמה page faults יתרחשו במהלך ביצוע \"Loop A\"? נמקו.\n2. כמה page faults יתרחשו במהלך ביצוע \"Loop B\"? נמקו.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": 20,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "נתונים:\n- גודל דף: 4KB = 4096 בייטים.\n- גודל int: 4 בייטים.\n- מספר שלמים לדף: 4096 / 4 = 1024 שלמים.\n- גודל מערך: ROWS * COLS = 1024 * 1024 שלמים.\n- גודל המערך בבייטים: 1024 * 1024 * 4 בייטים = 4MB.\n- מספר הדפים הכולל שהמערך תופס: 4MB / 4KB = 1024 דפים.\n\nההנחה המרכזית היא ש\"טבלת הדפים של התהליך ריקה לחלוטין בתחילת כל איטרציה של לולאת ה-`for` החיצונית של כל קטע קוד (Loop A ו-Loop B)\". המשמעות היא שכל דף שיגש אליו ייחשב כ'לא נגיש' שוב בתחילת האיטרציה הבאה של הלולאה החיצונית, גם אם הוא נגיש באיטרציה הנוכחית. (זהו תרחיש היפותטי שמטרתו לבחון הבנה של דפוסי גישה).\n\n**1. Page Faults במהלך ביצוע \"Loop A\" (גישה לפי שורות):**\n- הלולאה החיצונית (`for (int i = 0; i < ROWS; ++i)`) מבצעת 1024 איטרציות.\n- בכל איטרציה של הלולאה החיצונית (`i` קבוע), הלולאה הפנימית (`for (int j = 0; j < COLS; ++j)`) ניגשת לכל 1024 האלמנטים בשורה הנוכחית: `arr[i * COLS + j]` כאשר `j` משתנה מ-0 ל-1023.\n- מכיוון שכל שורה מכילה 1024 שלמים, ו-1024 שלמים תופסים בדיוק דף אחד (1024 * 4 בייטים = 4096 בייטים), כל שורה נמצאת בדף נפרד.\n- בתחילת כל איטרציה של הלולאה החיצונית (`i`), טבלת הדפים ריקה. לכן, הגישה הראשונה לשורה הנוכחית (למשל, `arr[i * COLS + 0]`) תגרום ל-page fault אחד כדי להביא את הדף המכיל את השורה כולה.\n- לאחר ה-page fault הראשון עבור השורה, כל שאר הגישות לשלמים באותה שורה יהיו בתוך אותו דף שכבר נטען, ולכן לא יגרמו ל-page faults נוספים באותה איטרציה של הלולאה החיצונית.\n- מכיוון שיש `ROWS = 1024` איטרציות בלולאה החיצונית, וכל איטרציה גורמת ל-1 page fault (עבור הדף של השורה הנוכחית), המספר הכולל של page faults ב-\"Loop A\" הוא: `1024 * 1 = 1024` page faults.\n\n**2. Page Faults במהלך ביצוע \"Loop B\" (גישה לפי עמודות):**\n- הלולאה החיצונית (`for (int j = 0; j < COLS; ++j)`) מבצעת 1024 איטרציות.\n- בכל איטרציה של הלולאה החיצונית (`j` קבוע), הלולאה הפנימית (`for (int i = 0; i < ROWS; ++i)`) ניגשת לאלמנטים `arr[i * COLS + j]` כאשר `i` משתנה מ-0 ל-1023.\n- הגישות הללו הן: `arr[j]`, `arr[COLS + j]`, `arr[2 * COLS + j]`, ..., `arr[(ROWS - 1) * COLS + j]`.\n- מכיוון ש-`COLS = 1024` שלמים, והמספר המקסימלי של שלמים בדף הוא 1024, כל גישה `arr[i * COLS + j]` קופצת לדף חדש לחלוטין ביחס לגישה הקודמת `arr[(i-1) * COLS + j]`. לדוגמה:\n  - `arr[j]` נמצא בדף 0.\n  - `arr[COLS + j]` נמצא בדף 1.\n  - `arr[2 * COLS + j]` נמצא בדף 2.\n  - ...\n  - `arr[(ROWS - 1) * COLS + j]` נמצא בדף `ROWS - 1`.\n- כלומר, בכל איטרציה של הלולאה הפנימית (`i`), אנו ניגשים לדף חדש.\n- בתחילת כל איטרציה של הלולאה החיצונית (`j`), טבלת הדפים ריקה. לכן, הלולאה הפנימית תגרום ל-page fault עבור כל גישה לאלמנט, מכיוון שכל גישה היא לדף חדש שטרם נטען (או שהיה נטען באיטרציה קודמת של הלולאה החיצונית אך נחשב כעת כ'לא נגיש').\n- הלולאה הפנימית מבצעת `ROWS = 1024` גישות לדפים שונים, ולכן תגרום ל-1024 page faults.\n- מכיוון שיש `COLS = 1024` איטרציות בלולאה החיצונית, וכל איטרציה גורמת ל-1024 page faults, המספר הכולל של page faults ב-\"Loop B\" הוא: `1024 * 1024 = 1,048,576` page faults."
    },
    "difficulty_estimation": "Medium"
  }
}