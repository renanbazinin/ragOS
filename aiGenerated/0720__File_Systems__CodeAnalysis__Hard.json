{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 23:53:58",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3062,
      "output_tokens": 3624,
      "total_tokens": 25469
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "File Systems",
      "Processes",
      "Concurrency",
      "System Calls",
      "Race Conditions"
    ],
    "content": {
      "text": "נתונה תוכנית C הבאה המשתמשת בקריאות מערכת לטיפול בקבצים ויוצרת תהליכים חדשים באמצעות `fork`. יש להניח שכל קריאות המערכת מצליחות, ושהמערכת מאפשרת ריצה מקבילה של תהליכים עם מנגנון תזמון שרירותי (כלומר, כל סדר ריצה אפשרי, כולל החלפות הקשר בין קריאות מערכת שונות). כל התהליכים מחכים לסיום ילדיהם לפני שהם מסיימים את דרכם.\n\nיש לציין את כל הפלטים האפשריים של תוכן הקובץ הסופי `output.txt` ולהסביר כל פלט בפירוט, תוך התייחסות למצבי מרוץ אפשריים בין התהליכים.\n\nתוכן הקובץ ההתחלתי הוא 12 תווים 'X'.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <string.h>\n\n#define FILENAME \"output.txt\"\n#define NUM_CHILDREN 2\n#define CHUNK_SIZE 4 // Each process writes 4 bytes\n#define FILE_LENGTH (CHUNK_SIZE * (NUM_CHILDREN + 1)) // Total length of 12 bytes\n\nint main() {\n    int fd;\n    pid_t pid;\n    int i;\n    char buffer[CHUNK_SIZE + 1];\n\n    fd = open(FILENAME, O_CREAT | O_RDWR | O_TRUNC, 0644);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Initialize file with 'X' characters up to FILE_LENGTH\n    for (i = 0; i < FILE_LENGTH; ++i) {\n        if (write(fd, \"X\", 1) == -1) {\n            perror(\"initial write\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    lseek(fd, 0, SEEK_SET); // Reset offset to beginning for subsequent writes\n\n    // Fork children\n    for (i = 0; i < NUM_CHILDREN; ++i) {\n        pid = fork();\n        if (pid == -1) {\n            perror(\"fork\");\n            exit(EXIT_FAILURE);\n        }\n\n        if (pid == 0) { // Child process\n            char child_char = '0' + i; // '0' for child 0, '1' for child 1\n            memset(buffer, child_char, CHUNK_SIZE);\n            buffer[CHUNK_SIZE] = '\\0';\n\n            // Child 0 targets offset 0, Child 1 targets offset 2\n            off_t target_offset = (off_t)(i * (CHUNK_SIZE / 2)); \n            \n            // Critical section: lseek + write\n            lseek(fd, target_offset, SEEK_SET); \n            usleep(10000); // Small delay to increase chance of interleaving\n            write(fd, buffer, CHUNK_SIZE);\n            \n            close(fd); // Child closes its copy of the file descriptor\n            exit(EXIT_SUCCESS);\n        }\n    }\n\n    // Parent also writes\n    char parent_char = 'P';\n    memset(buffer, parent_char, CHUNK_SIZE);\n    buffer[CHUNK_SIZE] = '\\0';\n    \n    // Parent targets offset 4\n    off_t parent_target_offset = (off_t)(NUM_CHILDREN * (CHUNK_SIZE / 2)); \n    \n    // Critical section: lseek + write\n    lseek(fd, parent_target_offset, SEEK_SET); \n    usleep(10000); // Small delay to increase chance of interleaving\n    write(fd, buffer, CHUNK_SIZE);\n\n    // Parent waits for children to finish\n    for (i = 0; i < NUM_CHILDREN; ++i) {\n        wait(NULL);\n    }\n\n    close(fd); // Parent closes its copy of the file descriptor\n\n    // Read and print final file content\n    fd = open(FILENAME, O_RDONLY);\n    if (fd == -1) {\n        perror(\"open for read\");\n        exit(EXIT_FAILURE);\n    }\n\n    char final_content[FILE_LENGTH + 1];\n    ssize_t bytes_read = read(fd, final_content, FILE_LENGTH);\n    if (bytes_read == -1) {\n        perror(\"read final\");\n        exit(EXIT_FAILURE);\n    }\n    final_content[bytes_read] = '\\0'; // Null-terminate\n\n    printf(\"Final file content: '%s'\\n\", final_content);\n\n    close(fd);\n    unlink(FILENAME); // Clean up the file\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון דורש הבנה עמוקה של אופן פעולת מתארי קבצים (file descriptors) לאחר קריאת `fork`, וכיצד פעולות `lseek` ו-`write` משפיעות על מיקום הכתיבה המשותף. כאשר תהליך אב מבצע `fork`, מתאר הקובץ `fd` משוכפל לילד. מתארים משוכפלים אלה (באב ובילדים) מצביעים כולם על אותה כניסה בטבלת הקבצים הפתוחים (open file table entry) של מערכת ההפעלה. המשמעות היא שהם חולקים את אותו מצביע קריאה/כתיבה (file offset).\n\nקריאת `lseek(fd, offset, SEEK_SET)` משנה את המצביע המשותף עבור כל התהליכים החולקים את אותה כניסה בטבלת הקבצים הפתוחים. קריאת `write` כותבת החל מהמצביע הנוכחי ומקדמת אותו במספר הבתים שנכתבו. מכיוון שקריאות `lseek` ו-`write` אינן אטומיות יחד, וקיים `usleep` ביניהן, ייתכנו מצבי מרוץ רבים שבהם סדר ביצוע הפעולות משפיע על התוצאה הסופית.\n\nהתוכנית יוצרת שני תהליכי בן (Child 0, Child 1) ותהליך אב (Parent). כל אחד מהם מנסה לכתוב מחרוזת בת 4 בתים לקובץ:\n- Child 0: כותב \"0000\", מטרתו לכתוב ב-offset 0.\n- Child 1: כותב \"1111\", מטרתו לכתוב ב-offset 2.\n- Parent: כותב \"PPPP\", מטרתו לכתוב ב-offset 4.\n\nהקובץ מאותחל ל-`XXXXXXXXXXXX` (12 תווי 'X').\n\nלהלן דוגמאות לפלטים אפשריים והסבר כיצד הם מתקבלים:\n\n**פלט אפשרי 1: `0011PPPPXXXX`**\n**תיאור סדר פעולות:** סדר הפעולות הוא (L=lseek, W=write):\n1.  **C0_L**: Child 0 קורא ל-`lseek(fd, 0, SEEK_SET)`. מצביע הקובץ המשותף (S) הופך ל-0.\n2.  **C0_W**: Child 0 קורא ל-`write(\"0000\", 4)`. כותב \"0000\" החל מ-S=0. הקובץ: `0000XXXXXXXX`. S הופך ל-4.\n3.  **C1_L**: Child 1 קורא ל-`lseek(fd, 2, SEEK_SET)`. S הופך ל-2.\n4.  **C1_W**: Child 1 קורא ל-`write(\"1111\", 4)`. כותב \"1111\" החל מ-S=2. הקובץ: `001111XXXXXX`. S הופך ל-6.\n5.  **P_L**: Parent קורא ל-`lseek(fd, 4, SEEK_SET)`. S הופך ל-4.\n6.  **P_W**: Parent קורא ל-`write(\"PPPP\", 4)`. כותב \"PPPP\" החל מ-S=4. הקובץ: `0011PPPPXXXX`. S הופך ל-8.\n\n**פלט אפשרי 2: `00001111PPPP`**\n**תיאור סדר פעולות:** כל פעולות ה-`lseek` מתבצעות לפני כל פעולות ה-`write`, בסדר מסוים:\n1.  **P_L**: Parent קורא ל-`lseek(fd, 4, SEEK_SET)`. S הופך ל-4.\n2.  **C1_L**: Child 1 קורא ל-`lseek(fd, 2, SEEK_SET)`. S הופך ל-2.\n3.  **C0_L**: Child 0 קורא ל-`lseek(fd, 0, SEEK_SET)`. S הופך ל-0.\n    (בשלב זה, כל קריאות ה-lseek הסתיימו, ו-S עומד על 0). \n4.  **C0_W**: Child 0 קורא ל-`write(\"0000\", 4)`. כותב \"0000\" החל מ-S=0. הקובץ: `0000XXXXXXXX`. S הופך ל-4.\n5.  **C1_W**: Child 1 קורא ל-`write(\"1111\", 4)`. כותב \"1111\" החל מ-S=4. הקובץ: `00001111XXXX`. S הופך ל-8.\n6.  **P_W**: Parent קורא ל-`write(\"PPPP\", 4)`. כותב \"PPPP\" החל מ-S=8. הקובץ: `00001111PPPP`. S הופך ל-12.\n\n**פלט אפשרי 3: `XX00001111PP`**\n**תיאור סדר פעולות:** דוגמה נוספת לסדר פעולות שונה:\n1.  **C0_L**: Child 0 קורא ל-`lseek(fd, 0, SEEK_SET)`. S הופך ל-0.\n2.  **P_L**: Parent קורא ל-`lseek(fd, 4, SEEK_SET)`. S הופך ל-4.\n3.  **C1_L**: Child 1 קורא ל-`lseek(fd, 2, SEEK_SET)`. S הופך ל-2.\n    (בשלב זה, כל קריאות ה-lseek הסתיימו, ו-S עומד על 2). \n4.  **C0_W**: Child 0 קורא ל-`write(\"0000\", 4)`. כותב \"0000\" החל מ-S=2. הקובץ: `XX0000XXXXXX`. S הופך ל-6.\n5.  **C1_W**: Child 1 קורא ל-`write(\"1111\", 4)`. כותב \"1111\" החל מ-S=6. הקובץ: `XX00001111XX`. S הופך ל-10.\n6.  **P_W**: Parent קורא ל-`write(\"PPPP\", 4)`. כותב \"PPPP\" החל מ-S=10. הקובץ: `XX00001111PP`. S הופך ל-14.\n    (הקריאה האחרונה של `read` תקרא רק 12 בתים, ולכן הפלט יהיה `XX00001111PP`).\n\n**פלט אפשרי 4: `1111PPPP0000`**\n**תיאור סדר פעולות:** דוגמה לסדר פעולות שבו ה-`write` של C0 מתרחש אחרון, וקריאת `lseek` של C1 היא האחרונה לפני ה-`write` הראשון:\n1.  **C0_L**: Child 0 קורא ל-`lseek(fd, 0, SEEK_SET)`. S הופך ל-0.\n2.  **P_L**: Parent קורא ל-`lseek(fd, 4, SEEK_SET)`. S הופך ל-4.\n3.  **C1_L**: Child 1 קורא ל-`lseek(fd, 2, SEEK_SET)`. S הופך ל-2.\n4.  **C1_W**: Child 1 קורא ל-`write(\"1111\", 4)`. כותב \"1111\" החל מ-S=2. הקובץ: `XX1111XXXXXX`. S הופך ל-6.\n5.  **P_W**: Parent קורא ל-`write(\"PPPP\", 4)`. כותב \"PPPP\" החל מ-S=6. הקובץ: `XX1111PPPPXX`. S הופך ל-10.\n6.  **C0_W**: Child 0 קורא ל-`write(\"0000\", 4)`. כותב \"0000\" החל מ-S=10. הקובץ: `XX1111PPPP00`. S הופך ל-14.\n    (הקריאה האחרונה של `read` תקרא רק 12 בתים, ולכן הפלט יהיה `XX1111PPPP00`).\n\nישנם פלטים אפשריים נוספים הנובעים משילובים שונים של סדרי הריצה, אך אלה ארבע דוגמאות הממחישות את מגוון התוצאות האפשריות עקב מצבי המרוץ על מצביע הקובץ המשותף."
    },
    "difficulty_estimation": "Hard"
  }
}