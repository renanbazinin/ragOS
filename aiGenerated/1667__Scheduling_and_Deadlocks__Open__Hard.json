{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 19:55:22",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3383,
      "output_tokens": 2811,
      "total_tokens": 10892
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Deadlocks",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה מרובת תהליכים (Multi-threaded) שבה רצים מספר תהליכים, המחולקים לשני סוגים: ProcessTypeA ו-ProcessTypeB. כל התהליכים במערכת דורשים גישה בלעדית לשני משאבים שונים, R1 ו-R2, כדי לבצע קטע קריטי. המשאבים מוגנים באמצעות סמפורים בינאריים, sem_R1 ו-sem_R2, המאותחלים ל-1. המערכת משתמשת במתזמן מסוג Round Robin פרה-אמטיבי.\nלהלן קטעי הקוד המתארים את אופן פעולת התהליכים מכל סוג:",
      "code_snippet": "sem_t sem_R1; // מאותחל ל-1\nsem_t sem_R2; // מאותחל ל-1\n\n// קוד עבור ProcessTypeA\nvoid* process_type_A(void* arg) {\n    while (1) {\n        // עבודה לא קריטית...\n        sem_wait(&sem_R1); // ניסיון לתפוס R1\n        sem_wait(&sem_R2); // ניסיון לתפוס R2\n\n        // קטע קריטי המשתמש ב-R1 וב-R2\n        // ...\n\n        sem_post(&sem_R2); // שחרור R2\n        sem_post(&sem_R1); // שחרור R1\n        // עבודה לא קריטית נוספת...\n    }\n    return NULL;\n}\n\n// קוד עבור ProcessTypeB\nvoid* process_type_B(void* arg) {\n    while (1) {\n        // עבודה לא קריטית...\n        sem_wait(&sem_R2); // ניסיון לתפוס R2\n        sem_wait(&sem_R1); // ניסיון לתפוס R1\n\n        // קטע קריטי המשתמש ב-R1 וב-R2\n        // ...\n\n        sem_post(&sem_R1); // שחרור R1\n        sem_post(&sem_R2); // שחרור R2\n        // עבודה לא קריטית נוספת...\n    }\n    return NULL;\n}"
    },
    "sub_questions": [
      {
        "id": "a",
        "text": "האם קיפאון (Deadlock) אפשרי במערכת זו? אם כן, הסבר את התנאים והצג רצף אירועים קונקרטי שיוביל לקיפאון.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "b",
        "text": "האם הרעבה (Starvation) אפשרית במערכת זו? אם כן, הסבר מדוע וכיצד היא יכולה להתרחש.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "c",
        "text": "הצע שינוי בקוד או בתכנון המערכת (לדוגמה, אסטרטגיית הקצאת משאבים או אינטראקציה עם המתזמן) שימנע קיפאונות מבלי לגרום להרעבה. הסבר את הפתרון שהצעת.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "a) קיפאון (Deadlock) אפשרי:\nכן, קיפאון אפשרי במערכת זו. התנאים ההכרחיים לקיפאון מתקיימים:\n1.  מניעה הדדית (Mutual Exclusion): המשאבים R1 ו-R2 מוגנים על ידי סמפורים בינאריים, כך שרק תהליך אחד יכול להחזיק בכל משאב נתון בכל רגע.\n2.  החזקה והמתנה (Hold and Wait): תהליך יכול להחזיק במשאב אחד (לדוגמה, ProcessTypeA מחזיק ב-R1) ולהמתין למשאב נוסף (במקרה זה, R2).\n3.  אי-הפקעה (No Preemption): משאבים אינם נלקחים מתהליך בכוח; הם משוחררים רק מרצון על ידי התהליך המחזיק בהם.\n4.  המתנה מעגלית (Circular Wait): זהו התנאי שיוביל לקיפאון במערכת זו, עקב סדר לקיחת המשאבים השונה בין שני סוגי התהליכים.\n\nרצף אירועים שיוביל לקיפאון:\nנניח שיש לנו תהליך אחד מכל סוג, PA (מ-ProcessTypeA) ו-PB (מ-ProcessTypeB).\n1.  PA מתחיל לרוץ. הוא מבצע sem_wait(&sem_R1) ומצליח, כלומר PA מחזיק כעת ב-R1.\n2.  המתזמן מבצע מיתוג הקשר (context switch) ל-PB.\n3.  PB מתחיל לרוץ. הוא מבצע sem_wait(&sem_R2) ומצליח, כלומר PB מחזיק כעת ב-R2.\n4.  המתזמן מבצע מיתוג הקשר בחזרה ל-PA.\n5.  PA מנסה לבצע sem_wait(&sem_R2). כיוון ש-PB מחזיק ב-R2, PA נחסם וממתין.\n6.  המתזמן מבצע מיתוג הקשר בחזרה ל-PB.\n7.  PB מנסה לבצע sem_wait(&sem_R1). כיוון ש-PA מחזיק ב-R1, PB נחסם וממתין.\nבשלב זה, PA ממתין ל-R2 שמוחזק על ידי PB, ו-PB ממתין ל-R1 שמוחזק על ידי PA. נוצרה המתנה מעגלית, ושני התהליכים נמצאים בקיפאון.\n\nb) הרעבה (Starvation) אפשרית:\nכן, הרעבה אפשרית במערכת זו, גם ללא קיפאון מוחלט.\nלדוגמה, נניח שיש מספר רב של תהליכים מ-ProcessTypeA ומספר קטן של תהליכים מ-ProcessTypeB. אם sem_R1 תפוס באופן קבוע על ידי תהליכים מ-ProcessTypeA (שכן הם תמיד מנסים לתפוס אותו ראשון), תהליכים מ-ProcessTypeB יתקשו מאוד, או שלא יצליחו לעולם, לתפוס את sem_R1 לאחר שתפסו את sem_R2. למרות שמתזמן Round Robin מבטיח שכל תהליך יקבל זמן מעבד, הוא אינו מבטיח שהתהליך יצליח לתפוס את המשאבים הנדרשים. אם יש זרם קבוע של תהליכים שמשחררים ותופסים את R1 (לדוגמה, תהליכי ProcessTypeA רבים), תהליך בודד מ-ProcessTypeB שזקוק ל-R1 לאחר שתפס את R2 עלול להמתין indefinitely.\nההוגנות של הסמפור עצמו (לדוגמה, FIFO) יכולה למנוע הרעבה של תהליכים שממתינים על אותו סמפור, אבל לא הרעבה של תהליך שצריך לתפוס שני סמפורים בסדר מסוים, כאשר הסמפור השני תפוס תמיד על ידי תהליכים אחרים.\n\nc) הצעת פתרון למניעת קיפאון והרעבה:\nהדרך הנפוצה והיעילה ביותר למנוע קיפאון במקרה זה היא למנוע את תנאי \"ההמתנה המעגלית\" על ידי אכיפת סדר עקבי של הקצאת משאבים לכל התהליכים במערכת.\n\nשינוי בקוד:\nנשנה את הקוד של ProcessTypeB כך שגם הוא יתפוס את המשאבים בסדר זהה ל-ProcessTypeA, לדוגמה, תמיד R1 ואז R2.\n\n```c\nsem_t sem_R1; // מאותחל ל-1\nsem_t sem_R2; // מאותחל ל-1\n\n// קוד עבור ProcessTypeA (ללא שינוי)\nvoid* process_type_A(void* arg) {\n    while (1) {\n        // עבודה לא קריטית...\n        sem_wait(&sem_R1); // ניסיון לתפוס R1\n        sem_wait(&sem_R2); // ניסיון לתפוס R2\n\n        // קטע קריטי המשתמש ב-R1 וב-R2\n        // ...\n\n        sem_post(&sem_R2); // שחרור R2\n        sem_post(&sem_R1); // שחרור R1\n        // עבודה לא קריטית נוספת...\n    }\n    return NULL;\n}\n\n// קוד עבור ProcessTypeB (לאחר שינוי)\nvoid* process_type_B(void* arg) {\n    while (1) {\n        // עבודה לא קריטית...\n        sem_wait(&sem_R1); // ניסיון לתפוס R1 (שינוי!)\n        sem_wait(&sem_R2); // ניסיון לתפוס R2 (שינוי!)\n\n        // קטע קריטי המשתמש ב-R1 וב-R2\n        // ...\n\n        sem_post(&sem_R2); // שחרור R2\n        sem_post(&sem_R1); // שחרור R1\n        // עבודה לא קריטית נוספת...\n    }\n    return NULL;\n}\n```\n\nהסבר:\nעל ידי אכיפת סדר עקבי של לקיחת משאבים (לדוגמה, תמיד R1 ואז R2) לכל סוגי התהליכים, אנו מונעים את תנאי ההמתנה המעגלית. כעת, לא ייתכן מצב שבו תהליך X מחזיק ב-R1 וממתין ל-R2, בעוד שתהליך Y מחזיק ב-R2 וממתין ל-R1, מכיוון שכל התהליכים ינסו לתפוס את R1 ראשון. אם R1 תפוס, כל התהליכים המבקשים אותו ייחסמו. ברגע ש-R1 ישוחרר, אחד מהם יצליח לתפוס אותו, ואז ימשיך לנסות לתפוס את R2.\nפתרון זה גם מונע הרעבה, מכיוון שהמתזמן Round Robin וההנחה (המשתמעת) שהסמפורים הוגנים (לדוגמה, FIFO) יבטיחו שכל תהליך שממתין למשאב בסופו של דבר יקבל אותו. אין יותר מצב שבו תהליך מחזיק במשאב אחד וממתין למשאב אחר שמוחזק על ידי תהליך אחר שממתין בחזרה למשאב הראשון. כל התהליכים ימתינו לאותו משאב ראשון, וברגע שהוא יתפנה, הממתין הבא בתור יקבל אותו."
    },
    "difficulty_estimation": "Hard"
  }
}