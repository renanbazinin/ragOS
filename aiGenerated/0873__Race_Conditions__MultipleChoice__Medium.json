{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Race Conditions",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 01:00:16",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 901,
      "output_tokens": 819,
      "total_tokens": 3618
    }
  },
  "question": {
    "id": 101,
    "type": "MultipleChoice",
    "topic": [
      "Race Conditions",
      "Concurrency",
      "Synchronization",
      "Threads"
    ],
    "content": {
      "text": "נתון קוד C הבא המשתמש במשתנה גלובלי משותף. שני תהליכונים (threads) מריצים את הפונקציה `increment_counter`. כל תהליכון קורא לפונקציה זו 1000 פעמים. המשתנה `counter` מאותחל ל-0. איזה מהבאים *אינו* ערך אפשרי עבור `counter` בסיום ריצת שני התהליכונים?",
      "code_snippet": "int counter = 0;\n\nvoid *increment_counter(void *arg) {\n    for (int i = 0; i < 1000; i++) {\n        counter++;\n    }\n    return NULL;\n}",
      "options": [
        "א. 1",
        "ב. 1999",
        "ג. 2000",
        "ד. 2001"
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ד. 2001",
      "explanation": "הבעיה המתוארת היא תנאי מירוץ (Race Condition). שני תהליכונים מנסים לעדכן משתנה משותף (`counter`) ללא סנכרון מתאים. פעולת ה-`counter++` אינה אטומית ומורכבת ממספר הוראות מכונה (קריאה, שינוי, כתיבה). כתוצאה מכך, ייתכן מצב שבו תהליכון אחד קורא את ערך המונה, מוחלף ע\"י תהליכון אחר שגם הוא קורא ומשנה את המונה, ואז התהליכון הראשון כותב בחזרה את הערך הישן שקרא, ובכך 'דורס' עדכון של התהליכון השני.\nכל תהליכון מבצע 1000 הגדלות, ובסך הכל אמורות להתבצע 2000 הגדלות. עקב תנאי מירוץ, חלק מההגדלות עלולות ללכת לאיבוד, ולכן הערך הסופי יהיה לרוב קטן מ-2000.\nהערך המינימלי האפשרי הוא 1 (במקרה קיצוני בו רק הגדלה אחת מכל ה-2000 מצליחה להתבצע במלואה מבלי להידרס). הערכים 1 ו-1999 הם בהחלט אפשריים.\nהערך המקסימלי האפשרי הוא 2000 (אם במקרה אין תנאי מירוץ כלל, או שהם מתרחשים באופן שלא גורם לאובדן עדכונים). לכן, 2000 הוא ערך אפשרי.\nערך מעל 2000 אינו אפשרי, מכיוון שאין אף פעולה שמגדילה את המונה ביותר מ-1 בכל פעם, וסה\"כ ההגדלות המתוכננות הוא 2000. לכן, 'ד. 2001' אינו ערך אפשרי."
    },
    "difficulty_estimation": "Medium"
  }
}