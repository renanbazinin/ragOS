{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 21:13:22",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 7783,
      "total_tokens": 25411
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Process Management",
      "Pipes",
      "Synchronization"
    ],
    "content": {
      "text": "נתונה מערכת המורכבת מתהליך אב ותהליכי בן. תהליך האב יוצר N תהליכי בן. כל תהליך בן מבצע חישוב כלשהו (סימולציה) ושולח עדכוני התקדמות לתהליך האב דרך צינור ייעודי. תהליך האב מצפה לסיים את כל תהליכי הבן באופן מסודר. במקרה שתהליך האב מקבל את האות SIGINT, עליו לסיים את כל תהליכי הבן באופן גרייספוּלי ולנקות את כל המשאבים. תהליכי הבן צריכים לזהות את בקשת הסיום ולצאת בצורה מסודרת, תוך שליחת הודעה סופית לאב. תהליך האב צריך גם לאסוף את סטטוס היציאה של כל הבנים באמצעות טיפול באות SIGCHLD.\n\nלהלן קטע קוד חלקי המממש חלק מהלוגיקה המתוארת. עליך לנתח את הקוד ולענות על השאלות הבאות:",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <string.h>\n#include <errno.h>\n\n#define NUM_CHILDREN 3\n#define MSG_SIZE 128\n#define TERMINATE_MSG \"TERMINATE\"\n#define DONE_MSG \"DONE\"\n\n// Global variables for parent\npid_t child_pids[NUM_CHILDREN];\nint child_pipes_read[NUM_CHILDREN][2]; // Parent reads from children\nint child_pipes_write[NUM_CHILDREN][2]; // Parent writes to children (to signal termination)\nvolatile sig_atomic_t sigint_received = 0;\nvolatile int active_children = 0;\n\nvoid cleanup_resources(int signum) {\n    printf(\"Parent: Cleaning up resources.\\n\");\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (child_pids[i] > 0) { // If child was successfully forked\n            // Send termination signal to child via pipe\n            if (write(child_pipes_write[i][1], TERMINATE_MSG, strlen(TERMINATE_MSG) + 1) == -1) {\n                perror(\"Parent: write TERMINATE_MSG to child pipe failed\");\n            }\n        }\n        close(child_pipes_read[i][0]); // Close parent's read end\n        close(child_pipes_read[i][1]); // Close child's write end (parent doesn't use)\n        close(child_pipes_write[i][0]); // Close child's read end (parent doesn't use)\n        close(child_pipes_write[i][1]); // Close parent's write end\n    }\n    // More cleanup if needed\n}\n\nvoid sigint_handler(int signum) {\n    sigint_received = 1;\n    // This handler should ideally do minimal work.\n    // The actual cleanup and termination signaling should happen in the main loop or a dedicated function.\n    printf(\"Parent: SIGINT received.\\n\");\n}\n\nvoid sigchld_handler(int signum) {\n    int status;\n    pid_t pid;\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        printf(\"Parent: Child %d terminated.\\n\", pid);\n        active_children--;\n        if (WIFEXITED(status)) {\n            printf(\"Parent: Child %d exited with status %d.\\n\", pid, WEXITSTATUS(status));\n        } else if (WIFSIGNALED(status)) {\n            printf(\"Parent: Child %d terminated by signal %d.\\n\", pid, WTERMSIG(status));\n        }\n    }\n}\n\nvoid child_process_logic(int child_id) {\n    char buffer[MSG_SIZE];\n    // Close unused pipe ends\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        close(child_pipes_read[i][0]); // Parent's read end\n        if (i != child_id) {\n            close(child_pipes_read[i][1]); // Other children's write end\n            close(child_pipes_write[i][0]); // Other children's read end\n            close(child_pipes_write[i][1]); // Other children's write end\n        }\n    }\n    close(child_pipes_read[child_id][0]); // Parent's read end (child doesn't use)\n    close(child_pipes_write[child_id][1]); // Parent's write end (child doesn't use)\n\n    printf(\"Child %d: Starting work.\\n\", child_id);\n    for (int i = 0; i < 5; ++i) { // Simulate work\n        sleep(1);\n        snprintf(buffer, MSG_SIZE, \"Child %d: Progress %d\", child_id, i);\n        if (write(child_pipes_read[child_id][1], buffer, strlen(buffer) + 1) == -1) {\n            perror(\"Child: write progress failed\");\n            break;\n        }\n\n        // Check for termination signal from parent\n        ssize_t bytes_read = read(child_pipes_write[child_id][0], buffer, MSG_SIZE);\n        if (bytes_read > 0) {\n            buffer[bytes_read] = '\\0';\n            if (strcmp(buffer, TERMINATE_MSG) == 0) {\n                printf(\"Child %d: Received TERMINATE signal. Exiting gracefully.\\n\", child_id);\n                break;\n            }\n        } else if (bytes_read == -1 && errno != EAGAIN) { // EAGAIN for non-blocking, but pipes are blocking by default\n            perror(\"Child: read from parent pipe failed\");\n            break;\n        }\n    }\n\n    snprintf(buffer, MSG_SIZE, \"%s from Child %d\", DONE_MSG, child_id);\n    write(child_pipes_read[child_id][1], buffer, strlen(buffer) + 1);\n    printf(\"Child %d: Exiting.\\n\", child_id);\n\n    close(child_pipes_read[child_id][1]);\n    close(child_pipes_write[child_id][0]);\n    exit(0);\n}\n\nint main() {\n    struct sigaction sa_int, sa_chld;\n\n    // Setup SIGINT handler\n    sa_int.sa_handler = sigint_handler;\n    sigemptyset(&sa_int.sa_mask);\n    sa_int.sa_flags = 0; // No SA_RESTART for simplicity, but could be important\n    if (sigaction(SIGINT, &sa_int, NULL) == -1) {\n        perror(\"sigaction SIGINT failed\");\n        exit(1);\n    }\n\n    // Setup SIGCHLD handler\n    sa_chld.sa_handler = sigchld_handler;\n    sigemptyset(&sa_chld.sa_mask);\n    sa_chld.sa_flags = SA_RESTART | SA_NOCLDSTOP; // SA_RESTART to restart interrupted syscalls, SA_NOCLDSTOP to not get signals for stopped children\n    if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {\n        perror(\"sigaction SIGCHLD failed\");\n        exit(1);\n    }\n\n    // Create pipes\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (pipe(child_pipes_read[i]) == -1 || pipe(child_pipes_write[i]) == -1) {\n            perror(\"pipe creation failed\");\n            exit(1);\n        }\n    }\n\n    // Fork children\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        child_pids[i] = fork();\n        if (child_pids[i] == -1) {\n            perror(\"fork failed\");\n            // Handle error: kill already forked children, cleanup pipes\n            exit(1);\n        } else if (child_pids[i] == 0) { // Child process\n            child_process_logic(i);\n            // Child exits here, should not reach parent's main logic\n        } else { // Parent process\n            active_children++;\n            // Close child's ends of pipes in parent\n            close(child_pipes_read[i][1]); // Child's write end\n            close(child_pipes_write[i][0]); // Child's read end\n        }\n    }\n\n    // Parent main loop\n    char buffer[MSG_SIZE];\n    fd_set read_fds;\n    int max_fd = 0;\n\n    printf(\"Parent: All children forked. Waiting for messages or SIGINT.\\n\");\n\n    while (active_children > 0) {\n        FD_ZERO(&read_fds);\n        if (sigint_received) {\n            // SIGINT received, signal children to terminate\n            cleanup_resources(SIGINT); // Use cleanup_resources to send terminate messages\n            sigint_received = 0; // Reset flag\n            // After sending terminate, parent should continue waiting for SIGCHLD\n            // and read any final messages\n        }\n\n        for (int i = 0; i < NUM_CHILDREN; ++i) {\n            if (child_pids[i] > 0) { // Only if child is still active\n                FD_SET(child_pipes_read[i][0], &read_fds);\n                if (child_pipes_read[i][0] > max_fd) {\n                    max_fd = child_pipes_read[i][0];\n                }\n            }\n        }\n        \n        // Use select with a timeout to periodically check sigint_received, or rely on signal handler to interrupt select\n        // For a blocking select, signal handler will interrupt it.\n        // A timeout is good practice to allow processing of flags like sigint_received\n        struct timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int ready_fds = select(max_fd + 1, &read_fds, NULL, NULL, &timeout);\n\n        if (ready_fds == -1) {\n            if (errno == EINTR) { // Interrupted by a signal (e.g., SIGCHLD or SIGINT)\n                printf(\"Parent: select interrupted by signal.\\n\");\n                continue; // Recheck sigint_received and active_children\n            }\n            perror(\"Parent: select failed\");\n            break;\n        } else if (ready_fds == 0) { // Timeout\n            printf(\"Parent: select timed out. Checking flags...\\n\");\n            continue; // Recheck sigint_received and active_children\n        }\n\n        for (int i = 0; i < NUM_CHILDREN; ++i) {\n            if (child_pids[i] > 0 && FD_ISSET(child_pipes_read[i][0], &read_fds)) {\n                ssize_t bytes_read = read(child_pipes_read[i][0], buffer, MSG_SIZE);\n                if (bytes_read > 0) {\n                    buffer[bytes_read] = '\\0';\n                    printf(\"Parent: Received from child %d: %s\\n\", i, buffer);\n                    if (strstr(buffer, DONE_MSG) != NULL) {\n                        // A child finished its task. We still wait for SIGCHLD to decrement active_children.\n                        // Or, we can set child_pids[i] = -1 here to mark it as done for the select loop.\n                        // But waitpid in SIGCHLD handler is the canonical way.\n                    }\n                } else if (bytes_read == 0) {\n                    printf(\"Parent: Child %d pipe closed.\\n\", i);\n                    // Child has closed its write pipe. This means it has exited or is about to.\n                    // The SIGCHLD handler will eventually catch its termination.\n                    child_pids[i] = -1; // Mark as inactive for select loop\n                } else {\n                    perror(\"Parent: read from child pipe failed\");\n                }\n            }\n        }\n    }\n\n    printf(\"Parent: All children terminated. Final cleanup.\\n\");\n    // Final cleanup of pipes that might not have been closed in cleanup_resources if SIGINT was not received\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (child_pipes_read[i][0] != -1) close(child_pipes_read[i][0]);\n        if (child_pipes_read[i][1] != -1) close(child_pipes_read[i][1]); // Should be closed by child or unused\n        if (child_pipes_write[i][0] != -1) close(child_pipes_write[i][0]); // Should be closed by child or unused\n        if (child_pipes_write[i][1] != -1) close(child_pipes_write[i][1]);\n    }\n\n    printf(\"Parent: Exiting.\\n\");\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "א. בקטע הקוד הנתון, אילו בעיות פוטנציאליות קיימות בטיפול באות `SIGINT` בתהליך האב? התייחס הן לפונקציית הטיפול באות (`sigint_handler`) והן לאופן שבו בקשת הסיום מטופלת בלולאה הראשית של האב. הסבר כיצד ניתן לתקן בעיות אלו.\nב. בתהליך הבן, פונקציית `child_process_logic` קוראת מצינור הסיום (termination pipe) באופן חוסם (blocking read). הסבר מדוע גישה זו עלולה להיות בעייתית במימושים מסוימים של לוגיקת הבן, וכיצד ניתן לשפר אותה כדי להבטיח תגובתיות טובה יותר לבקשות סיום מהאב.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "א. נניח שתהליך בן מסיים את עבודתו באופן טבעי (ללא קבלת `TERMINATE_MSG`) ושולח את הודעת `DONE_MSG`. תאר את רצף האירועים הצפוי בתהליך האב (כולל טיפול באותות וקריאה מצינורות) עד לסיום מלא של אותו בן. האם ישנם מצבים בהם האב עלול להמשיך להמתין לבן שכבר סיים?\nב. פונקציית `cleanup_resources` נקראת כרגע מתוך `sigint_handler` (לאחר שינויים מוצעים בסעיף 1.1.א, היא תקרא ממקום אחר). נתח את לוגיקת סגירת הצינורות בתוך `cleanup_resources` וציין אילו FDs נסגרים בצורה שגויה או עלולים לגרום לבעיות, ומדוע. כיצד יש לתקן את לוגיקת סגירת ה-FDs כדי להבטיח ניקיון נכון של המשאבים?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\n**סעיף 1.1**\n\n**א. בעיות בטיפול באות SIGINT בתהליך האב:**\n\n1.  **קריאות לא בטוחות לאות (Unsafe function calls in signal handler):** פונקציית `sigint_handler` קוראת ל-`printf`. `printf` אינה פונקציה 'async-signal-safe' (כלומר, היא אינה מובטחת לפעול כהלכה כאשר היא נקראת מתוך handler של אות, מכיוון שהיא עלולה להשתמש במנעולים פנימיים או במבני נתונים גלובליים שאינם במצב עקבי בזמן קבלת האות). קריאה כזו עלולה לגרום ל-deadlock או ל-undefined behavior.\n    **תיקון:** `sigint_handler` צריכה להיות מינימלית ככל האפשר. היא צריכה רק להגדיר דגל (כמו `sigint_received`) ולצאת. כל הלוגיקה המורכבת, כולל הדפסה וקריאה לפונקציות אחרות כמו `cleanup_resources`, צריכה להתבצע מחוץ ל-handler, בלולאה הראשית של האב, לאחר שהדגל נקבע.\n\n2.  **קריאה ל-`cleanup_resources` מתוך ה-handler (בעיה פוטנציאלית לאחר התיקון שהוצע):** גם אם `sigint_received` מוגדר ב-handler והלוגיקה עוברת ללולאה הראשית, הפונקציה `cleanup_resources` עצמה מכילה קריאות ל-`printf` ול-`write`. אמנם `write` היא 'async-signal-safe', אך `printf` אינה. לכן, גם אם `cleanup_resources` לא נקראת ישירות מתוך ה-handler, יש לוודא שהפונקציות בתוכה בטוחות בהקשר שבו הן נקראות. במקרה זה, `cleanup_resources` נקראת מהלולאה הראשית לאחר שהדגל `sigint_received` נקבע, ולכן היא פועלת בהקשר של התהליך הראשי ולא ה-handler, וקריאות ל-`printf` שם הן בטוחות. הבעיה העיקרית היא הסטה של הלוגיקה המורכבת מתוך ה-handler עצמו.\n\n**ב. בעיות בקריאה חוסמת מצינור הסיום בתהליך הבן:**\n\n1.  **חוסר תגובתיות (Lack of Responsiveness):** תהליך הבן מבצע לולאת עבודה (הכוללת `sleep` וכתיבה לצינור האב) ובכל איטרציה מנסה לקרוא באופן חוסם מצינור הסיום שלו. אם האב שולח הודעת סיום, הבן יגיב רק כאשר הוא מגיע לנקודת הקריאה בצינור. אם יש פעולה ארוכה אחרת (כמו `sleep(1)` או חישוב ממושך) לפני הקריאה ל-`read` בצינור הסיום, הבן עלול להמשיך לבצע עבודה מיותרת (או לא מתוכננת) במשך זמן מה לפני שיקבל את הודעת הסיום. במקרה שה-`read` עצמו נחסם (כי אין הודעה בצינור), הבן יתקע שם עד שהאב ישלח הודעה, או עד שהצינור ייסגר, ולא יוכל לבצע עבודה אחרת.\n    **תיקון:**\n    *   **שימוש ב-`select`/`poll`:** ניתן לשנות את לוגיקת הבן כך שתשתמש ב-`select` או `poll` כדי להמתין הן לסיום ה-`sleep` (אם ממשיכים להשתמש ב-`sleep`) והן להודעות מצינור הסיום. זה יאפשר לבן להגיב מיידית (או כמעט מיידית) כאשר האב שולח הודעת סיום, מבלי לחכות לסיום ה-`sleep` או לפעולה אחרת.\n    *   **הגדרת הצינור כלא חוסם (Non-blocking):** ניתן להגדיר את קצה הקריאה של צינור הסיום כלא חוסם (באמצעות `fcntl(fd, F_SETFL, O_NONBLOCK)`). במקרה כזה, קריאה ל-`read` תחזיר מיד -1 אם אין נתונים זמינים, עם `errno` שווה ל-`EAGAIN` או `EWOULDBLOCK`. הבן יכול אז לבדוק את הצינור באופן תקופתי מבלי להיחסם, ולהמשיך בעבודתו אם אין הודעת סיום. יש לשים לב שהקוד הנתון מנסה להתמודד עם `EAGAIN` אך הצינור אינו מוגדר כ-non-blocking ולכן `errno` לעולם לא יהיה `EAGAIN` אלא אם כן הצינור הוגדר ככזה.\n\n**סעיף 1.2**\n\n**א. רצף אירועים ובעיות המתנה לבן שסיים:**\n\n1.  **רצף אירועים צפוי:**\n    *   תהליך הבן מסיים את לולאת העבודה שלו.\n    *   הבן שולח את הודעת `DONE_MSG` לצינור האב (`child_pipes_read[child_id][1]`).\n    *   הבן סוגר את קצוות הצינורות שלו (`child_pipes_read[child_id][1]` ו-`child_pipes_write[child_id][0]`) ויוצא באמצעות `exit(0)`.\n    *   סגירת קצה הכתיבה של הצינור (`child_pipes_read[child_id][1]`) תגרום לכך שקצה הקריאה של האב (`child_pipes_read[child_id][0]`) יקבל אינדיקציה של EOF (End Of File) לאחר שכל הנתונים בצינור נקראו.\n    *   תהליך האב, שנמצא בלולאת `while (active_children > 0)` וממתין באמצעות `select`, יתעורר כאשר יש נתונים בצינור הבן (הודעת `DONE_MSG`) או כאשר הצינור נסגר.\n    *   האב יקרא את ה-`DONE_MSG` מהצינור.\n    *   כאשר הבן מסיים, מערכת ההפעלה שולחת אות `SIGCHLD` לתהליך האב.\n    *   `sigchld_handler` של האב מופעלת. היא קוראת ל-`waitpid(-1, &status, WNOHANG)` כדי לאסוף את סטטוס היציאה של הבן.\n    *   `active_children` מופחת באחד בתוך `sigchld_handler`.\n    *   לולאת ה-`while` הראשית של האב תמשיך לרוץ. כאשר `active_children` מגיע ל-0, הלולאה תסתיים.\n    *   בנוסף, אם ה-`read` של האב מהצינור של הבן החזיר 0 בתים (כלומר, EOF), האב יגדיר את `child_pids[i] = -1` עבור אותו בן, מה שיוציא אותו ממעקב ה-`select`.\n\n2.  **מצבים בהם האב עלול להמתין לבן שכבר סיים:**\n    *   **Race condition בין `read` ל-`SIGCHLD`:** תיתכן תחרות (race condition) בין קריאת הנתונים האחרונים מהצינור על ידי האב לבין קבלת `SIGCHLD` ועדכון `active_children`. אם האב קורא את ה-`DONE_MSG` ומסיים את לולאת ה-`for` הפנימית ב-`select`, אך אות `SIGCHLD` טרם הגיע או טרם טופל, המשתנה `active_children` עדיין יהיה גדול מ-0. ה-`select` הבא יכלול עדיין את ה-FD של הבן (אם `child_pids[i]` לא עודכן ל-1- במקרה של EOF), או שהאב ימתין עד ש-`SIGCHLD` יגיע ויעדכן את `active_children`. עם `SA_RESTART` ו-`WNOHANG` ב-`waitpid`, המנגנון די חסון, אך תמיד ייתכן שהאב יבלה קצת זמן נוסף בלולאה הראשית עד שכל האותות יטופלו והמונה יתעדכן.\n    *   **העדר עדכון `child_pids` במקרה של EOF:** בקוד הנתון, אם `read` מחזיר 0 (EOF), האב מגדיר `child_pids[i] = -1`. זה חשוב כדי להוציא את ה-FD מה-`fd_set` ב-`select` הבאים. אם מסיבה כלשהי `child_pids[i]` לא היה מתעדכן, האב היה מנסה להמשיך לקרוא מ-FD סגור או מ-FD של בן שכבר אינו פעיל, מה שיכול לגרום לשגיאות או להמתנה מיותרת. במקרה זה, העדכון קיים, כך שהבעיה מצומצמת.\n    *   **טיפול באות `SIGCHLD`:** אם ה-`SIGCHLD` נחסם או נדחה מסיבה כלשהי (למשל, האב מבצע פעולה ארוכה קריטית שמסכה את האות), האב עלול להמתין זמן רב יותר לבנים שכבר סיימו. עם זאת, השימוש ב-`SA_RESTART` וב-`WNOHANG` ב-`waitpid` ב-`sigchld_handler` מפחית מאוד את הסיכויים לכך.\n\n**ב. ניתוח לוגיקת סגירת הצינורות ב-`cleanup_resources`:**\n\nפונקציית `cleanup_resources` מתוכננת לטפל בסגירת משאבים במקרה של קבלת `SIGINT`. בבדיקה מעמיקה, נראה שיש בה מספר בעיות:\n\n1.  **סגירת קצוות צינורות של הבנים בתהליך האב:**\n    *   `close(child_pipes_read[i][1]);`: זהו קצה הכתיבה של הצינור שדרכו הבן כותב לאב. קצה זה שייך לתהליך הבן, והאב סגר אותו מיד לאחר ה-`fork` (בתוך לולאת ה-`for` של ה-`fork`). ניסיון לסגור אותו שוב ב-`cleanup_resources` יגרום לשגיאת `EBADF` (Bad File Descriptor) אם הוא כבר נסגר.\n    *   `close(child_pipes_write[i][0]);`: זהו קצה הקריאה של הצינור שדרכו הבן קורא מהאב. קצה זה שייך לתהליך הבן, והאב סגר אותו מיד לאחר ה-`fork`. ניסיון לסגור אותו שוב יגרום לשגיאת `EBADF`.\n    **תיקון:** האב צריך לסגור רק את קצוות הצינורות שהוא עצמו משתמש בהם. כלומר, ב-`cleanup_resources` (או בסיום התוכנית), האב צריך לסגור רק את `child_pipes_read[i][0]` (קצה הקריאה של האב מהבן) ואת `child_pipes_write[i][1]` (קצה הכתיבה של האב לבן). הקצוות של הבן נסגרים על ידי הבן עצמו.\n\n2.  **סגירת צינורות גם עבור בנים שטרם נוצרו או כבר סיימו:**\n    *   הלולאה ב-`cleanup_resources` עוברת על כל `NUM_CHILDREN` ומנסה לסגור את הצינורות. הבדיקה `if (child_pids[i] > 0)` מיועדת לוודא שהבן נוצר, אך היא לא מונעת ניסיון סגירה של FDs שכבר נסגרו (למשל, אם בן כבר סיים את פעולתו וה-FD שלו נסגר על ידי האב בלולאה הראשית במקרה של EOF). זה עלול להוביל לשגיאות `EBADF`.\n    **תיקון:** יש לעקוב אחר מצב ה-FDs (למשל, לאפס את הערך במערך ה-`child_pipes_read` או `child_pipes_write` ל-1- לאחר סגירה מוצלחת) ולסגור רק FDs שעדיין פתוחים. שיטה טובה יותר היא להשתמש במערך של FDs ולסגור אותם רק אם הם גדולים מ-0 (כלומר, פתוחים).\n\n**לוגיקת סגירת FDs מתוקנת (דוגמה ב-`cleanup_resources`):**\n\n```c\nvoid cleanup_resources_fixed(int signum) {\n    printf(\"Parent: Cleaning up resources.\\n\");\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        // Only if the child was successfully forked AND is still conceptually active\n        // (child_pids[i] might be -1 if child already exited and pipe closed)\n        if (child_pids[i] > 0) {\n            // Send termination message to child via its dedicated pipe\n            // Ensure the parent's write end is still open before writing\n            if (child_pipes_write[i][1] != -1) {\n                if (write(child_pipes_write[i][1], TERMINATE_MSG, strlen(TERMINATE_MSG) + 1) == -1) {\n                    if (errno != EPIPE) { // EPIPE means the read end was already closed\n                        perror(\"Parent: write TERMINATE_MSG to child pipe failed\");\n                    }\n                }\n            }\n        }\n        // Parent closes its own ends of the pipes\n        if (child_pipes_read[i][0] != -1) {\n            close(child_pipes_read[i][0]);\n            child_pipes_read[i][0] = -1; // Mark as closed\n        }\n        if (child_pipes_write[i][1] != -1) {\n            close(child_pipes_write[i][1]);\n            child_pipes_write[i][1] = -1; // Mark as closed\n        }\n        // The child's ends (child_pipes_read[i][1] and child_pipes_write[i][0])\n        // were closed by the parent after fork, and by the child itself before exiting.\n        // No need to close them again here.\n    }\n}\n\n// ב-main, לאחר ה-fork, יש לוודא שקצוות הצינורות של הבן נסגרים אצל האב:\n// for (int i = 0; i < NUM_CHILDREN; ++i) {\n//     child_pids[i] = fork();\n//     if (child_pids[i] == 0) { // Child process\n//         // ... child_process_logic ...\n//     } else { // Parent process\n//         active_children++;\n//         close(child_pipes_read[i][1]); // Close child's write end in parent\n//         child_pipes_read[i][1] = -1; // Mark as closed\n//         close(child_pipes_write[i][0]); // Close child's read end in parent\n//         child_pipes_write[i][0] = -1; // Mark as closed\n//     }\n// }\n//\n// ובסיום ה-main, במקום הלולאה הנוכחית, יש לקרוא ל-cleanup_resources_fixed\n// או לוודא שכל ה-FDs שנותרו פתוחים (של האב) נסגרים בצורה דומה.\n```"
    },
    "difficulty_estimation": "Hard"
  }
}