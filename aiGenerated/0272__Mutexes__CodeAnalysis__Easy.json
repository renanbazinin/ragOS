{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:25:22",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4189,
      "output_tokens": 1261,
      "total_tokens": 8925
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Mutexes",
      "Concurrency",
      "Deadlock"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת ב-mutex להגנה על משתנה גלובלי משותף (counter). מספר תהליכונים (threads) מנסים לעדכן את המונה באמצעות הפונקציה `update_shared_counter`. נתחו את הקוד וזהו בעיה אפשרית.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h> // For usleep\n\npthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;\nint shared_counter = 0;\n\nvoid* update_shared_counter(void* arg) {\n    pthread_mutex_lock(&counter_mutex); // Acquire lock\n\n    shared_counter++; // Critical section\n\n    if (shared_counter % 5 == 0) {\n        printf(\"Counter reached a multiple of 5: %d (Thread ID: %lu)\\n\", shared_counter, (unsigned long)pthread_self());\n        // BUG: Forgot to unlock the mutex before early return\n        return NULL; // Early exit\n    }\n\n    // Simulate some other work that might take time\n    usleep(10); // Small sleep to increase chance of other threads trying to acquire lock\n\n    pthread_mutex_unlock(&counter_mutex); // Release lock\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[10];\n    for (int i = 0; i < 10; ++i) {\n        pthread_create(&threads[i], NULL, update_shared_counter, NULL);\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", shared_counter);\n    pthread_mutex_destroy(&counter_mutex); // Clean up mutex\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הבעיה: קיפאון (Deadlock).\n\nהסבר:\nהפונקציה `update_shared_counter` נועלת את ה-mutex בתחילתה באמצעות `pthread_mutex_lock`. אם התנאי `shared_counter % 5 == 0` מתקיים, הפונקציה מבצעת יציאה מוקדמת (early return) מבלי לשחרר את ה-mutex. כתוצאה מכך, ה-mutex נשאר נעול. כאשר תהליכון אחר ינסה לגשת לקטע הקריטי (כלומר, יקרא ל-`pthread_mutex_lock`), הוא ייחסם לצמיתות וימתין לשחרור ה-mutex שלעולם לא יגיע, מה שיוביל לקיפאון של התוכנית.\n\nתיקון:\nיש לשחרר את ה-mutex בכל נתיבי היציאה מהפונקציה. יש להוסיף קריאה ל-`pthread_mutex_unlock(&counter_mutex);` לפני שורת ה-`return NULL;` בתוך בלוק ה-`if`.\n\nקוד מתוקן (השינוי בשורה 16):\n```c\n#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h> // For usleep\n\npthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;\nint shared_counter = 0;\n\nvoid* update_shared_counter(void* arg) {\n    pthread_mutex_lock(&counter_mutex); // Acquire lock\n\n    shared_counter++; // Critical section\n\n    if (shared_counter % 5 == 0) {\n        printf(\"Counter reached a multiple of 5: %d (Thread ID: %lu)\\n\", shared_counter, (unsigned long)pthread_self());\n        pthread_mutex_unlock(&counter_mutex); // FIX: Release lock before early return\n        return NULL; // Early exit\n    }\n\n    // Simulate some other work that might take time\n    usleep(10); // Small sleep to increase chance of other threads trying to acquire lock\n\n    pthread_mutex_unlock(&counter_mutex); // Release lock\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[10];\n    for (int i = 0; i < 10; ++i) {\n        pthread_create(&threads[i], NULL, update_shared_counter, NULL);\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", shared_counter);\n    pthread_mutex_destroy(&counter_mutex); // Clean up mutex\n    return 0;\n}\n```"
    },
    "difficulty_estimation": "Easy"
  }
}