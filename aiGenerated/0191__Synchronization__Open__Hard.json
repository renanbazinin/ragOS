{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Synchronization",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 19:57:16",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4073,
      "output_tokens": 4024,
      "total_tokens": 17025
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Threads",
      "Concurrency",
      "Mutexes",
      "Condition Variables",
      "Barriers"
    ],
    "content": {
      "text": "במערכות הפעלה מרובות-חוטים, לעיתים קרובות נדרש לסנכרן קבוצת חוטים כך שימתינו זה לזה, אך גם ימתינו לתנאי חיצוני מסוים. נתון אובייקט סנכרון בשם `ConditionalTurnstile` אשר מאפשר ל-N חוטים לעבור יחד, אך ורק כאשר תנאי חיצוני (שנקבע על ידי פונקציה אחרת) מתקיים. לאחר שקבוצה של N חוטים עברה, ה-`ConditionalTurnstile` מתאפס ומוכן לקבוצת החוטים הבאה.\n\nהאובייקט `ConditionalTurnstile` יכלול את הפעולות הבאות:\n*   `init(ConditionalTurnstile *ts, int N)`: מאתחל את ה-`Turnstile` עבור N חוטים.\n*   `destroy(ConditionalTurnstile *ts)`: משחרר משאבים.\n*   `wait_for_batch(ConditionalTurnstile *ts)`: חוט הקורא לפעולה זו ממתין עד ש-N חוטים נוספים (כולל הוא עצמו) קראו לפעולה, וכן שתנאי חיצוני מסוים מתקיים. רק אז, כל N החוטים משוחררים בו זמנית.\n*   `set_condition(ConditionalTurnstile *ts, bool condition_state)`: משנה את מצב התנאי החיצוני. אם התנאי הופך ל-`true` בזמן שחוטים ממתינים, והגיעה קבוצה של N חוטים, יש לשחררם.\n\nיש לממש את ה-`ConditionalTurnstile` תוך שימוש במנעולים (mutexes) ומשתני תנאי (condition variables) בלבד, ובאופן יעיל ככל האפשר. יש להקפיד על פתרון נטול קיפאון (deadlock-free) ותנאי מרוץ (race-condition-free).\n\nשימו לב במיוחד לטיפול במצבים הבאים:\n1.  מה קורה אם `set_condition` נקראת כאשר אין חוטים ממתינים?\n2.  מה קורה אם `set_condition` נקראת מספר פעמים ברצף?\n3.  כיצד מבטיחים שכל N החוטים ישוחררו יחד, ושהמונה יתאפס בצורה בטוחה לקבוצה הבאה, תוך כדי מניעת בעיית \"הנוסע הממהר\" (Early-departer problem) עם מחסומים הניתנים לשימוש חוזר?",
      "code_snippet": "#include <pthread.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int N;                      // Total threads required for a batch\n    int arrived_count;          // Threads that have arrived in the current \"wave\"\n    int passed_count;           // Threads that have passed the barrier in the current \"wave\"\n    int wave;                   // Current wave number for reusability\n    pthread_mutex_t mutex;\n    pthread_cond_t cond_arrival;   // Threads wait here until batch is full AND condition met\n    pthread_cond_t cond_departure; // Threads wait here until all N have departed\n    bool condition_met;         // The external condition state\n} ConditionalTurnstile;\n\nvoid init(ConditionalTurnstile *ts, int N);\nvoid destroy(ConditionalTurnstile *ts);\nvoid wait_for_batch(ConditionalTurnstile *ts);\nvoid set_condition(ConditionalTurnstile *ts, bool condition_state);",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\nהמימוש משתמש באלגוריתם מחסום דו-שלבי (two-phase barrier) בשילוב עם מונה דורות (generation counter) על מנת לאפשר שימוש חוזר במחסום ולמנוע תנאי מרוץ כגון \"הנוסע הממהר\" (early-departer).\n\nמבנה `ConditionalTurnstile`:\n*   `N`: מספר החוטים הנדרשים לקבוצה אחת.\n*   `arrived_count`: מונה את מספר החוטים שהגיעו לשלב הראשון של המחסום בקבוצה הנוכחית.\n*   `passed_count`: מונה את מספר החוטים שעברו את שלב השחרור ומתקדמים לשלב האיפוס בקבוצה הנוכחית.\n*   `wave`: מונה דורות, מזהה איזו קבוצה של חוטים נמצאת כרגע במחסום. מתקדם כל פעם שקבוצה שלמה עוברת.\n*   `mutex`: מנעול להגנה על משתני המצב (`arrived_count`, `passed_count`, `wave`, `condition_met`).\n*   `cond_arrival`: משתנה תנאי עליו ממתינים חוטים בשלב ההגעה, עד שכל `N` החוטים הגיעו וגם `condition_met` נכון.\n*   `cond_departure`: משתנה תנאי עליו ממתינים חוטים בשלב העזיבה, עד שהחוט האחרון בקבוצה איפס את המחסום.\n*   `condition_met`: דגל בוליאני המייצג את מצב התנאי החיצוני.\n\n```c\n#include <pthread.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int N;\n    int arrived_count;\n    int passed_count;\n    int wave;\n    pthread_mutex_t mutex;\n    pthread_cond_t cond_arrival;\n    pthread_cond_t cond_departure;\n    bool condition_met;\n} ConditionalTurnstile;\n\nvoid init(ConditionalTurnstile *ts, int N) {\n    ts->N = N;\n    ts->arrived_count = 0;\n    ts->passed_count = 0;\n    ts->wave = 0;\n    pthread_mutex_init(&ts->mutex, NULL);\n    pthread_cond_init(&ts->cond_arrival, NULL);\n    pthread_cond_init(&ts->cond_departure, NULL);\n    ts->condition_met = false;\n}\n\nvoid destroy(ConditionalTurnstile *ts) {\n    pthread_mutex_destroy(&ts->mutex);\n    pthread_cond_destroy(&ts->cond_arrival);\n    pthread_cond_destroy(&ts->cond_departure);\n}\n\nvoid wait_for_batch(ConditionalTurnstile *ts) {\n    pthread_mutex_lock(&ts->mutex);\n\n    int my_wave = ts->wave; // Captures the current wave number for this thread\n\n    ts->arrived_count++;\n\n    // Phase 1: Arrival - threads wait for N arrivals AND the external condition\n    if (ts->arrived_count == ts->N) { // This is the N-th thread to arrive\n        // The N-th thread waits until the external condition is met\n        while (!ts->condition_met) {\n            pthread_cond_wait(&ts->cond_arrival, &ts->mutex);\n        }\n        // Condition is met, and N threads have arrived. Release all threads in this batch.\n        // No need to increment wave here, it's done by the last departing thread.\n        pthread_cond_broadcast(&ts->cond_arrival);\n    } else { // Not the N-th thread to arrive\n        // Wait until the N-th thread signals that the batch is ready to proceed\n        // and the condition was met. We use 'my_wave' to ensure we wait for the current batch.\n        while (my_wave == ts->wave) {\n            pthread_cond_wait(&ts->cond_arrival, &ts->mutex);\n        }\n    }\n\n    // All N threads have now passed the arrival barrier and are released.\n    // Phase 2: Departure - threads decrement count and wait for the last thread to reset\n    ts->passed_count++;\n\n    if (ts->passed_count == ts->N) { // This is the N-th thread to depart\n        // Reset counts and advance the wave for the next batch\n        ts->arrived_count = 0;\n        ts->passed_count = 0;\n        ts->wave++; // Advance wave for the next batch of threads\n        // Signal all threads waiting in the departure phase that the barrier is reset\n        pthread_cond_broadcast(&ts->cond_departure);\n    } else { // Not the N-th thread to depart\n        // Wait until the last thread of this batch signals that the barrier is reset\n        while (my_wave == ts->wave) {\n            pthread_cond_wait(&ts->cond_departure, &ts->mutex);\n        }\n    }\n\n    pthread_mutex_unlock(&ts->mutex);\n}\n\nvoid set_condition(ConditionalTurnstile *ts, bool condition_state) {\n    pthread_mutex_lock(&ts->mutex);\n    ts->condition_met = condition_state;\n    // If the condition becomes true AND a full batch of threads is waiting,\n    // wake them up. This is crucial if the N-th thread is waiting for the condition.\n    if (condition_state && ts->arrived_count == ts->N) {\n        pthread_cond_broadcast(&ts->cond_arrival);\n    }\n    pthread_mutex_unlock(&ts->mutex);\n}\n```\n\nהסבר:\n\n**פונקציה `init(ConditionalTurnstile *ts, int N)`:**\n*   מאתחלת את המשתנים `N`, `arrived_count` (מונה חוטים שהגיעו), `passed_count` (מונה חוטים שעזבו), `wave` (מונה דורות לשימוש חוזר במחסום), ואת המנעול ומשתני התנאי. `condition_met` מאותחל ל-`false`.\n\n**פונקציה `destroy(ConditionalTurnstile *ts)`:**\n*   משחררת את המשאבים על ידי השמדת המנעול ומשתני התנאי.\n\n**פונקציה `wait_for_batch(ConditionalTurnstile *ts)`:**\n1.  **נעילה ורישום גל הדור:** החוט נועל את המוטקס ושומר את מספר ה\"גל\" (wave) הנוכחי במשתנה מקומי `my_wave`. זה מאפשר לו לזהות מתי המחסום התקדם ל\"גל\" הבא, ומונע תנאי מרוץ במחסום הניתן לשימוש חוזר.\n2.  **שלב ההגעה (Arrival Phase):**\n    *   `ts->arrived_count` מקודם. זהו מונה החוטים שהגיעו למחסום ב\"גל\" הנוכחי.\n    *   **אם החוט הוא החוט ה-N-י שמגיע (`ts->arrived_count == ts->N`):**\n        *   הוא ממתין (באמצעות `pthread_cond_wait` על `cond_arrival`) עד ש-`condition_met` יהפוך ל-`true`. הוא האחראי לשחרר את הקבוצה.\n        *   ברגע שהתנאי מתקיים, הוא משחרר את כל `N-1` החוטים הממתינים (באמצעות `pthread_cond_broadcast` על `cond_arrival`).\n    *   **אם החוט אינו החוט ה-N-י שמגיע (`ts->arrived_count < ts->N`):**\n        *   הוא ממתין (באמצעות `pthread_cond_wait` על `cond_arrival`) כל עוד `my_wave` שווה ל-`ts->wave`. הוא ישוחרר כאשר החוט ה-N-י ישדר `broadcast` וישנה את `my_wave` (על ידי קידום `ts->wave` בשלב העזיבה של הקבוצה).\n3.  **שלב העזיבה (Departure Phase):**\n    *   לאחר שכל `N` החוטים שוחררו משלב ההגעה, הם מקדמים את `ts->passed_count`. זהו מונה החוטים שעברו את שלב השחרור ב\"גל\" הנוכחי.\n    *   **אם החוט הוא החוט ה-N-י שעובר (`ts->passed_count == ts->N`):**\n        *   הוא מאפס את `arrived_count` ו-`passed_count` ל-0. פעולה זו \"מנקה\" את המחסום לקבוצה הבאה.\n        *   הוא מקדם את `ts->wave` (כדי לסמן שהמחסום מוכן לקבוצה הבאה).\n        *   הוא משחרר את כל `N-1` החוטים הממתינים בשלב העזיבה (באמצעות `pthread_cond_broadcast` על `cond_departure`).\n    *   **אם החוט אינו החוט ה-N-י שעובר (`ts->passed_count < ts->N`):**\n        *   הוא ממתין (באמצעות `pthread_cond_wait` על `cond_departure`) כל עוד `my_wave` שווה ל-`ts->wave`. הוא ישוחרר כאשר החוט האחרון יקדם את `ts->wave` ויבצע `broadcast`.\n4.  **שחרור:** החוט משחרר את המוטקס.\n\n**פונקציה `set_condition(ConditionalTurnstile *ts, bool condition_state)`:**\n1.  נועלת את המוטקס.\n2.  מעדכנת את `ts->condition_met` למצב החדש.\n3.  אם `condition_state` הפך ל-`true` וגם `ts->arrived_count` שווה ל-`ts->N` (כלומר, קבוצה מלאה של חוטים ממתינה על `cond_arrival`): היא משחררת את כל החוטים הממתינים על `cond_arrival` (באמצעות `pthread_cond_broadcast`). זה מאפשר לחוט ה-N-י (אם הוא ממתין על התנאי) או לשאר החוטים להתקדם.\n4.  משחררת את המוטקס.\n\n**טיפול במצבים מיוחדים:**\n1.  **`set_condition` נקראת כאשר אין חוטים ממתינים:** הפונקציה תעדכן את `condition_met`. אם `condition_state` הוא `true`, היא תבצע `broadcast` אך לא יהיו חוטים שיושפעו מכך באופן מיידי. החוטים שיגיעו מאוחר יותר ימצאו את `condition_met` כבר כ-`true` ויפעלו בהתאם.\n2.  **`set_condition` נקראת מספר פעמים ברצף:** רק הערך הסופי של `condition_state` יהיה רלוונטי. כל קריאה עשויה לבצע `broadcast` אם התנאי הופך ל-`true` וקבוצה מלאה ממתינה. אין בכך בעיה מבחינת נכונות, שכן `pthread_cond_broadcast` הוא אידמפוטנטי במובן זה של חוטים ממתינים.\n3.  **שחרור `N` חוטים יחד ואיפוס בטוח (מניעת \"הנוסע הממהר\"):**\n    *   מנגנון ה\"גל\" (`wave` counter) ומשתני התנאי `cond_arrival` ו-`cond_departure` מבטיחים זאת.\n    *   `cond_arrival` מבטיח שכל `N` החוטים יגיעו ושהתנאי יתקיים לפני שמישהו ימשיך. החוט ה-N-י הוא זה שמבצע `broadcast` כדי לשחרר את כולם.\n    *   `cond_departure` ומנגנון ה-`passed_count` מבטיחים שכל `N` החוטים יעברו את המחסום לפני ש-`ts->wave` יתקדם שוב. החוט האחרון שעוזב מאפס את המחסום ומקדם את ה\"גל\", ובכך מונע מחוטים מהגל הבא להתחיל לפני שהגל הקודם סיים את כל שלבי המחסום.\n    *   השימוש ב-`my_wave` המקומי בכל חוט מבטיח שחוט שקדם ל\"גל\" הבא לא ישוחרר בטעות על ידי `broadcast` המיועד ל\"גל\" קודם, וכן שחוט שפיגר לא ייתקע לנצח."
    },
    "difficulty_estimation": "Hard"
  }
}