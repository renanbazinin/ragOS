{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Concurrency",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 00:44:56",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4697,
      "output_tokens": 2823,
      "total_tokens": 14616
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Concurrency",
      "Synchronization",
      "Deadlock Prevention",
      "Resource Management",
      "Mutexes",
      "Condition Variables"
    ],
    "content": {
      "text": "מערכת הפעלה מודרנית דורשת ניהול יעיל של משאבים משותפים. נתונות K סוגי משאבים שונים (לדוגמה: מעבדים גרפיים, כרטיסי רשת מיוחדים, בלוקי זיכרון ייעודיים). כל סוג משאב `i` מכיל כמות התחלתית `initial_counts[i]` יחידות זמינות. תהליכים או תהליכונים במערכת צריכים לבקש סט של משאבים באופן אטומי: אם כל המשאבים הנדרשים זמינים, הם יוקצו לתהליך; אחרת, התהליך ימתין עד שכל המשאבים יהיו זמינים. תהליך שסיים להשתמש במשאבים מחזיר אותם למנהל.\n\nיש לממש את מבנה הנתונים `ResourceManager` ואת הפונקציות `init_resource_manager`, `destroy_resource_manager`, `acquire_resources`, ו-`release_resources`.\nהמימוש חייב להיות:\n1.  **נכון מבחינת סנכרון**: למנוע מצבי מרוץ (race conditions).\n2.  **ללא קיפאון (deadlock-free)**: להבטיח שלא ייווצר מצב שבו תהליכים ממתינים זה לזה באופן בלתי הפיך.\n3.  **ללא המתנה פעילה (busy-waiting)**: תהליכים צריכים לחכות ביעילות ולא לבזבז זמן מעבד.",
      "code_snippet": "```c\n#include <pthread.h>\n#include <stdlib.h> // For malloc, free\n#include <stdio.h>  // For printf (optional, for debugging)\n\n// Represents a request for resources.\n// resource_id_to_count[i] specifies the number of units required for resource type i.\ntypedef struct {\n    int K; // Number of resource types\n    int *resource_id_to_count; // Array of size K\n} ResourceRequest;\n\n// The resource manager structure - COMPLETE THIS STRUCTURE\ntypedef struct {\n    int K; // Number of resource types\n    // Add necessary synchronization primitives and resource state here\n    // For example:\n    // int *available_counts;\n    // pthread_mutex_t manager_mutex;\n    // pthread_cond_t resources_available_cond;\n} ResourceManager;\n\n// Initializes the resource manager\nvoid init_resource_manager(ResourceManager *manager, int K, const int *initial_counts);\n\n// Destroys the resource manager\nvoid destroy_resource_manager(ResourceManager *manager);\n\n// Acquires all resources specified in the request atomically.\n// If not all resources are available, the calling thread waits.\nvoid acquire_resources(ResourceManager *manager, const ResourceRequest *request);\n\n// Releases all resources specified in the request.\nvoid release_resources(ResourceManager *manager, const ResourceRequest *request);\n\n// Helper functions (optional, for testing/completeness)\nResourceRequest* create_request(int K, const int *counts);\nvoid destroy_request(ResourceRequest *request);\n```",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסבר:\nהמימוש יעשה שימוש ב-`pthread_mutex_t` ו-`pthread_cond_t` כדי להבטיח סנכרון נכון ולמנוע המתנה פעילה.\n*   **`manager_mutex`**: מנעול יחיד זה ישמש להגנה על מבנה הנתונים של `ResourceManager`, ובעיקר על המערך `available_counts`. כל גישה או שינוי של `available_counts` תהיה מוגנת על ידי מנעול זה. זה מבטיח אטומיות בבדיקת זמינות ובהקצאת משאבים.\n*   **`resources_available_cond`**: משתנה תנאי זה ישמש כדי לגרום לתהליכים להמתין ביעילות. כאשר תהליך מנסה לרכוש משאבים ומוצא שהם אינם זמינים, הוא ישחרר את ה-`manager_mutex` וימתין על משתנה התנאי. כאשר תהליך אחר משחרר משאבים, הוא יודיע לכל התהליכים הממתינים על ידי קריאה ל-`pthread_cond_broadcast`, מה שיעיר אותם כדי שיבדקו שוב את זמינות המשאבים.\n\n**מניעת מצבי מרוץ וקיפאון:**\n*   **מצבי מרוץ**: המנעול `manager_mutex` מונע מצבי מרוץ על ידי הבטחה שרק תהליך אחד יכול לבדוק ולשנות את `available_counts` בכל רגע נתון.\n*   **קיפאון (Deadlock)**: בפתרון זה, קיפאון נמנע מכיוון שתהליך לעולם אינו מחזיק במשאבים חלקיים וגם ממתין למשאבים אחרים. תהליך רוכש את המנעול `manager_mutex`, בודק אם *כל* המשאבים הנדרשים זמינים.\n    *   אם כן, הוא מקצה אותם (מפחית מהמונה), משחרר את המנעול וממשיך.\n    *   אם לא, הוא משחרר את המנעול ומיד נכנס למצב המתנה על `resources_available_cond`. הוא לא מחזיק באף משאב (רק במנעול `manager_mutex` לזמן קצר מאוד לבדיקה), ובכך מונע מצב שבו הוא יחסום תהליכים אחרים מלהתקדם.\n    *   סדר הרכישה של משאבים בתוך `acquire_resources` אינו משנה לבעיית הקיפאון, מכיוון שהבדיקה וההקצאה נעשות כולן תחת מנעול יחיד, ובאופן אטומי. אם לא ניתן להקצות את כולם, אף אחד לא מוקצה.\n\n**הימנעות מהמתנה פעילה:**\nהשימוש ב-`pthread_cond_wait` מבטיח שתהליכים הממתינים למשאבים לא יבזבזו זמן מעבד על סריקה חוזרת ונשנית (spinning) אלא ייכנסו למצב שינה עד שיאותתו להם על ידי `pthread_cond_broadcast`.\n\n```c\n#include <pthread.h>\n#include <stdlib.h> // For malloc, free\n#include <stdio.h>  // For printf (optional, for debugging)\n#include <string.h> // For memcpy\n\n// Represents a request for resources.\n// resource_id_to_count[i] specifies the number of units required for resource type i.\ntypedef struct {\n    int K; // Number of resource types\n    int *resource_id_to_count; // Array of size K\n} ResourceRequest;\n\n// The resource manager structure\ntypedef struct {\n    int K; // Number of resource types\n    int *available_counts; // Array of size K, current available units for each type\n    pthread_mutex_t manager_mutex;\n    pthread_cond_t resources_available_cond;\n} ResourceManager;\n\n// Initializes the resource manager\nvoid init_resource_manager(ResourceManager *manager, int K, const int *initial_counts) {\n    manager->K = K;\n    manager->available_counts = (int*) malloc(sizeof(int) * K);\n    if (manager->available_counts == NULL) {\n        perror(\"malloc failed for available_counts\");\n        exit(EXIT_FAILURE);\n    }\n    memcpy(manager->available_counts, initial_counts, sizeof(int) * K);\n\n    pthread_mutex_init(&manager->manager_mutex, NULL);\n    pthread_cond_init(&manager->resources_available_cond, NULL);\n}\n\n// Destroys the resource manager\nvoid destroy_resource_manager(ResourceManager *manager) {\n    free(manager->available_counts);\n    pthread_mutex_destroy(&manager->manager_mutex);\n    pthread_cond_destroy(&manager->resources_available_cond);\n}\n\n// Helper function to check if all resources in a request are available\nstatic int check_availability(ResourceManager *manager, const ResourceRequest *request) {\n    for (int i = 0; i < manager->K; ++i) {\n        if (request->resource_id_to_count[i] > 0 && \n            manager->available_counts[i] < request->resource_id_to_count[i]) {\n            return 0; // Not all resources are available\n        }\n    }\n    return 1; // All resources are available\n}\n\n// Acquires all resources specified in the request atomically.\n// If not all resources are available, the calling thread waits.\nvoid acquire_resources(ResourceManager *manager, const ResourceRequest *request) {\n    pthread_mutex_lock(&manager->manager_mutex);\n\n    while (!check_availability(manager, request)) {\n        // Resources not available, wait for a signal\n        pthread_cond_wait(&manager->resources_available_cond, &manager->manager_mutex);\n    }\n\n    // Resources are available, acquire them\n    for (int i = 0; i < manager->K; ++i) {\n        if (request->resource_id_to_count[i] > 0) {\n            manager->available_counts[i] -= request->resource_id_to_count[i];\n        }\n    }\n\n    pthread_mutex_unlock(&manager->manager_mutex);\n}\n\n// Releases all resources specified in the request.\nvoid release_resources(ResourceManager *manager, const ResourceRequest *request) {\n    pthread_mutex_lock(&manager->manager_mutex);\n\n    // Release resources\n    for (int i = 0; i < manager->K; ++i) {\n        if (request->resource_id_to_count[i] > 0) {\n            manager->available_counts[i] += request->resource_id_to_count[i];\n        }\n    }\n\n    // Notify all waiting threads that resources might now be available\n    pthread_cond_broadcast(&manager->resources_available_cond);\n\n    pthread_mutex_unlock(&manager->manager_mutex);\n}\n\n// Helper function to create a ResourceRequest (optional, for testing)\nResourceRequest* create_request(int K, const int *counts) {\n    ResourceRequest *req = (ResourceRequest*) malloc(sizeof(ResourceRequest));\n    if (req == NULL) {\n        perror(\"malloc failed for ResourceRequest\");\n        exit(EXIT_FAILURE);\n    }\n    req->K = K;\n    req->resource_id_to_count = (int*) malloc(sizeof(int) * K);\n    if (req->resource_id_to_count == NULL) {\n        perror(\"malloc failed for resource_id_to_count in request\");\n        free(req);\n        exit(EXIT_FAILURE);\n    }\n    memcpy(req->resource_id_to_count, counts, sizeof(int) * K);\n    return req;\n}\n\n// Helper function to destroy a ResourceRequest (optional, for testing)\nvoid destroy_request(ResourceRequest *request) {\n    free(request->resource_id_to_count);\n    free(request);\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}