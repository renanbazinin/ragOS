{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:51:24",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3433,
      "output_tokens": 3638,
      "total_tokens": 20182
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Producer-Consumer",
      "Synchronization",
      "Semaphores",
      "Concurrency"
    ],
    "content": {
      "text": "במפעל מודרני קיימת מערכת לניהול פריטים. ישנם סוגי עובדים שונים: `ItemProducer` ו-`BatchProcessor`.\n`ItemProducer` (יצרן פריטים) מייצר פריטים בודדים ומכניס אותם למאגר משותף (buffer).\n`BatchProcessor` (מעבד אצוות) צורך פריטים מהמאגר באצוות. מעבד אצוות חייב לצרוך **לפחות** `MIN_BATCH_SIZE` פריטים באצווה אחת כדי להתחיל לעבד. אם ישנם `MIN_BATCH_SIZE` פריטים או יותר במאגר, מעבד האצוות יקח את כמות הפריטים הזמינה, אך לא יותר מ-`MAX_BATCH_SIZE` פריטים. אם יש פחות מ-`MIN_BATCH_SIZE` פריטים, מעבד האצוות חייב להמתין עד שיהיו מספיק פריטים זמינים.\nהמאגר המשותף הוא מוגבל בגודלו (`BUFFER_SIZE`).\nיש לממש את פונקציות החוטים עבור `ItemProducer` ו-`BatchProcessor` כך שהמערכת תעבוד באופן תקין, תוך הימנעות מקיפאון (deadlock) או הרעבה (starvation).\n\n**דרישות:**\n1.  המאגר הוא מאגר מעגלי (circular buffer) בגודל `BUFFER_SIZE`.\n2.  יש להשתמש בסמפורים בלבד (לא ניתן להשתמש בפעולות מעבד אטומיות או באובייקטי סנכרון אחרים מלבד סמפורים).\n3.  יש להניח כי הסמפורים הוגנים (fair).\n4.  יש לכלול את כל המשתנים הגלובליים הנדרשים (כולל אתחול בהערות).\n5.  יש לכלול קוד C/C++ מלא עבור פונקציות החוטים `ItemProducer` ו-`BatchProcessor`.\n6.  יש לכלול הסבר מפורט לפתרון.",
      "code_snippet": "```c\n#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For usleep\n\n// Constants for buffer and batch sizes\n#define BUFFER_SIZE 10\n#define MIN_BATCH_SIZE 5\n#define MAX_BATCH_SIZE 8 // MAX_BATCH_SIZE must be <= BUFFER_SIZE\n\n// Shared Buffer\nint buffer[BUFFER_SIZE];\nint in = 0;\nint out = 0;\n\n// Synchronization Primitives\nsem_t mutex; // Protects buffer, buffer_item_count, batch_processor_waiting_count\nsem_t empty_slots; // Counts available empty slots in buffer\nsem_t batch_processor_gate; // Controls entry to the batch acquisition critical section (turnstile)\nsem_t batch_ready_signal; // Batch processors wait here for a batch to be ready\n\n// Shared Counters, protected by mutex\nint buffer_item_count = 0; // Number of items currently in the buffer\nint batch_processor_waiting_count = 0; // Number of batch processors waiting for >= MIN_BATCH_SIZE items\n\n// Function to simulate item creation\nint create_item() {\n    // In a real scenario, this would create an actual item\n    return rand() % 100; // Just a random integer for demonstration\n}\n\n// Function to simulate item processing (for batch)\nvoid process_item(int item) {\n    // In a real scenario, this would process the item\n    // printf(\"Processing item: %d\\n\", item); // Uncomment for verbose output\n}\n\n// Producer thread function\nvoid* ItemProducer(void* arg) {\n    while (1) {\n        int new_item = create_item();\n        \n        sem_wait(&empty_slots); // Wait for an empty slot in the buffer\n\n        sem_wait(&mutex); // Enter critical section to modify shared state\n        buffer[in] = new_item;\n        in = (in + 1) % BUFFER_SIZE;\n        buffer_item_count++;\n        // printf(\"Producer added item %d. Buffer count: %d\\n\", new_item, buffer_item_count); // Uncomment for verbose output\n        \n        // If enough items for a batch AND there's a BatchProcessor waiting, signal one.\n        // Otherwise, just release the mutex.\n        if (buffer_item_count >= MIN_BATCH_SIZE && batch_processor_waiting_count > 0) {\n            sem_post(&batch_ready_signal); // Signal one waiting batch processor\n        }\n        sem_post(&mutex); // Exit critical section\n        \n        usleep(rand() % 100000); // Simulate work outside critical section\n    }\n    return NULL;\n}\n\n// Consumer (BatchProcessor) thread function\nvoid* BatchProcessor(void* arg) {\n    while (1) {\n        sem_wait(&batch_processor_gate); // Acquire gate to enter batch acquisition logic (turnstile)\n        sem_wait(&mutex); // Acquire mutex to check/modify shared state\n\n        // Loop while not enough items for a batch\n        while (buffer_item_count < MIN_BATCH_SIZE) {\n            batch_processor_waiting_count++;\n            // printf(\"BatchProcessor waiting. Current buffer count: %d, waiting BPs: %d\\n\", buffer_item_count, batch_processor_waiting_count); // Uncomment for verbose output\n            \n            sem_post(&mutex); // Release mutex to allow producers to add items\n            sem_post(&batch_processor_gate); // Release gate for other BPs to try\n            \n            sem_wait(&batch_ready_signal); // Wait for a producer to signal a batch is ready\n            \n            sem_wait(&batch_processor_gate); // Re-acquire gate after waking up\n            sem_wait(&mutex); // Re-acquire mutex after waking up\n            batch_processor_waiting_count--;\n        }\n\n        // At this point, mutex and gate are acquired, and buffer_item_count >= MIN_BATCH_SIZE\n        // Determine how many items to take for the batch\n        int num_to_take = (buffer_item_count < MAX_BATCH_SIZE) ? buffer_item_count : MAX_BATCH_SIZE;\n        // printf(\"BatchProcessor taking %d items. Buffer count before: %d\\n\", num_to_take, buffer_item_count); // Uncomment for verbose output\n        \n        int batch[MAX_BATCH_SIZE]; // Local array to hold the batch of items\n        for (int i = 0; i < num_to_take; i++) {\n            batch[i] = buffer[out]; // Take item from buffer\n            out = (out + 1) % BUFFER_SIZE; // Advance circular buffer pointer\n            buffer_item_count--; // Decrement item count\n        }\n        // printf(\"BatchProcessor finished taking. Buffer count after: %d\\n\", buffer_item_count); // Uncomment for verbose output\n\n        // Release mutex and gate\n        sem_post(&mutex);\n        sem_post(&batch_processor_gate);\n\n        // Process the batch (outside critical sections)\n        for (int i = 0; i < num_to_take; i++) {\n            process_item(batch[i]);\n        }\n        \n        // Signal empty slots created by taking items from the buffer\n        for (int i = 0; i < num_to_take; i++) {\n            sem_post(&empty_slots);\n        }\n        \n        usleep(rand() % 200000); // Simulate work outside critical section\n    }\n    return NULL;\n}\n\n/*\n// Main function for testing (not part of the solution, but useful for verification)\nint main() {\n    pthread_t producer_threads[2], consumer_threads[2];\n\n    // Initialize semaphores\n    sem_init(&mutex, 0, 1);\n    sem_init(&empty_slots, 0, BUFFER_SIZE);\n    sem_init(&batch_processor_gate, 0, 1);\n    sem_init(&batch_ready_signal, 0, 0);\n\n    // Create threads\n    for (int i = 0; i < 2; i++) {\n        pthread_create(&producer_threads[i], NULL, ItemProducer, NULL);\n        pthread_create(&consumer_threads[i], NULL, BatchProcessor, NULL);\n    }\n\n    // Run for a while\n    sleep(10);\n\n    // Clean up (optional for a quick test, but good practice)\n    for (int i = 0; i < 2; i++) {\n        pthread_cancel(producer_threads[i]);\n        pthread_join(producer_threads[i], NULL);\n        pthread_cancel(consumer_threads[i]);\n        pthread_join(consumer_threads[i], NULL);\n    }\n\n    sem_destroy(&mutex);\n    sem_destroy(&empty_slots);\n    sem_destroy(&batch_processor_gate);\n    sem_destroy(&batch_ready_signal);\n\n    return 0;\n}\n*/\n```"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "תיאור הפתרון:\nהפתרון משתמש במספר סמפורים ומשתני עזר כדי לנהל את המאגר המשותף ולאכוף את תנאי האצווה:\n\n1.  `mutex` (אתחול ל-1): סמפור זה משמש להגנה על הקטע הקריטי, כלומר, גישה למאגר המשותף ולמשתני המצב הגלובליים (`buffer_item_count`, `in`, `out`, `batch_processor_waiting_count`).\n2.  `empty_slots` (אתחול ל-`BUFFER_SIZE`): סמפור זה עוקב אחר מספר המקומות הריקים במאגר. יצרנים (Producers) ממתינים עליו לפני הוספת פריט.\n3.  `batch_processor_gate` (אתחול ל-1): סמפור זה משמש כ'שער כניסה' (turnstile) למעבדי אצוות (BatchProcessors). הוא מבטיח שרק מעבד אצוות אחד יוכל לבדוק את תנאי האצווה ולנסות לקחת פריטים בכל רגע נתון. זה מונע מ'עדר רועם' (thundering herd) להתעורר בבת אחת ולגרום לתחרות מיותרת על המשאבים.\n4.  `batch_ready_signal` (אתחול ל-0): סמפור זה משמש את יצרני הפריטים כדי לאותת למעבדי האצוות שממתינים, שכעת יש מספיק פריטים (לפחות `MIN_BATCH_SIZE`) כדי ליצור אצווה. מעבדי אצוות ממתינים על סמפור זה כאשר אין מספיק פריטים.\n5.  `buffer_item_count` (אתחול ל-0): משתנה זה, המוגן על ידי `mutex`, עוקב אחר המספר הנוכחי של פריטים במאגר.\n6.  `batch_processor_waiting_count` (אתחול ל-0): משתנה זה, המוגן על ידי `mutex`, עוקב אחר מספר מעבדי האצוות שממתינים כרגע על `batch_ready_signal`.\n\n**פעולת ה-`ItemProducer`:**\n-   `ItemProducer` ממתין (באמצעות `sem_wait(&empty_slots)`) למקום פנוי במאגר.\n-   לאחר מכן הוא נכנס לקטע קריטי (באמצעות `sem_wait(&mutex)`), מוסיף את הפריט למאגר ומעדכן את `buffer_item_count`.\n-   אם לאחר הוספת הפריט, מספר הפריטים במאגר (`buffer_item_count`) הגיע או עבר את `MIN_BATCH_SIZE` וגם ישנם מעבדי אצוות שממתינים (`batch_processor_waiting_count > 0`), היצרן מאותת לאחד ממעבדי האצוות הממתינים באמצעות `sem_post(&batch_ready_signal)`.\n-   בסיום, היצרן משחרר את ה-`mutex`.\n\n**פעולת ה-`BatchProcessor`:**\n-   `BatchProcessor` נכנס תחילה דרך 'שער הכניסה' (באמצעות `sem_wait(&batch_processor_gate)`). זה מבטיח שרק BP אחד יבצע את בדיקת התנאי המורכבת.\n-   לאחר מכן הוא נכנס לקטע קריטי (באמצעות `sem_wait(&mutex)`) כדי לבדוק את `buffer_item_count`.\n-   אם אין מספיק פריטים (`buffer_item_count < MIN_BATCH_SIZE`):\n    -   ה-`BatchProcessor` מגדיל את `batch_processor_waiting_count` (כדי שהיצרנים ידעו שיש מי שמחכה).\n    -   הוא משחרר את ה-`mutex` ואת ה-`batch_processor_gate` (כדי לאפשר ליצרנים להוסיף פריטים ולמעבדי אצוות אחרים לנסות להיכנס דרך השער).\n    -   הוא ממתין על `sem_wait(&batch_ready_signal)` עד שיצרן יאותת שיש מספיק פריטים.\n    -   לאחר ההתעוררות, הוא רוכש מחדש את ה-`batch_processor_gate` ואת ה-`mutex` ומקטין את `batch_processor_waiting_count`.\n-   כאשר יש מספיק פריטים (`buffer_item_count >= MIN_BATCH_SIZE`):\n    -   ה-`BatchProcessor` מחשב כמה פריטים לקחת (בין `MIN_BATCH_SIZE` ל-`MAX_BATCH_SIZE`, או כל מה שיש אם פחות מ-`MAX_BATCH_SIZE`).\n    -   הוא מוציא את הפריטים מהמאגר ומעדכן את `buffer_item_count`.\n    -   הוא משחרר את ה-`mutex` ואת ה-`batch_processor_gate`.\n    -   לאחר מכן הוא מעבד את הפריטים (מחוץ לקטע הקריטי).\n    -   לבסוף, הוא מאותת על מספר המקומות הריקים שנוצרו במאגר (באמצעות `sem_post(&empty_slots)` כמספר הפריטים שנלקחו)."
    },
    "difficulty_estimation": "Hard"
  }
}