{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Page Replacement",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:29:11",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4205,
      "output_tokens": 4271,
      "total_tokens": 22975
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Paging",
      "Page Replacement"
    ],
    "content": {
      "text": "נתונה מערכת זיכרון וירטואלי המשתמשת בדפים בגודל קבוע. למערכת יש 3 מסגרות (frames) זמינות בזיכרון הפיזי עבור תהליך בודד. רצף פניות לדפים (reference string) הוא: `1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`.\nיש לענות על הסעיפים הבאים תוך פירוט מלא של כל שלבי החישוב והנימוקים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "7.1",
        "text": "חשב את מספר כשלי הדף (page faults) עבור רצף הפניות הנתון, תוך שימוש באלגוריתמים הבאים:\nא. FIFO (First-In, First-Out)\nב. LRU (Least Recently Used)\nג. Optimal (OPT)\nיש להציג את מצב המסגרות בכל שלב.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.2",
        "text": "נתח את התוצאות מסעיף א'. הסבר מדוע LRU, למרות היותו אלגוריתם נפוץ ויעיל בדרך כלל, עשוי להציג ביצועים פחות טובים במקרים מסוימים (כמו ברצף הנתון) בהשוואה לאלגוריתמים אחרים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.3",
        "text": "בהמשך לסעיף ב', נניח שדף מספר 1 הוא דף קריטי במערכת, וחשוב למזער את הוצאתו מהזיכרון. למרות זאת, המערכת ממשיכה להשתמש באלגוריתם LRU. הצע שינוי פשוט לאלגוריתם LRU (ללא שינוי מהותי במבנה הנתונים או מורכבות האלגוריתם) שיעניק עדיפות לדף 1 ויקשה על הוצאתו. נתח כיצד שינוי זה ישפיע על מספר כשלי הדף עבור רצף הפניות הנתון, והאם הוא פותר את הבעיה של דף 1. הצג את מצב המסגרות בכל שלב עבור האלגוריתם המוצע.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון מלא:\n\n**סעיף 7.1: חישוב כשלי דף**\nרצף פניות: `1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`\nמספר מסגרות: 3\n\n**א. FIFO (First-In, First-Out)**\n1. גישה לדף `1`: מסגרות: `[1, _, _]`. כשל דף (PF: 1)\n2. גישה לדף `2`: מסגרות: `[1, 2, _]`. כשל דף (PF: 2)\n3. גישה לדף `3`: מסגרות: `[1, 2, 3]`. כשל דף (PF: 3)\n4. גישה לדף `4`: מסגרות: `[4, 2, 3]`. דף `1` יוצא. כשל דף (PF: 4)\n5. גישה לדף `1`: מסגרות: `[4, 1, 3]`. דף `2` יוצא. כשל דף (PF: 5)\n6. גישה לדף `2`: מסגרות: `[4, 1, 2]`. דף `3` יוצא. כשל דף (PF: 6)\n7. גישה לדף `5`: מסגרות: `[5, 1, 2]`. דף `4` יוצא. כשל דף (PF: 7)\n8. גישה לדף `1`: מסגרות: `[5, 1, 2]`. פגיעה (Hit)\n9. גישה לדף `2`: מסגרות: `[5, 1, 2]`. פגיעה (Hit)\n10. גישה לדף `3`: מסגרות: `[5, 3, 2]`. דף `1` יוצא. כשל דף (PF: 8)\n11. גישה לדף `4`: מסגרות: `[5, 3, 4]`. דף `2` יוצא. כשל דף (PF: 9)\n12. גישה לדף `5`: מסגרות: `[5, 3, 4]`. פגיעה (Hit)\n**סה\"כ כשלי דף (FIFO): 9**\n\n**ב. LRU (Least Recently Used)**\n1. גישה לדף `1`: מסגרות: `[1, _, _]`. כשל דף (PF: 1)\n2. גישה לדף `2`: מסגרות: `[1, 2, _]`. כשל דף (PF: 2)\n3. גישה לדף `3`: מסגרות: `[1, 2, 3]`. כשל דף (PF: 3)\n4. גישה לדף `4`: מסגרות: `[2, 3, 4]`. דף `1` (LRU) יוצא. כשל דף (PF: 4)\n5. גישה לדף `1`: מסגרות: `[3, 4, 1]`. דף `2` (LRU) יוצא. כשל דף (PF: 5)\n6. גישה לדף `2`: מסגרות: `[4, 1, 2]`. דף `3` (LRU) יוצא. כשל דף (PF: 6)\n7. גישה לדף `5`: מסגרות: `[1, 2, 5]`. דף `4` (LRU) יוצא. כשל דף (PF: 7)\n8. גישה לדף `1`: מסגרות: `[2, 5, 1]`. פגיעה (Hit). דף `1` הופך ל-MRU.\n9. גישה לדף `2`: מסגרות: `[5, 1, 2]`. פגיעה (Hit). דף `2` הופך ל-MRU.\n10. גישה לדף `3`: מסגרות: `[1, 2, 3]`. דף `5` (LRU) יוצא. כשל דף (PF: 8)\n11. גישה לדף `4`: מסגרות: `[2, 3, 4]`. דף `1` (LRU) יוצא. כשל דף (PF: 9)\n12. גישה לדף `5`: מסגרות: `[3, 4, 5]`. דף `2` (LRU) יוצא. כשל דף (PF: 10)\n**סה\"כ כשלי דף (LRU): 10**\n\n**ג. Optimal (OPT)**\n(הדף שיצא הוא זה שישמש הכי רחוק בעתיד)\n1. גישה לדף `1`: מסגרות: `[1, _, _]`. כשל דף (PF: 1)\n2. גישה לדף `2`: מסגרות: `[1, 2, _]`. כשל דף (PF: 2)\n3. גישה לדף `3`: מסגרות: `[1, 2, 3]`. כשל דף (PF: 3)\n4. גישה לדף `4`: מסגרות: `[1, 2, 4]`. דף `3` (ישמש בגישה 10) יוצא. כשל דף (PF: 4)\n5. גישה לדף `1`: מסגרות: `[1, 2, 4]`. פגיעה (Hit)\n6. גישה לדף `2`: מסגרות: `[1, 2, 4]`. פגיעה (Hit)\n7. גישה לדף `5`: מסגרות: `[1, 2, 5]`. דף `4` (לא ישמש יותר) יוצא. כשל דף (PF: 5)\n8. גישה לדף `1`: מסגרות: `[1, 2, 5]`. פגיעה (Hit)\n9. גישה לדף `2`: מסגרות: `[1, 2, 5]`. פגיעה (Hit)\n10. גישה לדף `3`: מסגרות: `[3, 2, 5]`. דף `1` (ישמש בגישה 12) יוצא. כשל דף (PF: 6)\n11. גישה לדף `4`: מסגרות: `[4, 2, 5]`. דף `3` (לא ישמש יותר) יוצא. כשל דף (PF: 7)\n12. גישה לדף `5`: מסגרות: `[4, 2, 5]`. פגיעה (Hit)\n**סה\"כ כשלי דף (Optimal): 7**\n\n**סעיף 7.2: ניתוח ביצועי LRU**\nLRU בדרך כלל נחשב לאלגוריתם יעיל מאוד מכיוון שהוא מבוסס על עקרון הלוקליות בזמן (temporal locality) – דפים ששימשו לאחרונה צפויים להידרש שוב בקרוב. עם זאת, במקרה הנתון, LRU הציג 10 כשלי דף, יותר מ-FIFO (9) ו-Optimal (7). הסיבה לכך היא שרצף הפניות הנוכחי מדגים דפוס גישה מחזורי/לולאתי שבו מספר הדפים הפעילים (1, 2, 3, 4, 5) גדול ממספר המסגרות הזמינות (3). במצב כזה, LRU נכנס ללולאה שבה הוא מוציא דף (כי הוא היה ה-LRU) רק כדי לגלות שהוא נדרש שוב זמן קצר לאחר מכן, מה שגורם לכשל דף נוסף. לדוגמה:\n*   לאחר `1,2,3` המסגרות מלאות.\n*   כשמגיע `4`, דף 1 מוצא (היה ה-LRU).\n*   כשמגיע `1` שוב, דף 2 מוצא (היה ה-LRU).\n*   כשמגיע `2` שוב, דף 3 מוצא (היה ה-LRU).\nוכך הלאה. בכל פעם, דף שנדרש נטען, ודוחף החוצה דף אחר שנדרש זמן קצר קודם לכן, אך עדיין יהיה רלוונטי בהמשך הרצף. זהו מצב בו LRU לא מצליח לזהות את הדפוס המחזורי ואינו מצליח לשמור את כל הדפים הנדרשים בלולאה בזיכרון. במקרים כאלה, אלגוריתמים פשוטים יותר כמו FIFO יכולים להציג ביצועים טובים יותר, מכיוון שהם לא מנסים \"לזכור\" את העבר באופן מורכב ובכך נמנעים מלהוציא דפים שנדרשים שוב באופן מחזורי. מצב זה אינו \"אנומליה של בלאדי\" (Belady's Anomaly) שכן LRU אינו סובל מאנומליה זו, אך הוא כן יכול להציג ביצועים פחות טובים מ-FIFO עבור רצפי פניות ספציפיים כאשר מספר המסגרות קטן מדי ביחס למספר הדפים בלולאת הגישה. \n\n**סעיף 7.3: שינוי LRU לדף קריטי**\n**הצעה לשינוי:**\nכדי לתת עדיפות לדף 1 באלגוריתם LRU, ניתן להוסיף לו \"ביט הגנה\" (protection bit) או \"ביט נעילה\" (pinning bit). כאשר דף 1 נטען לזיכרון, ביט זה מוגדר, וכל עוד הוא מוגדר, דף 1 לא יכול להיבחר להחלפה על ידי LRU. כאשר אלגוריתם LRU נדרש להחליף דף, הוא יבחר את הדף שהיה בשימוש הכי פחות לאחרונה מבין כל הדפים שאינם מוגנים (כלומר, שביט ההגנה שלהם אינו מוגדר). במקרה שכל הדפים מוגנים (לא רלוונטי כאן עם 3 מסגרות ורק דף 1 מוגן), או שאין דפים לא מוגנים, המערכת תצטרך לטפל במצב חריג (למשל, להחליף את דף 1 למרות ההגנה, או להמתין). אנו נניח שדף 1 הוא הדף המוגן היחיד.\n\n**חישוב כשלי דף עם LRU משופר (דף 1 מוגן - 1P):**\n1. גישה לדף `1`: מסגרות: `[1P, _, _]`. דף 1 נטען ומוגן. כשל דף (PF: 1)\n2. גישה לדף `2`: מסגרות: `[1P, 2, _]`. כשל דף (PF: 2)\n3. גישה לדף `3`: מסגרות: `[1P, 2, 3]`. כשל דף (PF: 3)\n4. גישה לדף `4`: מסגרות: `[1P, 4, 3]`. דף `2` הוא LRU מבין הדפים הלא-מוגנים (`2`, `3`). כשל דף (PF: 4)\n5. גישה לדף `1`: מסגרות: `[1P, 4, 3]`. פגיעה (Hit).\n6. גישה לדף `2`: מסגרות: `[1P, 4, 2]`. דף `3` הוא LRU מבין הדפים הלא-מוגנים (`4`, `3`). כשל דף (PF: 5)\n7. גישה לדף `5`: מסגרות: `[1P, 5, 2]`. דף `4` הוא LRU מבין הדפים הלא-מוגנים (`5`, `2`). כשל דף (PF: 6)\n8. גישה לדף `1`: מסגרות: `[1P, 5, 2]`. פגיעה (Hit).\n9. גישה לדף `2`: מסגרות: `[1P, 5, 2]`. פגיעה (Hit). דף `2` הופך ל-MRU.\n10. גישה לדף `3`: מסגרות: `[1P, 3, 2]`. דף `5` הוא LRU מבין הדפים הלא-מוגנים (`5`, `2`). כשל דף (PF: 7)\n11. גישה לדף `4`: מסגרות: `[1P, 3, 4]`. דף `2` הוא LRU מבין הדפים הלא-מוגנים (`3`, `2`). כשל דף (PF: 8)\n12. גישה לדף `5`: מסגרות: `[1P, 5, 4]`. דף `3` הוא LRU מבין הדפים הלא-מוגנים (`3`, `4`). כשל דף (PF: 9)\n**סה\"כ כשלי דף (LRU משופר): 9**\n\n**ניתוח ההשפעה:**\n*   **מספר כשלי הדף:** מספר כשלי הדף ירד מ-10 (LRU רגיל) ל-9 (LRU משופר). זהו שיפור קל, והוא זהה לביצועי FIFO במקרה זה. \n*   **פתרון בעיית דף 1:** השינוי פותר באופן מובהק את בעיית דף 1. לאחר שדף 1 נטען לראשונה (בגישה מספר 1), הוא נשאר בזיכרון לכל אורך הרצף ואינו יוצא לעולם, מכיוון שהוא מוגן. זה מבטיח שגישות עתידיות לדף 1 יהיו תמיד פגיעות (hits). \n*   **השפעה על דפים אחרים:** ה\"הגנה\" על דף 1 באה על חשבון דפים אחרים. בפועל, היא מקטינה את מספר המסגרות הזמינות להחלפה עבור שאר הדפים מ-3 ל-2. משמעות הדבר היא ששאר הדפים מתחרים על פחות משאבים, מה שעלול להגדיל את כשלי הדף עבורם. במקרה זה, היתרון של שמירת דף 1 בזיכרון עלה על החיסרון של צמצום המסגרות לשאר הדפים, והביא לשיפור קל בביצועים הכוללים. עם זאת, עדיין לא הגענו לביצועים של Optimal (7 כשלי דף)."
    },
    "difficulty_estimation": "Hard"
  }
}