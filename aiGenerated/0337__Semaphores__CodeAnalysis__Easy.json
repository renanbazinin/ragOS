{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:56:23",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3853,
      "output_tokens": 769,
      "total_tokens": 6552
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Semaphores",
      "Concurrency",
      "Threads"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בסמפור (semaphore) לסנכרון גישה למשתנה גלובלי משותף. קראו את הקוד וענו על השאלה.\n\nמה יהיה הערך הסופי של המשתנה הגלובלי `global_counter` לאחר שכל ה-`NUM_THREADS` יסיימו את ריצתן?",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#define NUM_THREADS 5\n#define ITERATIONS_PER_THREAD 10\n\nint global_counter = 0;\nsem_t mutex;\n\nvoid *thread_function(void *arg) {\n    for (int i = 0; i < ITERATIONS_PER_THREAD; ++i) {\n        sem_wait(&mutex);\n        global_counter++;\n        sem_post(&mutex);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    // Initialize semaphore to 1 for mutual exclusion\n    sem_init(&mutex, 0, 1);\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, thread_function, NULL);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", global_counter);\n\n    sem_destroy(&mutex);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "הסבר: הסמפור `mutex` מאותחל לערך 1 (באמצעות `sem_init(&mutex, 0, 1)`), מה שהופך אותו למעשה למנעול בינארי (mutex). כל תהליך מבצע `sem_wait` לפני הכניסה לקטע הקריטי (הגדלת `global_counter`) ו-`sem_post` לאחר היציאה ממנו. זה מבטיח שרק תהליך אחד יכול לגשת ל-`global_counter` בכל רגע נתון, ובכך מונע תנאי מירוץ (race condition).\n\nמכיוון שכל אחד מ-`NUM_THREADS` (שהוגדר כ-5) התהליכים מבצע את ההגדלה `ITERATIONS_PER_THREAD` (שהוגדר כ-10) פעמים, והגישה מוגנת באופן הנכון, הערך הסופי של `global_counter` יהיה סך כל ההגדלות, כלומר `NUM_THREADS * ITERATIONS_PER_THREAD = 5 * 10 = 50`."
    },
    "difficulty_estimation": "Easy"
  }
}