{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:57:54",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3853,
      "output_tokens": 900,
      "total_tokens": 6643
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Semaphores",
      "Concurrency",
      "Threads"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בסמפור ובמספר תהליכים (threads). עיין בקוד וקבע מהו הערך הסופי של המשתנה המשותף `shared_counter` לאחר שכל התהליכים יסיימו את ריצתם. הסבר את תשובתך.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#define NUM_THREADS 5\n\nsem_t my_semaphore;\nint shared_counter = 0;\n\nvoid* thread_func(void* arg) {\n    sem_wait(&my_semaphore); // Wait for semaphore\n    \n    // Critical section\n    shared_counter++;\n    printf(\"Thread %ld: shared_counter is now %d\\n\", (long)arg, shared_counter);\n    \n    sem_post(&my_semaphore); // Release semaphore\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    int i;\n\n    // Initialize semaphore to 1 (binary semaphore/mutex)\n    sem_init(&my_semaphore, 0, 1); \n\n    for (i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, thread_func, (void*)(long)i);\n    }\n\n    for (i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final value of shared_counter: %d\\n\", shared_counter);\n\n    sem_destroy(&my_semaphore);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הערך הסופי של המשתנה `shared_counter` יהיה 5.\n\nהסבר:\nהסמפור `my_semaphore` מאותחל לערך 1 באמצעות `sem_init(&my_semaphore, 0, 1)`. אתחול זה הופך אותו לסמפור בינארי, הפועל למעשה כמו mutex (מנעול).\n\nבפונקציה `thread_func`, כל תהליך מבצע `sem_wait(&my_semaphore)` לפני שהוא נכנס לקטע הקריטי, ומבצע `sem_post(&my_semaphore)` כשהוא יוצא מהקטע הקריטי.\n\nמכיוון שהסמפור מאותחל ל-1, רק תהליך אחד יכול להיכנס לקטע הקריטי (שבו מתבצעת הפעולה `shared_counter++`) בכל רגע נתון. אם תהליך אחר ינסה להיכנס כשהסמפור תפוס, הוא ייחסם בקריאה ל-`sem_wait` עד שהתהליך הנוכחי ישחרר את הסמפור.\n\nפעולה זו מבטיחה שההגדלה של `shared_counter` היא אטומית ומוגנת מתנאי מירוץ. מכיוון שישנם `NUM_THREADS` (שהוגדר כ-5) תהליכים, וכל אחד מהם מגדיל את `shared_counter` בדיוק פעם אחת באופן מסונכרן, הערך הסופי של `shared_counter` יהיה 5."
    },
    "difficulty_estimation": "Easy"
  }
}