{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 19:39:51",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2411,
      "output_tokens": 2638,
      "total_tokens": 10319
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "IPC",
      "Processes",
      "Pipes",
      "Synchronization"
    ],
    "content": {
      "text": "תהליך אב ותהליך בן מתקשרים באמצעות צינורות (unnamed pipes). תהליך האב שולח סדרה של מספרים שלמים לתהליך הבן. תהליך הבן קורא את המספרים, מחשב את סכומם, ושולח את הסכום הסופי בחזרה לתהליך האב. להלן קוד C המנסה לממש תקשורת זו:",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define NUM_VALUES 5\n\nint main() {\n    int pipe_parent_to_child[2]; // Parent writes, child reads\n    int pipe_child_to_parent[2]; // Child writes, parent reads\n    pid_t pid;\n\n    if (pipe(pipe_parent_to_child) == -1 || pipe(pipe_child_to_parent) == -1) {\n        perror(\"pipe failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        close(pipe_parent_to_child[1]); // Close unused write end of P->C pipe\n        close(pipe_child_to_parent[0]); // Close unused read end of C->P pipe\n\n        int value;\n        int sum = 0;\n        printf(\"Child: Reading values from parent...\\n\");\n        while (read(pipe_parent_to_child[0], &value, sizeof(int)) > 0) {\n            sum += value;\n            printf(\"Child: Read %d, current sum = %d\\n\", value, sum);\n        }\n        close(pipe_parent_to_child[0]); // Close read end of P->C pipe\n\n        printf(\"Child: Sending sum (%d) to parent.\\n\", sum);\n        write(pipe_child_to_parent[1], &sum, sizeof(int));\n        close(pipe_child_to_parent[1]); // Close write end of C->P pipe\n\n        exit(EXIT_SUCCESS);\n    } else { // Parent process\n        close(pipe_parent_to_child[0]); // Close unused read end of P->C pipe\n        close(pipe_child_to_parent[1]); // Close unused write end of C->P pipe\n\n        printf(\"Parent: Sending values to child...\\n\");\n        for (int i = 1; i <= NUM_VALUES; i++) {\n            write(pipe_parent_to_child[1], &i, sizeof(int));\n            printf(\"Parent: Sent %d\\n\", i);\n        }\n        // BUG: Missing close(pipe_parent_to_child[1]); here\n\n        int final_sum;\n        printf(\"Parent: Waiting for child to send sum...\\n\");\n        read(pipe_child_to_parent[0], &final_sum, sizeof(int));\n        close(pipe_child_to_parent[0]); // Close read end of C->P pipe\n\n        printf(\"Parent: Received sum from child: %d\\n\", final_sum);\n\n        wait(NULL); // Wait for child to terminate\n        printf(\"Parent: Child terminated.\\n\");\n    }\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "האם הקוד הנתון יפעל כצפוי? אם לא, הסבר מדוע ומהי הבעיה המרכזית שתתרחש?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "כיצד היית מתקן את הקוד כדי שיפעל נכון?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "האם יש דרך אחרת להעביר את סוף הנתונים (end-of-file) מהאב לבן, מבלי לסגור את קצה הכתיבה של הצינור? פרט.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.4",
        "text": "השווה את מנגנון ה-pipes המשמש בקוד למנגנון זיכרון משותף (shared memory) בתוספת סמפורים (semaphores) לצורך מימוש אותה משימה. ציין יתרונות וחסרונות של כל גישה בהקשר זה.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "10.1:\nהקוד הנתון לא יפעל כצפוי. הבעיה המרכזית היא שתהליך הבן ייתקע (יתבצע deadlock) בלולאת ה-`read` שלו. הסיבה לכך היא שתהליך האב מסיים לשלוח את כל המספרים אך אינו סוגר את קצה הכתיבה של הצינור `pipe_parent_to_child[1]`. כל עוד קצה הכתיבה פתוח, ה-`read` של הבן לא יקבל הודעת EOF (סוף קובץ) גם אם אין נתונים נוספים בצינור, ולכן הוא ימתין לנתונים נוספים שלעולם לא יגיעו. במקביל, האב ממתין שהבן ישלח לו את הסכום, אך הבן תקוע ולא ישלח דבר.\n\n10.2:\nכדי לתקן את הקוד, יש להוסיף את השורה הבאה בתהליך האב, מיד לאחר לולאת הכתיבה ולפני קריאת הסכום מהבן:\n`close(pipe_parent_to_child[1]); // Close write end of P->C pipe to signal EOF`\nפעולה זו תגרום לכך שתהליך הבן יקבל EOF כאשר הוא ינסה לקרוא שוב מהצינור לאחר שהאב סיים לכתוב וסגר את הקצה שלו, ויאפשר לו להמשיך בביצוע.\n\n10.3:\nכן, יש דרך אחרת להעביר את סוף הנתונים מבלי לסגור את קצה הכתיבה של הצינור: שימוש בערך ספציפי (sentinel value) כסימן לסיום הנתונים. לדוגמה, אם ידוע שהמספרים החוקיים הם אי-שליליים, האב יכול לשלוח את הערך `-1` לאחר ששלח את כל המספרים. הבן יבדוק כל מספר שנקרא, ואם הוא מקבל `-1`, הוא יבין שהגיע לסוף הנתונים ויפסיק לקרוא. היתרון בגישה זו הוא שניתן להשאיר את הצינור פתוח לתקשורת עתידית אם יש צורך בכך, אך החיסרון הוא שזה דורש הסכמה על ערך שאינו יכול להופיע כנתון לגיטימי.\n\n10.4:\n**השוואה בין Pipes ל-Shared Memory עם Semaphores:**\n\n**Pipes (צינורות):**\n*   **יתרונות:**\n    *   **פשטות:** יחסית קלים לשימוש ליישומים פשוטים של יצרן-צרכן, במיוחד בין תהליכי אב-בן.\n    *   **תקשורת זרמית:** מתאימים להעברת זרם נתונים (byte stream).\n    *   **סנכרון מובנה:** קריאה וכתיבה חוסמות (blocking) באופן טבעי, מה שמספק סנכרון בסיסי (הקורא ממתין לנתונים, הכותב ממתין למקום בחוצץ).\n    *   **טיפול בחוצץ:** מערכת ההפעלה מנהלת את החוצץ הפנימי של הצינור.\n*   **חסרונות:**\n    *   **חד כיווני:** צינור בודד הוא חד כיווני; לתקשורת דו-כיוונית נדרשים שני צינורות.\n    *   **העתקת נתונים:** הנתונים מועתקים ממרחב הכתובות של הכותב לחוצץ הליבה, ומשם למרחב הכתובות של הקורא, מה שמוסיף תקורה.\n    *   **תהליכים קשורים:** בדרך כלל משמשים לתקשורת בין תהליכים קשורים (אב-בן או אחים).\n    *   **גודל מוגבל:** לצינור יש גודל חוצץ מוגבל.\n\n**Shared Memory (זיכרון משותף) עם Semaphores (סמפורים):**\n*   **יתרונות:**\n    *   **ביצועים גבוהים:** לאחר ההגדרה הראשונית, אין העתקת נתונים דרך הליבה. תהליכים ניגשים ישירות לאותו בלוק זיכרון, מה שהופך אותו למנגנון ה-IPC המהיר ביותר.\n    *   **גמישות:** מאפשר העברת מבני נתונים מורכבים וגישה אקראית לנתונים, בניגוד לזרם ב-pipes.\n    *   **תקשורת בין תהליכים לא קשורים:** יכול לשמש לתקשורת בין תהליכים שאינם קשורים (באמצעות מפתח).\n    *   **דו כיווני:** טבעו של זיכרון משותף מאפשר בקלות תקשורת דו-כיוונית.\n*   **חסרונות:**\n    *   **מורכבות:** דורש ניהול ידני של סנכרון (באמצעות סמפורים או מנגנוני נעילה אחרים) כדי למנוע תנאי מרוץ (race conditions) ולוודא עקביות נתונים.\n    *   **טיפול בחוצץ:** המתכנת אחראי לניהול החuצץ בזיכרון המשותף (לדוגמה, יישום חוצץ מעגלי).\n    *   **שגיאות קשות לאיתור:** בעיות סנכרון יכולות להיות קשות מאוד לאיתור ולתיקון."
    },
    "difficulty_estimation": "Medium"
  }
}