{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:27:05",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4527,
      "output_tokens": 4725,
      "total_tokens": 20488
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Threads",
      "Mutexes",
      "Condition Variables",
      "Race Conditions",
      "Deadlock",
      "Producer-Consumer"
    ],
    "content": {
      "text": "נתון קוד בשפת C המממש מערכת יצרן-צרכן (Producer-Consumer) פשוטה. תהליך ה-Producer מייצר משימות (Jobs) ומוסיף אותן לתור משותף. מספר תהליכי Worker צורכים משימות מהתור, מעבדים אותן, ומעדכנים מונה גלובלי `global_completed_jobs` המייצג את סך המשימות שהושלמו. קרא בעיון את הקוד המצורף וענה על השאלות הבאות:\n\n1. זהה והסבר את כל תנאי המירוץ (Race Conditions) הקיימים בקוד.\n2. האם קיים פוטנציאל לקיפאון (Deadlock) או רעב (Starvation)? אם כן, תאר את התרחיש.\n3. הצע פתרונות מתאימים לכל הבעיות שזיהית, כולל תיקון כל תנאי מירוץ, מניעת קיפאון/רעב, וכן מנגנון סיום עבודה בטוח וגרייספוּלי (Graceful Termination) עבור תהליכי ה-Worker והתהליך הראשי, תוך שמירה על יעילות. הצג את השינויים הנדרשים בקוד.",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For usleep\n\n#define MAX_QUEUE_SIZE 5\n#define NUM_WORKERS 3\n#define TOTAL_JOBS_TO_PROCESS 10\n\ntypedef struct {\n    int id;\n} Job;\n\nJob job_queue[MAX_QUEUE_SIZE];\nint head = 0;\nint tail = 0;\nint count = 0;\n\npthread_mutex_t queue_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;\npthread_cond_t not_full = PTHREAD_COND_INITIALIZER;\n\nint global_completed_jobs = 0; // Shared counter, unprotected\n\nvoid enqueue_job(Job job) {\n    pthread_mutex_lock(&queue_mutex);\n    while (count == MAX_QUEUE_SIZE) {\n        pthread_cond_wait(&not_full, &queue_mutex);\n    }\n    job_queue[tail] = job;\n    tail = (tail + 1) % MAX_QUEUE_SIZE;\n    count++;\n    printf(\"Producer: Enqueued Job %d, queue count: %d\\n\", job.id, count);\n    pthread_cond_signal(&not_empty);\n    pthread_mutex_unlock(&queue_mutex);\n}\n\nJob dequeue_job() {\n    pthread_mutex_lock(&queue_mutex);\n    while (count == 0) {\n        pthread_cond_wait(&not_empty, &queue_mutex);\n    }\n    Job job = job_queue[head];\n    head = (head + 1) % MAX_QUEUE_SIZE;\n    count--;\n    printf(\"Consumer: Dequeued Job %d, queue count: %d\\n\", job.id, count);\n    pthread_cond_signal(&not_full);\n    pthread_mutex_unlock(&queue_mutex);\n    return job;\n}\n\nvoid* producer(void* arg) {\n    for (int i = 0; i < TOTAL_JOBS_TO_PROCESS; ++i) {\n        Job new_job = { .id = i };\n        enqueue_job(new_job);\n        usleep(rand() % 100000); // Simulate work\n    }\n    return NULL;\n}\n\nvoid* worker(void* arg) {\n    while (1) { \n        Job job = dequeue_job();\n        \n        // Simulate job processing\n        usleep(rand() % 200000); \n\n        global_completed_jobs++; // RACE CONDITION HERE!\n        \n        printf(\"Worker %ld: Processed Job %d. Current completed: %d\\n\", (long)arg, job.id, global_completed_jobs);\n\n        // Termination condition is also problematic due to race condition and blocking dequeue\n        if (global_completed_jobs >= TOTAL_JOBS_TO_PROCESS) {\n            break;\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t producer_thread;\n    pthread_t worker_threads[NUM_WORKERS];\n\n    srand(time(NULL));\n\n    pthread_create(&producer_thread, NULL, producer, NULL);\n\n    for (long i = 0; i < NUM_WORKERS; ++i) {\n        pthread_create(&worker_threads[i], NULL, worker, (void*)i);\n    }\n\n    pthread_join(producer_thread, NULL);\n    printf(\"Main: Producer finished producing all jobs.\\n\");\n\n    // Main thread needs to wait for all workers to finish processing.\n    // This part is currently not handled gracefully, workers might be stuck.\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        pthread_join(worker_threads[i], NULL);\n    }\n\n    printf(\"Main: All workers finished. Final global_completed_jobs: %d\\n\", global_completed_jobs);\n\n    pthread_mutex_destroy(&queue_mutex);\n    pthread_cond_destroy(&not_empty);\n    pthread_cond_destroy(&not_full);\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסבר ופתרון:\n\n**1. זיהוי והסבר תנאי מירוץ (Race Conditions):**\n   *   **`global_completed_jobs`**: המשתנה `global_completed_jobs` הוא מונה גלובלי המשותף לכל תהליכי ה-Worker. הפעולה `global_completed_jobs++` אינה אטומית; היא מורכבת מקריאת הערך, הגדלתו, וכתיבת הערך החדש. אם שני תהליכי Worker או יותר מנסים לבצע פעולה זו בו-זמנית, ייתכן מצב שבו הם קוראים את אותו ערך ישן, מבצעים הגדלה, ושניהם כותבים בחזרה את אותו ערך (או ערך שגוי) – מה שיוביל לכך שהמונה לא ישקף נכונה את מספר המשימות שהושלמו. לדוגמה, אם `global_completed_jobs` הוא 5, שני תהליכים קוראים 5, שניהם מגדילים ל-6, ושניהם כותבים 6 בחזרה, במקום שיהיה 7.\n   *   **תנאי סיום של ה-Worker**: תנאי הסיום `if (global_completed_jobs >= TOTAL_JOBS_TO_PROCESS)` בתוך פונקציית ה-`worker` סובל אף הוא מתנאי מירוץ. בשל חוסר ההגנה על `global_completed_jobs`, ייתכן שתהליך אחד יקרא ערך מסוים, בעוד שתהליך אחר יעלה אותו, ורק לאחר מכן התהליך הראשון ישווה אותו. בנוסף, אם תהליך אחד מסיים ופורש (`break`), אחרים עדיין יכולים להישאר פעילים או לחכות לתור ריק, מה שיוביל ללוגיקת סיום לא עקבית ולא בטוחה.\n\n**2. פוטנציאל לקיפאון (Deadlock) או רעב (Starvation):**\n   *   **קיפאון**: בקוד הנתון, אין קיפאון מובהק (Classic Deadlock) מכיוון שמשתמשים רק ב-`queue_mutex` אחד, ואין חסימה הדדית על משאבים שונים. עם זאת, אם היינו מנסים לתקן את תנאי המירוץ על `global_completed_jobs` על ידי הוספת `mutex` נפרד (לדוגמה `counter_mutex`) ונועלים אותו בסדר שונה מ-`queue_mutex` (לדוגמה, תהליך Worker היה נועל את `queue_mutex` ואז מנסה לנעול את `counter_mutex`, בעוד שהתהליך הראשי היה מנסה לנעול את `counter_mutex` ואז את `queue_mutex` כדי לבדוק סיום), יכול היה להיווצר קיפאון. בקוד הנוכחי, בעיית הקיפאון אינה קיימת.\n   *   **רעב (Starvation)**: בקוד הנתון, אין רעב מובהק. המשתנים התנאים (`not_empty`, `not_full`) בשילוב עם `pthread_cond_wait` ו-`pthread_cond_signal` (בתוך לולאות `while`) מבטיחים שתהליכים יקבלו את ההזדמנות להתקדם ברגע שהתנאים שלהם מתקיימים. עם זאת, במערכות גדולות יותר, אם יש הרבה מאוד תהליכים שמתחרים על אותו משאב, ייתכן שתהליך מסוים יקבל פחות זמן מעבד או יתעכב באופן עקבי, אך זה לא תרחיש ספציפי לקוד זה.\n\n**3. פתרונות ושינויים בקוד (כולל סיום עבודה גרייספוּלי):**\n\nכדי לתקן את הבעיות וליישם סיום עבודה גרייספוּלי, נבצע את השינויים הבאים:\n\nא. **הגנה על `global_completed_jobs`**: נוסיף `mutex` ייעודי למשתנה זה וכן `condition variable` כדי שהתהליך הראשי יוכל להמתין לסיום כל המשימות.\nב. **מנגנון סיום עבודה גרייספוּלי**: נשתמש ב\"גלולת רעל\" (Poison Pill) – משימה מיוחדת שאינה מעובדת אלא מסמנת ל-Worker שאין עוד משימות לבצע ועליו לסיים. כל Worker שנתקל בגלולת רעל יעביר אותה הלאה (אם יש עוד Workers) ויסיים את פעולתו. בנוסף, נבטיח שהתהליך הראשי ממתין עד שכל המשימות הושלמו וכל ה-Workers סיימו.\n\n**קוד מתוקן:**\n\n```c\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For usleep\n\n#define MAX_QUEUE_SIZE 5\n#define NUM_WORKERS 3\n#define TOTAL_JOBS_TO_PROCESS 10\n\ntypedef struct {\n    int id;\n    int is_poison_pill; // Flag for graceful termination\n} Job;\n\nJob job_queue[MAX_QUEUE_SIZE];\nint head = 0;\nint tail = 0;\nint count = 0;\n\npthread_mutex_t queue_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;\npthread_cond_t not_full = PTHREAD_COND_INITIALIZER;\n\npthread_mutex_t completed_jobs_mutex = PTHREAD_MUTEX_INITIALIZER; // New mutex for global_completed_jobs\npthread_cond_t all_jobs_done = PTHREAD_COND_INITIALIZER; // New condition variable\nint global_completed_jobs = 0;\n\nvoid enqueue_job(Job job) {\n    pthread_mutex_lock(&queue_mutex);\n    while (count == MAX_QUEUE_SIZE) {\n        pthread_cond_wait(&not_full, &queue_mutex);\n    }\n    job_queue[tail] = job;\n    tail = (tail + 1) % MAX_QUEUE_SIZE;\n    count++;\n    printf(\"Producer: Enqueued Job %d (Poison: %d), queue count: %d\\n\", job.id, job.is_poison_pill, count);\n    pthread_cond_signal(&not_empty);\n    pthread_mutex_unlock(&queue_mutex);\n}\n\nJob dequeue_job() {\n    pthread_mutex_lock(&queue_mutex);\n    while (count == 0) {\n        pthread_cond_wait(&not_empty, &queue_mutex);\n    }\n    Job job = job_queue[head];\n    head = (head + 1) % MAX_QUEUE_SIZE;\n    count--;\n    printf(\"Consumer: Dequeued Job %d (Poison: %d), queue count: %d\\n\", job.id, job.is_poison_pill, count);\n    pthread_cond_signal(&not_full);\n    pthread_mutex_unlock(&queue_mutex);\n    return job;\n}\n\nvoid* producer(void* arg) {\n    for (int i = 0; i < TOTAL_JOBS_TO_PROCESS; ++i) {\n        Job new_job = { .id = i, .is_poison_pill = 0 };\n        enqueue_job(new_job);\n        usleep(rand() % 100000); // Simulate work\n    }\n    // Enqueue poison pills for each worker to signal termination\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        Job poison_pill = { .id = -1, .is_poison_pill = 1 };\n        enqueue_job(poison_pill);\n    }\n    return NULL;\n}\n\nvoid* worker(void* arg) {\n    while (1) { \n        Job job = dequeue_job();\n        \n        if (job.is_poison_pill) {\n            // Propagate the poison pill for other workers\n            enqueue_job(job); \n            break; // This worker exits\n        }\n\n        // Simulate job processing\n        usleep(rand() % 200000); \n\n        // Protect global_completed_jobs\n        pthread_mutex_lock(&completed_jobs_mutex);\n        global_completed_jobs++;\n        if (global_completed_jobs == TOTAL_JOBS_TO_PROCESS) {\n            pthread_cond_signal(&all_jobs_done); // Signal main thread if all jobs are done\n        }\n        pthread_mutex_unlock(&completed_jobs_mutex);\n        \n        printf(\"Worker %ld: Processed Job %d. Current completed: %d\\n\", (long)arg, job.id, global_completed_jobs);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t producer_thread;\n    pthread_t worker_threads[NUM_WORKERS];\n\n    srand(time(NULL));\n\n    pthread_create(&producer_thread, NULL, producer, NULL);\n\n    for (long i = 0; i < NUM_WORKERS; ++i) {\n        pthread_create(&worker_threads[i], NULL, worker, (void*)i);\n    }\n\n    pthread_join(producer_thread, NULL);\n    printf(\"Main: Producer finished producing all jobs and sent poison pills.\\n\");\n\n    // Main thread waits for all jobs to be completed\n    pthread_mutex_lock(&completed_jobs_mutex);\n    while (global_completed_jobs < TOTAL_JOBS_TO_PROCESS) {\n        pthread_cond_wait(&all_jobs_done, &completed_jobs_mutex);\n    }\n    pthread_mutex_unlock(&completed_jobs_mutex);\n    printf(\"Main: All %d jobs have been processed.\\n\", global_completed_jobs);\n\n    // Now join worker threads. They should all have terminated due to poison pills.\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        pthread_join(worker_threads[i], NULL);\n    }\n\n    printf(\"Main: All workers finished. Final global_completed_jobs: %d\\n\", global_completed_jobs);\n\n    pthread_mutex_destroy(&queue_mutex);\n    pthread_cond_destroy(&not_empty);\n    pthread_cond_destroy(&not_full);\n    pthread_mutex_destroy(&completed_jobs_mutex);\n    pthread_cond_destroy(&all_jobs_done);\n\n    return 0;\n}\n```\n\n**הסבר לשינויים:**\n\n*   **`Job` struct**: הוספנו שדה `is_poison_pill` כדי לסמן משימות מיוחדות המשמשות לאיתות סיום.\n*   **`completed_jobs_mutex` ו-`all_jobs_done`**: הוספנו `mutex` נפרד (`completed_jobs_mutex`) כדי להגן על `global_completed_jobs` ו-`condition variable` (`all_jobs_done`) כדי שהתהליך הראשי יוכל להמתין באופן יעיל לסיום כל המשימות מבלי לבצע ספין-לופ או לחסום משאבים אחרים. זה מונע את תנאי המירוץ על `global_completed_jobs`.\n*   **`producer` function**: לאחר יצירת כל המשימות הרגילות, ה-Producer מוסיף `NUM_WORKERS` \"גלולות רעל\" לתור. כל גלולת רעל מיועדת לאותת ל-Worker אחד לסיים את פעולתו.\n*   **`worker` function**: ה-Worker בודק האם המשימה שקיבל היא גלולת רעל. אם כן, הוא מעביר אותה הלאה לתור (באמצעות `enqueue_job`) כדי ש-Workers אחרים יוכלו לקבל אותה ולסיים, ויוצא מהלולאה שלו (`break`). פעולה זו מבטיחה שכל ה-Workers יקבלו את האות לסיים. העברת גלולת הרעל הלאה היא קריטית במקרה שיש יותר מ-Worker אחד, כדי שכולם יקבלו את האות.\n*   **עדכון `global_completed_jobs`**: בתוך ה-Worker, ההגדלה של `global_completed_jobs` נעשית כעת בתוך קטע קריטי המוגן על ידי `completed_jobs_mutex`, מה שמונע את תנאי המירוץ. בנוסף, כאשר `global_completed_jobs` מגיע ל-`TOTAL_JOBS_TO_PROCESS`, נשלח `signal` ל-`all_jobs_done` כדי להעיר את התהליך הראשי.\n*   **`main` function**: התהליך הראשי ממתין כעת על `all_jobs_done` בתוך לולאת `while` המוגנת על ידי `completed_jobs_mutex`. לאחר קבלת האות שכל המשימות הושלמו, הוא ממשיך לבצע `pthread_join` על כל ה-Workers, שכבר אמורים להיות בתהליך סיום עקב גלולות הרעל. סדר זה מבטיח סיום עבודה נכון וגרייספוּלי.\n*   **ניקוי משאבים**: הוספנו קריאות ל-`pthread_mutex_destroy` ו-`pthread_cond_destroy` כדי לשחרר את המשאבים של המנעולים והמשתנים התנאים בסיום התוכנית."
    },
    "difficulty_estimation": "Hard"
  }
}