{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 23:41:39",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4084,
      "output_tokens": 4573,
      "total_tokens": 19043
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "File Systems",
      "I/O",
      "Disk Scheduling",
      "Journaling"
    ],
    "content": {
      "text": "נתונה מערכת קבצים VSFS עם מבנה inode ייחודי ואלוקציית בלוקים מבוססת extents. במערכת זו:\n- גודל בלוק הוא 4KB (4096 בתים).\n- גודל inode הוא 256 בתים. מתוכם, 128 הבתים הראשונים מוקצים לאחסון נתוני קובץ ישירות ב-inode (עבור קבצים קטנים מאוד). רק כאשר גודל הקובץ חורג מ-128 בתים, נעשה שימוש במצביעי extents.\n- כל מצביע extent הוא בגודל 8 בתים ומכיל (start_block_id, num_blocks), כאשר num_blocks הוא שדה בגודל 1 בית (כלומר, עד 255 בלוקים רציפים לכל extent).\n- בכל inode יש 8 מצביעי extents ישירים.\n- בנוסף, קיים מצביע עקיף אחד לבלוק extents עקיף יחיד. בלוק זה מכיל מצביעי extents נוספים.\n- מבנה רשומת תיקייה (directory entry) מכיל שם קובץ ומספר inode בלבד.\n\nנתוני דיסק:\n- מהירות הסיבוב של הדיסק (RPM) היא 10000.\n- זמן ה-seek הממוצע של הדיסק הוא 8ms.\n- קצב ההעברה המקסימלי של הדיסק הוא 100 MB/s.\n\nמערכת הקבצים משתמשת ב-metadata journaling. פירוש הדבר שרק עדכוני metadata (כמו inodes, superblocks) נרשמים ל-journal לפני כתיבתם למיקומם הסופי. בלוקי נתונים (כולל בלוקי נתונים של תיקיות) נכתבים ישירות למיקומם הסופי על הדיסק ברגע שהטרנזקציה מוכנה, לפני שה-TxE נכתב ל-journal. יש לפרט ולנמק את כל החישובים בכל סעיף.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מהו הגודל המקסימלי של קובץ הנתמך במערכת הקבצים הנתונה? כמה בלוקי DATA (בלוקים המכילים נתוני קובץ בפועל) וכמה בלוקים נוספים (בלוקי metadata כגון בלוקי extents עקיפים) יידרשו עבור קובץ בגודל זה?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "משתמש ביצע פעולת קריאה של 500KB מתוך הקובץ: `/home/user/project/data.txt`.\nידוע שהקובץ `data.txt` הוא בגודל 1MB. הנתונים שלו מאוחסנים באמצעות extents, כאשר ה-128 בתים הראשונים נמצאים ב-inode, והשאר בשני extents ישירים רציפים (ה-extent הראשון מכיל 255 בלוקים, והשני מכיל את הבלוק הנותר). פעולת הקריאה היא מתחילת הקובץ (offset 0).\nנתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\nמה הזמן המינימלי שתיקח פעולה זו? יש לפרט את כל הבלוקים שנקראים, את גודלם הכולל, ואת חישוב הזמן.\nניתן להניח כל תרחיש שיוביל לזמן הקצר ביותר, כל עוד הוא עומד בנתונים ובמגבלות שצוינו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "משתמש יוצר קובץ חדש וריק בשם `newfile.txt` בתיקייה קיימת (`/home/user/project/`). נתון שבלוק הנתונים של התיקייה (`project`) מכיל מספיק מקום פנוי לרשומת התיקייה החדשה. המערכת משתמשת ב-metadata journaling כמתואר לעיל. תארו רצף פעולות קצר על הדיסק (לפחות 3 פעולות כתיבה) עבור יצירת הקובץ, וציינו באיזה שלב קריסה עלולה לגרום לבעיה במערכת הקבצים. יש להסביר מדוע הקריסה בעייתית וכיצד היא מתבטאת. לאחר מכן, הציעו פתרון לבעיה, תוך שמירה על עקרונות ה-metadata journaling (כלומר, אין לכתוב את תוכן בלוק הנתונים של הקובץ ל-journal).",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 5,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון שאלה 1:\n\n**סעיף 1.1: גודל קובץ מקסימלי ומספר בלוקים**\n\n*   **נתונים ב-inode**: 128 בתים.\n*   **מצביעי extents ישירים**: 8 מצביעים. כל מצביע יכול להפנות ל-255 בלוקים רציפים. כל בלוק הוא 4KB.\n    *   סה\"כ נתונים ממצביעים ישירים: `8 * 255 בלוקים * 4KB/בלוק = 8 * 1020KB = 8160KB`.\n*   **מצביע extent עקיף**: 1 מצביע לבלוק extents עקיף. בלוק זה (4KB) יכול להכיל `4096 בתים / 8 בתים/מצביע = 512 מצביעי extents`.\n    *   סה\"כ נתונים ממצביעים עקיפים: `512 מצביעים * 255 בלוקים/מצביע * 4KB/בלוק = 512 * 1020KB = 522240KB = 510MB`.\n\n*   **גודל קובץ מקסימלי**: `128 בתים + 8160KB + 522240KB = 530400KB + 128 בתים`.\n    *   `530400KB = 530400 * 1024 בתים = 543129600 בתים`. \n    *   סה\"כ: `543129600 + 128 = 543129728 בתים` (כ-518MB).\n\n*   **מספר בלוקי DATA נדרשים**: זהו סך הבלוקים המכילים את נתוני הקובץ בפועל.\n    *   ממצביעים ישירים: `8 * 255 = 2040 בלוקים`.\n    *   ממצביעים עקיפים: `512 * 255 = 130560 בלוקים`.\n    *   סה\"כ בלוקי DATA: `2040 + 130560 = 132600 בלוקים`.\n\n*   **מספר בלוקים נוספים (metadata)**:\n    *   בלוק אחד עבור בלוק ה-extents העקיף.\n\n**סעיף 1.2: זמן קריאת 500KB מהקובץ**\n\n**חישוב בלוקים לקריאה:**\n\n1.  **Superblock**: בלוק בודד לקריאת פרטי מערכת הקבצים (כולל מיקום inode השורש). (1 בלוק)\n2.  **מעבר בנתיב `/home/user/project/data.txt`**: לכל רכיב בנתיב נצטרך לקרוא את בלוק ה-inode שלו ואת בלוק הנתונים של התיקייה המכילה אותו כדי למצוא את ה-inode הבא.\n    *   **root**: קריאת inode של root (1 בלוק), קריאת בלוק הנתונים של root (כדי למצוא `home` - 1 בלוק).\n    *   **home**: קריאת inode של `home` (1 בלוק), קריאת בלוק הנתונים של `home` (כדי למצוא `user` - 1 בלוק).\n    *   **user**: קריאת inode של `user` (1 בלוק), קריאת בלוק הנתונים של `user` (כדי למצוא `project` - 1 בלוק).\n    *   **project**: קריאת inode של `project` (1 בלוק), קריאת בלוק הנתונים של `project` (כדי למצוא `data.txt` - 1 בלוק).\n    *   **data.txt**: קריאת inode של `data.txt` (1 בלוק).\n    *   סה\"כ בלוקי metadata עבור מעבר בנתיב: `1 (superblock) + 4 * (1 inode block + 1 directory data block) + 1 (data.txt inode block) = 1 + 8 + 1 = 10 בלוקים`.\n\n3.  **נתוני הקובץ**: נדרש לקרוא 500KB החל מאופסט 0.\n    *   ה-128 בתים הראשונים נמצאים ב-inode של `data.txt` (כבר נקרא בשלב הקודם).\n    *   היתרה לקריאה: `500KB - 128 בתים = 512000 - 128 = 511872 בתים`.\n    *   מספר בלוקי DATA הנדרשים: `511872 בתים / 4096 בתים/בלוק = 124.99...` כלומר 125 בלוקים.\n\n*   **סה\"כ בלוקים לקריאה**: `10 (metadata) + 125 (data) = 135 בלוקים`.\n*   **גודל כולל לקריאה**: `135 בלוקים * 4KB/בלוק = 540KB`.\n\n**חישוב זמן מינימלי:**\nכדי למזער את הזמן, נניח את התרחיש המיטבי:\n*   כל 10 בלוקי ה-metadata הנדרשים (superblock, inodes, directory data) נמצאים ברצף על הדיסק.\n*   כל 125 בלוקי ה-data של הקובץ נמצאים ברצף על הדיסק, ומיד לאחר בלוקי ה-metadata.\n*   הדיסק מתחיל לסובב בדיוק בנקודה שבה הנתונים נדרשים.\n\n*   **זמן Seek**: נניח seek אחד בלבד עבור כל הקריאה הרציפה: `8ms`.\n*   **זמן השהייה סיבובית ממוצעת (Rotational Latency)**: `0.5 סיבוב / (10000 סיבובים/דקה / 60 שניות/דקה) = 0.5 / 166.67 סיבובים/שניה = 0.003 שניות = 3ms`.\n*   **זמן העברה (Transfer Time)**: `540KB / 100MB/s = 0.54MB / 100MB/s = 0.0054 שניות = 5.4ms`.\n\n*   **זמן כולל מינימלי**: `8ms (seek) + 3ms (rotational latency) + 5.4ms (transfer) = 16.4ms`.\n\n**סעיף 1.3: בעיית Journaling ביצירת קובץ ופתרון**\n\n**רצף פעולות לדוגמה עבור `touch /home/user/project/newfile.txt`:**\n\n1.  **קריאת inode של התיקייה `project`**: קריאה מבלוק ה-inode המתאים.\n2.  **קריאת בלוק הנתונים של התיקייה `project`**: קריאה מבלוק ה-DATA המתאים.\n3.  **הקצאת inode חדש עבור `newfile.txt`**: הקצאת בלוק inode וכתיבת ה-inode החדש לבלוק זה.\n4.  **כתיבת TxB ל-journal**: רישום תחילת טרנזקציה עם פרטי עדכון ה-inode של `project` ושל `newfile.txt` (שניהם נחשבים metadata).\n5.  **עדכון בלוק הנתונים של התיקייה `project`**: הוספת רשומת `newfile.txt` לבלוק הנתונים של התיקייה `project` וכתיבתו למיקומו הסופי על הדיסק. (פעולת DATA).\n6.  **`fsync`**: הבטחת כתיבת בלוק הנתונים של `project` לדיסק.\n7.  **כתיבת TxE ל-journal**: סיום הטרנזקציה ב-journal.\n8.  **`fsync`**: הבטחת כתיבת ה-TxE לדיסק.\n9.  **עדכון inode של `project`**: כתיבת ה-inode המעודכן (זמן שינוי, גודל) למיקומו הסופי על הדיסק.\n10. **עדכון inode של `newfile.txt`**: כתיבת ה-inode המעודכן (זמן יצירה, גודל) למיקומו הסופי על הדיסק.\n\n**שלב בעייתי וכיצד קריסה מתבטאת:**\nקריסה **לאחר שלב 6 (fsync של בלוק הנתונים של התיקייה) ולפני שלב 7 (כתיבת TxE ל-journal)** תגרום לבעיה.\n*   **הסבר**: בשלב זה, בלוק הנתונים של התיקייה `project` כבר עודכן ונכתב לדיסק (עם רשומת `newfile.txt`), והכתיבה אושרה על ידי `fsync`. עם זאת, הטרנזקציה עדיין אינה מחויבת ב-journal (כי TxE טרם נכתב). כאשר המערכת תעלה מחדש, ה-recovery process יראה טרנזקציה פתוחה ב-journal. מכיוון שמערכת הקבצים משתמשת ב-metadata journaling בלבד, בלוק הנתונים של התיקייה `project` נחשב לבלוק נתונים רגיל, ולכן השינוי בו לא נרשם במלואו ל-journal (רק ה-inode של התיקייה נרשם כ-metadata). תהליך ה-recovery עלול לגלגל אחורה רק את השינויים שרשומים ב-journal (כלומר, את עדכוני ה-inode של `project` ושל `newfile.txt` אם נכתבו), אך לא יבטל את השינוי בבלוק הנתונים של התיקייה. התוצאה היא מצב לא עקבי: התיקייה `project` על הדיסק מכילה רשומה עבור `newfile.txt`, אך ה-inode של `project` עלול לא להיות מעודכן (לדוגמה, מספר הקישורים או זמן השינוי שלו), וה-inode של `newfile.txt` עלול להיות מוקצה אך לא מקושר כראוי, או להיחשב כבלוק שאינו בשימוש (אם הטרנזקציה גולגלה לאחור חלקית). הדבר יכול להוביל ל\"קובץ יתום\" (orphan file) או לרשומת תיקייה המפנה ל-inode לא תקין או לא קיים, מה שפוגע בעקביות מערכת הקבצים.\n\n**פתרון מוצע (שומר על עקרונות metadata journaling):**\nהפתרון הוא ליישם את עקרון **Copy-on-Write (CoW)** עבור בלוקי נתונים של תיקיות כאשר הם משתנים כחלק מטרנזקציה. \n\n1.  במקום לעדכן את בלוק הנתונים הקיים של התיקייה (`project`) במקום (שלב 5 לעיל), נקצה בלוק נתונים חדש לחלוטין.\n2.  נעתיק את התוכן של בלוק הנתונים הישן לבלוק החדש.\n3.  נוסיף את רשומת `newfile.txt` לבלוק הנתונים החדש.\n4.  הטרנזקציה ב-journal תכלול כעת לא רק את עדכוני ה-inode של `project` ושל `newfile.txt`, אלא גם את הפעולות של **הקצאת הבלוק החדש ושחרור הבלוק הישן** עבור נתוני התיקייה.\n5.  כתיבת בלוק הנתונים החדש תתבצע למיקומו הסופי.\n6.  לאחר מכן, ה-TxE יירשם ל-journal.\n7.  רק לאחר שהטרנזקציה ממומשת (TxE נכתב לדיסק), ה-inode של `project` יועדכן כך שיצביע על בלוק הנתונים החדש.\n\n*   **הסבר מדוע הפתרון מטפל בבעיה**: בגישה זו, אם המערכת קורסת לפני שהטרנזקציה מחויבת (כלומר, לפני כתיבת TxE ל-journal), בלוק הנתונים המקורי של התיקייה (`project`) נשאר ללא שינוי על הדיסק. בלוק הנתונים החדש (שעודכן) עלול להיות קיים על הדיסק, אך הוא אינו מקושר לאף inode, ולכן הוא ייחשב כבלוק שאינו בשימוש ויוכל להימחק בתהליך ניקוי עתידי (או שייכלל בלוג כבלוק שצריך לשחרר). תהליך ה-recovery יבטל את כל הפעולות הלא מחויבות, כולל הקצאת הבלוק החדש, ושחרור הבלוק הישן לא יתרחש. כך, גם אם קריסה תתרחש בכל שלב, מערכת הקבצים תישאר במצב עקבי: התיקייה `project` תישאר ללא השינוי, והקובץ `newfile.txt` לא יווצר, ללא שאריות או הפניות שגויות."
    },
    "difficulty_estimation": "Hard"
  }
}