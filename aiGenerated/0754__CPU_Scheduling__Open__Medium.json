{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 00:03:44",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2316,
      "output_tokens": 1174,
      "total_tokens": 5662
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "CPU Scheduling",
      "Scheduling",
      "Priority Scheduling",
      "Starvation"
    ],
    "content": {
      "text": "מערכת הפעלה משתמשת באלגוריתם תזמון מעבד מבוסס עדיפויות (Preemptive Priority Scheduling) כאשר העדיפויות סטטיות (נקבעות פעם אחת ולא משתנות במהלך חיי התהליך).\n\n1. תארו תרחיש ספציפי שבו אלגוריתם תזמון זה יוביל לביצועים ירודים או לחוסר הוגנות משמעותי. נמקו את תשובתכם.\n2. הציעו שינוי או הרחבה לאלגוריתם התזמון הנתון על מנת להתמודד עם הבעיה שתיארתם בסעיף 1. אין להפוך את האלגוריתם ל-Multi-Level Feedback Queue. תארו כיצד השינוי עובד והסבירו מדוע הוא פותר את הבעיה.\n3. ציינו חיסרון פוטנציאלי אחד לשינוי שהצעתם בסעיף 2.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. תרחיש לביצועים ירודים/חוסר הוגנות:\n   תרחיש: ישנם תהליכים בעלי עדיפות גבוהה שמגיעים למערכת באופן תדיר. תהליך בעל עדיפות נמוכה יותר מגיע ומוכן לריצה. עם זאת, בגלל ההגעה המתמדת של תהליכים בעלי עדיפות גבוהה, התהליך בעל העדיפות הנמוכה לעולם אינו מקבל זמן מעבד (או מקבל מעט מאוד) ונשאר במצב \"רעב\" (starvation).\n   נימוק: האלגוריתם הוא פריאמטיבי, כלומר תהליך בעל עדיפות גבוהה יותר יכול להפסיק תהליך בעל עדיפות נמוכה יותר. כאשר העדיפויות סטטיות, אין מנגנון לשפר את עדיפותו של תהליך שממתין זמן רב, ולכן תהליכים בעלי עדיפות נמוכה יכולים להיתקע באינסוף המתנה אם תהליכים בעלי עדיפות גבוהה ממשיכים להגיע.\n\n2. שינוי מוצע לפתרון הבעיה:\n   הצעה: מנגנון \"הזדקנות\" (Aging). במקום עדיפות סטטית, עדיפות של תהליך תשתנה באופן דינמי.\n   תיאור ופתרון: כל פרק זמן קבוע (לדוגמה, כל שנייה) או לאחר מספר מסוים של החלפות קונטקסט, עדיפותם של כל התהליכים שממתינים בתור ה-Ready (ולא רצים כרגע) תוגדל בערך קבוע כלשהו (לדוגמה, עדיפותם תפחת מספרית אם 0 היא העדיפות הגבוהה ביותר, או תגדל אם מספרים גבוהים יותר מציינים עדיפות גבוהה יותר). ברגע שתהליך מקבל זמן מעבד, עדיפותו מאופסת לערך ההתחלתי שלו. מנגנון זה מבטיח שגם תהליכים בעלי עדיפות התחלתית נמוכה יצברו מספיק עדיפות עם הזמן כדי לקבל בסופו של דבר זמן מעבד, ובכך נמנעת תופעת הרעב. זהו עדיין אלגוריתם מבוסס עדיפויות, רק שהעדיפויות דינמיות. זה לא הופך אותו ל-MLFQ, שכן אין מספר תורים נפרדים עם כללי מעבר מורכבים.\n\n3. חיסרון פוטנציאלי:\n   חיסרון: מנגנון ה-Aging מוסיף תקורה (overhead) למערכת. יש צורך לבדוק ולעדכן באופן שוטף את העדיפויות של התהליכים הממתינים. פעולה זו דורשת זמן מעבד ומשאבי זיכרון נוספים, ועלולה להשפיע על יעילות התזמון הכוללת, במיוחד במערכות עם מספר רב של תהליכים או עם תקופת עדכון קצרה מאוד. בנוסף, קביעת קצב ה\"הזדקנות\" והערך המקסימלי לעדיפות דורשת כוונון עדין כדי לא לפגוע בעדיפותם המקורית של תהליכים קריטיים."
    },
    "difficulty_estimation": "Medium"
  }
}