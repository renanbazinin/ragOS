{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems and I/O",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:47:23",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4088,
      "output_tokens": 5513,
      "total_tokens": 17772
    }
  },
  "question": {
    "id": 9,
    "type": "Open",
    "topic": [
      "File Systems",
      "I/O",
      "Journaling",
      "Performance"
    ],
    "content": {
      "text": "נתונה מערכת קבצים בשם VSFS-Modified עם המאפיינים הבאים:\n*   אין טבלת Inode מרכזית. במקום זאת, בלוקים של Inodes (המכילים מספר Inodes) מוקצים באופן דינמי לפי הצורך.\n*   רשומות בתיקיות (directory entries) הן מסוגים שונים:\n    *   **קובץ קטן**: עבור קבצים שגודלם עד 256 בתים, נתוני הקובץ נשמרים ישירות בתוך רשומת התיקייה, בנוסף לשם הקובץ ולמטא-דאטה בסיסית (כמו זמני יצירה/שינוי, הרשאות). אין Inode נפרד לקבצים אלו.\n    *   **קובץ גדול**: עבור קבצים שגודלם עולה על 256 בתים, רשומת התיקייה מכילה את שם הקובץ ומצביע ל-Inode (block_number, offset_within_block) בתוך אחד מבלוקי ה-Inodes. ה-Inode עצמו מכיל את המטא-דאטה ואת המצביעים לבלוקי הנתונים.\n    *   **קישור קשיח (Hard Link)**: רשומת התיקייה מכילה את שם הקישור ומצביע ל-Inode (block_number, offset_within_block) של קובץ יעד קיים. מונים את מספר הקישורים הקשיחים בתוך ה-Inode של הקובץ.\n    *   **קישור סימבולי (Symbolic Link)**: רשומת התיקייה מכילה את שם הקישור ואת הנתיב המלא של קובץ היעד.\n*   מערכת הקבצים משתמשת ב-metadata journaling (כפי שנלמד), כלומר רק מטא-דאטה נכתבת ללוג, ונתוני הקובץ (DATA) נכתבים פעם אחת למיקומם הסופי.\n*   גודל בלוק הוא 4KB.\n*   גודל רשומת תיקייה (עבור שם קובץ באורך ממוצע) הוא 32 בתים, בתוספת נתוני הקובץ (עבור קבצים קטנים) או מצביע ל-Inode (עבור קבצים גדולים/קישורים קשיחים) או נתיב (עבור קישורים סימבוליים).\n*   גודל Inode הוא 256 בתים.\n*   כל בלוק Inodes מכיל 16 Inodes.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "9.1",
        "text": "משתמש מוחק קובץ `fileA` באמצעות `unlink(\"/path/to/fileA\")`. ידוע ש-`fileA` הוא קובץ גדול, ויש לו שני קישורים קשיחים: `fileA` ו-`fileB`.\nא. תארו את רצף הפעולות (קריאה/כתיבה לדיסק) הנדרש במערכת קבצים זו עבור `unlink(\"/path/to/fileA\")`, כולל פעולות ה-journaling. יש להתמקד במקרה שבו מחיקה זו אינה מחיקת הקישור הקשיח האחרון (כלומר, `fileB` עדיין קיים).\nב. הניחו קריסה של המערכת מיד לאחר שלב הכתיבה ל-DATA של התיקייה, אך לפני שהטרנזקציה נסגרת (לפני כתיבת TxE). אילו בעיות עקביות עלולות להתעורר? האם ייתכן איבוד נתונים או מצב לא עקבי במערכת הקבצים? נמקו היטב.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "9.2",
        "text": "כיצד אופן הטיפול בקבצים קטנים (נתונים ישירות ברשומת התיקייה) משפיע על ביצועי מערכת הקבצים בהשוואה למערכת קבצים סטנדרטית (כמו EXT4) במקרים הבאים:\nא. יצירת אלפי קבצים קטנים (בגודל 100 בתים כל אחד) בתיקייה אחת.\nב. קריאת אלפי קבצים קטנים אלו ברצף.\nג. יצירת אלפי קבצים גדולים (בגודל 1MB כל אחד) בתיקייה אחת.\nהתייחסו להבדלים במספר גישות הדיסק (קריאה/כתיבה), ניצול שטח דיסק, וכן להשפעת ה-cache.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "9.3",
        "text": "משתמש יוצר קובץ חדש בשם `new_file` וכותב אליו 200 בתים. לאחר מכן, הוא כותב 100 בתים נוספים לאותו קובץ.\nא. תארו את השינויים ברשומת התיקייה ובמבני הנתונים של מערכת הקבצים לאחר כל אחת משתי פעולות הכתיבה.\nב. מהו מספר הפעולות המינימלי של קריאה וכתיבה לדיסק הנדרש לביצוע פעולת הכתיבה השנייה (הוספת 100 הבתים), בהנחה שאף cache אינו מכיל מידע רלוונטי, ושבלוק ה-DATA של התיקייה מלא ברובו אך יש בו מקום לרשומת הקובץ. פרטו אילו בלוקים נקראים ונכתבים ולמה.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון לשאלה 9:\n\n**שאלה 9.1: מחיקת קישור קשיח ועקביות**\nא. **רצף פעולות עבור `unlink(\"/path/to/fileA\")` (כאשר אינו הקישור האחרון):**\n1.  **קריאת בלוק ה-DATA של התיקייה:** קריאת הבלוק המכיל את רשומת התיקייה עבור `fileA`. (1 קריאה)\n2.  **קריאת בלוק ה-Inode:** מתוך רשומת התיקייה של `fileA` (שהוא קובץ גדול), אנו מקבלים מצביע לבלוק ה-Inode הרלוונטי. נקרא את בלוק ה-Inode הזה כדי לגשת ל-Inode של `fileA`. (1 קריאה)\n3.  **הורדת מונה הקישורים (link count) ב-Inode:** נעדכן את ה-Inode של `fileA` בזיכרון על ידי הורדת מונה הקישורים באחד.\n4.  **כתיבת טרנזקציה ללוג (TxB):** כתיבת רשומת טרנזקציה ללוג, הכוללת את בלוק ה-DATA המעודכן של התיקייה (עם רשומת `fileA` המסומנת למחיקה, או דחוסה), ואת בלוק ה-Inode המעודכן (עם מונה הקישורים המופחת). (1 כתיבה ללוג)\n5.  **כתיבת בלוק ה-DATA המעודכן של התיקייה:** כתיבת הבלוק של התיקייה למיקומו הסופי בדיסק, כאשר רשומת `fileA` הוסרה או סומנה כלא תקינה. (1 כתיבה)\n6.  **`fsync` (לבלוק ה-DATA של התיקייה):** לוודא שהכתיבה לבלוק ה-DATA של התיקייה בוצעה לדיסק.\n7.  **כתיבת בלוק ה-Inode המעודכן:** כתיבת הבלוק המכיל את ה-Inode של `fileA` למיקומו הסופי בדיסק. (1 כתיבה)\n8.  **`fsync` (לבלוק ה-Inode):** לוודא שהכתיבה לבלוק ה-Inode בוצעה לדיסק.\n9.  **כתיבת סיום טרנזקציה בלוג (TxE):** כתיבת רשומת סיום טרנזקציה ללוג. (1 כתיבה ללוג)\n10. **`fsync` (ללוג):** לוודא שה-TxE נכתב לדיסק.\n\nב. **קריסה לאחר כתיבה ל-DATA של התיקייה, לפני סגירת טרנזקציה:**\nאם המערכת קורסת לאחר שלב 5 (כתיבת בלוק ה-DATA המעודכן של התיקייה) ולפני שלב 9 (כתיבת TxE ללוג), מתעוררת בעיית עקביות חמורה במערכת הקבצים:\n*   **מצב התיקייה:** בלוק ה-DATA של התיקייה עודכן ונכתב לדיסק (שלב 5). כתוצאה מכך, רשומת `fileA` נעלמה מהתיקייה.\n*   **מצב ה-Inode:** בלוק ה-Inode של `fileA` *לא* עודכן עדיין למיקומו הסופי בדיסק (שלב 7 טרם בוצע). לכן, מונה הקישורים (link count) ב-Inode של `fileA` עדיין מחזיק בערכו הקודם (גבוה באחד מהערך הנכון).\n*   **הבעיה:** כאשר המערכת תעלה מחדש ותבצע recovery מה-journal, היא תזהה טרנזקציה פתוחה (TxB נכתב אך TxE לא). מכיוון שמדובר ב-metadata journaling, השינויים למטא-דאטה (כמו בלוק ה-DATA של התיקייה) שנכתבו למיקומם הסופי לפני הקריסה, נחשבים תקפים. ה-recovery יראה שרשומת `fileA` נמחקה, אך ה-Inode של `fileA` טרם עודכן. זהו מצב לא עקבי: הקישור `fileA` נעלם מהתיקייה, אך ה-Inode של הקובץ עדיין חושב שיש לו יותר קישורים (כולל הקישור שנמחק). אם בעתיד `fileB` (הקישור הקשיח השני) יימחק, מונה הקישורים ב-Inode יגיע לאפס, אך הקובץ ובלוקי הנתונים שלו לא ישוחררו בפועל. זה יגרום ל\"דליפת\" Inode ובלוקי נתונים (Lost Inode/Data Blocks) שלא ניתנים לגישה ואינם מסומנים כפנויים, ובכך לאבד שטח דיסק.\n\n**שאלה 9.2: אופטימיזציית קבצים קטנים וביצועים**\nא. **יצירת אלפי קבצים קטנים (100 בתים) בתיקייה אחת:**\n    *   **VSFS-Modified:** עבור קבצים קטנים, הנתונים נשמרים ישירות ברשומת התיקייה. יצירת קובץ דורשת: קריאת בלוק ה-DATA של התיקייה, עדכון רשומת התיקייה (הוספת שם הקובץ, מטא-דאטה וה-100 בתים), כתיבת בלוק ה-DATA המעודכן של התיקייה (בתוספת journaling). היתרון הגדול הוא שאין צורך להקצות Inode נפרד ובלוק DATA נפרד עבור כל קובץ. זה מפחית משמעותית את מספר גישות הדיסק (לפחות 2 קריאות ועוד 1-2 כתיבות לכל קובץ, כולל ה-journaling), ומפחית את ניצול שטח הדיסק (אין overhead של בלוקים שלמים עבור 100 בתים). ה-cache יכיל את בלוק ה-DATA של התיקייה, מה שיאיץ יצירה של קבצים רבים באותה תיקייה.\n    *   **EXT4 (מערכת קבצים סטנדרטית):** יצירת קובץ דורשת: איתור Inode פנוי (קריאת Inode bitmap), הקצאת Inode (כתיבה ל-Inode bitmap), כתיבת Inode חדש, איתור בלוק DATA פנוי (קריאת Data bitmap), הקצאת בלוק DATA (כתיבה ל-Data bitmap), כתיבת בלוק DATA עם ה-100 בתים, עדכון רשומת התיקייה (הוספת שם הקובץ ומספר ה-Inode), כתיבת בלוק ה-DATA של התיקייה. זה דורש הרבה יותר גישות דיסק (לפחות 2 קריאות ועוד 4-5 כתיבות לכל קובץ, כולל ה-bitmaps, ה-Inode, וה-DATA).\n\nב. **קריאת אלפי קבצים קטנים אלו ברצף:**\n    *   **VSFS-Modified:** קריאת קובץ קטן דורשת רק קריאת בלוק ה-DATA של התיקייה המכיל את רשומת הקובץ. אם כל הקבצים הקטנים נמצאים באותו בלוק DATA של תיקייה (או במספר מועט של בלוקים), קריאת בלוקים ספורים תאפשר גישה לנתונים של קבצים רבים. מספר גישות הדיסק יהיה נמוך משמעותית מאשר ב-EXT4. ה-cache יכיל את בלוקי ה-DATA של התיקייה, מה שיספק ביצועים מעולים.\n    *   **EXT4:** קריאת קובץ דורשת: קריאת בלוק ה-DATA של התיקייה (כדי למצוא את מספר ה-Inode), קריאת בלוק ה-Inode (כדי למצוא את המצביעים לבלוקי ה-DATA), קריאת בלוק ה-DATA של הקובץ. זה דורש לפחות 3 גישות דיסק לכל קובץ, מה שיהיה איטי יותר באופן ניכר עבור אלפי קבצים.\n\nג. **יצירת אלפי קבצים גדולים (1MB) בתיקייה אחת:**\n    *   **VSFS-Modified:** עבור קבצים גדולים, רשומת התיקייה מכילה מצביע ל-Inode. זה דורש: קריאת בלוק ה-DATA של התיקייה, עדכון רשומת התיקייה (הוספת שם הקובץ ומצביע ל-Inode), כתיבת בלוק ה-DATA של התיקייה. בנוסף, יש צורך להקצות Inode (בבלוק Inodes קיים או חדש) ולכתוב Inode חדש, ואז להקצות מספר רב של בלוקי DATA ולכתוב אותם. זה דומה מאוד ל-EXT4 מבחינת מספר גישות הדיסק עבור Inode ו-DATA. אין יתרון משמעותי ל-VSFS-Modified במקרה זה, שכן עיקר הזמן מושקע בכתיבת בלוקי ה-DATA הרבים.\n    *   **EXT4:** תהליך דומה, כולל הקצאת Inode (עם Inode bitmap), כתיבת Inode, הקצאת בלוקי DATA (עם Data bitmap), כתיבת בלוקי DATA, ועדכון רשומת התיקייה. ההבדלים בביצועים בין שתי המערכות יהיו פחות משמעותיים, שכן עיקר הזמן מושקע בכתיבת בלוקי הנתונים.\n\n**שאלה 9.3: גידול קובץ ופעולות I/O**\nא. **שינויים במבני הנתונים:**\n1.  **יצירת `new_file` וכתיבת 200 בתים:**\n    *   הקובץ `new_file` הוא קטן (200 בתים < 256 בתים).\n    *   **רשומת התיקייה:** בבלוק ה-DATA של התיקייה, תיווצר רשומה חדשה עבור `new_file`. רשומה זו תכיל את שם הקובץ, מטא-דאטה בסיסית, ואת 200 הבתים של נתוני הקובץ ישירות בתוכה. אין Inode נפרד לקובץ זה.\n2.  **כתיבת 100 בתים נוספים (סה\"כ 300 בתים):**\n    *   הקובץ `new_file` הופך להיות גדול (300 בתים > 256 בתים).\n    *   **רשומת התיקייה:** רשומת התיקייה עבור `new_file` תשתנה. היא לא תכיל עוד את נתוני הקובץ ישירות. במקום זאת, היא תכיל מצביע ל-Inode (block_number, offset_within_block).\n    *   **Inode חדש:** יוקצה Inode חדש בבלוק Inodes פנוי (או בבלוק Inodes קיים עם מקום פנוי). ה-Inode הזה יכיל את מטא-דאטה של הקובץ (גודל, זמנים, הרשאות) ואת המצביעים לבלוקי ה-DATA.\n    *   **בלוקי DATA:** יוקצה בלוק DATA אחד (4KB) עבור הקובץ. ה-300 בתים הקיימים (200 קודמים + 100 חדשים) ייכתבו לבלוק DATA זה. המצביע הראשון ב-Inode יצביע לבלוק DATA זה.\n\nב. **מינימום פעולות קריאה וכתיבה לדיסק עבור פעולת הכתיבה השנייה:**\nהנחות:\n*   אף cache אינו מכיל מידע רלוונטי.\n*   בלוק ה-DATA של התיקייה מלא ברובו אך יש בו מקום לרשומת הקובץ (כלומר, לא דורש הקצאת בלוק DATA חדש לתיקייה).\n*   יש מקום פנוי בבלוק Inodes קיים, ואין צורך להקצות בלוק Inodes חדש.\n\n**פעולות קריאה מינימליות:**\n1.  **קריאת בלוק ה-DATA של התיקייה:** כדי לגשת לרשומת `new_file` ולעדכן אותה. (1 קריאה)\n2.  **קריאת בלוק Inodes:** כדי לאתר Inode פנוי בבלוק Inodes קיים שאליו יועתק ה-Inode החדש. (1 קריאה)\n   *   *הערה:* אנו מניחים שהמערכת יודעת לאתר בלוק Inodes פנוי ללא סריקה נרחבת של כל הבלוקים. אם היתה Inode bitmap, היינו צריכים לקרוא אותה.\n\n**פעולות כתיבה מינימליות (כולל journaling):**\n1.  **כתיבה ללוג (TxB):** כתיבת רשומת טרנזקציה ללוג, הכוללת את בלוק ה-DATA המעודכן של התיקייה (עם המצביע ל-Inode במקום הנתונים), את בלוק ה-Inode החדש (עם מטא-דאטה ומצביע לבלוק DATA), ואת בלוק ה-DATA החדש של הקובץ. (1 כתיבה ללוג)\n2.  **כתיבת בלוק ה-DATA המעודכן של התיקייה:** למיקומו הסופי בדיסק (עם המצביע ל-Inode במקום הנתונים). (1 כתיבה)\n3.  **`fsync` (לבלוק ה-DATA של התיקייה):** לוודא שהכתיבה בוצעה לדיסק.\n4.  **כתיבת בלוק ה-Inode החדש:** למיקומו הסופי בדיסק. (1 כתיבה)\n5.  **`fsync` (לבלוק ה-Inode):** לוודא שהכתיבה בוצעה לדיסק.\n6.  **כתיבת בלוק ה-DATA החדש של הקובץ:** למיקומו הסופי בדיסק. (1 כתיבה)\n7.  **`fsync` (לבלוק ה-DATA של הקובץ):** לוודא שהכתיבה בוצעה לדיסק.\n8.  **כתיבה ללוג (TxE):** כתיבת רשומת סיום טרנזקציה ללוג. (1 כתיבה ללוג)\n9.  **`fsync` (ללוג):** לוודא שה-TxE נכתב לדיסק.\n\n**סה\"כ מינימלי של גישות דיסק פיזיות (קריאה + כתיבה למיקומם הסופי + כתיבה ללוג):**\n*   **קריאות:** 2 בלוקים.\n*   **כתיבות:** 3 בלוקים (בלוק DATA של תיקייה, בלוק Inodes, בלוק DATA של קובץ) + 2 כתיבות ללוג (TxB, TxE) = 5 כתיבות.\n*   **סה\"כ:** 2 קריאות + 5 כתיבות = 7 גישות דיסק פיזיות. (ה-`fsync` מבטיחים שהכתיבות הגיעו לדיסק אך אינם בהכרח כתיבות בלוק נוספות אם המידע כבר בדרכו או נכתב).\n\n**נימוק למינימום:**\n*   **קריאה:** חייבים לקרוא את בלוק התיקייה כדי לעדכן את הרשומה, וחייבים לקרוא בלוק Inodes כדי למצוא מקום פנוי ל-Inode החדש (בהיעדר cache).\n*   **כתיבה למיקום סופי:** חייבים לכתוב את בלוק התיקייה המעודכן, את בלוק ה-Inode החדש, ואת בלוק ה-DATA של הקובץ למיקומם הסופי בדיסק.\n*   **כתיבה ללוג:** חייבים לכתוב ללוג פעמיים (TxB ו-TxE) כדי להבטיח עקביות עם journaling ולסמן את תחילת וסיום הטרנזקציה.\n*   ה-`fsync`-ים נדרשים כדי להבטיח שהכתיבות הגיעו לדיסק, אך אינם מוסיפים בלוקים חדשים מעבר לכתיבות עצמן."
    },
    "difficulty_estimation": "Hard"
  }
}