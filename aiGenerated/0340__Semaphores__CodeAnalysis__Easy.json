{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:56:58",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3853,
      "output_tokens": 750,
      "total_tokens": 5845
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Semaphores",
      "Threads",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בסמפור (Semaphore) כדי לסנכרן גישה למשתנה משותף. קראו את הקוד וענו על השאלה:\n\nמה יהיה הפלט הסופי של התוכנית? נמקו את תשובתכם.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#define NUM_THREADS 2\n#define INCREMENTS_PER_THREAD 5\n\nint counter = 0;\nsem_t sem;\n\nvoid *thread_func(void *arg) {\n    for (int i = 0; i < INCREMENTS_PER_THREAD; ++i) {\n        sem_wait(&sem); // Wait for semaphore\n        counter++;      // Critical section\n        sem_post(&sem); // Signal semaphore\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    // Initialize semaphore to 1 (mutex)\n    sem_init(&sem, 0, 1);\n\n    // Create threads\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, thread_func, NULL);\n    }\n\n    // Join threads\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", counter);\n\n    // Destroy semaphore\n    sem_destroy(&sem);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסמפור `sem` מאותחל לערך 1, מה שהופך אותו למעשה למנעול (mutex). כל חוט (thread) מבצע לולאה 5 פעמים. בכל איטרציה, הוא קורא ל-`sem_wait()` לפני הכניסה לקטע הקריטי (הגדלת `counter`) ו-`sem_post()` לאחר היציאה ממנו. פעולות אלו מבטיחות שרק חוט אחד יכול לגשת למשתנה המשותף `counter` בכל רגע נתון. כתוצאה מכך, פעולת ההגדלה `counter++` היא אטומית ומוגנת מתנאי מירוץ. מכיוון שיש 2 חוטים וכל אחד מגדיל את המונה 5 פעמים, הערך הסופי של `counter` יהיה 2 * 5 = 10. הפלט יהיה:\n`Final counter value: 10`"
    },
    "difficulty_estimation": "Easy"
  }
}