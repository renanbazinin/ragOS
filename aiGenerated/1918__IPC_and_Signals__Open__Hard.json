{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:46:32",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 4257,
      "total_tokens": 15834
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals"
    ],
    "content": {
      "text": "מערכת מורכבת משלושה תהליכים: יצרן (Producer), צרכן (Consumer), ומנטר (Monitor). היצרן והצרכן מתקשרים באמצעות זיכרון משותף (Shared Memory) המהווה חיץ מעגלי (Circular Buffer) בגודל קבוע. סמפורים משמשים לסנכרון ביניהם: סמפור `full` (מספר תאים מלאים), סמפור `empty` (מספר תאים ריקים), וסמפור `mutex` (גישה הדדית לחיץ). המנטר אחראי לוודא שהיצרן והצרכן פועלים כראוי ולא נתקעים.\n\nכתבו תוכנית בשפת C/C++ המממשת מערכת זו. עליכם להתייחס לנקודות הבאות:\n\nא. **ארכיטקטורת תהליכים**: היצרן, הצרכן והמנטר ירוצו כתהליכים נפרדים. המנטר יהיה תהליך האב שיוצר את היצרן והצרכן באמצעות `fork()`.\nב. **זיכרון משותף וסמפורים**: השתמשו ב-POSIX Shared Memory (`shm_open`, `mmap`) עבור הזיכרון המשותף, וב-POSIX Named Semaphores (`sem_open`) עבור הסמפורים. יש לוודא ניקוי נאות של המשאבים במקרה של סיום תקין או חריג של כל אחד מהתהליכים.\nג. **זיהוי תקיעות (Deadlock Detection)**: הוסיפו שדה לזיכרון המשותף (לדוגמה, מונה גישות) שכל אחד מהתהליכים (יצרן/צרכן) יעדכן באופן מחזורי לאחר פעולה מוצלחת (הכנסה/הוצאה מהחיץ). המנטר יבדוק אם המונים הללו מתעדכנים. אם מונה כלשהו לא התעדכן במשך 5 שניות, המנטר יראה זאת כתקיעה.\nד. **טיפול בתקיעות באמצעות אותות (Signals)**:\n    1.  אם המנטר מזהה תקיעה באחד מהתהליכים (או שניהם), עליו לשלוח אות `SIGUSR1` לאותו תהליך/תהליכים.\n    2.  היצרן והצרכן חייבים לטפל באות `SIGUSR1`. ה-handler צריך להדפיס הודעה מתאימה (לדוגמה: \"SIGUSR1 received! Attempting to resume operation...\") ולנסות לחדש את פעולתם הרגילה.\nה. **סיום חריג וניקוי משאבים**: טפלו באותות `SIGINT` ו-`SIGTERM` בכל התהליכים (יצרן, צרכן, מנטר) כדי לוודא ניקוי נאות של הזיכרון המשותף והסמפורים (unlinking ו-closing) לפני סיום. יש לדאוג שהניקוי יתבצע *רק* פעם אחת על ידי התהליך האחראי (לרוב המנטר/האב).\n\n**שאלה נוספת לדיון**: הסבירו במפורט כיצד הטיפול באות `SIGUSR1` משפיע על פעולות `sem_wait` במקרה שהן נקטעות, וכיצד יש לטפל בכך בתוך קוד היצרן/צרכן כדי להבטיח את המשך הפעולה התקינה שלהם לאחר קבלת האות.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "להלן פירוט הרכיבים הנדרשים לפתרון והסבר מפורט לטיפול באותות וקריאות מערכת.\n\n**מבנה הזיכרון המשותף (Shared Memory Structure):**\nנצטרך להגדיר מבנה שיכלול את החיץ המעגלי, מצביעים (head, tail), מוני גישות עבור היצרן והצרכן, וכן את שמות הסמפורים (כדי שיהיה קל לנקות אותם).\n\n```c\n#define BUFFER_SIZE 10\n#define SHM_NAME \"/my_shm\"\n#define SEM_FULL_NAME \"/sem_full\"\n#define SEM_EMPTY_NAME \"/sem_empty\"\n#define SEM_MUTEX_NAME \"/sem_mutex\"\n\ntypedef struct {\n    int buffer[BUFFER_SIZE];\n    int head;\n    int tail;\n    volatile int producer_counter;\n    volatile int consumer_counter;\n    pid_t producer_pid; // To send signals\n    pid_t consumer_pid; // To send signals\n    int producer_active; // Flag to indicate if producer is still alive\n    int consumer_active; // Flag to indicate if consumer is still alive\n} shared_data_t;\n\nshared_data_t *shared_mem_ptr = NULL;\nsem_t *sem_full = NULL;\nsem_t *sem_empty = NULL;\nsem_t *sem_mutex = NULL;\n```\n\n**פונקציית ניקוי משאבים (Cleanup Function):**\nיש ליצור פונקציה שתטפל בניקוי הזיכרון המשותף והסמפורים. פונקציה זו תקרא באמצעות `atexit` או מתוך ה-signal handlers עבור `SIGINT` ו-`SIGTERM`.\nחשוב שהניקוי יבוצע רק פעם אחת, רצוי על ידי תהליך האב (המנטר) או התהליך האחרון שיוצא.\n\n```c\nvoid cleanup() {\n    if (shared_mem_ptr) {\n        if (getpid() == shared_mem_ptr->producer_pid) {\n            shared_mem_ptr->producer_active = 0;\n        } else if (getpid() == shared_mem_ptr->consumer_pid) {\n            shared_mem_ptr->consumer_active = 0;\n        }\n\n        // Only the last active process (or monitor if both children died) performs unlink\n        if (shared_mem_ptr->producer_active == 0 && shared_mem_ptr->consumer_active == 0) {\n            printf(\"[%d] All children inactive, performing final cleanup.\\n\", getpid());\n            if (sem_full) sem_unlink(SEM_FULL_NAME);\n            if (sem_empty) sem_unlink(SEM_EMPTY_NAME);\n            if (sem_mutex) sem_unlink(SEM_MUTEX_NAME);\n            shm_unlink(SHM_NAME);\n        }\n        munmap(shared_mem_ptr, sizeof(shared_data_t));\n    }\n    if (sem_full) sem_close(sem_full);\n    if (sem_empty) sem_close(sem_empty);\n    if (sem_mutex) sem_close(sem_mutex);\n    printf(\"[%d] Resources cleaned up.\\n\", getpid());\n}\n```\n\n**טיפול באותות `SIGINT` ו-`SIGTERM`:**\nכל תהליך יגדיר handler עבור אותות אלו, שיקרא לפונקציית הניקוי ויסיים את פעולתו.\n\n```c\nvoid term_handler(int signum) {\n    printf(\"[%d] Received signal %d. Exiting.\\n\", getpid(), signum);\n    cleanup();\n    exit(0);\n}\n\n// In main function of each process:\nstruct sigaction sa_term;\nmemset(&sa_term, 0, sizeof(sa_term));\nsa_term.sa_handler = term_handler;\nsigaction(SIGINT, &sa_term, NULL);\nsigaction(SIGTERM, &sa_term, NULL);\natexit(cleanup); // Ensure cleanup on normal exit as well\n```\n\n**טיפול באות `SIGUSR1` (ב-Producer ו-Consumer):**\nה-handler פשוט ידפיס הודעה. החלק הקריטי הוא איך התהליך ממשיך לפעול אם הוא נקטע בזמן `sem_wait`.\n\n```c\nvoid usr1_handler(int signum) {\n    printf(\"[%d] SIGUSR1 received! Attempting to resume operation...\\n\", getpid());\n    // No complex logic here, rely on main loop to retry interrupted system calls.\n}\n\n// In main function of Producer/Consumer:\nstruct sigaction sa_usr1;\nmemset(&sa_usr1, 0, sizeof(sa_usr1));\nsa_usr1.sa_handler = usr1_handler;\n// sa_usr1.sa_flags = SA_RESTART; // Could be used, but not guaranteed for sem_wait\nsigaction(SIGUSR1, &sa_usr1, NULL);\n```\n\n**הסבר על השפעת `SIGUSR1` על `sem_wait` וטיפול ב-`EINTR`:**\nכאשר אות כמו `SIGUSR1` נקלט, הוא יכול לקטוע קריאות מערכת איטיות כמו `sem_wait`. במקרה כזה, `sem_wait` יחזיר -1 ומשתנה הכללי `errno` יוגדר ל-`EINTR` (Interrupted system call). כדי להבטיח שהתהליך ימשיך את פעולתו כרגיל לאחר הטיפול באות, יש שתי גישות עיקריות:\n\n1.  **שימוש ב-`SA_RESTART`**: בעת הגדרת ה-`sigaction` לאות, ניתן להגדיר את הדגל `SA_RESTART` במבנה `sa_flags`. דגל זה גורם למערכת לנסות להפעיל מחדש באופן אוטומטי חלק מקריאות המערכת שנקטעו. עם זאת, לא כל קריאות המערכת ניתנות להפעלה מחדש אוטומטית (לדוגמה, `read` ו-`write` לרוב כן, אך `sem_wait` אינה מובטחת להיכלל בהן בכל מערכות ה-UNIX/Linux). הסתמכות על `SA_RESTART` עבור `sem_wait` אינה פורטבילית או אמינה מספיק.\n\n2.  **לולאת ניסיון חוזר (Manual Retry Loop)**: הגישה הבטוחה והפורטבילית יותר היא לבדוק את ערך ה-`errno` לאחר ש-`sem_wait` נכשל. אם `errno` שווה ל-`EINTR`, יש לנסות שוב את הקריאה ל-`sem_wait` בתוך לולאה. לדוגמה:\n    ```c\n    int ret;\n    do {\n        ret = sem_wait(sem_empty);\n    } while (ret == -1 && errno == EINTR);\n    if (ret == -1) {\n        perror(\"sem_wait failed (not EINTR)\");\n        exit(1);\n    }\n    // Continue with critical section\n    ```\n    במקרה זה, ה-`SIGUSR1` handler פשוט יבצע את פעולתו (הדפסה) ויחזיר שליטה, והלולאה הראשית תנסה שוב את `sem_wait`. זוהי הדרך המומלצת לטפל בקטיעות על ידי אותות בקריאות חסימה.\n\n**לוגיקת המנטר (Monitor Logic):**\nהמנטר (תהליך האב) יצור את היצרן והצרכן. הוא ישמור את ה-PID שלהם. בלולאה, הוא ימתין 5 שניות, ואז יבדוק את מוני הגישות בזיכרון המשותף. אם מונה כלשהו לא השתנה, הוא ישלח `SIGUSR1` לתהליך המתאים. המנטר גם ימתין לסיום הילדים (`waitpid`).\n\n```c\n// Monitor process (parent)\npid_t producer_pid, consumer_pid;\n// ... fork() calls to create producer and consumer\n\nshared_mem_ptr->producer_pid = producer_pid;\nshared_mem_ptr->consumer_pid = consumer_pid;\nshared_mem_ptr->producer_active = 1;\nshared_mem_ptr->consumer_active = 1;\n\nint prev_prod_count = 0;\nint prev_cons_count = 0;\n\nwhile (shared_mem_ptr->producer_active || shared_mem_ptr->consumer_active) {\n    sleep(5);\n\n    if (shared_mem_ptr->producer_active) {\n        if (shared_mem_ptr->producer_counter == prev_prod_count) {\n            printf(\"[Monitor] Producer seems stuck, sending SIGUSR1 to %d\\n\", producer_pid);\n            kill(producer_pid, SIGUSR1);\n        } else {\n            prev_prod_count = shared_mem_ptr->producer_counter;\n        }\n    }\n\n    if (shared_mem_ptr->consumer_active) {\n        if (shared_mem_ptr->consumer_counter == prev_cons_count) {\n            printf(\"[Monitor] Consumer seems stuck, sending SIGUSR1 to %d\\n\", consumer_pid);\n            kill(consumer_pid, SIGUSR1);\n        } else {\n            prev_cons_count = shared_mem_ptr->consumer_counter;\n        }\n    }\n\n    // Check if children have terminated\n    int status;\n    pid_t terminated_pid;\n    while ((terminated_pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        if (terminated_pid == producer_pid) {\n            printf(\"[Monitor] Producer (%d) terminated.\\n\", producer_pid);\n            shared_mem_ptr->producer_active = 0;\n        } else if (terminated_pid == consumer_pid) {\n            printf(\"[Monitor] Consumer (%d) terminated.\\n\", consumer_pid);\n            shared_mem_ptr->consumer_active = 0;\n        }\n    }\n}\nprintf(\"[Monitor] Both children terminated. Performing final cleanup.\\n\");\ncleanup(); // Final cleanup by the monitor\n```\n\n**לוגיקת היצרן (Producer Logic):**\n\n```c\n// Producer process\nint item = 0;\nwhile (1) {\n    // Manual retry loop for sem_wait\n    int ret;\n    do {\n        ret = sem_wait(sem_empty);\n    } while (ret == -1 && errno == EINTR);\n    if (ret == -1) { perror(\"Producer sem_empty failed\"); break; }\n\n    do {\n        ret = sem_wait(sem_mutex);\n    } while (ret == -1 && errno == EINTR);\n    if (ret == -1) { perror(\"Producer sem_mutex failed\"); break; }\n\n    shared_mem_ptr->buffer[shared_mem_ptr->head] = item;\n    shared_mem_ptr->head = (shared_mem_ptr->head + 1) % BUFFER_SIZE;\n    shared_mem_ptr->producer_counter++;\n    printf(\"[Producer %d] Produced: %d, counter: %d\\n\", getpid(), item, shared_mem_ptr->producer_counter);\n    item++;\n\n    sem_post(sem_mutex);\n    sem_post(sem_full);\n    sleep(1); // Simulate work\n}\n```\n\n**לוגיקת הצרכן (Consumer Logic):**\n\n```c\n// Consumer process\nwhile (1) {\n    // Manual retry loop for sem_wait\n    int ret;\n    do {\n        ret = sem_wait(sem_full);\n    } while (ret == -1 && errno == EINTR);\n    if (ret == -1) { perror(\"Consumer sem_full failed\"); break; }\n\n    do {\n        ret = sem_wait(sem_mutex);\n    } while (ret == -1 && errno == EINTR);\n    if (ret == -1) { perror(\"Consumer sem_mutex failed\"); break; }\n\n    int consumed_item = shared_mem_ptr->buffer[shared_mem_ptr->tail];\n    shared_mem_ptr->tail = (shared_mem_ptr->tail + 1) % BUFFER_SIZE;\n    shared_mem_ptr->consumer_counter++;\n    printf(\"[Consumer %d] Consumed: %d, counter: %d\\n\", getpid(), consumed_item, shared_mem_ptr->consumer_counter);\n\n    sem_post(sem_mutex);\n    sem_post(sem_empty);\n    sleep(2); // Simulate work\n}\n```\n\n**סיכום לפתרון מלא:**\nהפתרון המלא יכלול קובץ C בודד עם פונקציית `main` שתבצע אתחול משאבים, תיצור את היצרן והצרכן באמצעות `fork()`, ותריץ את לוגיקת המנטר. לוגיקת היצרן והצרכן תהיה בפונקציות נפרדות שנקראות בתהליכים הצאצאים. כל התהליכים יגדירו signal handlers מתאימים ופונקציית ניקוי משאבים שתופעל בסיום. הדגש הוא על הטיפול הנכון ב-`EINTR` סביב קריאות `sem_wait` כדי להבטיח עמידות לאותות.",
      "difficulty_estimation": "Hard"
    }
  }
}