{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems and I/O",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:50:18",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4088,
      "output_tokens": 5397,
      "total_tokens": 26064
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "File Systems",
      "I/O",
      "Journaling"
    ],
    "content": {
      "text": "נתונה מערכת קבצים חדשה בשם `HybridFS` המשלבת שיטות הקצאת בלוקים שונות במטרה לייעל את השימוש בדיסק.\nמאפייני המערכת הם כדלקמן:\n*   **גודל בלוק**: 4KB.\n*   **גודל Inode**: 256B.\n*   **מבנה Inode**:\n    *   `is_contiguous_flag`: שדה בוליאני (1 בית) המציין האם הקובץ מוקצה ברצף.\n    *   `num_allocated_blocks`: מספר הבלוקים הכולל שהוקצו לקובץ (4 בתים).\n    *   אם `is_contiguous_flag` הוא `true`: השדה `start_block_address` (4 בתים) מציין את הבלוק הראשון ברצף. הקצאה רציפה אפשרית לעד 128 בלוקים לכל היותר.\n    *   אם `is_contiguous_flag` הוא `false` (או שהקובץ דורש יותר מ-128 בלוקים): ה-inode עובר למבנה מצביעים מפוזר. במצב זה, ה-inode מכיל:\n        *   8 מצביעים ישירים (4 בתים כל אחד).\n        *   מצביע עקיף יחיד אחד (4 בתים).\n        *   מצביע עקיף כפול אחד (4 בתים).\n    *   **כלל מעבר**: קובץ מתחיל תמיד בהקצאה רציפה (עד 128 בלוקים). אם הקובץ גדל מעבר ל-128 בלוקים, הוא *מומר* למבנה המפוזר. תהליך ההמרה כולל הקצאה מחדש של *כל* הבלוקים הקיימים במבנה החדש (מצביעים ישירים/עקיפים), העתקת הנתונים הישנים למיקומים החדשים, ורק אז שחרור הבלוקים הרציפים הישנים.\n*   **גודל מצביע בבלוק עקיף**: 4 בתים.\n*   **Journaling**: המערכת משתמשת ב-metadata journaling (write-ahead logging). כלומר, נתוני המטא-דאטה נכתבים ליומן לפני שהם נכתבים למיקומם הסופי בדיסק. בלוקי נתונים (DATA) נכתבים ישירות למיקומם הסופי בדיסק.\n*   **מאפייני דיסק**:\n    *   מהירות סיבוב (RPM): 7500.\n    *   זמן Seek ממוצע: 10ms.\n    *   קצב העברה מקסימלי: 50MB/s.\n\n**שאלות:**\n1.  **גודל קובץ מקסימלי**: מהו גודל הקובץ המקסימלי הנתמך על ידי מערכת קבצים זו, ומה מספר הבלוקים של DATA שהוא יתפוס? יש לפרט את החישובים.\n2.  **ביצועי I/O**: משתמש מבצע פעולת הוספת נתונים (append) של 200KB לקובץ `file.txt` שגודלו הנוכחי הוא 400KB. הקובץ מוקצה כרגע באופן רציף (contiguous). נתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה.\n    *   תארו את רצף הפעולות הנדרש על הדיסק (קריאות וכתיבות לבלוקים ספציפיים, כולל פעולות יומן).\n    *   מהו הזמן המינימלי שתיקח פעולה זו? יש לפרט את כל החישובים ולנמק כל הנחה (למשל, לגבי מיקום בלוקים רציפים).\n3.  **עקביות בקריסה**: בהתבסס על תרחיש סעיף 2, המערכת קורסת *מיד לאחר* שכל בלוקי הנתונים החדשים (הן הנתונים הישנים שהועתקו והן הנתונים החדשים שנוספו) נכתבו למיקומם הסופי בדיסק, אך *לפני* שהטרנזקציה ביומן הושלמה ובלוקי המטא-דאטה הסופיים (inode ו-bitmaps) נכתבו למיקומם הקבוע.\n    *   תארו את מצב מערכת הקבצים לאחר ההתאוששות. האם היא עקבית? אילו בעיות (למשל, אובדן נתונים, דליפת שטח, בלוקים יתומים) עלולות להיווצר?\n    *   הציעו שינוי לרצף הפעולות או למבנה ה-journaling (תוך שמירה על metadata journaling בלבד) שימנע בעיות עקביות במקרה של קריסה בנקודה זו. נמקו את הצעתכם.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**פתרון לשאלה 1:**\n\n1.  **גודל קובץ מקסימלי:**\n    *   בלוק עקיף מכיל: 4KB / 4B/מצביע = 1024 מצביעים.\n    *   8 מצביעים ישירים: 8 בלוקים.\n    *   1 מצביע עקיף יחיד: 1 * 1024 בלוקים.\n    *   1 מצביע עקיף כפול: 1 * 1024 * 1024 בלוקים.\n    *   סה\"כ בלוקים במבנה מפוזר: 8 + 1024 + 1024^2 = 8 + 1024 + 1,048,576 = 1,049,608 בלוקים.\n    *   גודל קובץ מקסימלי במבנה מפוזר: 1,049,608 בלוקים * 4KB/בלוק = 4,198,432KB = 4.002TB.\n    *   מכיוון שהקובץ *מומר* למבנה המפוזר אם הוא עובר את 128 הבלוקים, הגודל המקסימלי נקבע על ידי המבנה המפוזר.\n    *   **גודל קובץ מקסימלי**: 4,198,432KB.\n    *   **מספר בלוקי DATA**: 1,049,608 בלוקים.\n\n2.  **ביצועי I/O:**\n    *   **נתונים**: קובץ בגודל 400KB (100 בלוקים), מוקצה רציף. הוספת 200KB (50 בלוקים).\n    *   **גודל חדש**: 600KB (150 בלוקים).\n    *   **ניתוח**: מכיוון ש-150 בלוקים גדול מ-128 בלוקים (הגבול להקצאה רציפה), הקובץ חייב לעבור המרה למבנה מפוזר. תהליך ההמרה כולל הקצאה מחדש של *כל* הבלוקים הקיימים, העתקת הנתונים הישנים, שחרור הבלוקים הישנים ועדכון ה-inode.\n    *   **רצף פעולות על הדיסק (מינימלי, בהנחה אופטימלית למיקום בלוקים ו-Ordered Journaling):**\n        1.  **קריאת Inode של הקובץ**: (1 קריאת בלוק) – כדי לזהות צורך בהמרה ולקבל את `start_block_address` ו-`num_allocated_blocks` הישנים.\n        2.  **קריאת Bitmap של בלוקי נתונים**: (נניח 1 בלוק, מספיק לכל המידע) – לצורך איתור בלוקים פנויים חדשים ולשחרור בלוקים ישנים.\n        3.  **הקצאת 150 בלוקים חדשים**: עבור המבנה המפוזר. עדכון מבני נתונים פנימיים (לא נכתב לדיסק בשלב זה).\n        4.  **הכנת Inode חדש**: בניית ה-inode החדש עם `is_contiguous_flag=false` ומילוי המצביעים הישירים/עקיפים ל-150 הבלוקים החדשים.\n        5.  **טרנזקציית Journaling (Atomic Commit)**:\n            *   כתיבת Transaction Begin ליומן (1 בלוק).\n            *   כתיבת ה-Inode החדש (עם מצביעים חדשים ו-flag=false) ליומן (1 בלוק).\n            *   כתיבת עדכוני ה-Bitmap ליומן (1 בלוק, מסמן 150 בלוקים חדשים כתפוסים, 100 בלוקים ישנים כפנויים).\n            *   כתיבת Transaction End ליומן (1 בלוק).\n            *   `fsync` (פעולה זו מבטיחה שהטרנזקציה כולה נכתבה לדיסק באופן עקבי).\n        6.  **כתיבת נתונים לדיסק (לאחר התחייבות היומן)**:\n            *   קריאת 100 בלוקי הנתונים הישנים מהמיקום הרציף (100 קריאות בלוקים).\n            *   כתיבת 100 בלוקי הנתונים הישנים ל-100 הבלוקים החדשים שהוקצו (100 כתיבות בלוקים).\n            *   כתיבת 50 בלוקי הנתונים החדשים (התוספת) ל-50 הבלוקים החדשים הנותרים (50 כתיבות בלוקים).\n        7.  **כתיבת מטא-דאטה סופי למיקומו הקבוע**: \n            *   כתיבת Inode חדש למיקומו הקבוע (1 כתיבת בלוק).\n            *   כתיבת Bitmap מעודכן למיקומו הקבוע (1 כתיבת בלוק).\n\n    *   **סיכום I/O (מינימלי):**\n        *   **קריאות**: Inode (1) + Bitmap (1) + נתונים ישנים (100) = 102 בלוקים.\n        *   **כתיבות**: Journal (1+1+1+1=4 בלוקים) + נתונים חדשים (150 בלוקים) + Inode סופי (1) + Bitmap סופי (1) = 156 בלוקים.\n        *   סה\"כ פעולות I/O: 102 קריאות + 156 כתיבות = 258 בלוקים.\n\n    *   **חישוב זמן מינימלי (הנחות למינימום):**\n        *   כל הבלוקים הרציפים הישנים נמצאים באזור רציף.\n        *   כל 150 הבלוקים החדשים מוקצים גם הם ברצף (או במספר קטן של רצפים). \n        *   בלוקי המטא-דאטה (Inode, Bitmap) והיומן ממוקמים בצורה אופטימלית למינימום seek.\n        *   כאשר קוראים/כותבים רצף בלוקים, זמן ה-seek וזמן ההמתנה לסיבוב מתרחשים רק פעם אחת בתחילת הרצף.\n        *   זמן סיבוב מלא: 60 שניות / 7500 RPM = 0.008 שניות = 8ms.\n        *   זמן המתנה לסיבוב ממוצע: 8ms / 2 = 4ms.\n\n        1.  **קריאת Inode + Bitmap**: נניח 2 בלוקים רציפים.\n            *   זמן Seek: 10ms.\n            *   זמן Latency: 4ms.\n            *   זמן העברה: 2 בלוקים * 4KB/בלוק / 50MB/s = 8KB / 50MB/s = 0.16ms.\n            *   סה\"כ: 10 + 4 + 0.16 = 14.16ms.\n\n        2.  **כתיבת Journal (4 בלוקים)**: (נניח רצף אחד)\n            *   זמן Seek: 10ms.\n            *   זמן Latency: 4ms.\n            *   זמן העברה: 4 בלוקים * 4KB/בלוק / 50MB/s = 16KB / 50MB/s = 0.32ms.\n            *   סה\"כ: 10 + 4 + 0.32 = 14.32ms.\n\n        3.  **קריאת 100 בלוקי נתונים ישנים**: (רצף אחד)\n            *   זמן Seek: 10ms.\n            *   זמן Latency: 4ms.\n            *   זמן העברה: 100 בלוקים * 4KB/בלוק / 50MB/s = 400KB / 50MB/s = 8ms.\n            *   סה\"כ: 10 + 4 + 8 = 22ms.\n\n        4.  **כתיבת 150 בלוקי נתונים חדשים**: (נניח כרצף אחד)\n            *   זמן Seek: 10ms.\n            *   זמן Latency: 4ms.\n            *   זמן העברה: 150 בלוקים * 4KB/בלוק / 50MB/s = 600KB / 50MB/s = 12ms.\n            *   סה\"כ: 10 + 4 + 12 = 26ms.\n\n        5.  **כתיבת Inode סופי + Bitmap סופי (2 בלוקים)**: (נניח רצף אחד)\n            *   זמן Seek: 10ms.\n            *   זמן Latency: 4ms.\n            *   זמן העברה: 2 בלוקים * 4KB/בלוק / 50MB/s = 8KB / 50MB/s = 0.16ms.\n            *   סה\"כ: 10 + 4 + 0.16 = 14.16ms.\n\n        *   **זמן כולל מינימלי**: 14.16 + 14.32 + 22 + 26 + 14.16 = **90.64ms**.\n\n3.  **עקביות בקריסה:**\n    *   **מצב המערכת לאחר התאוששות (לפי רצף הפעולות המקורי שצוין בשאלה):**\n        *   המערכת קורסת *מיד לאחר* שכל בלוקי הנתונים החדשים (הן הנתונים הישנים שהועתקו והן הנתונים החדשים שנוספו) נכתבו למיקומם הסופי בדיסק, אך *לפני* שהטרנזקציה ביומן הושלמה ובלוקי המטא-דאטה הסופיים (inode ו-bitmaps) נכתבו למיקומם הקבוע.\n        *   לאחר התאוששות, היומן לא יכיל טרנזקציה שלמה עבור פעולה זו, ולכן לא יבוצע שחזור (replay). מערכת הקבצים תחזור למצב שלפני הפעולה.\n        *   ה-inode של הקובץ `file.txt` עדיין מצביע על 100 הבלוקים הרציפים הישנים. `is_contiguous_flag` עדיין `true`.\n        *   100 הבלוקים הרציפים הישנים עדיין מסומנים כבשימוש ב-bitmap.\n        *   150 הבלוקים החדשים (שמכילים את הנתונים הישנים והחדשים) נכתבו לדיסק, ומסומנים כבשימוש ב-bitmap (כי ההקצאה בוצעה בשלב מוקדם), אך הם *אינם נגישים* דרך ה-inode של `file.txt` (או כל inode אחר), מכיוון שה-inode לא עודכן להצביע עליהם.\n    *   **בעיות**: \n        *   **דליפת שטח (Space Leakage)**: 150 הבלוקים החדשים שהוקצו ונכתבו נחשבים תפוסים (ב-bitmap) אך אינם בשימוש על ידי אף קובץ נגיש. זהו שטח דיסק מבוזבז. כלי `fsck` יזהה אותם כבלוקים יתומים וישחרר אותם.\n        *   **אובדן נתונים**: ה-200KB החדשים שנוספו לקובץ אבדו באופן אפקטיבי. הנתונים הישנים (400KB) נשמרים בבלוקים המקוריים, אך לא הועברו למיקומם החדש ולכן אובדים אם הבלוקים החדשים נשארים נגישים. בפועל, הקובץ חוזר למצב של 400KB בלבד. אם הבלוקים החדשים ישוחררו, גם הנתונים הישנים שהועתקו אליהם אובדים.\n        *   **אי עקביות מבנית**: ה-bitmap מצביע על 150 בלוקים תפוסים ללא בעלים חוקי, מה שמהווה אי עקביות מבנית.\n\n    *   **הצעת פתרון למניעת בעיות עקביות (תוך שמירה על metadata journaling):**\n        הבעיה נובעת מכך שהנתונים נכתבים לדיסק לפני שהמטא-דאטה שמאפשר גישה אליהם (ה-inode החדש ועדכוני ה-bitmap) מחויב (committed) ליומן. על מנת למנוע בעיות עקביות (מבנית), יש לשנות את סדר הפעולות ל-**Ordered Journaling**:\n        1.  **הכנה והקצאה**: קרא Inode ו-Bitmap. הקצה 150 בלוקים חדשים. הכן את ה-inode החדש (עם המצביעים למבנה המפוזר החדש ו-`is_contiguous_flag=false`). הכן את עדכוני ה-Bitmap (הקצאת 150 בלוקים ושחרור 100 הישנים).\n        2.  **התחייבות ליומן (Journal Commit)**:\n            *   כתוב TxB ליומן.\n            *   כתוב את ה-Inode המעודכן ליומן.\n            *   כתוב את עדכוני ה-Bitmap ליומן.\n            *   כתוב TxE ליומן.\n            *   **`fsync`**: פעולה זו מבטיחה שכל הטרנזקציה של המטא-דאטה מחויבת לדיסק באופן אטומי ועקבי.\n        3.  **כתיבת נתונים לדיסק**: \n            *   קרא את 100 הבלוקים הישנים.\n            *   כתוב את 100 הבלוקים הישנים ל-100 הבלוקים החדשים שהוקצו.\n            *   כתוב את 50 הבלוקים החדשים (התוספת) ל-50 הבלוקים החדשים הנותרים.\n        4.  **כתיבת מטא-דאטה למיקומו הקבוע**: \n            *   כתוב את ה-Inode המעודכן למיקומו הקבוע.\n            *   כתוב את עדכוני ה-Bitmap למיקומם הקבוע.\n\n        **נימוק לפתרון:**\n        *   **אם קריסה מתרחשת *לפני שלב 2 (התחייבות ליומן)***: הטרנזקציה ביומן לא הושלמה. בזמן התאוששות, היא תתעלם מהפעולה. מערכת הקבצים חוזרת למצב שלפני הפעולה. הקובץ המקורי (400KB רציף) נשמר. הבלוקים החדשים שהוקצו אך לא חויבו ביומן ישוחררו על ידי `fsck` (דליפת שטח זמנית). אין אובדן נתונים מקוריים, אך ה-200KB שנוספו אובדים.\n        *   **אם קריסה מתרחשת *לאחר שלב 2 (התחייבות ליומן)* אך *לפני שלב 3 (כתיבת נתונים)* או *לפני שלב 4 (כתיבת מטא-דאטה סופי)***: בזמן התאוששות, מנגנון ה-replay של היומן יקרא את הטרנזקציה המחויבת וישחזר את ה-inode וה-bitmap למיקומם הקבוע. לאחר השחזור, מבנה מערכת הקבצים יהיה עקבי: ה-inode יצביע על 150 הבלוקים החדשים, וה-bitmap ישקף את מצבם. אמנם, תוכן הנתונים ב-150 הבלוקים החדשים עלול להיות שגוי או חלקי (מכיוון ששלב 3 לא הושלם במלואו), אך *מבנה מערכת הקבצים עצמו יהיה עקבי*. לא יהיו בלוקים יתומים או מצביעים שגויים. הקובץ יהיה נגיש, אך הנתונים בתוכו עלולים להיות פגומים. זהו הפתרון הנפוץ ב-metadata journaling שמבטיח עקביות מבנית של מערכת הקבצים, גם אם על חשבון עקביות מלאה של נתוני המשתמש בכל תרחיש קריסה."
    },
    "difficulty_estimation": "Hard"
  }
}