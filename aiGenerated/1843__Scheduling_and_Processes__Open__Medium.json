{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 21:09:55",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2768,
      "output_tokens": 3090,
      "total_tokens": 12487
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Processes",
      "Concurrency",
      "Process States",
      "fork",
      "Round Robin"
    ],
    "content": {
      "text": "נתונה תוכנית C הבאה. נניח שהיא מורצת על מערכת הפעלה המשתמשת באלגוריתם תזמון Round Robin עם קוונטה (quantum) של 100 מילישניות. נניח שזמן החלפת הקשר (context switch) הוא 5 מילישניות. כל פעולת printf אורכת 1 מילישניה, וכל לולאת for (המדמה עבודה) אורכת 150 מילישניות. התעלמו מ-I/O אחר ומזמני מערכת נוספים.\n\n",
      "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    pid_t p1, p2;\n\n    printf(\"A\\n\"); // Parent starts\n\n    p1 = fork();\n    if (p1 == 0) { // Child 1\n        printf(\"B\\n\");\n        for (int i = 0; i < 1000000; i++); // Simulate work\n        printf(\"C\\n\");\n        return 0;\n    }\n\n    p2 = fork();\n    if (p2 == 0) { // Child 2\n        printf(\"D\\n\");\n        for (int i = 0; i < 1000000; i++); // Simulate work\n        printf(\"E\\n\");\n        return 0;\n    }\n\n    waitpid(p1, NULL, 0);\n    waitpid(p2, NULL, 0);\n    printf(\"F\\n\"); // Parent finishes\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "כמה תהליכים בסך הכל נוצרים במהלך ריצה תקינה של התוכנית, כולל התהליך הראשי?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "תארו את רצף המצבים (ready, running, waiting) של כל אחד מהתהליכים העיקריים (התהליך הראשי ושני ילדיו) מהרגע שנוצרו ועד לסיום התוכנית, והסבירו בקצרה מדוע כל תהליך עובר למצב מסוים. התייחסו גם לזמני הריצה והקוונטה הנתונים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "האם ישנם סדרי הדפסה מסוימים שאינם אפשריים בהכרח, או סדרי הדפסה שהם וודאיים? הסבירו ונמקו את תשובתכם תוך התייחסות לזמני הריצה והקוונטה, והדגימו סדר הדפסה אפשרי אחד.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1:\nבסך הכל נוצרים 3 תהליכים:\n1. התהליך הראשי (Parent, נקרא לו P0).\n2. תהליך הבן הראשון (Child 1, נקרא לו P1) הנוצר מה-fork הראשון.\n3. תהליך הבן השני (Child 2, נקרא לו P2) הנוצר מה-fork השני על ידי התהליך הראשי (P0).\n\n1.2:\nלהלן תיאור רצף המצבים עבור התהליכים P0, P1, P2 בהתחשב באלגוריתם Round Robin (RR) עם קוונטה של 100ms ו-context switch של 5ms:\n\n*   **P0 (התהליך הראשי):**\n    *   **Running:** מתחיל בריצה, מדפיס 'A' (1ms).\n    *   **Running:** מבצע fork ליצירת P1 (נניח 5ms). P1 נוצר ועובר למצב Ready.\n    *   **Running:** מבצע fork ליצירת P2 (נניח 5ms). P2 נוצר ועובר למצב Ready.\n    *   **Waiting:** P0 קורא ל-`waitpid(p1, NULL, 0)` ונכנס למצב Waiting, ממתין לסיום P1. בשלב זה, הקוונטה של P0 עדיין לא הסתיימה, אך הוא ויתר מרצונו על המעבד.\n    *   **Ready/Running:** כאשר P1 מסיים את ריצתו (באמצעות `return 0`), P0 מקבל אות (או יתעורר מה-`waitpid`), עובר למצב Ready (אם יש תהליכים אחרים רצים) או Running (אם הוא התהליך הבא בתור). הוא ממשיך לבצע `waitpid(p2, NULL, 0)`.\n    *   **Waiting:** אם P2 עדיין לא סיים, P0 יכנס שוב למצב Waiting.\n    *   **Running:** כאשר P2 מסיים את ריצתו, P0 מתעורר מחדש, מדפיס 'F' (1ms).\n    *   **Terminated:** P0 מסיים את ריצתו באמצעות `return 0` ויוצא.\n\n*   **P1 (תהליך הבן הראשון):**\n    *   **Ready:** נוצר על ידי P0 ונכנס למצב Ready Queue.\n    *   **Running:** נבחר על ידי המתזמן (Scheduler) לרוץ (לאחר ש-P0 נכנס ל-Waiting או הקוונטה שלו הסתיימה). מדפיס 'B' (1ms). נשאר לו 99ms קוונטה.\n    *   **Running:** מבצע חלק מלולאת העבודה (100ms מתוך 150ms). הקוונטה שלו מסתיימת.\n    *   **Ready:** נשלף מהמעבד (preempted) ועובר למצב Ready Queue (Context Switch של 5ms).\n    *   **Running:** נבחר שוב על ידי המתזמן. מבצע את שארית לולאת העבודה (50ms). נשאר לו 50ms קוונטה.\n    *   **Running:** מדפיס 'C' (1ms). נשאר לו 49ms קוונטה.\n    *   **Terminated:** P1 מסיים את ריצתו באמצעות `return 0` ויוצא.\n\n*   **P2 (תהליך הבן השני):**\n    *   **Ready:** נוצר על ידי P0 ונכנס למצב Ready Queue. סדר כניסתו לתור ביחס ל-P1 תלוי בסדר ביצוע ה-forks ובהחלטת מערכת ההפעלה.\n    *   **Running:** נבחר על ידי המתזמן לרוץ (לדוגמה, אחרי ש-P1 סיים את הקוונטה הראשונה שלו). מדפיס 'D' (1ms). נשאר לו 99ms קוונטה.\n    *   **Running:** מבצע חלק מלולאת העבודה (100ms מתוך 150ms). הקוונטה שלו מסתיימת.\n    *   **Ready:** נשלף מהמעבד (preempted) ועובר למצב Ready Queue (Context Switch של 5ms).\n    *   **Running:** נבחר שוב על ידי המתזמן. מבצע את שארית לולאת העבודה (50ms). נשאר לו 50ms קוונטה.\n    *   **Running:** מדפיס 'E' (1ms). נשאר לו 49ms קוונטה.\n    *   **Terminated:** P2 מסיים את ריצתו באמצעות `return 0` ויוצא.\n\n1.3:\n*   **סדרי הדפסה וודאיים:**\n    *   התו 'A' חייב להיות הראשון להופיע בפלט, שכן הוא מודפס על ידי P0 לפני יצירת תהליכי הבן ולפני ש-P0 נכנס למצב Waiting.\n    *   התו 'F' חייב להיות האחרון להופיע בפלט, שכן הוא מודפס על ידי P0 רק לאחר ששני תהליכי הבן (P1 ו-P2) סיימו את ריצתם (בזכות קריאות `waitpid`).\n    *   התו 'C' חייב להופיע אחרי 'B' (בשל סדר הפקודות ב-P1).\n    *   התו 'E' חייב להופיע אחרי 'D' (בשל סדר הפקודות ב-P2).\n\n*   **סדרי הדפסה אפשריים (וכן, ישנם סדרי הדפסה רבים אפשריים):**\n    *   הסדר בין 'B'/'C' לבין 'D'/'E' אינו קבוע ויהיה משולב (interleaved) עקב תזמון Round Robin וזמני הריצה של הלולאות. מכיוון שזמן לולאת העבודה (150ms) ארוך מהקוונטה (100ms), כל אחד מהתהליכים P1 ו-P2 יופסק לפחות פעם אחת במהלך הלולאה שלו, מה שמאפשר לתהליך השני לרוץ בינתיים.\n    *   לדוגמה, 'B' יכולה להופיע לפני 'D', או 'D' לפני 'B'. 'C' ו-'E' יופיעו בהתאם לסיום לולאות העבודה של כל תהליך. \n\n*   **סדרי הדפסה שאינם אפשריים בהכרח (כלומר, אלו שמפרים את הכללים הוודאיים):**\n    *   כל סדר שבו 'A' אינו הראשון (לדוגמה: B A C D E F).\n    *   כל סדר שבו 'F' אינו האחרון (לדוגמה: A B C F D E).\n    *   כל סדר שבו 'C' מופיע לפני 'B' (לדוגמה: A C B D E F).\n    *   כל סדר שבו 'E' מופיע לפני 'D' (לדוגמה: A B E D C F).\n\n*   **דוגמה לסדר הדפסה אפשרי אחד:**\n    1.  P0 מדפיס 'A' (1ms).\n    2.  P0 יוצר P1 ו-P2, ואז נכנס ל-Waiting.\n    3.  המתזמן בוחר את P1. P1 מדפיס 'B' (1ms), ואז רץ בלולאה (100ms). הקוונטה נגמרת. P1 עובר ל-Ready.\n    4.  Context Switch (5ms).\n    5.  המתזמן בוחר את P2. P2 מדפיס 'D' (1ms), ואז רץ בלולאה (100ms). הקוונטה נגמרת. P2 עובר ל-Ready.\n    6.  Context Switch (5ms).\n    7.  המתזמן בוחר את P1. P1 ממשיך בלולאה (50ms), ואז מדפיס 'C' (1ms). P1 מסיים ויוצא.\n    8.  Context Switch (5ms). P0 מתעורר (אם ממתין ל-P1) או עובר ל-Ready. \n    9.  המתזמן בוחר את P2. P2 ממשיך בלולאה (50ms), ואז מדפיס 'E' (1ms). P2 מסיים ויוצא.\n    10. Context Switch (5ms). P0 מתעורר (אם ממתין ל-P2).\n    11. P0 מדפיס 'F' (1ms). P0 מסיים ויוצא.\n\n    **סדר הדפסה אפשרי זה הוא: A -> B -> D -> C -> E -> F**\n    \n    חשוב לציין שקיימים סדרי הדפסה אפשריים נוספים, למשל: A -> D -> B -> E -> C -> F, או A -> B -> D -> E -> C -> F, תלוי בסדר בו המתזמן בוחר את התהליכים מה-Ready Queue לאחר כל החלפת קשר או סיום קוונטה."
    },
    "difficulty_estimation": "Medium"
  }
}