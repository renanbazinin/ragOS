{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:35:48",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4965,
      "output_tokens": 6639,
      "total_tokens": 19733
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Copy-on-Write",
      "Virtual Memory",
      "Process Management"
    ],
    "content": {
      "text": "מערכת הפעלה מודרנית (בדומה ללינוקס) מיישמת את קריאת המערכת `fork()` באמצעות מנגנון Copy-on-Write (CoW) לניהול זיכרון. גודל דף זיכרון הוא 4KB. נתון תהליך P1 עם מבנה זיכרון ראשוני הכולל:\n*   קטע קוד (Text Segment) בגודל 10 דפים (לקריאה בלבד).\n*   קטע נתונים (Data Segment) עבור משתנים גלובליים מאותחלים, בגודל 5 דפים.\n*   ערימה (Heap) בגודל 10 דפים.\n*   מחסנית (Stack) בגודל 2 דפים.\nיש לפרט ולנמק את כל החישובים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "תהליך P1 פועל עם מבנה הזיכרון המתואר לעיל. הוא מבצע `fork()` ליצירת תהליך P2.\nלאחר קריאת ה-`fork()`:\n*   P1 כותב ל-3 דפים שונים בתוך קטע הנתונים שלו.\n*   P2 כותב ל-4 דפים *שונים* בתוך הערימה שלו.\n*   P1 כותב לדף אחד במחסנית שלו.\n*   P2 כותב ל-2 דפים *שונים* בתוך קטע הנתונים שלו (אשר P1 לא כתב אליהם).\nחשבו:\n1.  כמה דפים פיזיים בסך הכל נמצאים בשימוש לאחר כל הפעולות הללו?\n2.  כמה אירועי CoW page faults התרחשו בסך הכל (על ידי P1 ו-P2 יחד)?\nהניחו שכל אזורי הזיכרון רציפים לדוגמה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "נתחו את קטע קוד ה-C הבא. הניחו ש-`PAGE_SIZE` הוא 4096 בתים.\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\n#define PAGE_SIZE 4096\n\n// Global data - will occupy 1 page in data segment\nint global_data[PAGE_SIZE / sizeof(int)]; \n\nint main() {\n    char *heap_buffer_ptr; // Pointer for heap memory\n    \n    // Allocate heap memory for 2 pages\n    heap_buffer_ptr = (char *)malloc(2 * PAGE_SIZE);\n    \n    // Initialize global array (first write to data segment page)\n    for (int i = 0; i < PAGE_SIZE / sizeof(int); ++i) {\n        global_data[i] = i;\n    }\n\n    // Initialize heap buffer (first write to 2 heap pages)\n    for (int i = 0; i < 2 * PAGE_SIZE; ++i) {\n        heap_buffer_ptr[i] = 'X';\n    }\n\n    // Stack variable, will be on stack page\n    int stack_var_parent = 5; \n\n    pid_t pid = fork();\n\n    if (pid == 0) { // Child process\n        printf(\"Child process (PID: %d)\\n\", getpid());\n        // Child modifies global_data page\n        global_data[0] = 100; // CoW on global_data page\n        // Child modifies the first heap page\n        heap_buffer_ptr[0] = 'Y'; // CoW on first heap page\n        // Child modifies its stack page\n        int stack_var_child = 15;\n        stack_var_child++; // CoW on child's stack page\n        printf(\"Child: global_data[0]=%d, heap_buffer_ptr[0]=%c, stack_var_child=%d\\n\", global_data[0], heap_buffer_ptr[0], stack_var_child);\n    } else if (pid > 0) { // Parent process\n        printf(\"Parent process (PID: %d)\\n\", getpid());\n        // Parent modifies global_data page\n        global_data[1] = 200; // CoW on global_data page\n        // Parent modifies the second heap page\n        heap_buffer_ptr[PAGE_SIZE] = 'Z'; // CoW on second heap page\n        // Parent modifies its stack page\n        stack_var_parent++; // CoW on parent's stack page\n        printf(\"Parent: global_data[1]=%d, heap_buffer_ptr[PAGE_SIZE]=%c, stack_var_parent=%d\\n\", global_data[1], heap_buffer_ptr[PAGE_SIZE], stack_var_parent);\n    } else {\n        perror(\"fork failed\");\n        return 1;\n    }\n\n    // Free memory (will be done by both processes independently)\n    free(heap_buffer_ptr);\n\n    return 0;\n}\n```\nחשבו:\n1.  כמה אירועי CoW page faults מתרחשים בסך הכל במהלך ביצוע תהליכי האב והבן לאחר ה-`fork()`?\n2.  כמה דפים פיזיים *חדשים* מוקצים *במיוחד עקב CoW*?\n3.  הסבירו אילו אזורי זיכרון/דפים ספציפיים גורמים ל-CoW עבור כל תהליך.",
        "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\n#define PAGE_SIZE 4096\n\n// Global data - will occupy 1 page in data segment\nint global_data[PAGE_SIZE / sizeof(int)]; \n\nint main() {\n    char *heap_buffer_ptr; // Pointer for heap memory\n    \n    // Allocate heap memory for 2 pages\n    heap_buffer_ptr = (char *)malloc(2 * PAGE_SIZE);\n    \n    // Initialize global array (first write to data segment page)\n    for (int i = 0; i < PAGE_SIZE / sizeof(int); ++i) {\n        global_data[i] = i;\n    }\n\n    // Initialize heap buffer (first write to 2 heap pages)\n    for (int i = 0; i < 2 * PAGE_SIZE; ++i) {\n        heap_buffer_ptr[i] = 'X';\n    }\n\n    // Stack variable, will be on stack page\n    int stack_var_parent = 5; \n\n    pid_t pid = fork();\n\n    if (pid == 0) { // Child process\n        printf(\"Child process (PID: %d)\\n\", getpid());\n        // Child modifies global_data page\n        global_data[0] = 100; // CoW on global_data page\n        // Child modifies the first heap page\n        heap_buffer_ptr[0] = 'Y'; // CoW on first heap page\n        // Child modifies its stack page\n        int stack_var_child = 15;\n        stack_var_child++; // CoW on child's stack page\n        printf(\"Child: global_data[0]=%d, heap_buffer_ptr[0]=%c, stack_var_child=%d\\n\", global_data[0], heap_buffer_ptr[0], stack_var_child);\n    } else if (pid > 0) { // Parent process\n        printf(\"Parent process (PID: %d)\\n\", getpid());\n        // Parent modifies global_data page\n        global_data[1] = 200; // CoW on global_data page\n        // Parent modifies the second heap page\n        heap_buffer_ptr[PAGE_SIZE] = 'Z'; // CoW on second heap page\n        // Parent modifies its stack page\n        stack_var_parent++; // CoW on parent's stack page\n        printf(\"Parent: global_data[1]=%d, heap_buffer_ptr[PAGE_SIZE]=%c, stack_var_parent=%d\\n\", global_data[1], heap_buffer_ptr[PAGE_SIZE], stack_var_parent);\n    } else {\n        perror(\"fork failed\");\n        return 1;\n    }\n\n    // Free memory (will be done by both processes independently)\n    free(heap_buffer_ptr);\n\n    return 0;\n}\n",
        "options": null
      },
      {
        "id": "1.3",
        "text": "שקלו תרחיש שבו תהליך אב מבצע `fork()` לתהלידים צאצאים רבים, וכל תהליך צאצא *רק קורא* מזיכרון האב, אך לעולם אינו כותב אליו. האב, לעומת זאת, כותב לעיתים קרובות לזיכרונו.\n1.  תארו את השלכות הביצועים של מנגנון CoW בתרחיש זה.\n2.  האם יהיה יעיל יותר לבטל את CoW עבור `fork()` בתרחיש כזה, ובמקום זאת לבצע העתקה מלאה של זיכרון האב לכל צאצא? נמקו את תשובתכם תוך התחשבות הן בניצול זיכרון והן בביצועים.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### פתרון לשאלה 1.1:\n\n*   **דפים פיזיים התחלתיים (לפני `fork()`):**\n    *   קטע קוד (Text): 10 דפים (לקריאה בלבד, משותפים כברירת מחדל).\n    *   קטע נתונים (Data): 5 דפים (לקריאה-כתיבה, מועמדים ל-CoW).\n    *   ערימה (Heap): 10 דפים (לקריאה-כתיבה, מועמדים ל-CoW).\n    *   מחסנית (Stack): 2 דפים (לקריאה-כתיבה, מועמדים ל-CoW).\n    *   סה\"כ: 10 (Text) + 5 (Data) + 10 (Heap) + 2 (Stack) = 27 דפים פיזיים.\n    *   כל 27 הדפים הללו משותפים בין P1 ו-P2 מיד לאחר ה-`fork()` (למעט דפי ה-Text שהם תמיד משותפים ו-read-only).\n\n*   **P1 כותב ל-3 דפי נתונים:**\n    *   3 דפים אלו היו משותפים. כל כתיבה מפעילה CoW fault.\n    *   P1 מקבל עותקים משלו ל-3 דפים אלה.\n    *   **CoW faults:** 3\n    *   **דפים פיזיים חדשים:** 3\n\n*   **P2 כותב ל-4 דפי ערימה:**\n    *   4 דפים אלו היו משותפים. כל כתיבה מפעילה CoW fault.\n    *   P2 מקבל עותקים משלו ל-4 דפים אלה.\n    *   **CoW faults:** 4 (סה\"כ מצטבר: 3+4=7)\n    *   **דפים פיזיים חדשים:** 4 (סה\"כ מצטבר: 3+4=7)\n\n*   **P1 כותב לדף מחסנית אחד:**\n    *   דף זה היה משותף. כתיבה זו מפעילה CoW fault.\n    *   P1 מקבל עותק משלו לדף זה.\n    *   **CoW faults:** 1 (סה\"כ מצטבר: 7+1=8)\n    *   **דפים פיזיים חדשים:** 1 (סה\"כ מצטבר: 7+1=8)\n\n*   **P2 כותב ל-2 דפי נתונים *שונים* (מאלו ש-P1 כתב אליהם):**\n    *   השאלה מציינת \"דפים שונים מאלו ש-P1 כתב אליהם\", מה שמרמז ש-P1 כתב ל-3 דפים מתוך ה-5, ו-P2 כותב ל-2 הנותרים (5-3=2) שעדיין היו משותפים.\n    *   2 דפים אלו היו משותפים. כל כתיבה מפעילה CoW fault.\n    *   P2 מקבל עותקים משלו ל-2 דפים אלה.\n    *   **CoW faults:** 2 (סה\"כ מצטבר: 8+2=10)\n    *   **דפים פיזיים חדשים:** 2 (סה\"כ מצטבר: 8+2=10)\n\n*   **חישובים מסכמים:**\n    1.  **סה\"כ דפים פיזיים בשימוש:**\n        *   **Text:** 10 דפים (משותפים, read-only). נשארים 10 דפים פיזיים.\n        *   **Data:** היו 5 דפים מקוריים. P1 עשה CoW ל-3 מהם, P2 עשה CoW ל-2 הנותרים. כלומר, 3 עותקים חדשים עבור P1, ו-2 עותקים חדשים עבור P2. 5 הדפים המקוריים כבר לא משותפים בכתיבה, אלא כל אחד מהם שייך או ל-P1 או ל-P2 (אם לא נוצר עותק חדש עבורו). למעשה, 5 דפים מקוריים + 3 עותקים חדשים עבור P1 + 2 עותקים חדשים עבור P2 = 10 דפי נתונים פיזיים בסך הכל.\n        *   **Heap:** היו 10 דפים מקוריים. P2 עשה CoW ל-4 מהם. כלומר, 4 עותקים חדשים עבור P2, ו-6 דפים נשארים משותפים (רק ל-P1). למעשה, 10 דפים מקוריים + 4 עותקים חדשים עבור P2 = 14 דפי ערימה פיזיים בסך הכל.\n        *   **Stack:** היו 2 דפים מקוריים. P1 עשה CoW לדף אחד. כלומר, עותק חדש אחד עבור P1, ודף אחד נשאר משותף (רק ל-P2). למעשה, 2 דפים מקוריים + 1 עותק חדש עבור P1 = 3 דפי מחסנית פיזיים בסך הכל.\n        *   **סה\"כ דפים פיזיים:** 10 (Text) + 10 (Data) + 14 (Heap) + 3 (Stack) = **37 דפים פיזיים**.\n    2.  **סה\"כ CoW page faults:**\n        *   P1 כותב ל-3 דפי נתונים -> 3 faults.\n        *   P2 כותב ל-4 דפי ערימה -> 4 faults.\n        *   P1 כותב לדף מחסנית אחד -> 1 fault.\n        *   P2 כותב ל-2 דפי נתונים -> 2 faults.\n        *   סה\"כ CoW faults = 3 + 4 + 1 + 2 = **10 faults**.\n\n### פתרון לשאלה 1.2:\n\n*   **מצב התחלתי (לפני `fork()`):**\n    *   `global_data`: דף אחד (קטע נתונים). מאותחל בלולאת `main`.\n    *   `heap_buffer_ptr`: 2 דפים (ערימה). מוקצים באמצעות `malloc`, מאותחלים בלולאת `main`.\n    *   `stack_var_parent`: על המחסנית.\n    *   **קטע קוד (Text):** דף אחד (עבור קוד `main`, `printf` וכו').\n    *   סה\"כ דפים התחלתיים: 1 (Text) + 1 (global_data) + 2 (Heap) + 1 (Stack עבור `main` ו-`stack_var_parent`) = 5 דפים. כולם לקריאה-כתיבה למעט Text (לקריאה בלבד).\n    *   לאחר ה-`fork()`, 5 דפים אלו משותפים בין תהליך האב (P) ותהליך הבן (C). דפי הנתונים, הערימה והמחסנית מסומנים כ-CoW.\n\n*   **תהליך הבן (pid == 0):**\n    *   `global_data[0] = 100;`: זוהי כתיבה לדף `global_data`.\n        *   **CoW fault: 1.** דף פיזי חדש מוקצה עבור העותק הפרטי של הבן לדף `global_data`.\n        *   **דפים פיזיים חדשים עקב CoW: 1.**\n    *   `heap_buffer_ptr[0] = 'Y';`: זוהי כתיבה לדף הערימה הראשון (אליו מצביע `heap_buffer_ptr`).\n        *   **CoW fault: 1.** דף פיזי חדש מוקצה עבור העותק הפרטי של הבן לדף הערימה הראשון.\n        *   **דפים פיזיים חדשים עקב CoW: 1.**\n    *   `stack_var_child++;`: זוהי שינוי של משתנה במחסנית של הבן.\n        *   **CoW fault: 1.** דף פיזי חדש מוקצה עבור העותק הפרטי של הבן לדף המחסנית שלו.\n        *   **דפים פיזיים חדשים עקב CoW: 1.**\n    *   `char temp = heap_buffer_ptr[PAGE_SIZE];`: זוהי פעולת קריאה לדף הערימה השני. אין כתיבה, ולכן אין CoW fault.\n\n*   **תהליך האב (pid > 0):**\n    *   `global_data[1] = 200;`: זוהי כתיבה לדף `global_data`. דף זה כבר עבר CoW על ידי הבן. כעת האב גם כותב אליו.\n        *   **CoW fault: 1.** דף פיזי חדש מוקצה עבור העותק הפרטי של האב לדף `global_data`. (הדף המקורי נשאר עם הנתונים המשותפים, והבן והאב מקבלים כל אחד עותק משלו. חשוב לציין שכל תהליך מקבל עותק משלו בעת הכתיבה *הראשונה* שלו לדף משותף).\n        *   **דפים פיזיים חדשים עקב CoW: 1.**\n    *   `heap_buffer_ptr[PAGE_SIZE] = 'Z';`: זוהי כתיבה לדף הערימה השני.\n        *   **CoW fault: 1.** דף פיזי חדש מוקצה עבור העותק הפרטי של האב לדף הערימה השני.\n        *   **דפים פיזיים חדשים עקב CoW: 1.**\n    *   `stack_var_parent++;`: זוהי שינוי של משתנה במחסנית של האב.\n        *   **CoW fault: 1.** דף פיזי חדש מוקצה עבור העותק הפרטי של האב לדף המחסנית שלו.\n        *   **דפים פיזיים חדשים עקב CoW: 1.**\n\n*   **חישובים מסכמים:**\n    1.  **סה\"כ CoW page faults:**\n        *   בן: 1 (global_data) + 1 (דף ערימה 1) + 1 (מחסנית) = 3 faults.\n        *   אב: 1 (global_data) + 1 (דף ערימה 2) + 1 (מחסנית) = 3 faults.\n        *   סה\"כ CoW faults = 3 + 3 = **6 faults**.\n    2.  **סה\"כ דפים פיזיים חדשים עקב CoW:**\n        *   בן: 1 (global_data) + 1 (דף ערימה 1) + 1 (מחסנית) = 3 דפים חדשים.\n        *   אב: 1 (global_data) + 1 (דף ערימה 2) + 1 (מחסנית) = 3 דפים חדשים.\n        *   סה\"כ דפים פיזיים חדשים = 3 + 3 = **6 דפים**.\n    3.  **הסבר על טריגרי CoW:**\n        *   **תהליך הבן:**\n            *   `global_data[0] = 100;`: מפעיל CoW עבור דף `global_data`. הבן מקבל עותק פרטי וניתן לכתיבה של דף זה.\n            *   `heap_buffer_ptr[0] = 'Y';`: מפעיל CoW עבור הדף הראשון של ה-heap buffer. הבן מקבל עותק פרטי וניתן לכתיבה.\n            *   `stack_var_child++;`: מפעיל CoW עבור דף המחסנית של הבן. הבן מקבל עותק פרטי וניתן לכתיבה.\n        *   **תהליך האב:**\n            *   `global_data[1] = 200;`: מפעיל CoW עבור דף `global_data`. האב מקבל עותק פרטי וניתן לכתיבה. שימו לב שלמרות שהבן גם כתב לדף זה, הכתיבות שלהם עצמאיות לאחר שכל תהליך קיבל עותק משלו.\n            *   `heap_buffer_ptr[PAGE_SIZE] = 'Z';`: מפעיל CoW עבור הדף השני של ה-heap buffer. האב מקבל עותק פרטי וניתן לכתיבה.\n            *   `stack_var_parent++;`: מפעיל CoW עבור דף המחסנית של האב. האב מקבל עותק פרטי וניתן לכתיבה.\n\n### פתרון לשאלה 1.3:\n\n1.  **השלכות הביצועים של CoW בתרחיש זה:**\n    *   **ניצול זיכרון:** CoW יעיל ביותר בתרחיש זה. מכיוון שהתהליכים הצאצאים רק קוראים, הם חולקים את כל דפי הזיכרון של האב (Text, Data, Heap, Stack) ללא העתקה ראשונית כלשהי. רק כתיבות של האב יפעילו CoW faults. המשמעות היא שעבור *כל* דף שהאב כותב אליו, עותק חדש ייווצר *רק עבור האב*. התהליכים הצאצאים ממשיכים לחלוק את הדף *המקורי*. זה מוביל לכפילות זיכרון מינימלית בין הצאצאים ולשימוש יעיל ב-RAM פיזי.\n    *   **תקורת ביצועים:**\n        *   קריאת `fork()` עצמה מהירה מאוד מכיוון שהיא רק מעתיקה טבלאות דפים ומסמנת דפים כ-read-only.\n        *   כתיבות האב: כל כתיבה של האב לדף משותף תגרום ל-CoW page fault. זה כרוך ב:\n            *   מלכודת (trap) לקרנל.\n            *   הקצאת דף פיזי חדש.\n            *   העתקת תוכן הדף המקורי לדף החדש.\n            *   עדכון ערך בטבלת הדפים של האב כדי שיצביע לדף הפרטי החדש ויסמן אותו כניתן לכתיבה.\n            *   עדכון מונה ההפניות של הדף המקורי (הפחתה) או סימונו כניתן לכתיבה עבור הצאצאים (אם לא קיימים עותקים ניתנים לכתיבה אחרים). \n            *   חזרה למרחב המשתמש.\n        *   תקורה זו יכולה להיות משמעותית אם האב כותב לדפים ייחודיים רבים, שכן כל כתיבה ראשונה לדף משותף יקרה יותר מכתיבה רגילה. עם זאת, כתיבות עוקבות לאותו דף על ידי האב לא יפעילו CoW faults נוספים.\n        *   קריאות הצאצאים: פעולות הקריאה של הצאצאים מהירות כמו קריאות רגילות, מכיוון שהן אינן מפעילות CoW faults.\n\n2.  **האם יהיה יעיל יותר לבטל את CoW ולבצע העתקה מלאה?**\n    *   **לא, בדרך כלל לא יהיה יעיל יותר לבטל את CoW ולבצע העתקה מלאה.**\n    *   **ניצול זיכרון:** העתקה מלאה תשכפל באופן מיידי את *כל* הזיכרון של האב עבור *כל* צאצא. אם ישנם צאצאים רבים, זה יוביל לעלייה עצומה בצריכת הזיכרון הפיזי (לדוגמה, אם לאב יש 1GB זיכרון ו-100 צאצאים, יידרשו 101GB RAM באופן ראשוני). עם CoW, רק קטע הקוד והדפים ששונו בפועל על ידי האב ישוכפלו, מה שיוביל לניצול זיכרון נמוך בהרבה.\n    *   **ביצועים:**\n        *   `fork()` עם העתקה מלאה יהיה איטי בהרבה, מכיוון שהוא כרוך בהעתקת כל דף ודף מזיכרון האב לפני שהבן בכלל יכול להתחיל בביצוע. זוהי עלות ראשונית משמעותית.\n        *   לאחר ההעתקה הראשונית, הן האב והן הצאצאים יחזיקו בעותקים פרטיים משלהם של כל הדפים. המשמעות היא שכתיבות עוקבות של האב *לא* יגרמו ל-CoW faults. עם זאת, העלות הראשונית של העתקת הכל גדולה בדרך כלל בהרבה מהעלות המצטברת של CoW faults עבור דפים ששונו בפועל.\n    *   **מסקנה:** בתרחיש זה, שבו הצאצאים בעיקר קוראים והאב כותב, CoW מועיל מאוד. הוא ממזער את התקורה הראשונית של `fork()` ואת טביעת הרגל של הזיכרון, וגורר עלויות רק עבור דפים ששונו בפועל על ידי האב. העתקה מלאה תהיה מזיקה הן ליעילות הזיכרון והן לביצועי ה-`fork()`."
    },
    "difficulty_estimation": "Hard"
  }
}