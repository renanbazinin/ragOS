{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Synchronization and Deadlocks",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:52:34",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 5388,
      "output_tokens": 2288,
      "total_tokens": 14533
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Deadlocks",
      "Concurrency"
    ],
    "content": {
      "text": "במערכת מרובת-חוטים, ישנם N חריצים (slots) הממוספרים מ-0 עד N-1. כל חריץ יכול להיות תפוס על ידי חוט אחד בלבד בכל רגע נתון. חוטים במערכת צריכים לתפוס שני חריצים סמוכים כדי לבצע פעולה כלשהי. חריצים סמוכים כוללים חריץ i וחריץ (i+1) % N (כלומר, החריצים מסודרים במעגל). לצורך סנכרון, לכל חריץ i קיים מנעול pthread_mutex_t slot_mutexes[i]. הקוד הבא מציג ניסיון לממש את לוגיקת תפיסת שני חריצים סמוכים עבור חוט המייצג את פילוסוף מספר id:\n\n1. האם הקוד הנתון עלול להוביל למצב של קיפאון (deadlock)? אם כן, הסבירו בפירוט מדוע, תוך התייחסות לארבעת התנאים ההכרחיים לקיפאון.\n\n2. תקנו את הפונקציה thread_func כך שתמנע קיפאון, תוך שימוש במנעולי pthread_mutex_t בלבד (קריאות pthread_mutex_lock, pthread_mutex_unlock). יש לשמור על רמת מקביליות גבוהה ככל האפשר ולהימנע מרעב (starvation). הציגו את הקוד המתוקן.",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For sleep\n\n#define N_SLOTS 5 // Example: 5 slots/philosophers\n\npthread_mutex_t slot_mutexes[N_SLOTS];\n\nvoid* thread_func(void* arg) {\n    int id = *(int*)arg;\n    int left_slot = id;\n    int right_slot = (id + 1) % N_SLOTS;\n\n    while (1) {\n        printf(\"Thread %d wants slots %d and %d\\n\", id, left_slot, right_slot);\n\n        // Naive attempt to acquire slots\n        pthread_mutex_lock(&slot_mutexes[left_slot]);\n        printf(\"Thread %d acquired slot %d\\n\", id, left_slot);\n\n        pthread_mutex_lock(&slot_mutexes[right_slot]);\n        printf(\"Thread %d acquired slot %d\\n\", id, right_slot);\n\n        printf(\"Thread %d acquired both slots %d and %d. Performing work...\\n\", id, left_slot, right_slot);\n        sleep(1); // Simulate work\n\n        pthread_mutex_unlock(&slot_mutexes[right_slot]);\n        printf(\"Thread %d released slot %d\\n\", id, right_slot);\n\n        pthread_mutex_unlock(&slot_mutexes[left_slot]);\n        printf(\"Thread %d released slot %d\\n\", id, left_slot);\n\n        sleep(1); // Think\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[N_SLOTS];\n    int ids[N_SLOTS];\n\n    for (int i = 0; i < N_SLOTS; ++i) {\n        pthread_mutex_init(&slot_mutexes[i], NULL);\n    }\n\n    for (int i = 0; i < N_SLOTS; ++i) {\n        ids[i] = i;\n        pthread_create(&threads[i], NULL, thread_func, &ids[i]);\n    }\n\n    for (int i = 0; i < N_SLOTS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    for (int i = 0; i < N_SLOTS; ++i) {\n        pthread_mutex_destroy(&slot_mutexes[i]);\n    }\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. הקוד הנתון אכן עלול להוביל למצב של קיפאון (deadlock). ההסבר לכך מתבסס על ארבעת התנאים ההכרחיים לקיפאון:\n   - **מניעה הדדית (Mutual Exclusion)**: כל מנעול (mutex) של חריץ יכול להיות מוחזק על ידי חוט אחד בלבד בכל רגע נתון. תנאי זה מתקיים.\n   - **החזק והמתן (Hold and Wait)**: חוט תופס מנעול אחד (לדוגמה, slot_mutexes[left_slot]) וממתין למנעול נוסף (slot_mutexes[right_slot]). תנאי זה מתקיים.\n   - **אי-נשללות (No Preemption)**: לא ניתן ליטול מנעול מחוט שמחזיק בו בכוח. רק החוט שמחזיק במנעול יכול לשחרר אותו. תנאי זה מתקיים.\n   - **המתנה מעגלית (Circular Wait)**: זהו התנאי שמוביל לקיפאון במקרה זה. דמיינו את התרחיש הבא: כל חוט (פילוסוף) תופס את המנעול השמאלי שלו וממתין למנעול הימני שלו. לדוגמה:\n     - חוט 0 תופס את slot_mutexes[0] וממתין ל-slot_mutexes[1].\n     - חוט 1 תופס את slot_mutexes[1] וממתין ל-slot_mutexes[2].\n     - ...\n     - חוט N-2 תופס את slot_mutexes[N-2] וממתין ל-slot_mutexes[N-1].\n     - חוט N-1 תופס את slot_mutexes[N-1] וממתין ל-slot_mutexes[0].\n     נוצר מעגל של המתנה, כאשר כל חוט ממתין למשאב שמוחזק על ידי החוט הבא במעגל, וכל החוטים לא יוכלו להתקדם. זהו מצב של קיפאון.\n\n2. כדי למנוע קיפאון, עלינו לשבור אחד מארבעת התנאים. הדרך הנפוצה והיעילה ביותר במצב זה היא לשבור את תנאי ההמתנה המעגלית על ידי הטלת סדר גלובלי על תפיסת המשאבים (המנעולים). אסטרטגיה אחת היא לדרוש מכל החוטים לתפוס את המנעולים תמיד לפי סדר עולה של המזהים שלהם. חוט N-1 הוא מקרה מיוחד שיצטרך לתפוס קודם את מנעול 0 (שהוא הנמוך מבין 0 ו-N-1) ואז את מנעול N-1. זה שובר את המעגל ומונע קיפאון, תוך שמירה על רמת מקביליות סבירה וללא רעב.\n\nקוד מתוקן לפונקציה `thread_func`:\n```c\nvoid* thread_func(void* arg) {\n    int id = *(int*)arg;\n    int slot1, slot2;\n\n    // Determine the order of acquiring slots based on ID to break circular wait\n    // For most threads: acquire id then (id+1)%N_SLOTS\n    // Special case for thread N-1: acquire (id+1)%N_SLOTS (which is 0) then id\n    if (id < (id + 1) % N_SLOTS) {\n        slot1 = id;\n        slot2 = (id + 1) % N_SLOTS;\n    } else { \n        slot1 = (id + 1) % N_SLOTS; // This will be 0 for id = N_SLOTS - 1\n        slot2 = id;\n    }\n\n    while (1) {\n        printf(\"Thread %d wants slots %d and %d (ordered: %d then %d)\\n\", id, id, (id+1)%N_SLOTS, slot1, slot2);\n\n        pthread_mutex_lock(&slot_mutexes[slot1]);\n        printf(\"Thread %d acquired slot %d\\n\", id, slot1);\n\n        pthread_mutex_lock(&slot_mutexes[slot2]);\n        printf(\"Thread %d acquired slot %d\\n\", id, slot2);\n\n        printf(\"Thread %d acquired both slots %d and %d. Performing work...\\n\", id, id, (id+1)%N_SLOTS);\n        sleep(1); // Simulate work\n\n        pthread_mutex_unlock(&slot_mutexes[slot2]);\n        printf(\"Thread %d released slot %d\\n\", id, slot2);\n\n        pthread_mutex_unlock(&slot_mutexes[slot1]);\n        printf(\"Thread %d released slot %d\\n\", id, slot1);\n\n        sleep(1); // Think\n    }\n    return NULL;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}