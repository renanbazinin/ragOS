{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Synchronization and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:54:36",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3054,
      "output_tokens": 3460,
      "total_tokens": 15283
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Deadlocks",
      "Readers-Writers Problem",
      "Condition Variables",
      "Starvation"
    ],
    "content": {
      "text": "נתון מימוש (חלקי) של מנגנון סנכרון \"קוראים-כותבים\" (Readers-Writers Lock) בשפת C/C++, המיועד להגן על משאב משותף. המנגנון מאפשר למספר קוראים לגשת למשאב במקביל, אך רק לכותב אחד לגשת למשאב בבלעדיות בכל רגע נתון. המטרה העיקרית של מימוש זה היא למנוע הרעבה של כותבים (Writer Starvation), כלומר, להבטיח שכותבים הממתינים יזכו לגישה למשאב תוך זמן סביר.\n\n```c\n#include <pthread.h> // Assume pthreads library is available\n\ntypedef struct {\n    pthread_mutex_t lock;\n    pthread_cond_t readers_q;\n    pthread_cond_t writers_q;\n    int readers_active; // Number of active readers\n    int writers_active; // 0 or 1\n    int writers_waiting; // Number of writers waiting\n} rw_lock_t;\n\nvoid rw_init(rw_lock_t *rw) {\n    pthread_mutex_init(&rw->lock, NULL);\n    pthread_cond_init(&rw->readers_q, NULL);\n    pthread_cond_init(&rw->writers_q, NULL);\n    rw->readers_active = 0;\n    rw->writers_active = 0;\n    rw->writers_waiting = 0;\n}\n\nvoid rw_destroy(rw_lock_t *rw) {\n    pthread_mutex_destroy(&rw->lock);\n    pthread_cond_destroy(&rw->readers_q);\n    pthread_cond_destroy(&rw->writers_q);\n}\n\nvoid rw_read_lock(rw_lock_t *rw) {\n    pthread_mutex_lock(&rw->lock);\n    while (rw->writers_active > 0 || rw->writers_waiting > 0) {\n        pthread_cond_wait(&rw->readers_q, &rw->lock);\n    }\n    rw->readers_active++;\n    pthread_mutex_unlock(&rw->lock);\n}\n\nvoid rw_read_unlock(rw_lock_t *rw) {\n    pthread_mutex_lock(&rw->lock);\n    rw->readers_active--;\n    if (rw->readers_active == 0) {\n        pthread_cond_signal(&rw->writers_q);\n    }\n    pthread_mutex_unlock(&rw->lock);\n}\n\nvoid rw_write_lock(rw_lock_t *rw) {\n    pthread_mutex_lock(&rw->lock);\n    rw->writers_waiting++;\n    while (rw->readers_active > 0 || rw->writers_active > 0) {\n        pthread_cond_wait(&rw->writers_q, &rw->lock);\n    }\n    rw->writers_waiting--;\n    rw->writers_active = 1;\n    pthread_mutex_unlock(&rw->lock);\n}\n\nvoid rw_write_unlock(rw_lock_t *rw) {\n    pthread_mutex_lock(&rw->lock);\n    rw->writers_active = 0;\n    if (rw->writers_waiting > 0) {\n        pthread_cond_signal(&rw->writers_q);\n    } else {\n        // שימו לב לשורה זו\n        pthread_cond_signal(&rw->readers_q);\n    }\n    pthread_mutex_unlock(&rw->lock);\n}\n```\n\n1.  האם המימוש מקיים מניעה הדדית (Mutual Exclusion) עבור כותבים? האם הוא מאפשר קריאה מקבילית? נמקו.\n2.  האם המימוש חופשי מקיפאון (Deadlock-free)? נמקו.\n3.  האם המימוש מבטיח אי-הרעבה (Starvation-free) לכותבים? נמקו.\n4.  האם המימוש מבטיח אי-הרעבה (Starvation-free) לקוראים? נמקו.\n5.  אם זיהיתם כשל כלשהו בסעיפים הקודמים (במיוחד בהיבטי אי-הרעבה או קיפאון), תקנו את המימוש באופן שיפתור את הכשל, תוך שמירה על המטרה המקורית למנוע הרעבה של כותבים, ונסחו מחדש את הקוד המתוקן.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **מניעה הדדית וקריאה מקבילית:**\n    *   **מניעה הדדית לכותבים:** כן, המימוש מבטיח מניעה הדדית לכותבים. המשתנה `writers_active` יכול להיות 0 או 1 בלבד, וכותב יכול להיכנס רק כאשר `writers_active` הוא 0 וגם `readers_active` הוא 0. כל כותב ממתין ב-`while (rw->readers_active > 0 || rw->writers_active > 0)` עד לתנאים אלה.\n    *   **קריאה מקבילית:** כן, המימוש מאפשר למספר קוראים לגשת למשאב במקביל. קוראים מגדילים את `readers_active` ויכולים להיכנס כל עוד אין כותב פעיל (`writers_active == 0`) ואין כותבים ממתינים (`writers_waiting == 0`). אין מגבלה על מספר הקוראים הפעילים.\n\n2.  **חופש מקיפאון (Deadlock-free):**\n    *   כן, המימוש נראה חופשי מקיפאון.\n        *   כותב לעולם לא יחזיק את המוטקס (`rw->lock`) בזמן שהוא ממתין על משתנה תנאי (`writers_q`). הוא משחרר את המוטקס לפני ההמתנה.\n        *   קורא לעולם לא יחזיק את המוטקס בזמן שהוא ממתין על משתנה תנאי (`readers_q`). הוא משחרר את המוטקס לפני ההמתנה.\n        *   הסדר שבו כותבים וקוראים ממתינים ומשוחררים מתוכנן כך שאין מעגל המתנה: קוראים ממתינים אם כותב פעיל או ממתין; כותבים ממתינים אם יש קוראים פעילים או כותב פעיל. קוראים משחררים כותבים, וכותבים משחררים קוראים או כותבים אחרים.\n        *   הקפדה על שחרור המוטקס לפני המתנה מונעת מצב שבו תהליך אחד מחזיק את המוטקס וממתין למשהו שרק תהליך אחר יכול לשחרר, כאשר התהליך האחר חסום בעצמו על אותו מוטקס.\n        *   אין מצב שבו כותב פעיל או קורא פעיל יחסום את שחרור המוטקס באופן קבוע.\n\n3.  **אי-הרעבה לכותבים (Writer Starvation-free):**\n    *   כן, המימוש מבטיח אי-הרעבה לכותבים.\n        *   ברגע שכותב מגיע, הוא מגדיל את `writers_waiting`. קוראים חדשים לא יכולים להיכנס אם `writers_waiting > 0`. זה נותן עדיפות לכותבים.\n        *   קוראים פעילים יסיימו בסופו של דבר את עבודתם, וכאשר הקורא האחרון מסיים (`readers_active == 0`), הוא מאותת לכותבים ממתינים (`pthread_cond_signal(&rw->writers_q)`). \n        *   לאחר שכותב מסיים, אם יש כותבים נוספים ממתינים (`rw->writers_waiting > 0`), הוא מאותת לאחד מהם (`pthread_cond_signal(&rw->writers_q)`).\n        *   מנגנון זה מבטיח שכותבים מקבלים עדיפות על פני קוראים חדשים, וכותב תמיד יקבל גישה למשאב ברגע שיתפנה, לכן כותבים לא יורעבו.\n\n4.  **אי-הרעבה לקוראים (Reader Starvation-free):**\n    *   **לא, המימוש אינו מבטיח אי-הרעבה לקוראים.** זוהי נקודת הכשל העיקרית במימוש זה.\n    *   הבעיה טמונה בשורה `pthread_cond_signal(&rw->readers_q);` בפעולה `rw_write_unlock`. כאשר כותב מסיים ואין כותבים נוספים הממתינים, הוא מאותת רק ל**קורא אחד** שממתין בתור.\n    *   **תרחיש הרעבה:**\n        1.  מספר רב של קוראים (לדוגמה: R1, R2, R3, R4) מגיעים וממתינים כי יש כותב פעיל או ממתין.\n        2.  כותב (W1) מסיים את עבודתו. אין כותבים נוספים ממתינים.\n        3.  `rw_write_unlock` מאותת ל-R1 בלבד. R1 מתעורר, נכנס ל-`rw_read_lock`, מגדיל את `readers_active` ומשחרר את המוטקס.\n        4.  מיד לאחר מכן, כותב חדש (W2) מגיע וקורא ל-`rw_write_lock`. הוא רואה ש-R1 פעיל (`readers_active > 0`), ולכן הוא נכנס למצב המתנה, ומגדיל את `writers_waiting`.\n        5.  R1 מסיים את עבודתו. `rw_read_unlock` מקטין את `readers_active` ל-0, ומאותת ל-W2.\n        6.  W2 מתעורר, נכנס, מסיים את עבודתו.\n        7.  `rw_write_unlock` מקטין את `writers_active` ל-0. אין כותבים נוספים ממתינים. הוא מאותת ל-R2 בלבד.\n        8.  מחזור זה חוזר על עצמו. אם כותבים חדשים ממשיכים להגיע במהירות מספקת, לפני שכל הקוראים שהמתינו במקור מספיקים להיכנס, רק קורא אחד יוכל להיכנס בכל \"חלון\" שבו אין כותבים ממתינים, ומיד ייתפס המשאב על ידי כותב חדש. קוראים כמו R3 ו-R4 עלולים להמתין ללא הגבלת זמן.\n\n5.  **תיקון המימוש:**\n    *   כדי למנוע הרעבה של קוראים (תוך שמירה על עדיפות כותבים ואי-הרעבת כותבים), יש לשנות את ה-`pthread_cond_signal` ל-`pthread_cond_broadcast` כאשר כותב מסיים ואין כותבים ממתינים. זאת כדי להעיר את **כל** הקוראים הממתינים, ולאפשר להם להיכנס למשאב במקביל.\n\n    ```c\n    #include <pthread.h> // Assume pthreads library is available\n\n    typedef struct {\n        pthread_mutex_t lock;\n        pthread_cond_t readers_q;\n        pthread_cond_t writers_q;\n        int readers_active; // Number of active readers\n        int writers_active; // 0 or 1\n        int writers_waiting; // Number of writers waiting\n    } rw_lock_t;\n\n    void rw_init(rw_lock_t *rw) {\n        pthread_mutex_init(&rw->lock, NULL);\n        pthread_cond_init(&rw->readers_q, NULL);\n        pthread_cond_init(&rw->writers_q, NULL);\n        rw->readers_active = 0;\n        rw->writers_active = 0;\n        rw->writers_waiting = 0;\n    }\n\n    void rw_destroy(rw_lock_t *rw) {\n        pthread_mutex_destroy(&rw->lock);\n        pthread_cond_destroy(&rw->readers_q);\n        pthread_cond_destroy(&rw->writers_q);\n    }\n\n    void rw_read_lock(rw_lock_t *rw) {\n        pthread_mutex_lock(&rw->lock);\n        while (rw->writers_active > 0 || rw->writers_waiting > 0) {\n            pthread_cond_wait(&rw->readers_q, &rw->lock);\n        }\n        rw->readers_active++;\n        pthread_mutex_unlock(&rw->lock);\n    }\n\n    void rw_read_unlock(rw_lock_t *rw) {\n        pthread_mutex_lock(&rw->lock);\n        rw->readers_active--;\n        if (rw->readers_active == 0) {\n            pthread_cond_signal(&rw->writers_q);\n        }\n        pthread_mutex_unlock(&rw->lock);\n    }\n\n    void rw_write_lock(rw_lock_t *rw) {\n        pthread_mutex_lock(&rw->lock);\n        rw->writers_waiting++;\n        while (rw->readers_active > 0 || rw->writers_active > 0) {\n            pthread_cond_wait(&rw->writers_q, &rw->lock);\n        }\n        rw->writers_waiting--;\n        rw->writers_active = 1;\n        pthread_mutex_unlock(&rw->lock);\n    }\n\n    void rw_write_unlock(rw_lock_t *rw) {\n        pthread_mutex_lock(&rw->lock);\n        rw->writers_active = 0;\n        if (rw->writers_waiting > 0) {\n            pthread_cond_signal(&rw->writers_q);\n        } else {\n            // תיקון: שינוי מ-signal ל-broadcast\n            pthread_cond_broadcast(&rw->readers_q);\n        }\n        pthread_mutex_unlock(&rw->lock);\n    }\n    ```"
    },
    "difficulty_estimation": "Hard"
  }
}