{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 08:58:30",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3509,
      "output_tokens": 3113,
      "total_tokens": 11977
    }
  },
  "question": {
    "id": 15,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Copy-on-Write",
      "Processes"
    ],
    "content": {
      "text": "קריאת המערכת `fork()` יוצרת תהליך בן (child process) שהוא כמעט זהה לתהליך האב (parent process) מבחינת מרחב הכתובות שלו. כדי לשפר את היעילות של `fork()`, מערכות הפעלה רבות משתמשות במנגנון Copy-on-Write (CoW).\n\nנתון קטע הקוד הבא:\n```c\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096\n\nint global_data[PAGE_SIZE / sizeof(int)]; // מערך גלובלי, כנראה משתרע על דף זיכרון אחד\n\nint main() {\n    for (int i = 0; i < PAGE_SIZE / sizeof(int); i++) {\n        global_data[i] = i;\n    }\n\n    pid_t pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        exit(1);\n    } else if (pid == 0) { // תהליך הבן\n        printf(\"Child process: Modifying data...\\n\");\n        global_data[0] = 100; // כתיבה ראשונה\n        global_data[1] = 200; // כתיבה שנייה\n        printf(\"Child process: global_data[0] = %d\\n\", global_data[0]);\n        exit(0);\n    } else { // תהליך האב\n        wait(NULL); // ממתין שהבן יסיים\n        printf(\"Parent process: global_data[0] = %d\\n\", global_data[0]);\n    }\n\n    return 0;\n}\n```\n\n1.  **הסבירו בפירוט את מנגנון ה-Copy-on-Write (CoW) בהקשר של קריאת המערכת `fork()`**. כיצד הוא עובד ברמת דפי הזיכרון (pages) ומהם השינויים בטבלאות הדפים (page tables) המתרחשים כאשר תהליך אב ותהליך בן חולקים דפים במצב CoW?\n2.  **מהם היתרונות המרכזיים של שימוש ב-CoW עבור `fork()`** בהשוואה לשיטה שבה כל הזיכרון של האב משוכפל מיד בתהליך ה-`fork()`?\n3.  בהתייחס לקטע הקוד הנתון, ובהנחה ש-`global_data` נמצא כולו בדף זיכרון אחד: **תארו את רצף האירועים והפעולות (כולל Page Faults, אם רלוונטי) המתרחשים כאשר תהליך הבן כותב ל-`global_data[0]` ולאחר מכן ל-`global_data[1]`**. מה תהיה ההשפעה של CoW על ביצועים במקרה זה, וכיצד היא תשפיע על צריכת הזיכרון?",
      "code_snippet": "#include <unistd.h>\n#include <stdio.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096\n\nint global_data[PAGE_SIZE / sizeof(int)]; // מערך גלובלי, כנראה משתרע על דף זיכרון אחד\n\nint main() {\n    for (int i = 0; i < PAGE_SIZE / sizeof(int); i++) {\n        global_data[i] = i;\n    }\n\n    pid_t pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        exit(1);\n    } else if (pid == 0) { // תהליך הבן\n        printf(\"Child process: Modifying data...\\n\");\n        global_data[0] = 100; // כתיבה ראשונה\n        global_data[1] = 200; // כתיבה שנייה\n        printf(\"Child process: global_data[0] = %d\\n\", global_data[0]);\n        exit(0);\n    } else { // תהליך האב\n        wait(NULL); // ממתין שהבן יסיים\n        printf(\"Parent process: global_data[0] = %d\\n\", global_data[0]);\n    }\n\n    return 0;\n}\n",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **מנגנון Copy-on-Write (CoW) ב-`fork()`:**\n    כאשר קריאת המערכת `fork()` מבוצעת, מערכת ההפעלה אינה משכפלת מיד את כל מרחב הכתובות של תהליך האב לתהליך הבן. במקום זאת, היא מבצעת את הפעולות הבאות:\n    *   **שיתוף דפים**: בתחילה, תהליך האב והבן חולקים את אותם דפים פיזיים בזיכרון. כלומר, כניסות טבלת הדפים (Page Table Entries - PTEs) של האב ושל הבן עבור אותם דפים וירטואליים מצביעות על אותן מסגרות פיזיות (physical frames).\n    *   **סימון לקריאה בלבד**: דפים אלו מסומנים כ'לקריאה בלבד' (read-only) בשתי טבלאות הדפים (של האב ושל הבן).\n    *   **כתיבה ו-Page Fault**: כאשר אחד התהליכים (האב או הבן) מנסה לכתוב לדף משותף זה, המעבד (CPU) מזהה ניסיון כתיבה לדף המסומן כ'לקריאה בלבד'. הדבר גורם ל-Page Fault (הפרעת כתיבה).\n    *   **טיפול ב-Page Fault**: מערכת ההפעלה מטפלת ב-Page Fault:\n        *   היא מקצה מסגרת פיזית חדשה (free frame) עבור התהליך המנסה לכתוב.\n        *   היא מעתיקה את תוכן הדף המשותף המקורי למסגרת הפיזית החדשה שהוקצתה.\n        *   היא מעדכנת את כניסת טבלת הדפים של התהליך הכותב כך שתצביע על המסגרת הפיזית החדשה והפרטית שלו, ומשנה את ההרשאות ל'קריאה וכתיבה' (read-write).\n        *   הדף המקורי נשאר עבור התהליך השני (שלא כתב) וייתכן שיישאר מסומן כ'לקריאה בלבד' אם הוא עדיין משותף עם תהליכים אחרים, או שיוחזרו לו הרשאות כתיבה אם הוא כבר לא משותף (במקרה פשוט של אב ובן בלבד, זה יקרה). ייתכן וגם ספירת התייחסויות (reference count) תשמש לקבוע מתי דף אינו משותף עוד.\n        *   הפקודה שגרמה ל-Page Fault מופעלת מחדש (restarted).\n\n2.  **יתרונות מרכזיים של CoW עבור `fork()`:**\n    *   **מהירות ביצוע `fork()`**: הקריאה ל-`fork()` הופכת למהירה בהרבה, מכיוון שאין צורך להעתיק את כל מרחב הכתובות של האב באופן מיידי. רק טבלאות הדפים (או חלקן) משוכפלות, ודפי הזיכרון עצמם רק משותפים ומסומנים.\n    *   **חיסכון בזיכרון פיזי**: אם תהליך הבן אינו משנה חלקים גדולים ממרחב הכתובות שלו (לדוגמה, אם הוא מבצע `exec()` מיד לאחר מכן, ובכך מחליף את מרחב הכתובות שלו), רוב הדפים לעולם לא ישוכפלו, ובכך נחסך זיכרון פיזי רב. גם אם הוא משנה, רק הדפים הספציפיים ששונו משוכפלים, ולא כל הזיכרון.\n\n3.  **רצף אירועים ופעולות בקטע הקוד הנתון:**\n    *   **לאחר `fork()`**: תהליך האב והבן חולקים את הדף הפיזי המכיל את המערך `global_data`. כניסות טבלת הדפים של שניהם מצביעות על אותו דף פיזי, והדף מסומן כ'לקריאה בלבד' בשתי טבלאות הדפים (של האב ושל הבן).\n    *   **כאשר תהליך הבן כותב ל-`global_data[0] = 100;`**: זוהי הכתיבה הראשונה של הבן לדף המשותף.\n        1.  המעבד מנסה לבצע את הכתיבה לכתובת הווירטואלית של `global_data[0]`. ה-MMU מזהה שהדף הפיזי הממופה לכתובת זו מסומן כ'לקריאה בלבד' (write-protected).\n        2.  נוצר Page Fault.\n        3.  מערכת ההפעלה מקבלת את ההפרעה ומטפלת בה:\n            *   היא מקצה מסגרת פיזית חדשה בזיכרון (לדוגמה, `Frame B`).\n            *   היא מעתיקה את כל התוכן של הדף המקורי (לדוגמה, `Frame A`) לתוך `Frame B`.\n            *   היא מעדכנת את כניסת טבלת הדפים של תהליך הבן עבור הדף הווירטואלי המכיל את `global_data` כך שתצביע כעת על `Frame B`, ומשנה את ההרשאות ל'קריאה וכתיבה'.\n            *   כניסת טבלת הדפים של תהליך האב ממשיכה להצביע על `Frame A` (עם הרשאות 'קריאה בלבד' או 'קריאה וכתיבה' אם אין עוד שותפים, תלוי במימוש).\n            *   הפקודה `global_data[0] = 100;` מופעלת מחדש על הדף הפרטי החדש של הבן (`Frame B`).\n    *   **כאשר תהליך הבן כותב ל-`global_data[1] = 200;`**: זוהי כתיבה נוספת לאותו דף וירטואלי, שכבר הפך להיות פרטי עבור הבן.\n        1.  המעבד מנסה לבצע את הכתיבה לכתובת הווירטואלית של `global_data[1]`. ה-MMU מוצא שכניסת טבלת הדפים של הבן עבור דף זה מצביעה על `Frame B` וההרשאות הן 'קריאה וכתיבה'.\n        2.  אין Page Fault. הכתיבה מתבצעת ישירות ל-`Frame B`.\n\n    **השפעה על ביצועים**: הכתיבה הראשונה לדף משותף ספגה עונש ביצועים משמעותי בשל ה-Page Fault, הקצאת זיכרון, והעתקת הדף (תהליך שכולל גישה לדיסק אם הדף היה מוחלף). כתיבות עוקבות לאותו דף על ידי אותו תהליך הן מהירות ואינן גורמות ל-Page Fault נוסף. אם תהליך הבן היה כותב לדפים וירטואליים שונים, כל כתיבה ראשונה לדף חדש הייתה גורמת ל-Page Fault נוסף.\n\n    **השפעה על צריכת זיכרון**: בתחילה, רק דף פיזי אחד (לדוגמה, `Frame A`) שימש את שניהם עבור `global_data`. לאחר שהבן כתב לראשונה, הוקצה דף פיזי נוסף (לדוגמה, `Frame B`) והזיכרון הפיזי הכולל ששימש את המערך `global_data` הוא כעת שני דפים. כלומר, במקרה זה, CoW גרם להכפלת צריכת הזיכרון עבור דף זה לאחר הכתיבה הראשונה של הבן, אך לא יותר מכך גם אם הבן ימשיך לכתוב לכל הבתים בדף זה."
    },
    "difficulty_estimation": "Medium"
  }
}