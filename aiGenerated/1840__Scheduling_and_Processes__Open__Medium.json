{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-09 21:05:18",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2768,
      "output_tokens": 2489,
      "total_tokens": 9997
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Processes",
      "Process States",
      "System Calls",
      "Context Switching"
    ],
    "content": {
      "text": "תהליכים הם יחידות העבודה הבסיסיות שמערכת ההפעלה מנהלת. תאר את מחזור החיים של תהליך מרגע יצירתו באמצעות קריאת המערכת `fork()` ועד לסיומו, תוך התייחסות למצבי התהליך (Process States) השונים בהם הוא יכול להימצא והאינטראקציה שלו עם מתזמן המעבד (CPU Scheduler).\n\nבהתבסס על קטע הקוד הבא, ובהנחה שמערכת ההפעלה משתמשת באלגוריתם תזמון מסוג Round Robin עם קוואנטום זמן קצר מספיק כדי לאפשר החלפות הקשר תכופות:\n1. תאר את רצף מצבי התהליכים (הורה וילד) ואת המעברים ביניהם מרגע קריאת `fork()` ועד סיום שני התהליכים.\n2. הסבר כיצד מתזמן ה-Round Robin ישפיע על סדר ההדפסות במקרה זה, תוך התייחסות לעומס שנוצר על ידי החלפות הקשר (Context Switches).",
      "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    pid_t pid;\n    printf(\"Parent process (PID: %d) starting.\\n\", getpid());\n\n    pid = fork();\n\n    if (pid < 0) {\n        // Error\n        fprintf(stderr, \"Fork failed.\\n\");\n        return 1;\n    } else if (pid == 0) {\n        // Child process\n        printf(\"Child process (PID: %d) created. Parent PID: %d\\n\", getpid(), getppid());\n        for (int i = 0; i < 3; i++) {\n            printf(\"Child running (%d)...\\n\", i);\n            usleep(10000); // Simulate some work (10ms)\n        }\n        printf(\"Child process (PID: %d) exiting.\\n\", getpid());\n    } else {\n        // Parent process\n        for (int i = 0; i < 2; i++) {\n            printf(\"Parent running (%d)...\\n\", i);\n            usleep(15000); // Simulate some work (15ms)\n        }\n        printf(\"Parent process (PID: %d) waiting for child.\\n\", getpid());\n        wait(NULL); // Wait for child to terminate\n        printf(\"Parent process (PID: %d) finished waiting. Exiting.\\n\", getpid());\n    }\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "תיאור מחזור החיים של תהליך שנוצר באמצעות `fork()`:\n\n**יצירת תהליך (fork()):**\nכאשר תהליך ההורה קורא ל-`fork()`, מערכת ההפעלה יוצרת עותק כמעט זהה של תהליך ההורה, הנקרא תהליך הילד. בשלב זה, שניהם נכנסים למצב **Ready** (מוכן) ומתחרים על המעבד. תהליך ההורה ימשיך מנקודת הקריאה ל-`fork()` עם ערך PID של הילד, ותהליך הילד ימשיך גם הוא מנקודת הקריאה ל-`fork()` אך עם ערך 0. שניהם יכולים לעבור למצב **Running** (רץ) בהתאם להחלטת המתזמן.\n\n**מצבי התהליך ומעברים:**\n*   **Ready (מוכן):** תהליך מוכן לרוץ אך ממתין לתורו לקבל את המעבד. גם ההורה וגם הילד נמצאים במצב זה לאחר ה-`fork()` ולפני שהמתזמן בוחר מי ירוץ. לאחר שחרור המעבד (פסיקה, סיום קוואנטום זמן, או קריאת מערכת חוסמת), תהליך יכול לחזור למצב זה.\n*   **Running (רץ):** תהליך מבצע הוראות על המעבד. המתזמן יכול להעביר תהליך ממצב Ready למצב Running. כאשר תהליך רץ, הוא יכול לעבור למצב Ready (אם נקטע עקב סיום קוואנטום זמן) או למצב Waiting (אם מבצע קריאת מערכת חוסמת, כמו `usleep()` או `wait()`).\n*   **Waiting/Blocked (ממתין/חסום):** תהליך ממתין לאירוע מסוים (למשל, השלמת I/O, קריאת `usleep` מסתיימת, או תהליך ילד מסתיים במקרה של `wait()`). במצב זה, הוא אינו מתחרה על המעבד. כאשר האירוע מתרחש, התהליך עובר למצב Ready.\n*   **Terminated (סיים):** תהליך סיים את ריצתו (בצורה נורמלית או כתוצאה משגיאה). משאביו משוחררים, אך ייתכן שהוא עדיין קיים כתהליך 'זומבי' עד שההורה יקרא לו `wait()` ויאסוף את סטטוס היציאה שלו.\n\n**אינטראקציה עם מתזמן המעבד:**\nהמתזמן אחראי להעביר תהליכים בין המצבים Ready ו-Running. הוא בוחר איזה תהליך ירוץ מבין אלה שבמצב Ready ומנהל את החלפות ההקשר (Context Switches) בין תהליכים.\n\n---\n\n**ניתוח קטע הקוד עם Round Robin:**\n\n**1. רצף מצבי התהליכים והמעברים:**\n*   **התחלה:** תהליך ההורה נמצא במצב Running, מדפיס את הודעת הפתיחה.\n*   **`fork()`:** ההורה קורא ל-`fork()`. הילד נוצר ועובר למצב Ready. ההורה ממשיך לרוץ (או עובר ל-Ready אם מוקטע). המתזמן יבחר מי ירוץ ראשון.\n*   **ריצת הילד (דוגמה):** נניח שהילד נבחר לרוץ. הוא עובר למצב Running, מדפיס את הודעת היצירה. בלולאה, הוא מדפיס ומבצע `usleep(10000)`. במהלך `usleep()`, הילד עובר למצב Waiting. לאחר 10ms, הילד חוזר למצב Ready. כך 3 פעמים.\n*   **ריצת ההורה (דוגמה):** כאשר הילד במצב Waiting (עקב `usleep`) או כאשר תורו מגיע לפי RR, ההורה נבחר לרוץ. ההורה עובר למצב Running. בלולאה, הוא מדפיס ומבצע `usleep(15000)`. במהלך `usleep()`, ההורה עובר למצב Waiting. לאחר 15ms, ההורה חוזר למצב Ready. כך 2 פעמים.\n*   **`wait()` בהורה:** לאחר שההורה מסיים את הלולאה שלו, הוא קורא ל-`wait(NULL)`. בשלב זה, ההורה עובר למצב Waiting וממתין לסיום הילד.\n*   **סיום הילד:** הילד מסיים את הלולאה שלו, מדפיס הודעת יציאה, ויוצא. הוא עובר למצב Terminated.\n*   **הילד יוצא, ההורה מתעורר:** כאשר הילד מסיים, ההורה מקבל אירוע, עובר ממצב Waiting למצב Ready, ואז ל-Running. הוא מדפיס את הודעת הסיום של ה-`wait()` ויוצא, עובר למצב Terminated.\n\n**2. השפעת מתזמן Round Robin ועלויות החלפת הקשר:**\n*   **סדר ההדפסות:** מכיוון ש-Round Robin מקצה קוואנטום זמן קצר לכל תהליך, ההדפסות מההורה ומהילד צפויות להיות **משולבות (interleaved)** באופן הדוק. לדוגמה, ייתכן שנראה הדפסה אחת מההורה, ואז הדפסה אחת מהילד, וחוזר חלילה. קריאות ה-`usleep()` גם יתרמו לשילוב, מכיוון שהתהליך הקורא ל-`usleep()` עובר למצב Waiting ומשחרר את המעבד מיד, מה שמאפשר לתהליך השני לרוץ. כתוצאה מכך, הפלט יהיה שילוב של ההדפסות מההורה ומהילד, לאו דווקא בסדר מסוים אך עם מעברים תכופים ביניהם.\n*   **עלויות החלפת הקשר (Context Switches):** כל מעבר בין תהליך ההורה לתהליך הילד (או להיפך) כתוצאה מסיום קוואנטום זמן או קריאת מערכת חוסמת (`usleep`, `wait`), כרוך בביצוע החלפת הקשר. החלפת הקשר היא פעולה שמערכת ההפעלה מבצעת כדי לשמור את מצבו של התהליך הנוכחי (רישומים, מונה תוכנית, מצב עמודים וכו') ולטעון את מצבו של התהליך הבא. זוהי **פעולה יקרה** מבחינת ביצועים, שכן היא גוזלת זמן מעבד שאינו מוקדש לעבודת התוכנית עצמה. אם קוואנטום הזמן קצר מאוד, כפי שצוין בשאלה, מספר החלפות ההקשר יהיה גבוה מאוד, והעומס הכולל על המערכת יגדל. זה עלול להוביל לירידה ב-throughput (תפוקה כוללת) של המערכת, למרות שיפור בזמן התגובה (responsiveness) של כל תהליך בנפרד."
    },
    "difficulty_estimation": "Medium"
  }
}