{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Processes and Threads",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 10:14:44",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1710,
      "output_tokens": 680,
      "total_tokens": 4545
    }
  },
  "question": {
    "id": 101,
    "type": "MultipleChoice",
    "topic": [
      "Processes",
      "Threads",
      "System Calls"
    ],
    "content": {
      "text": "נתונה תוכנית רב-תהליכונית (multithreaded program) שבה נוצרו מספר תהליכונים. אחד מהתהליכונים הללו מבצע קריאת מערכת `fork()`. איזו טענה נכונה לגבי המצב לאחר הקריאה המוצלחת ל-`fork()`?",
      "code_snippet": null,
      "options": [
        "א. תהליך הבן נוצר עם עותק של כל התהליכונים שהיו קיימים בתהליך האב.",
        "ב. תהליך הבן נוצר עם עותק של התהליכון שקרא ל-`fork()` בלבד. שאר התהליכונים בתהליך האב אינם קיימים בתהליך הבן.",
        "ג. הקריאה ל-`fork()` תיכשל תמיד כאשר היא מבוצעת על ידי תהליכון בתוכנית רב-תהליכונית.",
        "ד. תהליך הבן נוצר עם עותק של התהליכון שקרא ל-`fork()`, ושאר התהליכונים בתהליך הבן נמצאים במצב חסום (blocked) ודורשים אתחול מחדש.",
        "ה. תהליך הבן נוצר, אך רק התהליך הראשי (main thread) של האב משוכפל אליו, ללא קשר לאיזה תהליכון ביצע את הקריאה."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "כאשר תהליכון בתוכנית רב-תהליכונית קורא ל-`fork()`, מערכת ההפעלה יוצרת תהליך בן חדש. תהליך הבן הוא עותק של תהליך האב, אך הוא מכיל רק את התהליכון שביצע את הקריאה ל-`fork()`. כל שאר התהליכונים שהיו קיימים בתהליך האב אינם משוכפלים לתהליך הבן. זהו המימוש הסטנדרטי ב-POSIX, שנועד למנוע בעיות מורכבות הקשורות למצב משותף (כמו מנעולים) בתהליכונים אחרים בתהליך הבן, שכן מצבם יהיה בלתי צפוי. לרוב, לאחר `fork()`, תהליך הבן יקרא מיד ל-`exec()` כדי לטעון תוכנית חדשה, ובכך להימנע מבעיות אלו."
    },
    "difficulty_estimation": "Medium"
  }
}