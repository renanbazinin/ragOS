{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:45:46",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 5478,
      "total_tokens": 22822
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Shared Memory",
      "Semaphores"
    ],
    "content": {
      "text": "יש ליישם מערכת שבה תהליך אב (parent) יוצר N תהליכי בן (child). כל תהליך בן מחשב מספר אקראי ושומר אותו במקטע זיכרון משותף (shared memory). תהליך האב ממתין שכל תהליכי הבן יסיימו את עבודתם ולאחר מכן מסכם את המספרים ממקטע הזיכרון המשותף. המערכת חייבת להיות חסינה (robust) ובעלת התנהגות מוגדרת במצבים הבאים:\n\n1.  **סגירה חלקה (Graceful Shutdown) על ידי האב:** תהליך האב צריך להיות מסוגל לסיים בעדינות את כל תהליכי הבן ולנקות את משאבי ה-IPC (זיכרון משותף וסמפורים) כאשר הוא מקבל את האות `SIGINT`.\n2.  **הפסקת בן ספציפי:** תהליך האב צריך להיות מסוגל לשלוח את האות `SIGUSR1` לתהליך בן ספציפי, מה שיגרום לבן זה להפסיק באופן מיידי את פעולתו הנוכחית (גם אם הוא חסום על סמפור) ולצאת.\n3.  **סנכרון נכון:** יש להבטיח שהבנים כותבים למיקומים נפרדים בזיכרון המשותף ושתהליך האב קורא את הנתונים רק לאחר שכל הבנים סיימו לכתוב את תוצאותיהם.\n\nספקו קוד C/C++ מלא עבור תהליכי האב והבן, והסבירו את בחירות התכנון, במיוחד בהתייחס לטיפול באותות (signal handling), מנגנוני IPC, וחסינות מפני שגיאות (error robustness).",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <sys/sem.h>\n#include <signal.h>\n#include <errno.h>\n#include <time.h> // For srand/rand\n#include <sys/wait.h> // For wait/waitpid\n\n#define NUM_CHILDREN 5\n#define SHM_KEY 1234\n#define SEM_KEY 5678\n\n// Union for semctl (required by some systems)\nunion semun {\n    int val;\n    struct semid_ds *buf;\n    unsigned short *array;\n    struct seminfo *__buf;\n};\n\nstruct SharedData {\n    int results[NUM_CHILDREN];\n    int completed_children_count;\n};\n\n// Global variables for signal handlers and IPC IDs\nint shm_id = -1;\nint sem_id = -1;\nstruct SharedData *shared_data = NULL;\npid_t child_pids[NUM_CHILDREN];\nvolatile sig_atomic_t parent_should_exit = 0;\nvolatile sig_atomic_t child_should_exit = 0;\n\n// Semaphore operations wrapper\nvoid sem_op(int semid, int sem_num, int op) {\n    struct sembuf sb = {sem_num, op, 0};\n    while (semop(semid, &sb, 1) == -1) {\n        if (errno == EINTR) {\n            // Interrupted by signal, recheck exit flag if child\n            if (getpid() != getppid() && child_should_exit) {\n                fprintf(stderr, \"Child %d: semop interrupted, exiting due to SIGUSR1.\\n\", getpid());\n                exit(EXIT_FAILURE); // Exit immediately if told to\n            }\n            continue; // Retry semop if EINTR and not exiting\n        } else {\n            perror(\"semop failed\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n// Cleanup function for parent process\nvoid cleanup_parent() {\n    printf(\"Parent: Cleaning up IPC resources.\\n\");\n    if (shared_data != (void*)-1 && shared_data != NULL) {\n        if (shmdt(shared_data) == -1) {\n            perror(\"parent shmdt failed during cleanup\");\n        }\n        shared_data = (void*)-1;\n    }\n    if (shm_id != -1 && shmctl(shm_id, IPC_RMID, NULL) == -1) {\n        perror(\"shmctl IPC_RMID failed\");\n    }\n    shm_id = -1;\n    if (sem_id != -1 && semctl(sem_id, 0, IPC_RMID) == -1) { // 0 is sem_num, ignored for IPC_RMID\n        perror(\"semctl IPC_RMID failed\");\n    }\n    sem_id = -1;\n    printf(\"Parent: Cleanup complete.\\n\");\n}\n\n// Signal handler for parent (SIGINT)\nvoid parent_sigint_handler(int signum) {\n    printf(\"Parent (PID: %d): Received SIGINT. Initiating graceful shutdown...\\n\", getpid());\n    parent_should_exit = 1;\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (child_pids[i] > 0) {\n            printf(\"Parent: Sending SIGUSR1 to child %d (PID: %d).\\n\", i, child_pids[i]);\n            kill(child_pids[i], SIGUSR1); // Tell children to exit\n        }\n    }\n}\n\n// Signal handler for child (SIGUSR1)\nvoid child_sigusr1_handler(int signum) {\n    printf(\"Child (PID: %d): Received SIGUSR1. Setting exit flag.\\n\", getpid());\n    child_should_exit = 1;\n}\n\nvoid child_process(int child_idx) {\n    // Attach to shared memory\n    shared_data = (struct SharedData *)shmat(shm_id, NULL, 0);\n    if (shared_data == (void *)-1) {\n        perror(\"child shmat failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Setup SIGUSR1 handler\n    struct sigaction sa_child;\n    sa_child.sa_handler = child_sigusr1_handler;\n    sigemptyset(&sa_child.sa_mask);\n    sa_child.sa_flags = 0; // No SA_RESTART to ensure semop can be interrupted\n    if (sigaction(SIGUSR1, &sa_child, NULL) == -1) {\n        perror(\"child sigaction SIGUSR1 failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    srand(getpid() * time(NULL)); // Seed random number generator\n\n    printf(\"Child %d (PID: %d) started.\\n\", child_idx, getpid());\n\n    // Simulate work\n    sleep(rand() % 3 + 1); // Simulate some work before writing\n\n    if (child_should_exit) {\n        printf(\"Child %d (PID: %d): Exiting before writing due to SIGUSR1.\\n\", child_idx, getpid());\n        if (shmdt(shared_data) == -1) { perror(\"child shmdt failed on early exit\"); }\n        exit(EXIT_SUCCESS);\n    }\n\n    // Acquire semaphore for critical section (incrementing count, writing result)\n    sem_op(sem_id, 0, -1); // Decrement semaphore 0 (mutex)\n\n    if (child_should_exit) { // Check again after acquiring sem, in case signal arrived during wait\n        printf(\"Child %d (PID: %d): Exiting after acquiring sem due to SIGUSR1.\\n\", child_idx, getpid());\n        sem_op(sem_id, 0, 1); // Release semaphore before exiting\n        if (shmdt(shared_data) == -1) { perror(\"child shmdt failed on early exit after semop\"); }\n        exit(EXIT_SUCCESS);\n    }\n\n    // Write result to shared memory\n    int random_num = rand() % 100 + 1;\n    shared_data->results[child_idx] = random_num;\n    shared_data->completed_children_count++;\n    printf(\"Child %d (PID: %d) wrote %d. Completed: %d/%d\\n\",\n           child_idx, getpid(), random_num, shared_data->completed_children_count, NUM_CHILDREN);\n\n    // Release semaphore\n    sem_op(sem_id, 0, 1); // Increment semaphore 0 (mutex)\n\n    // Detach from shared memory\n    if (shmdt(shared_data) == -1) {\n        perror(\"child shmdt failed\");\n    }\n    printf(\"Child %d (PID: %d) finished and exiting.\\n\", child_idx, getpid());\n    exit(EXIT_SUCCESS);\n}\n\nint main() {\n    // Create shared memory\n    shm_id = shmget(SHM_KEY, sizeof(struct SharedData), IPC_CREAT | 0666);\n    if (shm_id == -1) {\n        perror(\"shmget failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Attach to shared memory\n    shared_data = (struct SharedData *)shmat(shm_id, NULL, 0);\n    if (shared_data == (void *)-1) {\n        perror(\"parent shmat failed\");\n        cleanup_parent();\n        exit(EXIT_FAILURE);\n    }\n    // Initialize shared data\n    shared_data->completed_children_count = 0;\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        shared_data->results[i] = 0; // Initialize results\n    }\n\n    // Create semaphores (1 semaphore for mutex on completed_children_count)\n    sem_id = semget(SEM_KEY, 1, IPC_CREAT | 0666);\n    if (sem_id == -1) {\n        perror(\"semget failed\");\n        cleanup_parent();\n        exit(EXIT_FAILURE);\n    }\n\n    // Initialize semaphore 0 (mutex) to 1\n    union semun arg;\n    arg.val = 1;\n    if (semctl(sem_id, 0, SETVAL, arg) == -1) {\n        perror(\"semctl SETVAL failed\");\n        cleanup_parent();\n        exit(EXIT_FAILURE);\n    }\n\n    // Setup SIGINT handler for parent\n    struct sigaction sa_parent;\n    sa_parent.sa_handler = parent_sigint_handler;\n    sigemptyset(&sa_parent.sa_mask);\n    sa_parent.sa_flags = 0; // No SA_RESTART to ensure waitpid can be interrupted if needed\n    if (sigaction(SIGINT, &sa_parent, NULL) == -1) {\n        perror(\"parent sigaction SIGINT failed\");\n        cleanup_parent();\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Parent (PID: %d) started. Forking %d children...\\n\", getpid(), NUM_CHILDREN);\n\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        pid_t pid = fork();\n        if (pid == -1) {\n            perror(\"fork failed\");\n            // Attempt to clean up already forked children and IPC\n            for (int j = 0; j < i; ++j) {\n                if (child_pids[j] > 0) {\n                    kill(child_pids[j], SIGUSR1); // Tell children to exit\n                }\n            }\n            cleanup_parent();\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) {\n            // Child process\n            child_process(i);\n            // Should not reach here, child_process exits directly\n            exit(EXIT_FAILURE); \n        } else {\n            // Parent process\n            child_pids[i] = pid;\n        }\n    }\n\n    printf(\"Parent: All children forked. Waiting for them to complete...\\n\");\n\n    // Parent waits for all children to complete their work or for SIGINT\n    int children_exited_count = 0;\n    while (children_exited_count < NUM_CHILDREN) {\n        if (parent_should_exit) {\n            printf(\"Parent: SIGINT received, breaking wait loop.\\n\");\n            break;\n        }\n\n        // Parent checks completed_children_count in shared memory\n        // Must protect access to shared_data->completed_children_count\n        sem_op(sem_id, 0, -1); // Acquire mutex\n        int current_completed = shared_data->completed_children_count;\n        sem_op(sem_id, 0, 1); // Release mutex\n\n        if (current_completed == NUM_CHILDREN) {\n            printf(\"Parent: All children reported completion via shared memory.\\n\");\n            break;\n        }\n        \n        // Wait for any child to exit, or for a signal\n        // Using waitpid with WNOHANG and a short sleep to avoid busy-waiting\n        pid_t terminated_pid;\n        int status;\n        while ((terminated_pid = waitpid(-1, &status, WNOHANG)) > 0) {\n            children_exited_count++;\n            printf(\"Parent: Child %d exited (status: %d). Total exited: %d\\n\", terminated_pid, status, children_exited_count);\n        }\n        sleep(1); // Small delay to avoid busy-waiting\n    }\n\n    // If SIGINT arrived, ensure all children are terminated before cleanup\n    if (parent_should_exit) {\n        int remaining_children = NUM_CHILDREN - children_exited_count;\n        if (remaining_children > 0) {\n            printf(\"Parent: Waiting for %d remaining children to terminate after SIGINT...\\n\", remaining_children);\n            for (int i = 0; i < NUM_CHILDREN; ++i) {\n                if (child_pids[i] > 0) {\n                    int status;\n                    // Use waitpid without WNOHANG to block until child exits\n                    if (waitpid(child_pids[i], &status, 0) == -1 && errno != ECHILD) {\n                        perror(\"waitpid during SIGINT cleanup failed\");\n                    } else {\n                        printf(\"Parent: Child %d confirmed terminated.\\n\", child_pids[i]);\n                    }\n                }\n            }\n        }\n    } else {\n        // Normal completion: wait for any children that might still be running (e.g., if they didn't finish fast enough)\n        printf(\"Parent: All children completed their work. Waiting for all to terminate.\\n\");\n        int status;\n        while (wait(&status) > 0); // Wait for all children to terminate\n    }\n\n    if (!parent_should_exit) {\n        // Calculate sum only if not interrupted by SIGINT\n        printf(\"Parent: All children completed. Calculating sum...\\n\");\n        int total_sum = 0;\n        for (int i = 0; i < NUM_CHILDREN; ++i) {\n            total_sum += shared_data->results[i];\n        }\n        printf(\"Parent: Total sum of results from children: %d\\n\", total_sum);\n    } else {\n        printf(\"Parent: Sum calculation skipped due to SIGINT.\\n\");\n    }\n\n    // Clean up IPC resources\n    cleanup_parent();\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון כולל שימוש בזיכרון משותף (shared memory) לאחסון התוצאות ומונה של תהליכי בן שהשלימו את עבודתם, וסמפורים (System V semaphores) לסנכרון גישה למונה זה. טיפול באותות מיושם באמצעות `sigaction` כדי להבטיח התנהגות אמינה וניתנת לשליטה.\n\n**מבנה הנתונים המשותף:**\nמקטע הזיכרון המשותף מכיל מבנה `SharedData` הכולל:\n*   מערך `results` בגודל `NUM_CHILDREN` לאחסון המספרים האקראיים שכל בן מייצר. כל בן כותב לתא המיועד לו במערך זה (`results[child_idx]`).\n*   משתנה `completed_children_count` המונה כמה תהליכי בן סיימו לכתוב את תוצאותיהם. משתנה זה דורש הגנה באמצעות סמפור.\n\n**מנגנוני IPC:**\n1.  **זיכרון משותף (`shmget`, `shmat`, `shmdt`, `shmctl`):** משמש להעברת התוצאות מהבנים לאב ולסנכרון באמצעות המונה המשותף.\n2.  **סמפורים (`semget`, `semop`, `semctl`):** מוגדר מערך סמפורים עם סמפור אחד (אינדקס 0) המשמש כמוטקס (binary semaphore) להגנה על הגישה ל`completed_children_count` בזיכרון המשותף. הוא מאותחל ל-1.\n\n**טיפול באותות (Signal Handling):**\n*   **תהליך האב (`SIGINT`):**\n    *   האות `SIGINT` (Ctrl+C) נתפס על ידי handler ייעודי `parent_sigint_handler`.\n    *   ה-handler מגדיר דגל `parent_should_exit` ל-1.\n    *   הוא שולח את האות `SIGUSR1` לכל תהליכי הבן הפעילים כדי לגרום להם לצאת.\n    *   לאחר מכן, תהליך האב ממתין שכל הבנים יסיימו (באמצעות `waitpid`) לפני ניקוי משאבי ה-IPC.\n    *   השימוש ב`sigaction` עם `sa_flags = 0` מבטיח שמערכות קריאה כמו `waitpid` יכולות להיות מופסקות על ידי האות `SIGINT`, מה שמאפשר לאב להגיב מיידית.\n*   **תהליך הבן (`SIGUSR1`):**\n    *   האות `SIGUSR1` נתפס על ידי handler ייעודי `child_sigusr1_handler`.\n    *   ה-handler מגדיר דגל `child_should_exit` ל-1.\n    *   בתוך לולאת העבודה של הבן וגם לפני ואחרי פעולות קריטיות (כמו `semop`), הבן בודק את הדגל `child_should_exit`. אם הוא מוגדר, הבן יוצא מיד.\n    *   השימוש ב`sigaction` עם `sa_flags = 0` מבטיח שקריאות מערכת כמו `semop` יופסקו על ידי `SIGUSR1` ויחזירו `EINTR`, מה שמאפשר לבן לבדוק את הדגל ולצאת גם אם היה חסום על סמפור.\n*   **משתנים `volatile sig_atomic_t`:** דגלי היציאה `parent_should_exit` ו`child_should_exit` מוכרזים כ`volatile sig_atomic_t` כדי להבטיח גישה נכונה ובטוחה מתוך ה-signal handlers.\n\n**סנכרון ו-Robustness:**\n1.  **כתיבה למיקומים נפרדים:** כל תהליך בן מקבל אינדקס ייחודי (`child_idx`) וכותב את תוצאתו אך ורק ל`shared_data->results[child_idx]`, ובכך נמנעים תנאי מירוץ על מערך התוצאות עצמו.\n2.  **הגנה על המונה המשותף:** הגישה ל`shared_data->completed_children_count` מוגנת על ידי סמפור 0, המבטיח שרק תהליך אחד יכול לעדכן את המונה בכל רגע נתון.\n3.  **המתנה לסיום הבנים:** תהליך האב ממתין ש`shared_data->completed_children_count` יגיע ל`NUM_CHILDREN`. הוא עושה זאת בלולאה, בודק את המונה (תוך הגנה בסמפור) וממתין לילדים שיצאו באמצעות `waitpid` עם `WNOHANG` כדי לא לחסום באופן מוחלט ולאפשר תגובה ל-`SIGINT`.\n4.  **ניקוי משאבים:** פונקציה ייעודית `cleanup_parent` דואגת לשחרר את הזיכרון המשותף והסמפורים. היא נקראת בסיום התוכנית של האב, וגם במקרה של שגיאה קריטית או כאשר מתקבל `SIGINT`.\n5.  **טיפול ב-`EINTR` ב-`semop`:** פונקציית העזר `sem_op` מטפלת ב-`EINTR` (הפרעה על ידי אות) על ידי ניסיון חוזר של פעולת הסמפור, אלא אם כן דגל `child_should_exit` מוגדר, מה שמאפשר יציאה מיידית של הבן.\n6.  **מניעת Zombie Processes:** תהליך האב קורא ל`waitpid` (או `wait`) כדי לוודא שכל תהליכי הבן שהסתיימו נאספים, ובכך נמנעים תהליכי זומבי.\n\nהקוד מדגים כיצד לשלב IPC ואותות בצורה חסינה, תוך התחשבות במצבי קצה כמו סיום בלתי צפוי או בקשת סיום יזומה."
    },
    "difficulty_estimation": "Hard"
  }
}