{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:53:00",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4278,
      "output_tokens": 2751,
      "total_tokens": 13723
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Reader-Writer Problem",
      "Deadlock Prevention",
      "Starvation Prevention"
    ],
    "content": {
      "text": "נתונה מערכת עם משאב משותף אליו ניגשים תהליכי קוראים (Readers) ותהליכי כותבים (Writers).\nמספר קוראים יכולים לגשת למשאב בו זמנית.\nרק כותב אחד יכול לגשת למשאב בכל רגע נתון, ואין קוראים או כותבים אחרים בזמן כתיבה.\nנדרש לממש מדיניות עדיפות לכותבים: אם כותב ממתין, אף קורא חדש לא יוכל להתחיל לקרוא עד שהכותב יסיים את פעולתו (קוראים שכבר קוראים יכולים להמשיך עד לסיום).\nמדיניות זו נועדה למנוע הרעבה (Starvation) של כותבים.\n\nהשלם את קטעי הקוד הבאים עבור הפונקציות reader_task ו-writer_task תוך שימוש בסמפורים בלבד, כך שיענו על הדרישות הנ\"ל.\nהנח שהסמפורים והמשתנים הגלובליים (read_count, write_count) מוגדרים ומאותחלים כראוי.",
      "code_snippet": "#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For sleep\n\n// Global semaphores and counters (to be initialized)\nsem_t resource_access;        // Controls access to the shared resource\nsem_t mutex_read_count;     // Protects read_count\nsem_t mutex_write_count;    // Protects write_count\nsem_t readers_queue_block;  // Blocks new readers if writers are waiting\n\nint read_count = 0;   // Number of readers currently reading\nint write_count = 0;  // Number of writers currently writing (should be 0 or 1)\n\n// Shared resource (simplified)\nint shared_data = 0;\n\nvoid reader_task() {\n    // TODO: Implement semaphore logic for reader\n    \n    // Critical Section: Reading\n    printf(\"Reader %lu is reading: %d\\n\", pthread_self(), shared_data);\n    sleep(1); // Simulate reading time\n    \n    // TODO: Implement semaphore logic for reader\n}\n\nvoid writer_task() {\n    // TODO: Implement semaphore logic for writer\n    \n    // Critical Section: Writing\n    shared_data++;\n    printf(\"Writer %lu is writing: %d\\n\", pthread_self(), shared_data);\n    sleep(2); // Simulate writing time\n    \n    // TODO: Implement semaphore logic for writer\n}\n\n// Main function for initialization and thread creation (not part of the answer)\n// int main() {\n//     sem_init(&resource_access, 0, 1);\n//     sem_init(&mutex_read_count, 0, 1);\n//     sem_init(&mutex_write_count, 0, 1);\n//     sem_init(&readers_queue_block, 0, 1);\n//     // ... create threads ...\n//     return 0;\n// }"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\n**1. השלמת קטעי הקוד:**\n\n```c\n#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For sleep\n\n// Global semaphores and counters (to be initialized)\nsem_t resource_access;        // Controls access to the shared resource\nsem_t mutex_read_count;     // Protects read_count\nsem_t mutex_write_count;    // Protects write_count\nsem_t readers_queue_block;  // Blocks new readers if writers are waiting\n\nint read_count = 0;   // Number of readers currently reading\nint write_count = 0;  // Number of writers currently writing (should be 0 or 1)\n\n// Shared resource (simplified)\nint shared_data = 0;\n\nvoid reader_task() {\n    sem_wait(&readers_queue_block); // Wait if writers are waiting/writing\n    sem_wait(&mutex_read_count);\n    read_count++;\n    if (read_count == 1) { // First reader\n        sem_wait(&resource_access); // Acquire resource_access\n    }\n    sem_post(&mutex_read_count);\n    sem_post(&readers_queue_block); // Allow other readers to pass readers_queue_block\n\n    // Critical Section: Reading\n    printf(\"Reader %lu is reading: %d\\n\", pthread_self(), shared_data);\n    sleep(1); // Simulate reading time\n\n    sem_wait(&mutex_read_count);\n    read_count--;\n    if (read_count == 0) { // Last reader\n        sem_post(&resource_access); // Release resource_access\n    }\n    sem_post(&mutex_read_count);\n}\n\nvoid writer_task() {\n    sem_wait(&mutex_write_count);\n    write_count++;\n    if (write_count == 1) { // First writer\n        sem_wait(&readers_queue_block); // Block new readers from entering\n    }\n    sem_post(&mutex_write_count);\n\n    sem_wait(&resource_access); // Get exclusive access\n\n    // Critical Section: Writing\n    shared_data++;\n    printf(\"Writer %lu is writing: %d\\n\", pthread_self(), shared_data);\n    sleep(2); // Simulate writing time\n\n    sem_post(&resource_access); // Release exclusive access\n\n    sem_wait(&mutex_write_count);\n    write_count--;\n    if (write_count == 0) { // Last writer\n        sem_post(&readers_queue_block); // Allow readers to enter again\n    }\n    sem_post(&mutex_write_count);\n}\n\n// Main function for initialization and thread creation (not part of the answer)\n// int main() {\n//     sem_init(&resource_access, 0, 1);\n//     sem_init(&mutex_read_count, 0, 1);\n//     sem_init(&mutex_write_count, 0, 1);\n//     sem_init(&readers_queue_block, 0, 1);\n//     // ... create threads ...\n//     return 0;\n// }\n```\n\n**2. הסבר על הפתרון ומניעת הרעבה:**\n\nהפתרון המוצע מיישם את בעיית קוראים-כותבים בעדיפות לכותבים, תוך שימוש בארבעה סמפורים בינאריים ושני מונים גלובליים.\n\n**תפקידי הסמפורים והמשתנים הגלובליים:**\n*   `resource_access` (סמפור בינארי, מאותחל ל-1): זהו הסמפור הראשי השולט על הגישה למשאב המשותף עצמו. כותבים חייבים לבצע `sem_wait` עליו כדי לגשת למשאב באופן בלעדי. קוראים משתמשים בו באופן קולקטיבי: הקורא הראשון שנכנס מבצע `sem_wait` והקורא האחרון שיוצא מבצע `sem_post`. זה מבטיח שרק כותב אחד או מספר קוראים יכולים לגשת למשאב, אך לא שניהם יחד.\n*   `mutex_read_count` (סמפור בינארי, מאותחל ל-1): מגן על הגישה למונה `read_count`. הוא מבטיח שרק תהליך אחד בכל רגע נתון יכול לעדכן את `read_count` כדי למנוע תנאי מירוץ (Race Condition) בגישה למונה זה.\n*   `mutex_write_count` (סמפור בינארי, מאותחל ל-1): מגן על הגישה למונה `write_count`. בדומה ל-`mutex_read_count`, הוא מונע תנאי מירוץ בעת עדכון `write_count`.\n*   `readers_queue_block` (סמפור בינארי, מאותחל ל-1): זהו המנגנון העיקרי למתן עדיפות לכותבים ולמניעת הרעבתם. כותב ראשון שמגיע (כלומר `write_count` הופך ל-1) מבצע `sem_wait` על סמפור זה, ובכך חוסם כל קורא חדש מלהיכנס ללולאת הגישה למשאב. רק כאשר הכותב האחרון מסיים (כלומר `write_count` חוזר ל-0), הוא מבצע `sem_post` ובכך מאפשר לקוראים חדשים להמשיך.\n*   `read_count` (מונה שלם, מאותחל ל-0): סופר את מספר הקוראים הפעילים כרגע במשאב המשותף. כאשר הוא מגיע ל-1, הקורא הראשון מנסה לרכוש את `resource_access`. כאשר הוא מגיע ל-0, הקורא האחרון משחרר את `resource_access`.\n*   `write_count` (מונה שלם, מאותחל ל-0): סופר את מספר הכותבים הממתינים או הפעילים (בפועל, רק 0 או 1 פעילים). כאשר הוא מגיע ל-1, הכותב הראשון חוסם את `readers_queue_block`. כאשר הוא חוזר ל-0, הכותב האחרון משחרר את `readers_queue_block`.\n\n**מניעת הרעבה (Starvation) של כותבים:**\n\nהפתרון מונע הרעבה של כותבים באמצעות הסמפור `readers_queue_block` והמונה `write_count`. כאשר כותב מגיע ומגדיל את `write_count` ל-1 (כלומר, הוא הכותב הראשון שמגיע או הראשון שמתחיל לכתוב לאחר תקופה של חוסר כותבים), הוא מבצע `sem_wait(&readers_queue_block)`. פעולה זו חוסמת כל קורא עתידי מלהיכנס לאזור הקריטי של הקוראים. קוראים שכבר נמצאים באזור הקריטי ימשיכו לסיים את עבודתם, וכאשר הקורא האחרון יצא, הוא ישחרר את `resource_access`. בשלב זה, הכותב הממתין יוכל לרכוש את `resource_access` ולהתחיל לכתוב. רק לאחר שהכותב מסיים ו-`write_count` חוזר ל-0, הוא משחרר את `readers_queue_block`, מה שמאפשר לקוראים חדשים להיכנס שוב. בכך, לכותבים יש עדיפות מובהקת על פני קוראים חדשים, ומונעת מצב שבו זרם בלתי פוסק של קוראים ימנע מכותב אי פעם לגשת למשאב."
    },
    "difficulty_estimation": "Hard"
  }
}