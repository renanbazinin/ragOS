{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:36:52",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4395,
      "output_tokens": 5069,
      "total_tokens": 13916
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Deadlocks",
      "Resource Management",
      "Starvation",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה מערכת ובה N תהליכים (או תהליכונים) ו-M סוגי משאבים שונים. לכל סוג משאב R_i קיימות C_i יחידות זמינות. תהליכים במערכת מבצעים בקשות לרכישת מספר יחידות משאב מסוגים שונים, ומשחררים אותן לאחר שימוש. המערכת משתמשת בסמפורים לניהול הגישה למשאבים. ענו על הסעיפים הבאים:",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "הסבירו כיצד עלול להתרחש קיפאון (Deadlock) במערכת כזו במימוש נאיבי, שבו כל תהליך מנסה לרכוש את יחידות המשאבים להן הוא זקוק באופן עצמאי באמצעות סמפורים (בינאריים או סמפורי מונה) עבור כל יחידת משאב. ספקו דוגמת קוד ב-C/C++ לתרחיש שבו שני תהליכים עלולים להיכנס לקיפאון, בהנחה שיש שני סוגי משאבים, R0 ו-R1, עם יחידה אחת מכל סוג.",
        "code_snippet": "/* קוד עזר (אין לשנות) */\n#include <semaphore.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h> // For sleep\n\n#define NUM_RESOURCE_TYPES 2\n#define R0_UNITS 1\n#define R1_UNITS 1\n\n// Resource structure\ntypedef struct {\n    sem_t units_sem;\n    int id;\n} ResourceType;\n\nResourceType resources[NUM_RESOURCE_TYPES];\n\nvoid init_resources_for_deadlock_example() {\n    sem_init(&resources[0].units_sem, 0, R0_UNITS); // Resource R0 has R0_UNITS\n    resources[0].id = 0;\n    sem_init(&resources[1].units_sem, 0, R1_UNITS); // Resource R1 has R1_UNITS\n    resources[1].id = 1;\n}\n\nvoid destroy_resources_for_deadlock_example() {\n    sem_destroy(&resources[0].units_sem);\n    sem_destroy(&resources[1].units_sem);\n}\n\n/* קוד למימוש תהליך לדוגמה (יש להשלים) */\nvoid* thread_func_1(void* arg) {\n    // Thread 1 requests R0 then R1\n    // הוסף כאן פעולות סמפור כדי להדגים קיפאון\n    return NULL;\n}\n\nvoid* thread_func_2(void* arg) {\n    // Thread 2 requests R1 then R0\n    // הוסף כאן פעולות סמפור כדי להדגים קיפאון\n    return NULL;\n}",
        "options": null
      },
      {
        "id": "10.2",
        "text": "כדי למנוע קיפאון, אחת השיטות היא להטיל סדר גלובלי על רכישת המשאבים. כלומר, תהליך שמבקש מספר משאבים (יחידה אחת מכל סוג) חייב לרכוש אותם לפי סדר מוגדר מראש (לדוגמה, לפי מזהה המשאב העולה). ממשו את הפונקציות `acquire_resources_ordered` ו-`release_resources_ordered` ב-C/C++, אשר רוכשות ומשחררות סט של משאבים (יחידה אחת מכל משאב) לפי סדר מוגדר, ומונעות קיפאון. הניחו שכל תהליך זקוק ליחידה אחת מכל משאב שברשימת הבקשה, ושרשימת ה-`resource_ids` במבנה `ResourceSetRequest` מסודרת בסדר עולה.",
        "code_snippet": "/* קוד עזר (אין לשנות) */\n#include <semaphore.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h> // For sleep\n\n#define MAX_RESOURCE_TYPES 5 // Up to 5 types of resources\n#define MAX_RESOURCE_UNITS_PER_TYPE 3 // Max units for any single type\n\ntypedef struct {\n    sem_t units_sem;\n    int id;\n    int total_units;\n} ResourceType;\n\n// Global array of resource types\nResourceType global_resources[MAX_RESOURCE_TYPES];\nint num_global_resource_types = 0;\n\nvoid init_global_resources(int num_types, int* initial_units_per_type) {\n    num_global_resource_types = num_types;\n    for (int i = 0; i < num_types; ++i) {\n        global_resources[i].id = i;\n        global_resources[i].total_units = initial_units_per_type[i];\n        sem_init(&global_resources[i].units_sem, 0, initial_units_per_type[i]);\n    }\n}\n\nvoid destroy_global_resources() {\n    for (int i = 0; i < num_global_resource_types; ++i) {\n        sem_destroy(&global_resources[i].units_sem);\n    }\n}\n\n// A request for a set of resources (each 1 unit)\n// The resource_ids array contains the IDs of resources needed\n// Example: resource_ids = {0, 2} means need 1 unit of R0 and 1 unit of R2\n// The array is assumed to be sorted by resource ID for this part of the question\ntypedef struct {\n    int* resource_ids;\n    int count; // Number of resource types in this request\n} ResourceSetRequest;\n\n/* יש לממש פונקציות אלו */\nvoid acquire_resources_ordered(ResourceSetRequest* req) {\n    // Implement acquisition of 1 unit for each resource in req->resource_ids, following resource ID order\n}\n\nvoid release_resources_ordered(ResourceSetRequest* req) {\n    // Implement release of 1 unit for each resource in req->resource_ids, following resource ID order\n}",
        "options": null
      },
      {
        "id": "10.3",
        "text": "גישת סדר המשאבים יעילה למניעת קיפאון, אך היא עלולה להוביל לרעב (Starvation) אם תהליך זקוק למשאבים מסוימים אשר תמיד נרכשים על ידי תהליכים אחרים לפני שהוא מצליח לרכוש אותם. בנוסף, היא מניחה שהתהליך יודע מראש את כל המשאבים להם הוא זקוק, ורוכש אותם כולם בבת אחת או בסדר קבוע. הציעו ופרטו מימוש חלופי לפונקציות `acquire_resources_safe` ו-`release_resources_safe` (אין צורך בקוד C/C++ מלא, אלא תיאור אלגוריתמי מפורט), אשר יאפשר לתהליכים לבקש מספר יחידות מסוגי משאבים שונים באופן שרירותי (לאו דווקא בסדר עולה), ויוודא מניעת קיפאון וגם מניעת רעב. הניחו שכל תהליך מצהיר על המשאבים המקסימליים להם הוא עשוי להזדקק לפני תחילת ביצועו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **הסבר לקיפאון:** קיפאון (Deadlock) מתרחש כאשר ארבעה תנאים מתקיימים בו זמנית:\n    *   **מניעה הדדית (Mutual Exclusion):** משאב ניתן לשימוש על ידי תהליך אחד בלבד בכל רגע נתון (כמו סמפור).\n    *   **החזקה והמתנה (Hold and Wait):** תהליך מחזיק במשאב אחד לפחות וממתין לרכישת משאבים נוספים המוחזקים על ידי תהליכים אחרים.\n    *   **אי-הפקעה (No Preemption):** לא ניתן להפקיע משאב מתהליך המחזיק בו; הוא חייב לשחרר אותו מרצונו.\n    *   **המתנה מעגלית (Circular Wait):** קיימת שרשרת תהליכים P1, P2, ..., Pn כך ש-P1 ממתין למשאב המוחזק על ידי P2, P2 ממתין למשאב המוחזק על ידי P3, וכן הלאה, עד ש-Pn ממתין למשאב המוחזק על ידי P1.\n\n    במימוש נאיבי עם סמפורים, תנאי המניעה ההדדית ואי-ההפקעה מתקיימים באופן טבעי על ידי הסמפורים. תנאי ההחזקה והמתנה יכול להתקיים אם תהליך רוכש משאב אחד ואז מנסה לרכוש משאב נוסף תוך כדי החזקת הראשון. תנאי ההמתנה המעגלית יתקיים אם ישנם שני תהליכים או יותר המנסים לרכוש משאבים בסדר הפוך.\n\n    **דוגמת קוד לקיפאון:**\n    ```c\n    void* thread_func_1(void* arg) {\n        printf(\"Thread 1: Trying to acquire R0\\n\");\n        sem_wait(&resources[0].units_sem); // Acquire R0\n        printf(\"Thread 1: Acquired R0, waiting for R1\\n\");\n        sleep(1); // Simulate some work or delay\n        sem_wait(&resources[1].units_sem); // Acquire R1\n        printf(\"Thread 1: Acquired R1. Doing work.\\n\");\n        // ... critical section ...\n        sem_post(&resources[1].units_sem); // Release R1\n        printf(\"Thread 1: Released R1\\n\");\n        sem_post(&resources[0].units_sem); // Release R0\n        printf(\"Thread 1: Released R0\\n\");\n        return NULL;\n    }\n\n    void* thread_func_2(void* arg) {\n        printf(\"Thread 2: Trying to acquire R1\\n\");\n        sem_wait(&resources[1].units_sem); // Acquire R1\n        printf(\"Thread 2: Acquired R1, waiting for R0\\n\");\n        sleep(1); // Simulate some work or delay\n        sem_wait(&resources[0].units_sem); // Acquire R0\n        printf(\"Thread 2: Acquired R0. Doing work.\\n\");\n        // ... critical section ...\n        sem_post(&resources[0].units_sem); // Release R0\n        printf(\"Thread 2: Released R0\\n\");\n        sem_post(&resources[1].units_sem); // Release R1\n        printf(\"Thread 2: Released R1\\n\");\n        return NULL;\n    }\n\n    // בקוד הראשי:\n    // pthread_t t1, t2;\n    // init_resources_for_deadlock_example();\n    // pthread_create(&t1, NULL, thread_func_1, NULL);\n    // pthread_create(&t2, NULL, thread_func_2, NULL);\n    // pthread_join(t1, NULL);\n    // pthread_join(t2, NULL);\n    // destroy_resources_for_deadlock_example();\n    ```\n    בתרחיש זה, אם Thread 1 רוכש את R0 ו-Thread 2 רוכש את R1 בו-זמנית (או בסמיכות), שניהם ינסו לרכוש את המשאב הנותר וייכנסו למצב של המתנה מעגלית, מה שיוביל לקיפאון.\n\n2.  **מניעת קיפאון באמצעות סדר משאבים:**\n    גישת סדר המשאבים מונעת קיפאון על ידי מניעת התנאי של המתנה מעגלית. אם כל התהליכים רוכשים משאבים לפי סדר גלובלי מוגדר (לדוגמה, לפי מזהה משאב עולה), לא יכולה להיווצר שרשרת המתנה מעגלית. תהליך שצריך משאבים R_a ו-R_b כאשר ID(R_a) < ID(R_b) ירכוש תמיד את R_a ואז את R_b. לא ניתן יהיה ליצור מצב שבו P1 מחזיק R_a וממתין ל-R_b, ובמקביל P2 מחזיק R_b וממתין ל-R_a, שכן P2 היה צריך לרכוש את R_a קודם לכן.\n\n    ```c\n    void acquire_resources_ordered(ResourceSetRequest* req) {\n        // Assuming req->resource_ids is already sorted by resource ID\n        for (int i = 0; i < req->count; ++i) {\n            int res_id = req->resource_ids[i];\n            sem_wait(&global_resources[res_id].units_sem);\n            printf(\"Thread %lu acquired R%d\\n\", pthread_self(), res_id);\n        }\n    }\n\n    void release_resources_ordered(ResourceSetRequest* req) {\n        // Release order doesn't strictly matter for deadlock prevention\n        // but releasing in reverse of acquisition order is a common practice.\n        for (int i = req->count - 1; i >= 0; --i) {\n            int res_id = req->resource_ids[i];\n            sem_post(&global_resources[res_id].units_sem);\n            printf(\"Thread %lu released R%d\\n\", pthread_self(), res_id);\n        }\n    }\n    ```\n\n3.  **מניעת קיפאון ורעב בבקשות שרירותיות:**\n    כדי להתמודד עם בקשות משאבים שרירותיות (לא בסדר קבוע) ולמנוע הן קיפאון והן רעב, נדרש מנגנון מורכב יותר, הדומה לאלגוריתם הבנקאי (Banker's Algorithm) בשילוב עם מנגנון הוגנות.\n\n    **תיאור אלגוריתמי מפורט:**\n\n    *   **מבני נתונים גלובליים:**\n        *   `Available[M]`: מערך המציין את מספר היחידות הזמינות מכל סוג משאב. (שווה לערך הסמפור).\n        *   `Max[N][M]`: מטריצה המציינת את המשאבים המקסימליים שכל תהליך (N) עשוי לדרוש מכל סוג (M). תהליך מצהיר על כך מראש.\n        *   `Allocation[N][M]`: מטריצה המציינת את המשאבים שכל תהליך מחזיק כרגע.\n        *   `Need[N][M]`: מטריצה המציינת את המשאבים הנוספים שכל תהליך עדיין זקוק להם ( `Need = Max - Allocation`).\n        *   `request_queue`: תור המתנה של בקשות למשאבים, ייתכן שיכיל גם מזהה תהליך וגם את הבקשה הספציפית.\n        *   `resource_manager_mutex`: מנעול (mutex) גלובלי המגן על הגישה לכל מבני הנתונים של מנהל המשאבים.\n        *   `resource_available_cv`: משתנה תנאי (condition variable) כללי עליו תהליכים ימתינו כאשר בקשתם לא ניתנת לביצוע באופן בטוח או מיידי.\n\n    *   **פונקציית `acquire_resources_safe(thread_id, ResourceRequest* req)`:**\n        1.  **נעילה:** התהליך רוכש את `resource_manager_mutex` כדי להבטיח גישה בלעדית למנהל המשאבים.\n        2.  **בדיקת בטיחות ולולאת המתנה:** התהליך נכנס ללולאה:\n            א.  **בדיקת זמינות ו\"מצב בטוח\":** מנהל המשאבים בודק אם הבקשה `req` יכולה להתבצע באופן מיידי: כלומר, אם `req` <= `Available` (יש מספיק יחידות), ואם מתן המשאבים יוביל למצב בטוח (Safe State). מצב בטוח פירושו שקיימת סדרה של תהליכים שיכולה להשלים את ביצועה (באמצעות `Banker's Safety Algorithm`).\n            ב.  **ביצוע הבקשה (אם בטוח):** אם הבקשה בטוחה וניתנת לביצוע:\n                *   מעדכן את `Available` (מפחית את יחידות `req`).\n                *   מעדכן את `Allocation[thread_id]` (מוסיף את יחידות `req`).\n                *   מעדכן את `Need[thread_id]` (מפחית את יחידות `req`).\n                *   התהליך יוצא מהלולאה.\n            ג.  **המתנה (אם לא בטוח או לא זמין):** אם הבקשה אינה בטוחה או שאין מספיק משאבים זמינים:\n                *   התהליך מוסיף את בקשתו ל-`request_queue` (זה מבטיח הוגנות - בקשות יטופלו לפי סדר הגעתן).\n                *   התהליך משחרר את `resource_manager_mutex` ומיד ממתין על `resource_available_cv`.\n                *   כאשר התהליך מתעורר (על ידי `signal` או `broadcast`), הוא רוכש שוב את `resource_manager_mutex` וחוזר לתחילת הלולאה כדי לבדוק שוב.\n        3.  **שחרור נעילה:** התהליך משחרר את `resource_manager_mutex`.\n\n    *   **פונקציית `release_resources_safe(thread_id, ResourceRequest* req)`:**\n        1.  **נעילה:** התהליך רוכש את `resource_manager_mutex`.\n        2.  **שחרור משאבים:**\n            *   מעדכן את `Available` (מוסיף את יחידות `req`).\n            *   מעדכן את `Allocation[thread_id]` (מפחית את יחידות `req`).\n            *   מעדכן את `Need[thread_id]` (מוסיף את יחידות `req`).\n        3.  **התראה לתהליכים ממתינים:**\n            *   מנהל המשאבים בודק את `request_queue` (בסדר FIFO) כדי לראות אם כעת ניתן לשרת איזושהי בקשה ממתינה באופן בטוח. אם כן, הוא מוציא את הבקשה מהתור, מבצע אותה (מעדכן את `Available`, `Allocation`, `Need` של התהליך הממתין), ומעיר את התהליך המתאים (באמצעות `pthread_cond_signal` או `pthread_cond_broadcast` אם יש מספר תהליכים שעלולים להיות רלוונטיים).\n            *   חשוב לבצע בדיקת בטיחות (Safety Check) עבור כל בקשה פוטנציאלית מהתור כדי לוודא שמתן המשאבים לא יוביל לקיפאון.\n        4.  **שחרור נעילה:** התהליך משחרר את `resource_manager_mutex`.\n\n    **מניעת רעב:** מניעת רעב מושגת באמצעות תור ה-`request_queue` אשר מטפל בבקשות בסדר הגעתן (FIFO). כאשר משאבים משתחררים, המערכת בודקת את התור ומוודאת שכל בקשה שנמצאת בראש התור (או כל בקשה אחרת שניתן לשרת בבטחה) תקבל את ההזדמנות שלה, ולא תישאר מוגבלת על ידי בקשות מאוחרות יותר או חוסר מזל תמידי."
    },
    "difficulty_estimation": "Hard"
  }
}