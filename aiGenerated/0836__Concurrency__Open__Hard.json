{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Concurrency",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 00:42:48",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4697,
      "output_tokens": 3647,
      "total_tokens": 18968
    }
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Concurrency",
      "Synchronization",
      "Threads",
      "Producer-Consumer",
      "Condition Variables",
      "Mutexes"
    ],
    "content": {
      "text": "מערכת מנהלת תור הודעות משותף בעל קיבולת סופית (MessageQueue), אליו כותבים מספר חוטי 'יצרן' (Producer Threads) וממנו קוראים מספר חוטי 'צרכן' (Consumer Threads). בנוסף, קיים חוט 'מנתח' (Analyzer Thread) שתפקידו לנטר את התור.\n\nאם חוט המנתח מזהה (באופן עקיף, דרך מונה) שישנן הודעות 'קריטיות' (CRITICAL) בתור, עליו להשהות באופן מיידי את כל חוטי היצרן. חוטי היצרן יישארו מושהים עד שכל ההודעות הקריטיות בתור יצרכו על ידי חוטי הצרכן. לאחר שכל ההודעות הקריטיות נצרכו, וחוט המנתח זיהה זאת, חוטי היצרן יכולים לחזור לפעולתם הרגילה. יש לזכור שהודעות קריטיות יכולות להתווסף לתור בכל עת, וחוט המנתח צריך להגיב בהתאם.\n\nיש לממש את מבנה הנתונים של תור ההודעות (MessageQueue) ואת הפעולות הנדרשות (`init_queue`, `destroy_queue`, `put_message`, `get_message`), וכן את לוגיקת חוט המנתח (`analyzer_thread_func`), תוך שימוש באובייקטי סנכרון (כגון mutexes ו-condition variables) כדי למנוע תנאי מירוץ וקיפאונות. יש להקפיד על סדר נעילה נכון של mutexes.\n\nהשתמשו במבנה Message הבא:\n```c\nenum MessageType {\n    REGULAR,\n    CRITICAL\n};\n\nstruct Message {\n    int id;\n    MessageType type;\n};\n```",
      "code_snippet": "/* מבנה הנתונים והפונקציות הנדרשות */\n#include <pthread.h>\n#include <queue> // שימוש ב-STL queue לפשטות, ניתן להחליף בתור מבוסס מערך ב-C\n#include <iostream>\n#include <unistd.h> // עבור sleep\n\n// הגדרת הודעה\nenum MessageType {\n    REGULAR,\n    CRITICAL\n};\n\nstruct Message {\n    int id;\n    MessageType type;\n};\n\n// מבנה תור ההודעות\ntypedef struct {\n    std::queue<Message> q;\n    int capacity;\n    pthread_mutex_t queue_mutex;\n    pthread_cond_t not_full_cv;       // יצרנים ממתינים כאן אם התור מלא\n    pthread_cond_t not_empty_cv;      // צרכנים ממתינים כאן אם התור ריק\n    pthread_cond_t producers_resume_cv; // יצרנים ממתינים כאן אם הושעו על ידי המנתח\n\n    int critical_messages_count; // מונה הודעות קריטיות בתור\n    bool producers_halted;       // דגל המציין אם היצרנים מושעים\n} MessageQueue;\n\n// אתחול התור\nvoid init_queue(MessageQueue *mq, int capacity) {\n    mq->capacity = capacity;\n    pthread_mutex_init(&mq->queue_mutex, NULL);\n    pthread_cond_init(&mq->not_full_cv, NULL);\n    pthread_cond_init(&mq->not_empty_cv, NULL);\n    pthread_cond_init(&mq->producers_resume_cv, NULL);\n    mq->critical_messages_count = 0;\n    mq->producers_halted = false;\n}\n\n// שחרור משאבי התור\nvoid destroy_queue(MessageQueue *mq) {\n    pthread_mutex_destroy(&mq->queue_mutex);\n    pthread_cond_destroy(&mq->not_full_cv);\n    pthread_cond_destroy(&mq->not_empty_cv);\n    pthread_cond_destroy(&mq->producers_resume_cv);\n}\n\n// הכנסת הודעה לתור (על ידי יצרן)\nvoid put_message(MessageQueue *mq, Message msg) {\n    pthread_mutex_lock(&mq->queue_mutex);\n\n    // המתן אם התור מלא\n    while (mq->q.size() == mq->capacity) {\n        pthread_cond_wait(&mq->not_full_cv, &mq->queue_mutex);\n    }\n    // המתן אם היצרנים הושעו על ידי המנתח\n    while (mq->producers_halted) {\n        pthread_cond_wait(&mq->producers_resume_cv, &mq->queue_mutex);\n    }\n\n    mq->q.push(msg);\n    if (msg.type == CRITICAL) {\n        mq->critical_messages_count++;\n    }\n\n    pthread_cond_signal(&mq->not_empty_cv); // איתות לצרכנים שיש הודעה חדשה\n    pthread_mutex_unlock(&mq->queue_mutex);\n}\n\n// הוצאת הודעה מהתור (על ידי צרכן)\nMessage get_message(MessageQueue *mq) {\n    pthread_mutex_lock(&mq->queue_mutex);\n\n    // המתן אם התור ריק\n    while (mq->q.empty()) {\n        pthread_cond_wait(&mq->not_empty_cv, &mq->queue_mutex);\n    }\n\n    Message msg = mq->q.front();\n    mq->q.pop();\n\n    if (msg.type == CRITICAL) {\n        mq->critical_messages_count--;\n        // אם כל ההודעות הקריטיות נצרכו והיצרנים היו מושעים, יש להמשיך אותם\n        if (mq->critical_messages_count == 0 && mq->producers_halted) {\n            mq->producers_halted = false;\n            pthread_cond_broadcast(&mq->producers_resume_cv); // הער את כל היצרנים הממתינים\n        }\n    }\n\n    pthread_cond_signal(&mq->not_full_cv); // איתות ליצרנים שהתור אינו מלא יותר\n    pthread_mutex_unlock(&mq->queue_mutex);\n    return msg;\n}\n\n// פונקציית חוט המנתח\nvoid *analyzer_thread_func(void *arg) {\n    MessageQueue *mq = (MessageQueue *)arg;\n    while (true) {\n        sleep(2); // נתח כל 2 שניות\n\n        pthread_mutex_lock(&mq->queue_mutex);\n\n        if (mq->critical_messages_count > 0 && !mq->producers_halted) {\n            mq->producers_halted = true;\n            // אין צורך לאותת, יצרנים יבדקו את הדגל 'producers_halted' בניסיונם הבא להכניס הודעה\n            // או כאשר יוערו על ידי not_full_cv ואז יפלו להמתנה על producers_resume_cv.\n        } else if (mq->critical_messages_count == 0 && mq->producers_halted) {\n            mq->producers_halted = false;\n            pthread_cond_broadcast(&mq->producers_resume_cv); // המשך יצרנים\n        }\n\n        pthread_mutex_unlock(&mq->queue_mutex);\n    }\n    return NULL;\n}\n"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון משתמש במנגנון Producer-Consumer סטנדרטי עם הרחבה לשליטה על ידי חוט מנתח. כל המצב המשותף (התור עצמו, קיבולת, מונה הודעות קריטיות, ודגל השעיית יצרנים) מוגן על ידי מנעול יחיד (`queue_mutex`). גישה למשתנים אלו תמיד מתבצעת תחת נעילה של `queue_mutex`.\n\n**מבנה `MessageQueue`:**\n- `q`: תור ה-STL המשמש לאחסון ההודעות.\n- `capacity`: הקיבולת המקסימלית של התור.\n- `queue_mutex`: מנעול שמגן על כל המצב המשותף של התור, כולל המונה של ההודעות הקריטיות ודגל השעיית היצרנים. שימוש במנעול יחיד לכל המצב המשותף מונע בעיות של סדר נעילה וקיפאונות בין פעולות שונות.\n- `not_full_cv`: משתנה תנאי עליו ממתינים חוטי יצרן כאשר התור מלא. הוא מאותת כאשר מתפנה מקום בתור.\n- `not_empty_cv`: משתנה תנאי עליו ממתינים חוטי צרכן כאשר התור ריק. הוא מאותת כאשר מתווספת הודעה לתור.\n- `producers_resume_cv`: משתנה תנאי ספציפי עליו ממתינים חוטי יצרן כאשר הם מושעים על ידי חוט המנתח.\n- `critical_messages_count`: מונה את מספר ההודעות הקריטיות הנוכחי בתור.\n- `producers_halted`: דגל בוליאני המציין אם חוטי היצרן מושעים (true) או רשאים להמשיך לייצר (false).\n\n**פעולת `put_message` (יצרן):**\n1.  החוט נועל את `queue_mutex`.\n2.  הוא בודק בשתי לולאות `while` נפרדות את שני תנאי ההמתנה: אם התור מלא (`q.size() == mq->capacity`) או אם היצרנים מושעים (`mq->producers_halted`).\n    -   אם התור מלא, הוא ממתין על `not_full_cv`. כאשר הוא מתעורר, הוא בודק מחדש את התנאי.\n    -   אם היצרנים מושעים, הוא ממתין על `producers_resume_cv`. כאשר הוא מתעורר, הוא בודק מחדש את התנאי.\n    -   שימו לב: גם אם התעורר מ-`not_full_cv`, הוא עדיין צריך לבדוק אם `producers_halted` הוא `true` ולהיכנס להמתנה על `producers_resume_cv` אם צריך.\n3.  לאחר שעבר את שני תנאי ההמתנה, הוא מוסיף את ההודעה לתור.\n4.  אם ההודעה קריטית, הוא מגדיל את `critical_messages_count`.\n5.  הוא מאותת ל-`not_empty_cv` כדי להעיר צרכנים פוטנציאליים.\n6.  הוא משחרר את `queue_mutex`.\n\n**פעולת `get_message` (צרכן):**\n1.  החוט נועל את `queue_mutex`.\n2.  הוא ממתין בלולאת `while` על `not_empty_cv` אם התור ריק.\n3.  לאחר שהתור אינו ריק, הוא מוציא את ההודעה מהתור.\n4.  אם ההודעה הייתה קריטית, הוא מקטין את `critical_messages_count`.\n5.  **לוגיקת השחרור של היצרנים:** אם `critical_messages_count` הגיע ל-0 **וגם** `producers_halted` היה `true`, זה אומר שכל ההודעות הקריטיות נצרכו. במקרה זה, הצרכן משנה את `producers_halted` ל-`false` ומאותת באמצעות `pthread_cond_broadcast` לכל חוטי היצרן הממתינים על `producers_resume_cv` כדי שימשיכו לפעול.\n6.  הוא מאותת ל-`not_full_cv` כדי להעיר יצרנים פוטנציאליים (כי התפנה מקום בתור).\n7.  הוא משחרר את `queue_mutex` ומחזיר את ההודעה.\n\n**פונקציית `analyzer_thread_func` (מנתח):**\n1.  החוט רץ בלולאה אינסופית ומבצע `sleep` תקופתי (לדוגמה, כל 2 שניות).\n2.  הוא נועל את `queue_mutex` כדי לגשת למצב המשותף.\n3.  **לוגיקת השעיית היצרנים:**\n    -   אם `critical_messages_count` גדול מ-0 **וגם** `producers_halted` הוא `false`, המנתח מזהה שיש הודעות קריטיות והיצרנים אינם מושעים. הוא משנה את `producers_halted` ל-`true`.\n    -   במקרה זה, אין צורך לאותת ל-`producers_resume_cv`. חוטי יצרן שינסו להכניס הודעה יבדקו את הדגל `producers_halted` וייכנסו למצב המתנה בעצמם. יצרנים שכבר ממתינים על `not_full_cv` יתעוררו, יבדקו את `producers_halted` וייכנסו להמתנה על `producers_resume_cv`.\n4.  **לוגיקת המשך פעולת היצרנים:**\n    -   אם `critical_messages_count` שווה ל-0 **וגם** `producers_halted` הוא `true`, המנתח מזהה שכל ההודעות הקריטיות נצרכו אך היצרנים עדיין מושעים (ייתכן וצרכן בודד עשה זאת, אך המנתח מוודא את המצב). הוא משנה את `producers_halted` ל-`false` ומאותת באמצעות `pthread_cond_broadcast` לכל חוטי היצרן הממתינים על `producers_resume_cv` כדי שימשיכו לפעול.\n5.  הוא משחרר את `queue_mutex`.\n\n**יתרונות הפתרון:**\n-   שימוש במנעול יחיד לכל המצב המשותף מונע קיפאונות הנובעים מסדר נעילה שונה.\n-   שימוש נכון במשתני תנאי מבטיח שחוטים ממתינים ביעילות ולא מבצעים busy-waiting.\n-   הפרדה ברורה בין תנאי ההמתנה של התור המלא/ריק לבין תנאי ההמתנה של השעיית היצרנים מסייעת בהבנת הלוגיקה.\n-   ה-`broadcast` ב-`producers_resume_cv` מבטיח שכל היצרנים המושעים יתעוררו כאשר התנאי משתנה."
    },
    "difficulty_estimation": "Hard"
  }
}