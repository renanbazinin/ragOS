{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory and Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 11:11:30",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2412,
      "output_tokens": 1586,
      "total_tokens": 5914
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Virtual Memory",
      "Copy-on-Write",
      "Process Management"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת בזיכרון וירטואלי ובמנגנון דפדוף (paging). תהליך אב מבצע קריאת מערכת `fork()` ליצירת תהליך בן.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "א. הסבר כיצד מנגנון Copy-on-Write (CoW) משפיע על דפי הזיכרון המשותפים בין תהליך האב לתהליך הבן מיד לאחר קריאת ה-`fork()`.",
        "code_snippet": null,
        "options": null,
        "solution": {
          "is_present_in_file": true,
          "correct_option": null,
          "explanation": null
        }
      },
      {
        "id": "10.2",
        "text": "ב. תאר מה קורה כאשר תהליך האב או הבן מנסה לכתוב לדף זיכרון שהיה משותף במקור תחת מנגנון CoW.",
        "code_snippet": null,
        "options": null,
        "solution": {
          "is_present_in_file": true,
          "correct_option": null,
          "explanation": null
        }
      },
      {
        "id": "10.3",
        "text": "ג. השווה את צריכת הזיכרון הפיזי הכוללת עבור תהליך האב והבן במצב שבו המערכת תומכת ב-CoW לעומת מצב שבו היא אינה תומכת ב-CoW (בהנחה שכל הדפים של התהליך נטענים לזיכרון הפיזי).",
        "code_snippet": null,
        "options": null,
        "solution": {
          "is_present_in_file": true,
          "correct_option": null,
          "explanation": null
        }
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. מיד לאחר קריאת ה-`fork()`, במערכת התומכת ב-Copy-on-Write, תהליך האב והתהליך הבן חולקים את אותם דפי זיכרון פיזיים עבור כל מרחב הכתובות שלהם (קוד, נתונים, מחסנית, ערימה). דפים אלו מסומנים בטבלאות הדפים של שני התהליכים כקריאה בלבד (read-only). בפועל, לא מתבצעת העתקה פיזית של הזיכרון בשלב זה, אלא רק העתקה של טבלאות הדפים (או הצבעה לאותן טבלאות דפים משותפות), וכל הכניסות לדפים המשותפים מצביעות על אותן מסגרות זיכרון פיזיות.\n\nב. כאשר אחד מהתהליכים (האב או הבן) מנסה לבצע פעולת כתיבה לדף זיכרון שהיה משותף במקור וסומן כקריאה בלבד, מתרחשת 'הפרעת דף' (page fault). מערכת ההפעלה מזהה שההפרעה נובעת מניסיון כתיבה לדף המסומן כ-read-only תחת מנגנון CoW. בתגובה, מערכת ההפעלה מבצעת את הפעולות הבאות:\n1.  מקצה מסגרת זיכרון פיזי חדשה.\n2.  מעתיקה את תוכן הדף המקורי למסגרת הפיזית החדשה.\n3.  מעדכנת את כניסת טבלת הדפים של התהליך המבצע את הכתיבה, כך שתצביע על המסגרת הפיזית החדשה.\n4.  מסמנת את כניסת טבלת הדפים של התהליך המבצע את הכתיבה כניתנת לכתיבה (writable).\nהתהליך השני (שלא ביצע את הכתיבה) ממשיך להצביע על הדף הפיזי המקורי, והדף הזה נשאר מסומן כקריאה בלבד בטבלת הדפים שלו (אלא אם כן הוא גם מנסה לכתוב אליו מאוחר יותר).\n\nג. השוואת צריכת זיכרון פיזי:\n*   **ללא תמיכה ב-CoW:** כאשר תהליך מבצע `fork()` במערכת ללא CoW, מערכת ההפעלה נאלצת להעתיק באופן מיידי את כל דפי הזיכרון הניתנים לכתיבה (writable pages) של תהליך האב למסגרות פיזיות חדשות עבור תהליך הבן. זה מוביל לצריכת זיכרון פיזי כפולה עבור דפים אלו מיד לאחר ה-`fork()`, גם אם התהליך הבן לעולם לא ישנה את רוב הנתונים. לדוגמה, אם לתהליך האב יש 100 דפי נתונים ניתנים לכתיבה, לאחר ה-`fork()` יוקצו 100 דפים נוספים עבור הבן, ובסה\"כ 200 דפים פיזיים עבור נתונים אלו.\n*   **עם תמיכה ב-CoW:** עם CoW, מיד לאחר ה-`fork()`, רוב דפי הזיכרון (כולל הניתנים לכתיבה) משותפים בין האב לבן. העתקה פיזית של דף מתרחשת רק כאשר אחד התהליכים מנסה לשנות אותו. זה חוסך משמעותית בזיכרון פיזי, במיוחד אם תהליכי הבן מבצעים בעיקר קריאה מנתוני האב, או משנים רק חלק קטן מהם. לדוגמה, אם לתהליך האב יש 100 דפי נתונים ניתנים לכתיבה, ורק 5 מהם שונו על ידי הבן, אז רק 5 דפים יועתקו פיזית (סה\"כ 105 דפים פיזיים עבור נתונים אלו), במקום 200 ללא CoW. החיסכון בזיכרון מתבטא גם בביצועים טובים יותר, מכיוון שיש פחות פעולות העתקה יקרות ב-`fork()`."
    },
    "difficulty_estimation": "Medium"
  }
}