{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling and Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 11:49:21",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2319,
      "output_tokens": 2307,
      "total_tokens": 9476
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "CPU Scheduling",
      "Context Switching",
      "Threads"
    ],
    "content": {
      "text": "החלפת הקשר (Context Switching) היא פעולה מהותית במערכות הפעלה מרובות משימות, אך היא גם כרוכה בתקורה משמעותית. ענו על השאלות הבאות:",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "א. מהי החלפת הקשר? פרטו את השלבים העיקריים המעורבים בביצועה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "ב. השוו את עלות החלפת ההקשר בין תהליכונים ברמת המשתמש (User-level threads) לבין תהליכונים ברמת הליבה (Kernel-level threads). הסבירו מדוע יש הבדל בעלויות.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "ג. נתון יישום המבצע מספר רב של פעולות קלט/פלט ומשתמש בתהליכונים. אם מערכת ההפעלה משתמשת באלגוריתם תזמון Round Robin עם קוונטום זמן קצר מאוד, כיצד תשפיע הבחירה בין תהליכונים ברמת המשתמש לתהליכונים ברמת הליבה על תדירות החלפות ההקשר ועל הביצועים הכוללים של היישום? נמקו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 15,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסבר:\n\n10.1. החלפת הקשר היא תהליך שבו מערכת ההפעלה שומרת את מצבו (ההקשר) של תהליך או תהליכון שרץ כעת על המעבד, וטוענת את מצבו של תהליך או תהליכון אחר כדי שיוכל להתחיל לרוץ. זהו מנגנון בסיסי המאפשר ריבוי משימות (multitasking) וחלוקת זמן המעבד בין ישויות שונות.\nהשלבים העיקריים המעורבים בביצוע החלפת הקשר הם:\n1.  שמירת מצב המעבד (ערכי אוגרים כלליים, מונה תוכנית (PC), מצביע מחסנית (SP) וכו') של התהליך/תהליכון הנוכחי לתוך בלוק בקרת התהליך (PCB) או בלוק בקרת התהליכון (TCB) שלו.\n2.  שמירת מידע קשור לניהול זיכרון (כגון אוגרי יחידת ניהול זיכרון - MMU, או אוגר בסיס טבלת הדפים) אם מדובר בהחלפה בין תהליכים שונים.\n3.  במקרים של החלפה בין תהליכים, ייתכן שיהיה צורך לבטל רשומות מטמון תרגום הכתובות (TLB invalidate/flush) כדי למנוע שימוש במיפויים שגויים של הזיכרון הווירטואלי.\n4.  טעינת מצב המעבד (אוגרים, PC, SP וכו') של התהליך/תהליכון החדש מתוך ה-PCB/TCB שלו.\n5.  עדכון אוגרי ניהול הזיכרון עבור התהליך החדש, במידת הצורך.\n6.  עדכון מצב התהליך/תהליכון בטבלאות התזמון של מערכת ההפעלה.\n\n10.2. ההבדל בעלויות החלפת ההקשר בין תהליכונים ברמת המשתמש (User-level threads - ULTs) לבין תהליכונים ברמת הליבה (Kernel-level threads - KLTs) נובע מאופן המימוש והשליטה עליהם:\n*   **תהליכונים ברמת המשתמש (ULTs):** ממומשים ומנוהלים על ידי ספריית זמן ריצה (runtime library) במרחב המשתמש, מבלי שהליבה תהיה מודעת לקיומם האינדיבידואלי. הליבה רואה רק את התהליך הבודד המכיל את כל התהליכונים הללו. כאשר מתרחשת החלפת הקשר בין שני ULTs השייכים לאותו תהליך, היא מתבצעת באופן מלא במרחב המשתמש. אין צורך במעבר למצב ליבה (kernel mode), אין צורך לשטוף את ה-TLB (מכיוון שמרחב הכתובות נשאר זהה), ופחות אוגרים כלליים של המעבד נשמרים/נטענים (רק אלו הספציפיים לתהליכון, לא אלו של התהליך כולו). לכן, עלות החלפת ההקשר של ULTs היא **נמוכה יותר**.\n*   **תהליכונים ברמת הליבה (KLTs):** ממומשים ומנוהלים ישירות על ידי מערכת ההפעלה (הליבה). הליבה מודעת לכל KLT בנפרד ומבצעת את תזמונם. כאשר מתרחשת החלפת הקשר בין KLTs (גם אם הם שייכים לאותו תהליך), היא דורשת מעבר למצב ליבה. מעבר זה כרוך בשמירת מצב מלא יותר של המעבד ובביצוע פעולות נוספות על ידי הליבה. גם אם TLB אינו נשטף בהחלפה בין KLTs באותו תהליך, התקורה של הכניסה והיציאה ממצב ליבה הופכת את הפעולה ל**יקרה יותר** בהשוואה להחלפה בין ULTs.\n\n10.3. נתון יישום עם מספר רב של פעולות קלט/פלט ואלגוריתם תזמון Round Robin עם קוונטום זמן קצר מאוד:\n\n*   **במקרה של תהליכונים ברמת המשתמש (ULTs):**\n    *   **תדירות החלפות הקשר:** החלפות הקשר פנימיות בין ULTs באותו תהליך יהיו תכופות (בגלל שהם נתמכים על ידי ספריית המשתמש והיישום יכול להחליט מתי להחליף). עם זאת, כאשר ULT אחד מבצע פעולת קלט/פלט חוסמת (blocking I/O), הליבה רואה את *כל התהליך* כחסום. במצב זה, הליבה תבצע החלפת הקשר ל*תהליך אחר לגמרי*. כל שאר ה-ULTs בתוך אותו תהליך, גם אם הם מוכנים לריצה, לא יוכלו לרוץ עד שפעולת הקלט/פלט של ה-ULT החוסם תסתיים. זה יוביל לתדירות נמוכה יותר של החלפות קשר *מועילות* עבור היישום הספציפי, שכן ה-CPU לא ינוצל על ידי תהליכונים אחרים באותו תהליך בזמן ההמתנה.\n    *   **ביצועים כוללים:** הביצועים יהיו **נמוכים יחסית**. למרות שהחלפות הקשר פנימיות הן זולות, חסימה של ULT אחד משתקת את כל התהליך. קוונטום זמן קצר באלגוריתם RR של הליבה יגרום להחלפות קשר תכופות בין תהליכים שונים, אך לא יסייע לניצול יעיל של ה-CPU בתוך התהליך המושפע מפעולות קלט/פלט חוסמות.\n\n*   **במקרה של תהליכונים ברמת הליבה (KLTs):**\n    *   **תדירות החלפות הקשר:** תהיה **גבוהה יותר**. מכיוון שהליבה מודעת לכל KLT בנפרד, אלגוריתם ה-Round Robin עם קוונטום זמן קצר יתזמן אותם באופן פעיל. כאשר KLT אחד נחסם על ידי פעולת קלט/פלט, הליבה יכולה לבצע החלפת הקשר ל-KLT *אחר באותו תהליך* (אם קיים כזה ומוכן לריצה) או ל-KLT מתהליך אחר. זה יגרום להחלפות קשר תכופות יותר ברמת הליבה.\n    *   **ביצועים כוללים:** הביצועים יהיו **טובים יותר**. למרות שעלות החלפת קשר בודדת בין KLTs גבוהה יותר מאשר בין ULTs, היכולת של הליבה לתזמן KLTs באופן עצמאי מאפשרת ניצול טוב יותר של המעבד. כאשר KLT אחד ממתין לקלט/פלט, KLTs אחרים באותו תהליך יכולים להמשיך לרוץ, מה שמגביר את התפוקה הכוללת של היישום ואת היענותו (responsiveness). קוונטום זמן קצר יבטיח חלוקה הוגנת ומהירה של זמן המעבד בין כל התהליכונים המוכלים במערכת."
    },
    "difficulty_estimation": "Medium"
  }
}