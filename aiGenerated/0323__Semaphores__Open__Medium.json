{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:46:17",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2630,
      "output_tokens": 1727,
      "total_tokens": 11106
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Semaphores",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה מערכת מרובת חוטים בה קיימת מקטע קוד קריטי שיכול להיות מבוצע על ידי מספר חוטים במקביל. יש לממש מנגנון סנכרון המבטיח שבכל רגע נתון, לא יותר מ-K חוטים יבצעו את המקטע הקריטי. השתמשו בסמפורים בלבד. צרפו קוד C/C++ המדגים את השימוש בסמפורים בתוך פונקציה המייצגת את פעולת החוט, והסבירו את הלוגיקה, כולל אתחול הסמפורים ומיקום פעולות ה-wait וה-signal.",
      "code_snippet": "// Assume semaphore related headers are included (e.g., <semaphore.h>, <pthread.h>)\n// Assume a global semaphore 'resource_access' is declared.\n\nvoid thread_function(int thread_id) {\n    // קוד לפני המקטע הקריטי\n    printf(\"Thread %d attempting to enter critical section.\\n\", thread_id);\n\n    // TODO: הוסף כאן את קריאות ה-wait לסמפור 'resource_access'\n    \n    // המקטע הקריטי (critical section)\n    printf(\"Thread %d entered critical section.\\n\", thread_id);\n    // סימולציה של עבודה במקטע הקריטי\n    sleep(1);\n    printf(\"Thread %d exiting critical section.\\n\", thread_id);\n\n    // TODO: הוסף כאן את קריאות ה-signal לסמפור 'resource_access'\n    \n    // קוד אחרי המקטע הקריטי\n}\n\n// TODO: יש להוסיף אתחול לסמפור הגלובלי 'resource_access' לערך K במיין,\n// וכן אתחול וסיום תהליכונים (threads) ושחרור משאבים.\n// int main() { ... }"
    },
    "sub_questions": null,
    "points": 15,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון דורש שימוש בסמפור מונה (counting semaphore). סמפור זה מאותחל לערך K, המייצג את מספר המקומות הפנויים במקטע הקריטי. כל חוט שמעוניין להיכנס למקטע הקריטי מבצע פעולת wait (או P) על הסמפור. פעולה זו מקטינה את מונה הסמפור באחד. אם מונה הסמפור הופך שלילי (כלומר, כל K המקומות תפוסים), החוט נחסם עד שחוט אחר ישחרר מקום. לאחר שהחוט מסיים את ביצוע המקטע הקריטי, הוא מבצע פעולת signal (או V) על הסמפור. פעולה זו מגדילה את מונה הסמפור באחד. אם היו חוטים חסומים שממתינים למקום, אחד מהם ישוחרר ויורשה לו להיכנס למקטע הקריטי.\n\nלהלן מימוש ב-C/C++:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep\n\n// הגדרת סמפור גלובלי\nsem_t resource_access;\n\nvoid *thread_function(void *arg) {\n    int thread_id = *(int*)arg;\n    \n    // קוד לפני המקטע הקריטי\n    printf(\"חוט %d מנסה להיכנס למקטע הקריטי.\\n\", thread_id);\n\n    // פעולת wait (P) על הסמפור לפני הכניסה למקטע הקריטי\n    // אם מספר המשאבים הפנויים (K) הוא 0, החוט ייחסם כאן.\n    sem_wait(&resource_access);\n    \n    // המקטע הקריטי (critical section)\n    int val;\n    sem_getvalue(&resource_access, &val); // בדיקת ערך הסמפור (לצורך הדגמה)\n    printf(\"חוט %d נכנס למקטע הקריטי. מקומות פנויים נותרו: %d\\n\", thread_id, val);\n    sleep(2); // סימולציה של עבודה במקטע הקריטי\n    printf(\"חוט %d יוצא מהמקטע הקריטי.\\n\", thread_id);\n\n    // פעולת signal (V) על הסמפור לאחר היציאה מהמקטע הקריטי\n    // משחרר \\\"מקום\\\" אחד במקטע הקריטי, ואם יש חוטים חסומים, אחד מהם ישוחרר.\n    sem_post(&resource_access);\n    \n    // קוד אחרי המקטע הקריטי\n    return NULL;\n}\n\nint main() {\n    int N_THREADS = 10; // לדוגמה, 10 חוטים\n    int K_LIMIT = 3;    // לדוגמה, לכל היותר 3 חוטים במקביל\n    pthread_t threads[N_THREADS];\n    int thread_ids[N_THREADS];\n\n    // אתחול הסמפור:\n    // הארגומנט הראשון הוא מצביע לסמפור.\n    // הארגומנט השני הוא 0 אם הסמפור משמש חוטים באותו תהליך, או 1 אם הוא משותף בין תהליכים.\n    // הארגומנט השלישי הוא הערך ההתחלתי של הסמפור, שהוא K_LIMIT במקרה זה.\n    // K_LIMIT מייצג את מספר ה\\\"היתרים\\\" או ה\\\"מקומות\\\" הזמינים במקטע הקריטי.\n    if (sem_init(&resource_access, 0, K_LIMIT) != 0) {\n        perror(\"sem_init failed\");\n        return 1;\n    }\n\n    // יצירת והפעלת החוטים\n    for (int i = 0; i < N_THREADS; i++) {\n        thread_ids[i] = i;\n        if (pthread_create(&threads[i], NULL, thread_function, &thread_ids[i]) != 0) {\n            perror(\"pthread_create failed\");\n            return 1;\n        }\n    }\n\n    // המתנה לסיום החוטים\n    for (int i = 0; i < N_THREADS; i++) {\n        pthread_join(threads[i], NULL);\n    }\n\n    // שחרור משאבים - השמדת הסמפור\n    sem_destroy(&resource_access);\n\n    printf(\"כל החוטים סיימו את פעולתם.\\n\");\n\n    return 0;\n}\n```"
    },
    "difficulty_estimation": "Medium"
  }
}