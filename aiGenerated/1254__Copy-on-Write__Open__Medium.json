{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 08:59:39",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3509,
      "output_tokens": 3236,
      "total_tokens": 12606
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Copy-on-Write",
      "Processes"
    ],
    "content": {
      "text": "מנגנון Copy-on-Write (CoW) הוא אופטימיזציה נפוצה בניהול זיכרון, המשמשת במערכות הפעלה רבות, במיוחד בהקשר של יצירת תהליכים חדשים באמצעות קריאת המערכת `fork()`. מנגנון זה מאפשר לתהליכים שונים לחלוק עמודי זיכרון פיזיים כל עוד הם רק קוראים מהם, ורק כאשר אחד מהם מנסה לכתוב לעמוד משותף, נוצר עותק פרטי של העמוד עבור התהליך הכותב.\n\nנתון קטע הקוד הבא:\n",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define PAGE_SIZE 4096 // Assume a page size of 4KB\n\nint global_var = 10;\nint large_array[PAGE_SIZE / sizeof(int)]; // An array that fills one page\n\nint main() {\n    for (int i = 0; i < PAGE_SIZE / sizeof(int); i++) {\n        large_array[i] = i;\n    }\n\n    pid_t pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        exit(1);\n    } else if (pid == 0) { // Child process\n        printf(\"Child: global_var before change = %d\\n\", global_var);\n        printf(\"Child: large_array[0] before change = %d\\n\", large_array[0]);\n        global_var = 20; // Write 1\n        large_array[0] = 100; // Write 2\n        printf(\"Child: global_var after change = %d\\n\", global_var);\n        printf(\"Child: large_array[0] after change = %d\\n\", large_array[0]);\n        exit(0);\n    } else { // Parent process\n        wait(NULL); // Wait for child to finish\n        printf(\"Parent: global_var after child = %d\\n\", global_var);\n        printf(\"Parent: large_array[0] after child = %d\\n\", large_array[0]);\n        large_array[1] = 200; // Write 3\n        printf(\"Parent: large_array[1] after change = %d\\n\", large_array[1]);\n    }\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "101.1",
        "text": "א. תארו כיצד מנגנון Copy-on-Write ממומש ברמת טבלאות הדפים (Page Tables) כאשר תהליך אב יוצר תהליך בן באמצעות `fork()`. התייחסו לשינויים בביטי ההרשאות (permissions bits) ובמצבי הדפים (page states).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.2",
        "text": "ב. נתחו את קטע הקוד המצורף. תארו באופן מפורט אילו כתיבות (Write 1, Write 2, Write 3) יגרמו ל-CoW Page Faults, ומדוע. עבור כל CoW Page Fault, הסבירו מהם השלבים שמערכת ההפעלה תבצע כדי לטפל בו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.3",
        "text": "ג. ציינו שני יתרונות עיקריים של מנגנון CoW בהשוואה לשיטה של העתקה מלאה של כל מרחב הכתובות של האב לבן מיד עם קריאת ה-`fork()`. כמו כן, ציינו חסרון פוטנציאלי אחד או מקרה שבו CoW עלול להיות פחות יעיל.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. כאשר תהליך אב יוצר תהליך בן באמצעות `fork()`:\n1.  מערכת ההפעלה יוצרת טבלת דפים חדשה עבור תהליך הבן.\n2.  במקום להעתיק את כל העמודים הפיזיים ממרחב הכתובות של האב לבן, מערכת ההפעלה גורמת לכך שרשומות טבלת הדפים (Page Table Entries - PTEs) הן של האב והן של הבן, יצביעו על אותם עמודים פיזיים בזיכרון.\n3.  ביטי ההרשאות של עמודים אלו בשתי טבלאות הדפים (של האב ושל הבן) מוגדרים כ-'קריאה בלבד' (Read-Only). ביט 'שינוי' (dirty bit) מאופס. בנוסף, ביט 'נוכחות' (present bit) מוגדר כדי להעיד שהעמוד נמצא בזיכרון הפיזי.\n4.  כאשר אחד מהתהליכים (האב או הבן) מנסה לכתוב לעמוד כזה, המעבד יזהה הפרת הרשאה (write-protection fault) ויפעיל פסיקת דף (page fault) לליבה.\n\nב. ניתוח קטע הקוד:\n*   **מצב התחלתי לאחר `fork()`**: המשתנים `global_var` ו-`large_array` נמצאים בעמודים פיזיים משותפים לאב ולבן. רשומות טבלת הדפים עבור עמודים אלו בשני התהליכים מצביעות על אותם עמודים פיזיים, וההרשאות מוגדרות כ-'קריאה בלבד'.\n\n*   **`global_var = 20;` (Write 1 - תהליך בן)**:\n    *   **CoW Page Fault?** כן. זוהי הכתיבה הראשונה לעמוד המכיל את `global_var` על ידי הבן. העמוד מוגדר כ-Read-Only בטבלת הדפים של הבן.\n    *   **פעולת מערכת ההפעלה**: כאשר הבן מנסה לכתוב, נגרמת פסיקת דף (write-protection fault).\n        1.  מערכת ההפעלה מזהה את הפסיקה.\n        2.  מקצה עמוד פיזי חדש בזיכרון עבור הבן.\n        3.  מעתיקה את התוכן של העמוד הפיזי המקורי (שמכיל את `global_var`) אל העמוד הפיזי החדש שהוקצה.\n        4.  מעדכנת את רשומת טבלת הדפים של הבן עבור הכתובת הווירטואלית של `global_var` כך שתצביע על העמוד הפיזי החדש, ומגדירה את ההרשאות שלו ל-'קריאה וכתיבה' (Read-Write). ביט ה-dirty מוגדר.\n        5.  הכתיבה של `global_var = 20` מתבצעת כעת בעמוד החדש של הבן.\n    *   **תוצאה**: לאב נשאר עותק משלו של `global_var` (שערכו עדיין 10), ולבן יש עותק משלו (שערכו כעת 20).\n\n*   **`large_array[0] = 100;` (Write 2 - תהליך בן)**:\n    *   **CoW Page Fault?** כן. זוהי הכתיבה הראשונה לעמוד המכיל את `large_array` על ידי הבן. העמוד מוגדר כ-Read-Only בטבלת הדפים של הבן.\n    *   **פעולת מערכת ההפעלה**: תהליך דומה ל-Write 1.\n        1.  נגרמת פסיקת דף.\n        2.  מערכת ההפעלה מקצה עמוד פיזי חדש.\n        3.  מעתיקה את תוכן העמוד הפיזי המקורי (שמכיל את `large_array`) אל העמוד הפיזי החדש.\n        4.  מעדכנת את רשומת טבלת הדפים של הבן עבור הכתובת הווירטואלית של `large_array` כך שתצביע על העמוד הפיזי החדש, ומגדירה את ההרשאות שלו ל-'קריאה וכתיבה'.\n        5.  הכתיבה של `large_array[0] = 100` מתבצעת כעת בעמוד החדש של הבן.\n    *   **תוצאה**: לאב נשאר עותק משלו של `large_array` (עם הערכים המקוריים), ולבן יש עותק משלו (עם `large_array[0] = 100`).\n\n*   **`large_array[1] = 200;` (Write 3 - תהליך אב)**:\n    *   **CoW Page Fault?** כן. זוהי הכתיבה הראשונה לעמוד המכיל את `large_array` על ידי האב (אחרי שהבן כבר יצר עותק משלו). העמוד הפיזי שהאב עדיין מצביע עליו מוגדר כ-Read-Only בטבלת הדפים של האב.\n    *   **פעולת מערכת ההפעלה**: תהליך דומה ל-Write 1 ו-Write 2.\n        1.  נגרמת פסיקת דף.\n        2.  מערכת ההפעלה מקצה עמוד פיזי חדש עבור האב (אם העמוד המקורי עדיין משותף עם תהליכים אחרים, או אם הוא עדיין מוגדר כ-Read-Only). במקרה זה, העמוד המקורי שהאב הצביע עליו היה משותף (לפני שהבן עשה CoW), ולאחר שהבן עשה CoW, האב עדיין מצביע על העמוד המקורי שעדיין מסומן כ-Read-Only (כי הוא היה משותף פוטנציאלית). לכן, גם עבור האב תתרחש פסיקה.\n        3.  מעתיקה את תוכן העמוד הפיזי המקורי (שמכיל את `large_array`, כפי שהאב רואה אותו) אל העמוד הפיזי החדש.\n        4.  מעדכנת את רשומת טבלת הדפים של האב עבור הכתובת הווירטואלית של `large_array` כך שתצביע על העמוד הפיזי החדש, ומגדירה את ההרשאות שלו ל-'קריאה וכתיבה'.\n        5.  הכתיבה של `large_array[1] = 200` מתבצעת כעת בעמוד החדש של האב.\n    *   **תוצאה**: האב מקבל עותק משלו של העמוד ומעדכן אותו. העמוד של הבן נשאר ללא שינוי מהכתיבה של האב.\n\nג. יתרונות וחסרונות של CoW:\n*   **יתרונות עיקריים**:\n    1.  **חיסכון בזיכרון**: אם תהליך הבן אינו משנה חלקים נרחבים ממרחב הכתובות של האב, הוא יכול להמשיך לחלוק עמודים פיזיים רבים, ובכך לחסוך בצריכת זיכרון RAM. זה יעיל במיוחד בתרחישים שבהם תהליך בן נוצר רק כדי לבצע `exec()` מיד לאחר מכן (לדוגמה, כאשר מעטפת (shell) מריצה פקודה), שכן במקרה כזה כל מרחב הכתובות של הבן מוחלף בכל מקרה.\n    2.  **יצירת תהליכים מהירה יותר**: פעולת ה-`fork()` הופכת למהירה יותר משמעותית, מכיוון שהיא דורשת רק העתקת טבלת הדפים ועדכון ביטי הרשאות, במקום העתקה פיזית של כל תוכן הזיכרון. זה מפחית את זמן ההשהיה ביצירת תהליכים חדשים.\n\n*   **חסרון פוטנציאלי / מקרה שבו CoW פחות יעיל**:\n    1.  **תקורה של פסיקות דף (Page Fault Overhead)**: אם תהליך הבן או האב משנים מספר רב של עמודים מיד לאחר ה-`fork()`, כל כתיבה ראשונה לעמוד תגרום לפסיקת דף CoW. כל פסיקה כזו דורשת התערבות של מערכת ההפעלה, הקצאת זיכרון פיזי חדש, והעתקת תוכן העמוד. במקרים קיצוניים, שבהם כמעט כל העמודים משתנים, התקורה המצטברת של פסיקות אלו עלולה להיות גבוהה יותר מהעלות של העתקה מלאה של כל מרחב הכתובות מלכתחילה."
    },
    "difficulty_estimation": "Medium"
  }
}