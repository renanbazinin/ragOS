{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:47:31",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2630,
      "output_tokens": 2335,
      "total_tokens": 13419
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Threads"
    ],
    "content": {
      "text": "נתונה מערכת עם N חוטים. כל חוט מבצע באופן מחזורי שתי משימות: `Task A` ולאחריה `Task B`. יש דרישת סנכרון לפיה אף חוט לא יכול להתחיל את `Task B` שלו לפני שכל N החוטים סיימו את `Task A` שלהם. כלומר, כל החוטים חייבים להגיע לנקודת מחסום (Barrier) לאחר `Task A` לפני שהם ממשיכים ל`Task B`. מנגנון המחסום צריך להיות ניתן לשימוש חוזר (reusable) עבור המחזורים הבאים.\nכתוב את קוד ה-C/C++ עבור פונקציית `worker_thread` שתממש את ההתנהגות המתוארת, תוך שימוש בסמפורים (semaphores) ובמנעולים (mutexes) בלבד. יש להגדיר את כל המשתנים הגלובליים הנדרשים ולאתחל אותם כראוי. אין להשתמש באובייקטי סנכרון מובנים אחרים (כמו `pthread_barrier_t`).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון מבוסס על מנגנון \"מחסום דו-שלבי\" (Double Turnstile Barrier), המשתמש בשני סמפורים (turnstiles) ובמנעול (mutex) כדי להבטיח סנכרון נכון ושימוש חוזר.\n\n**1. משתנים גלובליים ואתחול:**\n```c\n#include <pthread.h>\n#include <semaphore.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For sleep (in example tasks)\n\n// הגדרת מספר החוטים הכולל\n#define NUM_THREADS 5 // N לדוגמה\n\nint N = NUM_THREADS;\nint count = 0;\npthread_mutex_t mutex;\nsem_t barrier;\nsem_t barrier_reset;\n\nvoid init_barrier() {\n    pthread_mutex_init(&mutex, NULL);\n    sem_init(&barrier, 0, 0);       // סמפור ראשי (סגור בהתחלה)\n    sem_init(&barrier_reset, 0, 1); // סמפור איפוס (פתוח בהתחלה)\n}\n\nvoid destroy_barrier() {\n    pthread_mutex_destroy(&mutex);\n    sem_destroy(&barrier);\n    sem_destroy(&barrier_reset);\n}\n```\n\n**2. פונקציית `barrier_wait()`:**\nפונקציה זו מממשת את ההמתנה במחסום:\n```c\nvoid barrier_wait() {\n    // שלב 1: איסוף החוטים במחסום הראשון\n    pthread_mutex_lock(&mutex);\n    count++;\n    if (count == N) {\n        // החוט האחרון שהגיע: סוגר את מחסום האיפוס ופותח את המחסום הראשי\n        sem_wait(&barrier_reset); \n        for (int i = 0; i < N; i++) {\n            sem_post(&barrier);\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    sem_wait(&barrier); // כל החוטים ממתינים כאן עד שהמחסום הראשי ייפתח\n\n    // שלב 2: איפוס המחסום עבור המחזור הבא\n    pthread_mutex_lock(&mutex);\n    count--;\n    if (count == 0) {\n        // החוט האחרון שיוצא: סוגר את המחסום הראשי ופותח את מחסום האיפוס\n        for (int i = 0; i < N; i++) {\n            sem_post(&barrier_reset);\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    sem_wait(&barrier_reset); // כל החוטים ממתינים כאן עד שמחסום האיפוס ייפתח\n}\n```\n\n**3. פונקציית `worker_thread`:**\nכל חוט מבצע את המשימות שלו ומשתמש ב-`barrier_wait`:\n```c\n// פונקציות לדוגמה למשימות A ו-B (אין צורך לממשן במבחן, רק לצורך הדגמה)\nvoid taskA(int thread_id) {\n    printf(\"Thread %d: Starting Task A\\n\", thread_id);\n    sleep(rand() % 2); // הדמיית עבודה\n    printf(\"Thread %d: Finished Task A\\n\", thread_id);\n}\n\nvoid taskB(int thread_id) {\n    printf(\"Thread %d: Starting Task B\\n\", thread_id);\n    sleep(rand() % 2); // הדמיית עבודה\n    printf(\"Thread %d: Finished Task B\\n\", thread_id);\n}\n\nvoid *worker_thread(void *arg) {\n    int thread_id = *(int *)arg;\n    free(arg); // שחרור הזיכרון שהוקצה למזהה החוט\n\n    while (1) { // לולאה אינסופית עבור מחזורים חוזרים\n        taskA(thread_id);\n        barrier_wait(); // המתן עד שכל N החוטים יסיימו את Task A\n        taskB(thread_id);\n        printf(\"Thread %d: Cycle complete.\\n\", thread_id);\n        sleep(1); // השהייה קטנה לפני המחזור הבא\n    }\n    return NULL;\n}\n```\n\n**הסבר מפורט:**\n\n*   **משתנים גלובליים:**\n    *   `N`: קבוע המגדיר את מספר החוטים הכולל במערכת. יש לאתחל אותו לפני יצירת החוטים.\n    *   `count`: מונה את מספר החוטים שהגיעו לנקודת הסנכרון בשלב הנוכחי. מאופס בכל מחזור.\n    *   `mutex`: מנעול `pthread_mutex_t` המשמש להגנה על הגישה למשתנה `count` המשותף, ובכך מבטיח עדכון אטומי (atomic) של המונה. מאותחל ל-1 (פתוח).\n    *   `barrier`: סמפור `sem_t` המשמש לחסימת חוטים בשלב הראשון של המחסום, עד שכל `N` החוטים מגיעים. מאותחל ל-0 (סגור לחלוטין).\n    *   `barrier_reset`: סמפור `sem_t` נוסף המשמש לחסימת חוטים בשלב השני, ומונע מהם להתחיל מחזור חדש לפני שכל החוטים סיימו את המחזור הקודם. מאותחל ל-1 (פתוח עבור המחזור הראשון).\n\n*   **פעולת `barrier_wait()`:**\n    1.  **שלב ראשון (איסוף):** כל חוט שמגיע קורא ל-`pthread_mutex_lock(&mutex)`, מגדיל את `count`, ומשחרר את ה-`mutex`. כאשר החוט ה-`N` מגיע (כלומר, `count` מגיע ל-`N`), הוא מזהה שהוא האחרון. חוט זה מבצע `sem_wait(&barrier_reset)` כדי \"לסגור\" את שער האיפוס (ובכך למנוע מחזורים עתידיים להתקדם בטרם עת) ולאחר מכן מבצע `sem_post(&barrier)` `N` פעמים. פעולה זו משחררת את כל `N` החוטים שייתכן שממתינים או שיגיעו בקרוב ל-`sem_wait(&barrier)`. כל החוטים, כולל החוט ה-`N`, ממתינים ב-`sem_wait(&barrier)` עד שהסמפור ייפתח.\n    2.  **שלב שני (איפוס):** לאחר שכל החוטים עברו את `sem_wait(&barrier)`, הם נכנסים לשלב השני. כל חוט נועל שוב את ה-`mutex`, מקטין את `count`, ומשחרר את ה-`mutex`. כאשר החוט האחרון שיוצא (כלומר, `count` מגיע ל-`0`) מזהה שהוא האחרון. חוט זה מבצע `sem_post(&barrier_reset)` `N` פעמים כדי \"לפתוח\" מחדש את שער האיפוס עבור המחזור הבא. כל החוטים ממתינים ב-`sem_wait(&barrier_reset)` עד שהסמפור ייפתח. זה מבטיח שכל החוטים סיימו לחלוטין את המחזור הנוכחי (כולל איפוס המונה) לפני שמישהו יתחיל את השלב הראשון של המחזור הבא.\n\n*   **פונקציית `worker_thread`:** כל חוט מבצע בלולאה אינסופית את `taskA`, ולאחר מכן קורא ל-`barrier_wait()` כדי להמתין לשאר החוטים. רק לאחר שכל `N` החוטים סיימו את `taskA` ועברו את המחסום, כולם ממשיכים יחד ל-`taskB`. הדבר מבטיח את דרישת הסנכרון ואת יכולת השימוש החוזר של המחסום."
    },
    "difficulty_estimation": "Medium"
  }
}