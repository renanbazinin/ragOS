{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Synchronization",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 19:49:24",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3682,
      "output_tokens": 1311,
      "total_tokens": 7046
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Race Condition",
      "Mutex",
      "Threads"
    ],
    "content": {
      "text": "נתונה תוכנית C בה מספר חוטים (threads) ניגשים במקביל למשתנה גלובלי משותף ומגדילים אותו. קטע הקוד הבא מציג את הפונקציה אותה מריץ כל חוט:",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint shared_counter = 0; // משתנה גלובלי משותף\n\nvoid* increment_counter(void* arg) {\n    for (int i = 0; i < 100000; ++i) {\n        shared_counter++; // גישה למשתנה המשותף\n    }\n    return NULL;\n}\n\n// פונקציית main לא הוצגה במלואה, אך היא יוצרת מספר חוטים המריצים את increment_counter",
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "הסבירו מדוע קטע הקוד הנ\"ל עלול להוביל לתוצאה שגויה כאשר מספר חוטים מריצים אותו במקביל. מהו הבעיה המרכזית כאן?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "הציעו פתרון לבעיה באמצעות מנעול (mutex) בסביבת pthreads. כתבו את קטע הקוד המתוקן.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "10.1: הבעיה המרכזית היא תנאי מרוץ (Race Condition). הפעולה `shared_counter++` אינה פעולה אטומית. למעשה, היא מתורגמת למספר הוראות מכונה:\n1. קריאת הערך של `shared_counter` מהזיכרון לתוך רגיסטר.\n2. הגדלת הערך ברגיסטר באחד.\n3. כתיבת הערך המעודכן מהרגיסטר בחזרה לזיכרון.\n\nכאשר מספר חוטים מריצים את הפעולות הללו במקביל, ייתכן שחוט אחד יקרא את הערך של `shared_counter`, לפני שחוט אחר הספיק לכתוב את ערכו המעודכן בחזרה. לדוגמה, אם `shared_counter` הוא 10, חוט A קורא 10, חוט B קורא 10. שניהם מגדילים ל-11 ברגיסטר שלהם. חוט A כותב 11, ומיד אחריו חוט B כותב 11. במקרה כזה, למרות שבוצעו שתי פעולות הגדלה, המונה יגדל רק באחד במקום בשניים, מה שיוביל לתוצאה שגויה (פחותה מהצפוי).\n\n10.2: כדי לפתור את בעיית תנאי המרוץ, יש להגן על הגישה למשתנה המשותף `shared_counter` באמצעות מנעול (mutex). מנעול מבטיח שרק חוט אחד יוכל להיכנס לקטע קריטי (Critical Section) מסוים בכל רגע נתון.\nיש לאתחל את המנעול, לנעול אותו לפני הגישה למשתנה המשותף, ולשחרר אותו לאחר מכן.\n\nקוד מתוקן:\n```c\n#include <stdio.h>\n#include <pthread.h>\n\nint shared_counter = 0; // משתנה גלובלי משותף\npthread_mutex_t counter_mutex; // הכרזת על מנעול\n\nvoid* increment_counter_safe(void* arg) {\n    for (int i = 0; i < 100000; ++i) {\n        pthread_mutex_lock(&counter_mutex); // נעל את המנעול\n        shared_counter++;                   // גישה בטוחה למשתנה המשותף\n        pthread_mutex_unlock(&counter_mutex); // שחרר את המנעול\n    }\n    return NULL;\n}\n\n// פונקציית main (לצורך הדגמה, לא חלק מהשאלה המקורית)\n/*\nint main() {\n    pthread_t threads[5];\n    pthread_mutex_init(&counter_mutex, NULL); // אתחול המנעול\n\n    for (int i = 0; i < 5; ++i) {\n        pthread_create(&threads[i], NULL, increment_counter_safe, NULL);\n    }\n\n    for (int i = 0; i < 5; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", shared_counter); // אמור להיות 500000\n    pthread_mutex_destroy(&counter_mutex); // שחרור המנעול\n    return 0;\n}\n*/\n```"
    },
    "difficulty_estimation": "Easy"
  }
}