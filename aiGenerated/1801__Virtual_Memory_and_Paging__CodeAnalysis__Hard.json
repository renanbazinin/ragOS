{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory and Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:55:47",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2792,
      "output_tokens": 3283,
      "total_tokens": 13422
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Paging",
      "Address Translation",
      "Operating Systems"
    ],
    "content": {
      "text": "מערכת הפעלה מסוימת מממשת זיכרון וירטואלי באמצעות טבלאות עמודים דו-רמתיות. גודל עמוד הוא 4 קילובייט (4KB). כתובות וירטואליות ופיזיות הן בגודל 32 ביט.\n\nמבנה הכתובת הווירטואלית הוא כדלקמן:\n- 10 הסיביות העליונות (ביטים 22-31) משמשות כאינדקס לספריית העמודים (Page Directory Index - VPN1).\n- 10 הסיביות הבאות (ביטים 12-21) משמשות כאינדקס לטבלת העמודים מהרמה השנייה (Page Table Index - VPN2).\n- 12 הסיביות התחתונות (ביטים 0-11) משמשות כהיסט בתוך העמוד (Page Offset).\n\nכל רשומת טבלת עמודים (PTE) היא מספר שלם בגודל 32 ביט (unsigned int) ומכילה את המידע הבא:\n- סיבית 0 (הנמוכה ביותר): Valid bit - מציינת האם הרשומה תקינה (1) או לא (0). אם הרשומה לא תקינה, היא מצביעה על כשל עמוד (Page Fault).\n- סיבית 1: Read-Only bit - מציינת האם העמוד מוגן מפני כתיבה (1) או ניתן לכתיבה (0).\n- סיביות 2-11: שמורות (Reserved) - יש להתעלם מהן.\n- סיביות 12-31: מספר מסגרת פיזית (Physical Frame Number - PFN) - מצביעות על מסגרת הזיכרון הפיזית אליה ממופה העמוד.\n\nהמערכת מספקת שני מערכים גלובליים המדמים את הזיכרון הפיזי שבו מאוחסנות טבלאות העמודים:\n`uint32_t page_directory[1024];` - ספריית העמודים. כל כניסה מכילה PTE המצביע על טבלת עמודים מהרמה השנייה.\n`uint32_t page_tables[1024 * 1024];` - כל טבלאות העמודים מהרמה השנייה. כל כניסה מכילה PTE המצביע על עמוד נתונים.\n\nכתבו את הפונקציה `translate_virtual_to_physical` אשר מקבלת כתובת וירטואלית וסוג גישה (קריאה/כתיבה) ומחזירה את הכתובת הפיזית המתאימה. במקרה של כשל תרגום (Page Fault) או הפרת הרשאות (Permission Violation), הפונקציה צריכה להחזיר את הערך `0xFFFFFFFFU`.\n\nיש להשתמש בפעולות ביט בלבד (AND, OR, SHIFT) לחילוץ המידע מרשומות ה-PTE ומהכתובת הווירטואלית. אין להשתמש במבני `struct` עבור PTE.\n\n**הערה:** המערכים `page_directory` ו-`page_tables` מדמים את הזיכרון הפיזי ומאפשרים גישה ישירה לרשומות טבלאות העמודים. אין צורך לחשב כתובות פיזיות עבור גישה למערכים אלו. PFN של טבלת עמודים ברמה השנייה הוא אינדקס בתוך המערך `page_tables` (כלומר, `page_tables[PFN * 1024]` תהיה תחילת טבלת העמודים הזו).",
      "code_snippet": "#include <stdint.h>\n\n// Constants for virtual address breakdown\n#define PAGE_OFFSET_BITS 12\n#define VPN2_BITS 10\n#define VPN1_BITS 10\n\n#define PAGE_OFFSET_MASK ((1U << PAGE_OFFSET_BITS) - 1)\n#define VPN2_MASK ((1U << VPN2_BITS) - 1)\n#define VPN1_MASK ((1U << VPN1_BITS) - 1)\n\n#define VPN2_SHIFT PAGE_OFFSET_BITS\n#define VPN1_SHIFT (PAGE_OFFSET_BITS + VPN2_BITS)\n\n// Constants for PTE structure (32-bit unsigned int)\n#define PTE_VALID_BIT_SHIFT 0\n#define PTE_RO_BIT_SHIFT 1\n#define PTE_PFN_SHIFT 12 // PFN starts from bit 12\n\n#define PTE_VALID_MASK (1U << PTE_VALID_BIT_SHIFT)\n#define PTE_RO_MASK (1U << PTE_RO_BIT_SHIFT)\n#define PTE_PFN_EXTRACT_MASK (((1U << 20) - 1) << PTE_PFN_SHIFT) // Mask to extract 20 PFN bits (bits 12-31)\n\n#define INVALID_ADDRESS 0xFFFFFFFFU\n\n// Simulated physical memory for page tables\nuint32_t page_directory[1024];\nuint32_t page_tables[1024 * 1024]; // 1024 page tables, each with 1024 entries\n\n// Function to translate virtual address to physical address\n// write_access: 1 if it's a write operation, 0 if read operation\nuint32_t translate_virtual_to_physical(uint32_t virtual_address, int write_access) {\n    // Implement your code here\n}",
      "options": null
    },
    "sub_questions": null,
    "points": 25,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון מורכב ממספר שלבים, העוקבים אחר לוגיקת תרגום הכתובות הדו-רמתית:\n\n1.  **חילוץ רכיבי הכתובת הווירטואלית:**\n    *   ראשית, יש לחלץ את ה-VPN1 (אינדקס ספריית העמודים), ה-VPN2 (אינדקס טבלת העמודים ברמה השנייה) וה-Offset (היסט בתוך העמוד) מהכתובת הווירטואלית שניתנה. זה נעשה באמצעות פעולות הזזה (shift) ומסיכה (AND) בהתאם לקבועי המבנה שהוגדרו.\n\n2.  **בדיקת ספריית העמודים (Page Directory):**\n    *   משתמשים ב-VPN1 כדי לגשת לרשומת ספריית העמודים המתאימה במערך `page_directory`.\n    *   בודקים את סיבית התקינות (Valid bit) של רשומה זו. אם הסיבית אינה דלוקה (0), משמעות הדבר היא כשל עמוד ברמה הראשונה (Page Fault), והפונקציה מחזירה `INVALID_ADDRESS` (`0xFFFFFFFFU`).\n    *   אם הרשומה תקינה, מחלצים ממנה את ה-PFN של טבלת העמודים ברמה השנייה. זהו ה-PFN הבסיסי של טבלת העמודים הזו.\n\n3.  **בדיקת טבלת העמודים ברמה השנייה (Second-Level Page Table):**\n    *   באמצעות ה-PFN של טבלת העמודים ברמה השנייה שחולץ בשלב הקודם, וכן ה-VPN2, מחשבים את האינדקס המתאים במערך `page_tables`. האינדקס מחושב על ידי `(pt_base_pfn * 1024 + vpn2)`, כאשר 1024 הוא מספר הרשומות בטבלת עמודים אחת.\n    *   ניגשים לרשומת טבלת העמודים המתאימה.\n    *   בודקים את סיבית התקינות (Valid bit) של רשומה זו. אם הסיבית אינה דלוקה (0), משמעות הדבר היא כשל עמוד ברמה השנייה (Page Fault), והפונקציה מחזירה `INVALID_ADDRESS`.\n    *   בודקים את הרשאות הגישה: אם הפעולה המבוקשת היא כתיבה (`write_access` הוא 1) וסיבית ה-Read-Only (RO bit) ברשומה דלוקה (1), משמעות הדבר היא הפרת הרשאה (Permission Violation), והפונקציה מחזירה `INVALID_ADDRESS`.\n\n4.  **הרכבת הכתובת הפיזית:**\n    *   אם כל הבדיקות עברו בהצלחה, מחלצים את ה-PFN של עמוד הנתונים מרשומת טבלת העמודים הסופית.\n    *   מרכיבים את הכתובת הפיזית על ידי שילוב ה-PFN של עמוד הנתונים עם ה-Offset שחולץ מהכתובת הווירטואלית. ה-PFN מוזז שמאלה במספר הסיביות של ה-Offset (`PAGE_OFFSET_BITS`) ולאחר מכן מחובר באמצעות OR עם ה-Offset.\n\n```c\n#include <stdint.h>\n\n// Constants for virtual address breakdown\n#define PAGE_OFFSET_BITS 12\n#define VPN2_BITS 10\n#define VPN1_BITS 10\n\n#define PAGE_OFFSET_MASK ((1U << PAGE_OFFSET_BITS) - 1)\n#define VPN2_MASK ((1U << VPN2_BITS) - 1)\n#define VPN1_MASK ((1U << VPN1_BITS) - 1)\n\n#define VPN2_SHIFT PAGE_OFFSET_BITS\n#define VPN1_SHIFT (PAGE_OFFSET_BITS + VPN2_BITS)\n\n// Constants for PTE structure (32-bit unsigned int)\n#define PTE_VALID_BIT_SHIFT 0\n#define PTE_RO_BIT_SHIFT 1\n#define PTE_PFN_SHIFT 12 // PFN starts from bit 12\n\n#define PTE_VALID_MASK (1U << PTE_VALID_BIT_SHIFT)\n#define PTE_RO_MASK (1U << PTE_RO_BIT_SHIFT)\n#define PTE_PFN_EXTRACT_MASK (((1U << 20) - 1) << PTE_PFN_SHIFT) // Mask to extract 20 PFN bits (bits 12-31)\n\n#define INVALID_ADDRESS 0xFFFFFFFFU\n\n// Simulated physical memory for page tables\nuint32_t page_directory[1024];\nuint32_t page_tables[1024 * 1024]; // 1024 page tables, each with 1024 entries\n\n// Function to translate virtual address to physical address\n// write_access: 1 if it's a write operation, 0 if read operation\nuint32_t translate_virtual_to_physical(uint32_t virtual_address, int write_access) {\n    // 1. Extract components of the virtual address\n    uint32_t vpn1 = (virtual_address >> VPN1_SHIFT) & VPN1_MASK;\n    uint32_t vpn2 = (virtual_address >> VPN2_SHIFT) & VPN2_MASK;\n    uint32_t offset = virtual_address & PAGE_OFFSET_MASK;\n\n    // 2. Look up in Page Directory\n    uint32_t pd_entry = page_directory[vpn1];\n\n    // Check PD entry's valid bit\n    if (!(pd_entry & PTE_VALID_MASK)) {\n        return INVALID_ADDRESS; // Page fault (level 1)\n    }\n\n    // Extract PFN of the second-level page table\n    uint32_t pt_base_pfn = (pd_entry & PTE_PFN_EXTRACT_MASK) >> PTE_PFN_SHIFT;\n\n    // 3. Look up in Second-Level Page Table\n    // Each second-level page table occupies one 4KB page, which means 1024 entries.\n    // So, pt_base_pfn is the base frame number for that page table.\n    // Index into the global `page_tables` array: (pt_base_pfn * 1024) + vpn2\n    uint32_t pt_entry = page_tables[pt_base_pfn * 1024 + vpn2];\n\n    // Check PT entry's valid bit\n    if (!(pt_entry & PTE_VALID_MASK)) {\n        return INVALID_ADDRESS; // Page fault (level 2)\n    }\n\n    // Check permissions\n    if (write_access && (pt_entry & PTE_RO_MASK)) {\n        return INVALID_ADDRESS; // Permission violation (attempt to write to read-only page)\n    }\n\n    // 4. Construct the Physical Address\n    uint32_t data_pfn = (pt_entry & PTE_PFN_EXTRACT_MASK) >> PTE_PFN_SHIFT;\n    uint32_t physical_address = (data_pfn << PAGE_OFFSET_BITS) | offset;\n\n    return physical_address;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}