{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Page Replacement",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 07:59:56",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3033,
      "output_tokens": 2561,
      "total_tokens": 14707
    }
  },
  "question": {
    "id": 9,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Paging",
      "Page Replacement"
    ],
    "content": {
      "text": "נתונה מערכת ניהול זיכרון וירטואלי המשתמשת במנגנון דפדוף (paging). לתהליך מסוים מוקצות 3 מסגרות זיכרון פיזיות (frames). רצף הגישות לדפים עבור תהליך זה הוא: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "9.1",
        "text": "חשב את מספר כשלי הדף (page faults) שיתרחשו עבור רצף הגישות הנתון, אם המערכת משתמשת באלגוריתם החלפת דפים FIFO (First-In, First-Out).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "9.2",
        "text": "חשב את מספר כשלי הדף (page faults) שיתרחשו עבור רצף הגישות הנתון, אם המערכת משתמשת באלגוריתם החלפת דפים LRU (Least Recently Used).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "9.3",
        "text": "חשב את מספר כשלי הדף (page faults) שיתרחשו עבור רצף הגישות הנתון, אם המערכת משתמשת באלגוריתם החלפת דפים Optimal (אופטימלי).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "9.4",
        "text": "השווה בין ביצועי שלושת האלגוריתמים (FIFO, LRU, Optimal) עבור רצף הגישות הנתון. הסבר מדוע האלגוריתם האופטימלי השיג את התוצאה הטובה ביותר, ומדוע LRU נחשב לגישה טובה יותר מ-FIFO במערכות אמיתיות, למרות מורכבות המימוש שלו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "רצף הגישות לדפים: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5\nמספר מסגרות זיכרון פיזיות: 3\n\n**9.1: אלגוריתם FIFO (First-In, First-Out)**\n| גישה | מצב מסגרות (הישן ביותר -> החדש ביותר) | כשל דף? |\n|------|---------------------------------------|----------|\n| 1    | [1, _, _]                             | כן       |\n| 2    | [1, 2, _]                             | כן       |\n| 3    | [1, 2, 3]                             | כן       |\n| 4    | [4, 2, 3] (1 יצא)                     | כן       |\n| 1    | [4, 1, 3] (2 יצא)                     | כן       |\n| 2    | [4, 1, 2] (3 יצא)                     | כן       |\n| 5    | [5, 1, 2] (4 יצא)                     | כן       |\n| 1    | [5, 1, 2]                             | לא       |\n| 2    | [5, 1, 2]                             | לא       |\n| 3    | [5, 3, 2] (1 יצא)                     | כן       |\n| 4    | [5, 3, 4] (2 יצא)                     | כן       |\n| 5    | [5, 3, 4]                             | לא       |\n**סה\"כ כשלי דף עבור FIFO: 9**\n\n**9.2: אלגוריתם LRU (Least Recently Used)**\n| גישה | מצב מסגרות (פחות בשימוש לאחרונה -> יותר בשימוש לאחרונה) | כשל דף? |\n|------|---------------------------------------------------------|----------|\n| 1    | [1, _, _]                                               | כן       |\n| 2    | [1, 2, _]                                               | כן       |\n| 3    | [1, 2, 3]                                               | כן       |\n| 4    | [4, 2, 3] (1 הוא LRU)                                   | כן       |\n| 1    | [4, 1, 3] (2 הוא LRU)                                   | כן       |\n| 2    | [4, 1, 2] (3 הוא LRU)                                   | כן       |\n| 5    | [5, 1, 2] (4 הוא LRU)                                   | כן       |\n| 1    | [5, 2, 1] (1 נמצא, הופך ל-MRU)                          | לא       |\n| 2    | [5, 1, 2] (2 נמצא, הופך ל-MRU)                          | לא       |\n| 3    | [3, 1, 2] (5 הוא LRU)                                   | כן       |\n| 4    | [3, 4, 2] (1 הוא LRU)                                   | כן       |\n| 5    | [3, 4, 5] (2 הוא LRU)                                   | כן       |\n**סה\"כ כשלי דף עבור LRU: 11**\n\n**9.3: אלגוריתם Optimal (אופטימלי)**\n| גישה | מצב מסגרות (הדף שיצא הוא זה שישמש הכי מאוחר בעתיד) | כשל דף? |\n|------|-----------------------------------------------------|----------|\n| 1    | [1, _, _]                                           | כן       |\n| 2    | [1, 2, _]                                           | כן       |\n| 3    | [1, 2, 3]                                           | כן       |\n| 4    | [1, 2, 4] (3 הוא הרחוק ביותר)                       | כן       |\n| 1    | [1, 2, 4]                                           | לא       |\n| 2    | [1, 2, 4]                                           | לא       |\n| 5    | [1, 2, 5] (4 הוא הרחוק ביותר)                       | כן       |\n| 1    | [1, 2, 5]                                           | לא       |\n| 2    | [1, 2, 5]                                           | לא       |\n| 3    | [1, 2, 3] (5 הוא הרחוק ביותר)                       | כן       |\n| 4    | [1, 2, 4] (3 הוא הרחוק ביותר)                       | כן       |\n| 5    | [1, 2, 5] (4 הוא הרחוק ביותר)                       | כן       |\n**סה\"כ כשלי דף עבור Optimal: 9**\n\n**9.4: השוואה והסבר**\nעבור רצף גישות זה, האלגוריתם האופטימלי ו-FIFO השיגו את אותה תוצאה של 9 כשלי דף, בעוד LRU השיג 11 כשלי דף. במקרה ספציפי זה, LRU ביצע פחות טוב מ-FIFO, למרות שבאופן כללי LRU נחשב לאלגוריתם טוב יותר.\n\n*   **אלגוריתם Optimal:** האלגוריתם האופטימלי תמיד ישיג את מספר כשלי הדף המינימלי האפשרי (או ישתווה אליו) מכיוון שהוא 'יודע את העתיד' ומוציא תמיד את הדף שישמש הכי מאוחר בעתיד. זוהי גישה תיאורטית שאינה ניתנת ליישום מעשי.\n\n*   **השוואת LRU ל-FIFO במקרה זה:** למרות ש-LRU מנצל את עקרון לוקליות ההתייחסות (locality of reference) ומוציא דפים שלא היו בשימוש לאחרונה, במקרה זה הוא הוציא דפים שהיו נחוצים שוב זמן קצר לאחר מכן. לדוגמה, כאשר נדרש הדף 3 (לאחר הגישות ל-1, 2, 5), LRU הוציא את דף 5 (שהיה ה-LRU), אך דף 5 נדרש שוב מיד בסוף הרצף, מה שגרם לכשל דף נוסף. לעומת זאת, FIFO, במקרה זה, הוציא דפים שפחות נדרשו בהמשך הרצף, או שנדרשו רק לאחר שהם כבר יצאו מהזיכרון בכל מקרה, מה שהוביל לביצועים טובים יותר במקרה זה.\n\n*   **מדוע LRU נחשב לגישה טובה יותר מ-FIFO במערכות אמיתיות:**\n    *   **ניצול לוקליות ההתייחסות:** LRU מבוסס על ההנחה שדפים ששימשו לאחרונה ידרשו שוב בקרוב. הנחה זו נכונה לרוב בתוכניות מחשב אמיתיות (לוקליות בזמן), ולכן LRU בדרך כלל משיג ביצועים טובים יותר מ-FIFO, שאינו מתחשב כלל בדפוסי שימוש אלא רק בסדר הכניסה.\n    *   **מורכבות מימוש:** LRU מורכב יותר ליישום מ-FIFO. הוא דורש מעקב אחר זמן השימוש האחרון של כל דף (לדוגמה, באמצעות חותמות זמן או רשימה מקושרת/מחסנית), מה שמוסיף תקורה (overhead) למערכת. FIFO, לעומת זאת, דורש רק תור פשוט שבו הדף הראשון שנכנס הוא הראשון שיוצא. למרות המורכבות, היתרון בביצועים הממוצעים של LRU לרוב מצדיק את עלות המימוש שלו במערכות הפעלה מודרניות."
    },
    "difficulty_estimation": "Medium"
  }
}