{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:58:14",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3383,
      "output_tokens": 2546,
      "total_tokens": 12722
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Deadlocks",
      "Resource Management"
    ],
    "content": {
      "text": "מערכת הפעלה מנהלת משאבים משני סוגים: `ResourceA` ו-`ResourceB`. קיימות `N_A` יחידות זמינות של `ResourceA` ו-`N_B` יחידות זמינות של `ResourceB`. תהליכים במערכת מבצעים פעולה קריטית הדורשת שימוש ביחידה אחת מכל סוג משאב (יחידה אחת מ-`ResourceA` ויחידה אחת מ-`ResourceB`). סדר הפעולות של כל תהליך הוא קבוע: הוא תמיד מבקש את `ResourceA` תחילה, ורק לאחר שקיבל אותו בהצלחה, הוא מבקש את `ResourceB`. לאחר קבלת שני המשאבים, התהליך מבצע את הפעולה הקריטית שלו, ולאחר מכן משחרר את שני המשאבים שברשותו באופן מיידי. המערכת משתמשת במתזמן (scheduler) מסוג Round Robin עם קוונטום זמן קבוע `Q`.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "a",
        "text": "האם קיפאון (deadlock) יכול להתרחש במערכת כזו? אם כן, תאר מצב ספציפי (לדוגמה, מספר תהליכים, מספר יחידות מכל משאב) שבו קיפאון אכן יתרחש. הסבר כיצד ארבעת התנאים ההכרחיים לקיפאון (מניעה הדדית, החזק והמתן, אי-נתיקות, המתנה מעגלית) מתקיימים במצב שתארת.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "b",
        "text": "כיצד המתזמן מסוג Round Robin משפיע על הסיכוי להתרחשות קיפאון או על הגילוי שלו? האם שינוי בקוונטום הזמן `Q` יכול להשפיע על התרחשות הקיפאון? נמק.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "c",
        "text": "הצע אסטרטגיה למניעת קיפאון במערכת זו, תוך שינוי מינימלי בקוד התהליכים או במדיניות המתזמן. הסבר כיצד האסטרטגיה שהצעת מונעת את הקיפאון (באילו תנאים היא מטפלת). האם לאסטרטגיה זו יש השפעה על רמת המקביליות (concurrency) או על התפוקה (throughput) של המערכת?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. כן, קיפאון יכול להתרחש במערכת כזו. נתאר מצב ספציפי:\nנניח שיש 2 תהליכים (P1, P2), יחידה אחת של `ResourceA` (N_A=1) ויחידה אחת של `ResourceB` (N_B=1).\n\nתרחיש קיפאון:\n1. P1 מבקש ומקבל את `ResourceA`.\n2. המתזמן מבצע מיתוג הקשר (context switch) ל-P2 (לפני ש-P1 הספיק לבקש את `ResourceB`).\n3. P2 מבקש ומקבל את `ResourceB`.\n4. כעת, P1 מחזיק ב-`ResourceA` וממתין ל-`ResourceB`. P2 מחזיק ב-`ResourceB` וממתין ל-`ResourceA`. שניהם חסומים וזהו מצב קיפאון.\n\nהסבר תנאי הקיפאון:\n*   **מניעה הדדית (Mutual Exclusion):** מתקיימת. כל יחידת משאב (גם A וגם B) ניתנת לשימוש על ידי תהליך אחד בלבד בכל רגע נתון. ברגע שתהליך תופס משאב, הוא אינו זמין לתהליך אחר.\n*   **החזק והמתן (Hold and Wait):** מתקיים. תהליך (לדוגמה P1) מחזיק במשאב אחד (ResourceA) וממתין (חסום) לקבלת משאב נוסף (ResourceB) המוחזק על ידי תהליך אחר.\n*   **אי-נתיקות (No Preemption):** מתקיים. ברגע שתהליך תפס משאב, המערכת לא יכולה לקחת ממנו את המשאב בכוח. התהליך חייב לשחרר אותו מרצונו לאחר סיום השימוש בו.\n*   **המתנה מעגלית (Circular Wait):** מתקיימת. בתרחיש שתואר, P1 ממתין למשאב שמוחזק על ידי P2, ו-P2 ממתין למשאב שמוחזק על ידי P1. נוצרת שרשרת המתנה מעגלית.\n\nב. **השפעת המתזמן Round Robin:**\nהמתזמן מסוג Round Robin הוא מתזמן מקדים (preemptive). הוא אינו מונע קיפאון כשלעצמו, אך הוא יכול להשפיע על הסיכוי להתרחשותו. בכך שהוא מבצע מיתוגי הקשר תכופים, הוא מגדיל את הסיכוי שתרחיש כמו זה שתואר בסעיף א' יתרחש – כלומר, שתהליך אחד יתפוס משאב (A) ויקדים אותו מיתוג הקשר לפני שיספיק לתפוס את המשאב השני (B), ובכך לאפשר לתהליך אחר לתפוס את המשאב השני (B). מצד שני, המתזמן אינו מספק מידע על בקשות למשאבים, ולכן אינו יכול לזהות או למנוע קיפאון ישירות.\n\n**השפעת קוונטום הזמן Q:**\nכן, שינוי בקוונטום הזמן `Q` יכול להשפיע על הסיכוי לקיפאון. \n*   **Q קטן מאוד:** קוונטום זמן קטן מאוד מגביר את הסיכוי לקיפאון. הסיבה היא שתהליך עשוי לקבל את `ResourceA`, להשתמש בחלק קטן מהקוונטום שלו, ואז לעבור מיתוג הקשר לפני שביצע את הקריאה ל-`ResourceB`. זה מגביר את הסבירות ששני תהליכים יגיעו למצב של החזק והמתן בו-זמנית.\n*   **Q גדול מאוד:** קוונטום זמן גדול מאוד (אשר שואף ל-FCFS) מקטין את הסיכוי לקיפאון בתרחיש זה. אם `Q` גדול מספיק כדי שתהליך שיקבל את המעבד יספיק לבקש את `ResourceA` *וגם* את `ResourceB` (אם הם זמינים), ואז לשחרר אותם לפני מיתוג הקשר, אז הסיכוי לקיפאון יקטן משמעותית. במקרה זה, תהליך אחד יתפוס את שני המשאבים, ישחרר אותם, ורק אז המתזמן יעביר את השליטה לתהליך אחר. עם זאת, אם המשאבים אינם זמינים, התהליך עדיין יכול להיחסם ולהחזיק במשאב אחד, ואז המתזמן יעביר את השליטה, וקיפאון עדיין אפשרי.\n\nג. **אסטרטגיה למניעת קיפאון:**\nאחת האסטרטגיות היעילות והפשוטות למניעת קיפאון בתרחיש זה היא **\"בקש את כל המשאבים יחד\" (Request All Resources At Once)**. במקום לבקש את `ResourceA` ואז את `ResourceB` בנפרד, התהליך יבקש את שני המשאבים בעסקה אטומית אחת. אם שני המשאבים זמינים, הוא יקבל את שניהם. אם אחד מהם (או שניהם) אינו זמין, התהליך ייחסם ולא יקבל אף משאב עד ששניהם יהיו זמינים.\n\n**הסבר כיצד האסטרטגיה מונעת קיפאון:**\nאסטרטגיה זו מונעת את תנאי ה\"החזק והמתן\" (Hold and Wait). תהליך לעולם לא יחזיק במשאב אחד וימתין לאחר. הוא יקבל את כל המשאבים הנדרשים לו בבת אחת, או שלא יקבל אף אחד מהם. בכך, הוא לא יכול להחזיק ב-`ResourceA` ולהמתין ל-`ResourceB` כאשר `ResourceB` מוחזק על ידי תהליך אחר, ובכך נשבר התנאי ההכרחי לקיפאון.\n\n**השפעה על רמת המקביליות והתפוקה:**\nלאסטרטגיה זו עשויה להיות **השפעה שלילית** על רמת המקביליות ועל התפוקה:\n*   **מקביליות מופחתת:** תהליך עשוי להיחסם לזמן רב יותר אם הוא ממתין לשני משאבים במקום לאחד. אם רק `ResourceA` זמין, אך `ResourceB` אינו זמין, התהליך לא יתפוס את `ResourceA` גם אם הוא פנוי, ובכך מונע מתהליכים אחרים שאולי צריכים רק את `ResourceA` להשתמש בו. זה מפחית את ניצול המשאבים הכללי ואת המקביליות.\n*   **תפוקה מופחתת:** כתוצאה מהמקביליות המופחתת ומההמתנה הארוכה יותר למשאבים, התפוקה הכוללת של המערכת (מספר הפעולות הקריטיות שמבוצעות ליחידת זמן) עלולה לרדת. עם זאת, במקרים מסוימים, מניעת קיפאון עשויה לשפר את התפוקה לטווח הארוך על ידי הימנעות מהצורך בביטול תהליכים או שחזור מערכת כתוצאה מקיפאון."
    },
    "difficulty_estimation": "Hard"
  }
}