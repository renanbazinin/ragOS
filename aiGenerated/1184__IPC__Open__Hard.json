{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:32:03",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4148,
      "output_tokens": 6233,
      "total_tokens": 23193
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Synchronization",
      "Shared Memory",
      "Semaphores",
      "Producer-Consumer"
    ],
    "content": {
      "text": "תכנן ויישם מערכת מפיק-צרכן (Producer-Consumer) המשתמשת בזיכרון משותף (Shared Memory) ובסמפורים (Semaphores) לצורך סנכרון. במערכת זו, N תהליכי מפיק מייצרים פריטי נתונים ומכניסים אותם לחוצץ משותף מעגלי בגודל קבוע `BUFFER_SIZE`. M תהליכי צרכן מוציאים פריטי נתונים מהחוצץ. יש להבטיח שהפתרון ימנע תנאי מרוץ, גלישת חוצץ (Buffer Overflow) ותת-גלישת חוצץ (Buffer Underflow).",
      "code_snippet": "```c\n#include <stdbool.h>\n#define BUFFER_SIZE 10 // גודל החוצץ\n\n// מבנה לזיכרון המשותף\ntypedef struct {\n    int buffer[BUFFER_SIZE];\n    int in;  // אינדקס להכנסה\n    int out; // אינדקס להוצאה\n} shared_data_t;\n\n// הגדרת שמות לסמפורים ולזיכרון המשותף (לשימוש ב-sem_open, shm_open)\n#define SEM_MUTEX_NAME \"/my_mutex_sem\"\n#define SEM_FULL_NAME \"/my_full_sem\"\n#define SEM_EMPTY_NAME \"/my_empty_sem\"\n#define SHM_NAME \"/my_shm\"\n\n// פונקציית מפיק (פסאודו-קוד)\nvoid producer(int id) {\n    int item;\n    while (true) { // או לולאה עם מספר פריטים מוגדר\n        // 1. המתן למקום ריק בחוצץ (sem_wait(empty))\n        // 2. קבל נעילה לגישה לחוצץ (sem_wait(mutex))\n\n        // קטע קריטי: הכנס פריט לחוצץ\n        // item = ...\n        // shared_mem_ptr->buffer[shared_mem_ptr->in] = item;\n        // shared_mem_ptr->in = (shared_mem_ptr->in + 1) % BUFFER_SIZE;\n\n        // 3. שחרר נעילה (sem_post(mutex))\n        // 4. אותת שיש פריט חדש בחוצץ (sem_post(full))\n    }\n}\n\n// פונקציית צרכן (פסאודו-קוד)\nvoid consumer(int id) {\n    int item;\n    while (true) { // או לולאה עם מספר פריטים מוגדר\n        // 1. המתן לפריט זמין בחוצץ (sem_wait(full))\n        // 2. קבל נעילה לגישה לחוצץ (sem_wait(mutex))\n\n        // קטע קריטי: הוצא פריט מהחוצץ\n        // item = shared_mem_ptr->buffer[shared_mem_ptr->out];\n        // shared_mem_ptr->out = (shared_mem_ptr->out + 1) % BUFFER_SIZE;\n\n        // 3. שחרר נעילה (sem_post(mutex))\n        // 4. אותת שיש מקום ריק חדש בחוצץ (sem_post(empty))\n    }\n}\n\n// פונקציית אתחול (פסאודו-קוד למיין)\nint main() {\n    // 1. יצירה ופתיחת זיכרון משותף (shm_open, ftruncate, mmap)\n    //    ואתחול שדות shared_data_t (in, out)\n    \n    // 2. יצירה ואתחול סמפורים (sem_open)\n    //    mutex: ערך התחלתי 1\n    //    full: ערך התחלתי 0\n    //    empty: ערך התחלתי BUFFER_SIZE\n\n    // 3. יצירת תהליכי מפיקים וצרכנים (fork)\n\n    // 4. המתנה לסיום התהליכים (wait)\n\n    // 5. ניקוי משאבים (munmap, shm_unlink, sem_close, sem_unlink)\n    return 0;\n}\n```",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "פרט והסבר אילו מנגנוני תקשורת בין-תהליכית (IPC) נדרשים לפתרון זה, את מטרתם הספציפית ואת אופן השימוש בהם (לדוגמה, סמפורים: מה כל סמפור מייצג וכיצד הוא משמש). ציין גם כיצד הזיכרון המשותף יבנה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "ספק קטע קוד ב-C/C++ המדגים את המבנה הכללי של תוכנית המערכת, כולל פונקציות המפיק והצרכן (או לולאות עיקריות), ואת אתחול משאבי ה-IPC. יש להשתמש ב-POSIX shared memory וב-POSIX semaphores (סמפורים בעלי שם).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "במידה וסמפורים אינם מיושמים נכון (לדוגמה, סדר פעולות שגוי של `sem_wait` ו-`sem_post`), אילו בעיות (כגון קיפאון (Deadlock) או הרעבה (Starvation)) עלולות להיווצר? תאר דוגמה לתרחיש כזה והסבר מדוע הוא בעייתי.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### 1.1 הסבר מנגנוני IPC\n\nלפתרון בעיית המפיק-צרכן עם חוצץ משותף נדרשים שני מנגנוני IPC עיקריים:\n\n*   **זיכרון משותף (Shared Memory):**\n    *   **מטרה:** לאחסן את החוצץ המעגלי עצמו (מערך `buffer`), יחד עם משתני האינדקסים `in` ו-`out` המצביעים על המקום הבא להכנסה והמקום הבא להוצאה בהתאמה. אלו הם הנתונים המשותפים שכל התהליכים (מפיקים וצרכנים) צריכים לגשת אליהם.\n    *   **אופן בנייה ושימוש:** הזיכרון המשותף ייווצר על ידי תהליך האב (או תהליך ייעודי לאתחול) באמצעות `shm_open` ו-`ftruncate`, ולאחר מכן ימופה למרחב הכתובות של התהליכים המעורבים באמצעות `mmap`. כל תהליך בן (מפיק או צרכן) יירש את מפת הזיכרון הזו או ימפה אותה מחדש. גישה לנתונים בזיכרון המשותף מתבצעת ישירות דרך מצביע.\n\n*   **סמפורים (Semaphores):**\n    *   **מטרה:** לסנכרן את הגישה לזיכרון המשותף ולנהל את המשאבים (מקומות ריקים/מלאים בחוצץ), ובכך למנוע תנאי מרוץ, גלישת חוצץ ותת-גלישת חוצץ.\n    *   **אופן השימוש:** נדרשים שלושה סמפורים מסוג POSIX named semaphores:\n        1.  `mutex` (סמפור בינארי):\n            *   **מייצג:** מנעול הדרה הדדית (mutual exclusion lock) לגישה לחוצץ המשותף. מטרתו להבטיח שרק תהליך אחד יבצע פעולות קריאה/כתיבה על החuצץ בזמן נתון.\n            *   **ערך התחלתי:** 1 (החוצץ פנוי לגישה).\n            *   **שימוש:** לפני כניסה לקטע הקריטי (גישה לחוצץ), תהליך מבצע `sem_wait(mutex)`. לאחר היציאה מהקטע הקריטי, הוא מבצע `sem_post(mutex)`.\n        2.  `empty` (סמפור סופר / counting semaphore):\n            *   **מייצג:** את מספר המקומות הריקים הזמינים בחוצץ.\n            *   **ערך התחלתי:** `BUFFER_SIZE` (בהתחלה כל המקומות ריקים).\n            *   **שימוש:** מפיק מבצע `sem_wait(empty)` לפני הכנסת פריט (ממתין למקום ריק). אם אין מקומות ריקים, המפיק נחסם. צרכן מבצע `sem_post(empty)` לאחר הוצאת פריט (משחרר מקום ריק ומאותת למפיקים).\n        3.  `full` (סמפור סופר / counting semaphore):\n            *   **מייצג:** את מספר המקומות המלאים (פריטים זמינים) בחוצץ.\n            *   **ערך התחלתי:** 0 (בהתחלה אין פריטים בחוצץ).\n            *   **שימוש:** צרכן מבצע `sem_wait(full)` לפני הוצאת פריט (ממתין לפריט זמין). אם אין פריטים, הצרכן נחסם. מפיק מבצע `sem_post(full)` לאחר הכנסת פריט (מודיע על פריט חדש ומאותת לצרכנים).\n\n### 1.2 קוד C/C++\n\nלהלן קוד C/C++ מלא המדגים את המבנה של מערכת מפיק-צרכן באמצעות זיכרון משותף וסמפורים בעלי שם (POSIX named semaphores). הקוד כולל יצירת תהליכים באמצעות `fork`.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <semaphore.h>\n#include <stdbool.h>\n#include <time.h>\n\n#define BUFFER_SIZE 5 // גודל החוצץ - הוקטן לדוגמה קצרה יותר\n#define NUM_PRODUCERS 2\n#define NUM_CONSUMERS 2\n#define NUM_ITEMS_PER_PRODUCER 3 // כל מפיק מייצר 3 פריטים\n\n// מבנה לזיכרון המשותף\ntypedef struct {\n    int buffer[BUFFER_SIZE];\n    int in;  // אינדקס להכנסה\n    int out; // אינדקס להוצאה\n} shared_data_t;\n\n// שמות לסמפורים ולזיכרון המשותף\n#define SEM_MUTEX_NAME \"/my_mutex_sem\"\n#define SEM_FULL_NAME \"/my_full_sem\"\n#define SEM_EMPTY_NAME \"/my_empty_sem\"\n#define SHM_NAME \"/my_shm\"\n\n// מצביעים לסמפורים ולזיכרון המשותף (גלובליים כדי שיהיו נגישים לתהליכים הבנים)\nsem_t *mutex; \nsem_t *full;  \nsem_t *empty; \nshared_data_t *shared_mem_ptr; \nint shm_fd; \n\nvoid producer(int id) {\n    int item;\n    srand(time(NULL) ^ getpid()); // אתחול מחולל מספרים אקראיים ייחודי לכל תהליך\n\n    for (int i = 0; i < NUM_ITEMS_PER_PRODUCER; ++i) {\n        item = (id * 100) + i; // פריט ייחודי למפיק\n        \n        sem_wait(empty); // המתן למקום ריק\n        sem_wait(mutex); // קבל נעילה לגישה לחוצץ\n\n        // קטע קריטי: הכנס פריט לחוצץ\n        shared_mem_ptr->buffer[shared_mem_ptr->in] = item;\n        shared_mem_ptr->in = (shared_mem_ptr->in + 1) % BUFFER_SIZE;\n        printf(\"Producer %d produced item %d. Buffer state: in=%d, out=%d\\n\", id, item, shared_mem_ptr->in, shared_mem_ptr->out);\n        fflush(stdout); // וודא שהפלט נכתב מיד\n\n        sem_post(mutex); // שחרר נעילה\n        sem_post(full);  // אותת שיש מקום מלא נוסף\n        \n        usleep(rand() % 100000); // הדמיית עבודה\n    }\n    printf(\"Producer %d finished producing %d items.\\n\", id, NUM_ITEMS_PER_PRODUCER);\n}\n\nvoid consumer(int id) {\n    int item;\n    srand(time(NULL) ^ getpid()); // אתחול מחולל מספרים אקראיים ייחודי לכל תהליך\n    int total_items_to_consume = (NUM_ITEMS_PER_PRODUCER * NUM_PRODUCERS) / NUM_CONSUMERS;\n\n    for (int i = 0; i < total_items_to_consume; ++i) {\n        sem_wait(full);  // המתן לפריט זמין\n        sem_wait(mutex); // קבל נעילה לגישה לחוצץ\n\n        // קטע קריטי: הוצא פריט מהחוצץ\n        item = shared_mem_ptr->buffer[shared_mem_ptr->out];\n        shared_mem_ptr->out = (shared_mem_ptr->out + 1) % BUFFER_SIZE;\n        printf(\"Consumer %d consumed item %d. Buffer state: in=%d, out=%d\\n\", id, item, shared_mem_ptr->in, shared_mem_ptr->out);\n        fflush(stdout);\n\n        sem_post(mutex); // שחרר נעילה\n        sem_post(empty); // אותת שיש מקום ריק נוסף\n        \n        usleep(rand() % 150000); // הדמיית עבודה\n    }\n    printf(\"Consumer %d finished consuming %d items.\\n\", id, total_items_to_consume);\n}\n\nint main() {\n    printf(\"Starting Producer-Consumer system...\\n\");\n\n    // 1. יצירה ופתיחת זיכרון משותף\n    shm_fd = shm_open(SHM_NAME, O_CREAT | O_EXCL | O_RDWR, 0666); // O_EXCL מבטיח יצירה חדשה\n    if (shm_fd == -1) {\n        perror(\"shm_open\");\n        // אם הקובץ קיים, ננסה לפתוח אותו בלעדי O_EXCL ולנקות משאבים קודמים\n        shm_fd = shm_open(SHM_NAME, O_RDWR, 0666);\n        if (shm_fd == -1) {\n            perror(\"shm_open (retry)\");\n            exit(EXIT_FAILURE);\n        }\n        fprintf(stderr, \"Warning: Shared memory '%s' already existed. Attempting to unlink previous resources.\\n\", SHM_NAME);\n        shm_unlink(SHM_NAME); // ניקוי יזום\n        shm_fd = shm_open(SHM_NAME, O_CREAT | O_EXCL | O_RDWR, 0666); // ניסיון יצירה חוזר\n        if (shm_fd == -1) {\n            perror(\"shm_open (final retry)\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    if (ftruncate(shm_fd, sizeof(shared_data_t)) == -1) {\n        perror(\"ftruncate\");\n        exit(EXIT_FAILURE);\n    }\n    shared_mem_ptr = (shared_data_t *)mmap(NULL, sizeof(shared_data_t), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (shared_mem_ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n    // אתחול הזיכרון המשותף\n    shared_mem_ptr->in = 0;\n    shared_mem_ptr->out = 0;\n    printf(\"Shared memory '%s' created and initialized.\\n\", SHM_NAME);\n\n    // 2. יצירה ואתחול סמפורים\n    // ניקוי סמפורים קודמים במידה וקיימים\n    sem_unlink(SEM_MUTEX_NAME);\n    sem_unlink(SEM_FULL_NAME);\n    sem_unlink(SEM_EMPTY_NAME);\n\n    mutex = sem_open(SEM_MUTEX_NAME, O_CREAT | O_EXCL, 0666, 1); \n    full = sem_open(SEM_FULL_NAME, O_CREAT | O_EXCL, 0666, 0); \n    empty = sem_open(SEM_EMPTY_NAME, O_CREAT | O_EXCL, 0666, BUFFER_SIZE); \n    if (mutex == SEM_FAILED || full == SEM_FAILED || empty == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Semaphores '%s', '%s', '%s' created and initialized.\\n\", SEM_MUTEX_NAME, SEM_FULL_NAME, SEM_EMPTY_NAME);\n\n    // 3. יצירת תהליכי מפיקים\n    pid_t pid;\n    for (int i = 0; i < NUM_PRODUCERS; ++i) {\n        pid = fork();\n        if (pid == 0) { // תהליך בן (מפיק)\n            producer(i + 1);\n            exit(EXIT_SUCCESS);\n        } else if (pid < 0) {\n            perror(\"fork producer\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    // 4. יצירת תהליכי צרכנים\n    for (int i = 0; i < NUM_CONSUMERS; ++i) {\n        pid = fork();\n        if (pid == 0) { // תהליך בן (צרכן)\n            consumer(i + 1);\n            exit(EXIT_SUCCESS);\n        } else if (pid < 0) {\n            perror(\"fork consumer\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    // 5. המתנה לסיום כל התהליכים\n    for (int i = 0; i < NUM_PRODUCERS + NUM_CONSUMERS; ++i) {\n        wait(NULL);\n    }\n    printf(\"All producers and consumers finished.\\n\");\n\n    // 6. ניקוי משאבים\n    if (munmap(shared_mem_ptr, sizeof(shared_data_t)) == -1) {\n        perror(\"munmap\");\n    }\n    if (shm_unlink(SHM_NAME) == -1) {\n        perror(\"shm_unlink\");\n    }\n    if (sem_close(mutex) == -1 || sem_close(full) == -1 || sem_close(empty) == -1) {\n        perror(\"sem_close\");\n    }\n    if (sem_unlink(SEM_MUTEX_NAME) == -1) {\n        perror(\"sem_unlink mutex\");\n    }\n    if (sem_unlink(SEM_FULL_NAME) == -1) {\n        perror(\"sem_unlink full\");\n    }\n    if (sem_unlink(SEM_EMPTY_NAME) == -1) {\n        perror(\"sem_unlink empty\");\n    }\n    printf(\"IPC resources cleaned up.\\n\");\n\n    return 0;\n}\n```\n\n### 1.3 ניתוח תקלות\n\nיישום שגוי של סמפורים עלול להוביל לבעיות חמורות במערכות מקביליות, כגון קיפאון (Deadlock) או הרעבה (Starvation).\n\n*   **קיפאון (Deadlock):**\n    *   **הגדרה:** מצב שבו שני תהליכים או יותר ממתינים זה לזה למשאב שתפוס על ידי האחר, וכתוצאה מכך אף אחד מהם לא יכול להמשיך בביצוע. בבעיית המפיק-צרכן, קיפאון יכול להתרחש אם סדר פעולות ה-`sem_wait` וה-`sem_post` אינו נכון.\n    *   **תרחיש לדוגמה (מפיק):** נניח שמפיק מבצע את הפעולות בסדר הבא:\n        1.  `sem_wait(mutex)` (תופס את המנעול לחוצץ)\n        2.  `sem_wait(empty)` (ממתין למקום ריק)\n        אם החוצץ מלא, המפיק יחסם ב-`sem_wait(empty)`. כיוון שהמפיק מחזיק כעת את ה-`mutex`, אף צרכן לא יוכל לגשת לחוצץ כדי להוציא פריטים ולשחרר מקום (פעולת `sem_post(empty)`). כתוצאה מכך, המפיק נשאר חסום באופן קבוע, וכל הצרכנים שירצו לגשת לחוצץ יחסמו גם הם בניסיון לתפוס את ה-`mutex`. זוהי סיטואציה קלאסית של קיפאון.\n    *   **תרחיש לדוגמה (צרכן):** באופן דומה, אם צרכן מבצע את הפעולות בסדר הבא:\n        1.  `sem_wait(mutex)` (תופס את המנעול לחוצץ)\n        2.  `sem_wait(full)` (ממתין לפריט זמין)\n        אם החוצץ ריק, הצרכן יחסם ב-`sem_wait(full)`. כיוון שהצרכן מחזיק כעת את ה-`mutex`, אף מפיק לא יוכל לגשת לחוצץ כדי להכניס פריטים ולשחרר את הצרכן (פעולת `sem_post(full)`). הצרכן נשאר חסום באופן קבוע, וכל המפיקים יחסמו בניסיון לתפוס את ה-`mutex`. גם זו סיטואציה של קיפאון.\n\n*   **הרעבה (Starvation):**\n    *   **הגדרה:** מצב שבו תהליך מסוים נמנע באופן בלתי מוגבל מלקבל גישה למשאב או מביצוע פעולה, למרות שהמשאב זמין עבור תהליכים אחרים. הרעבה שונה מקיפאון בכך שהמערכת כולה ממשיכה לפעול, אך תהליך ספציפי אינו מתקדם.\n    *   **תרחיש לדוגמה:** אם מנגנון התזמון של מערכת ההפעלה או יישום הסמפורים אינו הוגן (לא מבטיח סדר הגעה או עדיפות), ייתכן שתהליכים מסוימים יקבלו עדיפות באופן קבוע על פני אחרים. לדוגמה, אם יש קבוצה גדולה של מפיקים מהירים מאוד וקבוצה קטנה של צרכנים איטיים, ייתכן שמפיק מסוים תמיד יצליח לתפוס את ה-`mutex` או את מקום ה-`empty` לפני שמפיק אחר (פחות \"בר מזל\" או בעל עדיפות נמוכה יותר) יצליח לעשות זאת. כתוצאה מכך, מפיק אחד יכול להיתקע בהמתנה אינסופית לגישה לחוצץ, גם אם החוצץ אינו מלא באופן קבוע, פשוט כי תמיד יש מפיק אחר שזוכה בגישה לפניו. באופן דומה, צרכן יכול להיתקל בהרעבה אם יש תמיד צרכנים אחרים שזוכים להוציא פריטים לפניו. הרעבה פחות סבירה ביישומי POSIX semaphores הסטנדרטיים, הנוטים להיות הוגנים, אך היא עדיין סיכון תיאורטי ביישומים מורכבים יותר או עם תזמון לא אופטימלי.\n"
    },
    "difficulty_estimation": "Hard"
  }
}