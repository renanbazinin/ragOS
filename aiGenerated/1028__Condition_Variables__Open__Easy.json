{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Condition Variables",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-08 07:31:04",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1573,
      "output_tokens": 766,
      "total_tokens": 4274
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Condition Variables",
      "Synchronization"
    ],
    "content": {
      "text": "הסבירו את מטרתן של משתני תנאי (Condition Variables) בתכנות מקבילי. תארו את הפעולות העיקריות הקשורות אליהם וכיצד הם משמשים בדרך כלל יחד עם מנעולים (mutexes) להשגת סנכרון.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "מטרת משתני תנאי (Condition Variables) היא לספק מנגנון לתזמון תהליכים (threads) בתכנות מקבילי, המאפשר לחוטים להמתין ביעילות לתנאי מסוים שיתקיים, מבלי לבצע המתנה פעילה (busy-waiting). כאשר חוט ממתין לתנאי, הוא נכנס למצב שינה ומשחרר את המעבד, עד שחוט אחר מאותת לו שהתנאי אולי השתנה.\n\nהפעולות העיקריות הקשורות למשתני תנאי הן:\n1.  **`wait(mutex)`**: פעולה זו משחררת באופן אטומי את המנעול (mutex) ומכניסה את החוט הקורא למצב שינה. החוט יישאר במצב שינה עד שחוט אחר יאותת לו. כאשר החוט מתעורר, הוא רוכש מחדש את המנעול לפני שהוא ממשיך בביצוע. חשוב שהתנאי ייבדק בלולאה לאחר היקיצה, מכיוון שייתכנו \"התעוררויות כוזבות\" (spurious wakeups) או שהתנאי כבר לא מתקיים.\n2.  **`signal()` / `notify_one()`**: פעולה זו מעירה חוט אחד מבין החוטים הממתינים על משתנה התנאי. אם אין חוטים ממתינים, הפעולה לא עושה דבר.\n3.  **`broadcast()` / `notify_all()`**: פעולה זו מעירה את כל החוטים הממתינים על משתנה התנאי.\n\nמשתני תנאי משמשים תמיד יחד עם מנעולים (mutexes). המנעול מגן על הנתונים המשותפים שהתנאי תלוי בהם. לפני שחוט בודק תנאי או משנה נתונים שמשפיעים על התנאי, עליו לרכוש את המנעול. כאשר חוט ממתין לתנאי, הוא קורא ל-`wait` עם המנעול. פעולה זו מבטיחה שהמנעול ישוחרר בזמן שהחוט ישן, כדי לאפשר לחוטים אחרים לגשת לנתונים המשותפים ולשנות את התנאי. כאשר החוט מתעורר, המנעול נרכש מחדש אוטומטית, מה שמבטיח עקביות בגישה לנתונים."
    },
    "difficulty_estimation": "Easy"
  }
}