{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 21:45:28",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4278,
      "output_tokens": 2944,
      "total_tokens": 17463
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Resource Management",
      "Starvation Prevention",
      "Mutual Exclusion"
    ],
    "content": {
      "text": "נתונה מערכת בעלת N יחידות עיבוד (לדוגמה, GPU). ישנם שני סוגי משימות:\n1.  **משימות אצווה (Batch Jobs)**: כל משימת אצווה דורשת את כל N יחידות העיבוד באופן בלעדי. רק משימת אצווה אחת יכולה לרוץ בכל רגע נתון.\n2.  **משימות אינטראקטיביות (Interactive Jobs)**: כל משימה אינטראקטיבית דורשת יחידת עיבוד אחת בלבד. מספר משימות אינטראקטיביות יכולות לרוץ במקביל, כל עוד יש יחידות פנויות.\n\nעליכם לתכנן מנגנון סנכרון באמצעות סמפורים בשפת C/C++ אשר יבטיח את הדברים הבאים:\nא.  הקצאת משאבים נכונה: משימות אצווה מקבלות את כל N היחידות, ומשימות אינטראקטיביות מקבלות יחידה אחת.\nב.  הדדיות (Mutual Exclusion): כאשר משימת אצווה רצה, אף משימה אינטראקטיבית אינה יכולה לרוץ, ולהיפך.\nג.  מניעת הרעבה (Starvation Prevention): אף סוג של משימה לא יסבול מהרעבה.\n\nיש לכלול את הגדרות הסמפורים והמשתנים הגלובליים, ואת קוד המבנה של הפונקציות עבור כל סוג משימה (acquire/release).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\nהבעיה היא וריאציה של בעיית ה\"קוראים והכותבים\" (Readers-Writers Problem) עם העדפה לכותבים (Writer Preference), כאשר משימות אצווה הן ה\"כותבים\" ומשימות אינטראקטיביות הן ה\"קוראים\". ההבדל העיקרי הוא שמשימות אצווה דורשות את כל N היחידות באופן בלעדי, בעוד שמשימות אינטראקטיביות דורשות יחידה אחת בלבד מתוך N היחידות הזמינות. מנגנון העדפה לכותבים (משימות אצווה) מבטיח מניעת הרעבה.\n\n**הגדרות גלובליות:**\n```c\n#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define N_UNITS 5 // מספר יחידות העיבוד הכולל\n\n// סמפורים\nsem_t mutex;                 // מגן על המשתנים המשותפים active_interactive_jobs ו-waiting_batch_jobs. אתחול: 1\nsem_t batch_lock;            // מנגנון הדדיות למשימות אצווה מול משימות אינטראקטיביות. אתחול: 1\nsem_t interactive_slots;     // סמפור מונה עבור N היחידות הזמינות למשימות אינטראקטיביות. אתחול: N_UNITS\nsem_t batch_turnstile;       // מנגנון תור למשימות אצווה למניעת הרעבה של משימות אצווה. אתחול: 1\n\n// משתנים משותפים\nint active_interactive_jobs = 0; // מספר משימות אינטראקטיביות פעילות כרגע\nint waiting_batch_jobs = 0;      // מספר משימות אצווה שממתינות לריצה\n```\n\n**קוד עבור משימת אצווה (Batch Job):**\n```c\nvoid batch_job_acquire() {\n    sem_wait(&batch_turnstile);   // 1. נכנסים לתור העדיפות של משימות האצווה (מונע ממשימות אינטראקטיביות חדשות להתחיל אם יש משימות אצווה שממתינות)\n    sem_wait(&mutex);              // 2. מגן על המשתנים המשותפים\n    waiting_batch_jobs++;          // 3. הגדל מונה של משימות אצווה ממתינות\n    sem_post(&mutex);              // 4. שחרר מגן על המשתנים המשותפים\n\n    sem_wait(&batch_lock);         // 5. המתן לקבלת גישה בלעדית לכל N היחידות (משימת אצווה ממתינה עד שמשימות אינטראקטיביות יסיימו)\n    \n    // *** משימת האצווה מבצעת את עבודתה ***\n    printf(\"Batch Job acquired all %d units.\\n\", N_UNITS);\n    sleep(2); // הדמיית עבודה\n    printf(\"Batch Job released all %d units.\\n\", N_UNITS);\n}\n\nvoid batch_job_release() {\n    sem_post(&batch_lock);         // 6. שחרר את הגישה הבלעדית ל-N היחידות\n\n    sem_wait(&mutex);              // 7. מגן על המשתנים המשותפים\n    waiting_batch_jobs--;          // 8. הקטן מונה של משימות אצווה ממתינות\n    sem_post(&mutex);              // 9. שחרר מגן על המשתנים המשותפים\n    sem_post(&batch_turnstile);    // 10. אפשר למשימת האצווה הבאה (או למשימה אינטראקטיבית) לנסות להיכנס\n}\n```\n\n**קוד עבור משימה אינטראקטיבית (Interactive Job):**\n```c\nvoid interactive_job_acquire() {\n    sem_wait(&batch_turnstile);    // 1. נכנסים לתור העדיפות של משימות האצווה (אם משימת אצווה ממתינה, משימה אינטראקטיבית זו תמתין)\n    sem_wait(&mutex);              // 2. מגן על המשתנים המשותפים\n    active_interactive_jobs++;     // 3. הגדל מונה של משימות אינטראקטיביות פעילות\n    if (active_interactive_jobs == 1) { // 4. אם זו המשימה האינטראקטיבית הראשונה\n        sem_wait(&batch_lock);     // 5. חסום משימות אצווה מלהיכנס\n    }\n    sem_post(&mutex);              // 6. שחרר מגן על המשתנים המשותפים\n    sem_post(&batch_turnstile);    // 7. אפשר למשימה אינטראקטיבית הבאה לנסות להיכנס\n\n    sem_wait(&interactive_slots);  // 8. רכוש יחידת עיבוד אחת\n\n    // *** המשימה האינטראקטיבית מבצעת את עבודתה ***\n    printf(\"Interactive Job acquired 1 unit.\\n\");\n    sleep(1); // הדמיית עבודה\n    printf(\"Interactive Job released 1 unit.\\n\");\n}\n\nvoid interactive_job_release() {\n    sem_post(&interactive_slots);  // 9. שחרר יחידת עיבוד אחת\n\n    sem_wait(&mutex);              // 10. מגן על המשתנים המשותפים\n    active_interactive_jobs--;     // 11. הקטן מונה של משימות אינטראקטיביות פעילות\n    if (active_interactive_jobs == 0) { // 12. אם זו המשימה האינטראקטיבית האחרונה\n        sem_post(&batch_lock);     // 13. שחרר את החסימה עבור משימות אצווה\n    }\n    sem_post(&mutex);              // 14. שחרר מגן על המשתנים המשותפים\n}\n```\n\n**הסבר:**\nהפתרון המובא מיישם את תבנית \"קוראים וכותבים עם העדפה לכותבים\", כאשר:\n*   **משימות אצווה** מתנהגות כ\"כותבים\": הן דורשות גישה בלעדית לכל המשאבים (N יחידות)..\n*   **משימות אינטראקטיביות** מתנהגות כ\"קוראים\": הן דורשות יחידה אחת בלבד ויכולות לרוץ במקביל.\n\n1.  `batch_lock`: סמפור בינארי המשמש כמנגנון ההדדיות העיקרי. כאשר משימת אצווה פעילה, היא מחזיקה ב-`batch_lock`, ובכך מונעת ממשימות אינטראקטיביות להיכנס. כאשר משימות אינטראקטיביות פעילות, המשימה האינטראקטיבית הראשונה שרוכשת משאב רוכשת את `batch_lock`, ובכך מונעת ממשימות אצווה להיכנס.\n2.  `interactive_slots`: סמפור מונה המאותחל ל-N_UNITS. הוא מאפשר למשימות אינטראקטיביות לרכוש יחידת עיבוד אחת בכל פעם, עד שמגיעים למגבלה של N יחידות.\n3.  `mutex`: סמפור בינארי המגן על הגישה למשתנים המשותפים `active_interactive_jobs` ו-`waiting_batch_jobs`, אשר סופרים את מספר המשימות הפעילות והממתינות.\n4.  `batch_turnstile`: סמפור בינארי המשמש כמנגנון תור שנותן עדיפות למשימות אצווה. משימת אצווה רוכשת אותו בתחילת דרכה, ומשחררת אותו רק לאחר שרכשה (או המתינה ל-`batch_lock`). משימות אינטראקטיביות חייבות לרכוש ולשחרר אותו גם כן. אם משימת אצווה ממתינה על `batch_turnstile`, משימות אינטראקטיביות חדשות יחסמו שם, ובכך מובטח שמשימות אצווה לא יסבלו מהרעבה ויוכלו להיכנס כאשר המשאבים יתפנו.\n\n**תהליך ריצה:**\n*   **משימת אצווה:** רוכשת את `batch_turnstile` כדי למנוע ממשימות אינטראקטיביות חדשות להיכנס. מגדילה את `waiting_batch_jobs`. ממתינה ל-`batch_lock` (כלומר, ממתינה שכל המשימות האינטראקטיביות הפעילות יסיימו). ברגע ש-`batch_lock` נרכש, היא מקבלת גישה בלעדית לכל N היחידות. בסיום, היא משחררת את `batch_lock`, מקטינה את `waiting_batch_jobs`, ומשחררת את `batch_turnstile`.\n*   **משימה אינטראקטיבית:** רוכשת את `batch_turnstile` (אם משימת אצווה ממתינה על `batch_turnstile`, היא תמתין שם). מגדילה את `active_interactive_jobs`. אם היא המשימה האינטראקטיבית הראשונה שנכנסת, היא רוכשת את `batch_lock` (ובכך חוסמת משימות אצווה מלהיכנס). משחררת את `batch_turnstile` כדי לאפשר למשימות אינטראקטיביות נוספות להיכנס. רוכשת יחידה אחת מ-`interactive_slots`. בסיום, משחררת את יחידת העיבוד, מקטינה את `active_interactive_jobs`, ואם היא המשימה האינטראקטיבית האחרונה, משחררת את `batch_lock`."
    },
    "difficulty_estimation": "Hard"
  }
}