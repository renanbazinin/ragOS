{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Page Replacement",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 07:58:17",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3033,
      "output_tokens": 2163,
      "total_tokens": 12911
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Paging",
      "Page Replacement"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת בזיכרון וירטואלי עם טעינה לפי דרישה (Demand Paging). הזיכרון הפיזי של התהליך יכול להכיל 3 מסגרות (frames) בלבד. לפניכם רצף הפניות לדפים (Page Reference String):\n\n`7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "חשבו את מספר כשלונות הדף (Page Faults) עבור אלגוריתם FIFO (First-In, First-Out). הציגו את מצב המסגרות בכל שלב.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "חשבו את מספר כשלונות הדף (Page Faults) עבור אלגוריתם LRU (Least Recently Used). הציגו את מצב המסגרות בכל שלב, תוך ציון סדר השימוש האחרון.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "הסבירו מדוע קיים הבדל במספר כשלונות הדף בין שני האלגוריתמים עבור רצף הפניות נתון זה, ומהו העיקרון המנחה מאחורי הביצועים של כל אלגוריתם במקרה זה.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\n**10.1. חישוב כשלונות דף עבור אלגוריתם FIFO (3 מסגרות):**\nרצף הפניות: `7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`\nמסגרות: [_, _, _] (מספר הפניות: 20)\n\n1.  7: F -> [7, _, _]\n2.  0: F -> [7, 0, _]\n3.  1: F -> [7, 0, 1]\n4.  2: F (7 יוצא) -> [0, 1, 2]\n5.  0: H\n6.  3: F (0 יוצא) -> [1, 2, 3]\n7.  0: F (1 יוצא) -> [2, 3, 0]\n8.  4: F (2 יוצא) -> [3, 0, 4]\n9.  2: F (3 יוצא) -> [0, 4, 2]\n10. 3: F (0 יוצא) -> [4, 2, 3]\n11. 0: F (4 יוצא) -> [2, 3, 0]\n12. 3: H\n13. 2: H\n14. 1: F (2 יוצא) -> [3, 0, 1]\n15. 2: F (3 יוצא) -> [0, 1, 2]\n16. 0: H\n17. 1: H\n18. 7: F (0 יוצא) -> [1, 2, 7]\n19. 0: F (1 יוצא) -> [2, 7, 0]\n20. 1: F (2 יוצא) -> [7, 0, 1]\n\n**סה\"כ כשלונות דף (FIFO): 17**\n\n**10.2. חישוב כשלונות דף עבור אלגוריתם LRU (3 מסגרות):**\nרצף הפניות: `7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`\nמסגרות (הדף השמאלי ביותר הוא ה-LRU, הדף הימני ביותר הוא ה-MRU):\n\n1.  7: F -> [7]\n2.  0: F -> [7, 0]\n3.  1: F -> [7, 0, 1]\n4.  2: F (7 הוא ה-LRU, יוצא) -> [0, 1, 2]\n5.  0: H (0 הופך ל-MRU) -> [1, 2, 0]\n6.  3: F (1 הוא ה-LRU, יוצא) -> [2, 0, 3]\n7.  0: H (0 הופך ל-MRU) -> [2, 3, 0]\n8.  4: F (2 הוא ה-LRU, יוצא) -> [3, 0, 4]\n9.  2: F (3 הוא ה-LRU, יוצא) -> [0, 4, 2]\n10. 3: F (0 הוא ה-LRU, יוצא) -> [4, 2, 3]\n11. 0: F (4 הוא ה-LRU, יוצא) -> [2, 3, 0]\n12. 3: H (3 הופך ל-MRU) -> [2, 0, 3]\n13. 2: H (2 הופך ל-MRU) -> [0, 3, 2]\n14. 1: F (0 הוא ה-LRU, יוצא) -> [3, 2, 1]\n15. 2: H (2 הופך ל-MRU) -> [3, 1, 2]\n16. 0: F (3 הוא ה-LRU, יוצא) -> [1, 2, 0]\n17. 1: H (1 הופך ל-MRU) -> [2, 0, 1]\n18. 7: F (2 הוא ה-LRU, יוצא) -> [0, 1, 7]\n19. 0: H (0 הופך ל-MRU) -> [1, 7, 0]\n20. 1: H (1 הופך ל-MRU) -> [7, 0, 1]\n\n**סה\"כ כשלונות דף (LRU): 13**\n\n**10.3. הסבר ההבדלים בביצועים:**\n\nאלגוריתם FIFO (First-In, First-Out) מחליף את הדף שהיה בזיכרון הפיזי במשך הזמן הארוך ביותר, ללא קשר לתדירות השימוש בו. הוא פועל על בסיס סדר ההגעה של הדפים לזיכרון.\n\nאלגוריתם LRU (Least Recently Used) מחליף את הדף שלא נעשה בו שימוש במשך הזמן הארוך ביותר. הוא מבוסס על עקרון לוקליות זמנית (Temporal Locality), לפיו דפים שנעשה בהם שימוש לאחרונה צפויים להיעשות בהם שימוש שוב בעתיד הקרוב.\n\nבמקרה הנתון, LRU הניב 13 כשלונות דף בעוד FIFO הניב 17 כשלונות דף. LRU הציג ביצועים טובים יותר באופן משמעותי. הסיבה לכך היא שברצף הפניות זה, ישנם דפים (כמו 0, 1, 2, 3) שנעשה בהם שימוש חוזר ונשנה. LRU, בזכות עקרון הלוקליות הזמנית, מצליח לשמור דפים אלה בזיכרון הפיזי למשך זמן רב יותר, שכן הם נחשבים 'בשימוש' ולכן אינם מועמדים להחלפה. לעומת זאת, FIFO עשוי להחליף דפים אלו מוקדם מדי אם הם היו בין הדפים הראשונים שנטענו, גם אם הם נדרשים שוב זמן קצר לאחר מכן. הדבר מוביל לכשלונות דף חוזרים עבור אותם דפים ב-FIFO, מה שמגדיל את המספר הכולל של כשלונות הדף."
    },
    "difficulty_estimation": "Medium"
  }
}