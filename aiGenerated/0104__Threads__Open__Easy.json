{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Threads",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 18:39:57",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3183,
      "output_tokens": 767,
      "total_tokens": 6289
    },
    "subject": "Virtualization"
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "Threads",
      "Concurrency",
      "Race Conditions"
    ],
    "content": {
      "text": "לפניכם קטע קוד בשפת C המשתמש בספריית pthreads. התוכנית יוצרת שני חוטים (threads) שכל אחד מהם מעלה את הערך של משתנה גלובלי משותף counter בתוך לולאה 10,000 פעמים.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint counter = 0;\n\nvoid* increment(void* arg) {\n    for (int i = 0; i < 10000; i++) {\n        counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, increment, NULL);\n    pthread_create(&t2, NULL, increment, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"Final counter: %d\\n\", counter);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "7.1",
        "text": "מהי התוצאה המקסימלית האפשרית של המשתנה counter בסיום ריצת התוכנית?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.2",
        "text": "האם מובטח שהפלט של התוכנית יהיה תמיד התוצאה המקסימלית? הסבירו מדוע, והשתמשו במושג \"מרוץ תהליכים\" (Race Condition) בהסברכם.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 10,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "7.1. התוצאה המקסימלית היא 20,000 (כל אחד משני החוטים מבצע 10,000 פעולות הגדלה).\n7.2. לא, לא מובטח שהפלט יהיה 20,000. הסיבה לכך היא קיום של מרוץ תהליכים (Race Condition). הפעולה ++counter אינה פעולה אטומית (Atomic) ברמת המעבד; היא מורכבת משלושה שלבים: קריאת הערך מהזיכרון לרגיסטר, הוספת 1 ברגיסטר, וכתיבת הערך חזרה לזיכרון. אם מתבצע context switch בין חוטים באמצע שלבים אלו, חוט אחד עלול לקרוא ערך ישן ולדרוס עדכון של חוט אחר, מה שיוביל לכך שחלק מההגדלות יאבדו והתוצאה הסופית תהיה קטנה מ-20,000."
    },
    "difficulty_estimation": "Easy"
  }
}