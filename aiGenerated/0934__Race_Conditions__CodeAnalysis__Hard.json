{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Race Conditions",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:01:19",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 5728,
      "output_tokens": 2319,
      "total_tokens": 14631
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Race Conditions",
      "Concurrency",
      "Threads",
      "Shared Memory"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בחוטים (threads) לעיבוד משימות במערך משותף. התוכנית מוגדרת עם שני קבועים: `N_TASKS` המייצג את מספר המשימות הכולל, ו-`N_THREADS` המייצג את מספר החוטים שירוצו במקביל. כל חוט מנסה לבצע `N_TASKS` פעולות, כאשר כל פעולה כוללת קבלת מזהה משימה ייחודי (task ID) ממשתנה גלובלי משותף `next_task_id` ולאחר מכן קידום התא המתאים במערך `results` אם מזהה המשימה חוקי. שימו לב: הפעולה `next_task_id++` אינה אטומית. נתונים: `N_TASKS = 3`, `N_THREADS = 2`. כל חוט מבצע לולאה של `N_TASKS` איטרציות. `results` מאותחל למערך של אפסים, ו-`next_task_id` מאותחל ל-0. יש לענות על הסעיפים הבאים. לכל סעיף יש לפרט את התזמונים הספציפיים שמובילים לערכים המינימליים והמקסימליים.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\n#define N_TASKS 3\n#define N_THREADS 2\n\nint results[N_TASKS];\nint next_task_id = 0;\n\nvoid* worker(void* arg) {\n    for (int i = 0; i < N_TASKS; ++i) { // Each thread attempts N_TASKS increments\n        int current_task;\n        current_task = next_task_id++; // Race condition here\n        \n        if (current_task < N_TASKS) {\n            results[current_task]++;\n        }\n    }\n    return NULL;\n}"
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מהו הערך המינימלי והמקסימלי האפשרי עבור `next_task_id` בסיום ריצת התוכנית? פרטו את התזמונים המובילים לכל ערך.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "מהו הערך המינימלי והמקסימלי האפשרי עבור סכום כל האיברים במערך `results` בסיום ריצת התוכנית? פרטו את התזמונים המובילים לכל ערך.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "מהו הערך המינימלי והמקסימלי האפשרי עבור הערך המקסימלי שנמצא בכל תא במערך `results` (כלומר, `max(results[j])` עבור `j=0..N_TASKS-1`) בסיום ריצת התוכנית? פרטו את התזמונים המובילים לכל ערך.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הקבועים הנתונים הם `N_TASKS = 3` ו-`N_THREADS = 2`. כל חוט מבצע לולאה של `N_TASKS` איטרציות. סך הכל יבוצעו `N_THREADS * N_TASKS = 2 * 3 = 6` ניסיונות לקדם את `next_task_id`.\n\n**1.1: הערך המינימלי והמקסימלי האפשרי עבור `next_task_id`:**\n*   **מינימלי (1)**: זה קורה כאשר כל 6 הפעולות של `next_task_id++` קוראות את הערך הנוכחי של `next_task_id` לפני שמי מהן מספיקה לכתוב את הערך המעודכן בחזרה. במקרה זה, כל 6 הפעולות יקראו `0`. לאחר מכן, כל אחת מהן תנסה לכתוב `1` ל-`next_task_id`. בפועל, הערך הסופי שיישמר יהיה `1`, למרות ש-6 ניסיונות קידום בוצעו (חמש מהן \"נאבדות\" עקב overwriting). לדוגמה, חוט A קורא 0, חוט B קורא 0 (פעמיים), חוט A קורא 0 (פעמיים), חוט B קורא 0. כעת, חוט A כותב 1, חוט B כותב 1, וכן הלאה. בסוף `next_task_id` יהיה 1.\n*   **מקסימלי (6)**: זה קורה כאשר פעולות הקידום של `next_task_id` מתבצעות באטום יחסי (כלומר, כל קריאה ומיד אחריה הכתיבה, לפני שחוט אחר קורא או כותב). לדוגמה: חוט A קורא 0, כותב 1. חוט B קורא 1, כותב 2. חוט A קורא 2, כותב 3. חוט B קורא 3, כותב 4. חוט A קורא 4, כותב 5. חוט B קורא 5, כותב 6. בסיום, `next_task_id` יהיה `6`.\n\n**1.2: הערך המינימלי והמקסימלי האפשרי עבור סכום כל האיברים במערך `results`:**\n*   **מינימלי (3)**: הסכום המינימלי הוא `N_TASKS` (3 במקרה זה). זה קורה כאשר `next_task_id` מתקדם באופן יעיל ככל האפשר, וכל מזהה משימה בין 0 ל-`N_TASKS-1` נלקח בדיוק פעם אחת. לדוגמה, אם `next_task_id` מתקדם באופן מקסימלי (עד 6, כפי שתואר בסעיף 1.1), אז מזהי המשימות `0, 1, 2, 3, 4, 5` נלקחים על ידי החוטים. רק המזהים `0, 1, 2` עומדים בתנאי `current_task < N_TASKS`. לכן, כל אחד מתאים להגדלה של `results[0]`, `results[1]`, `results[2]` פעם אחת. סכום המערך יהיה `1+1+1 = 3`. דוגמת תזמון: חוט A מקבל 0,1,2 ומעדכן את `results[0]=1, results[1]=1, results[2]=1`. חוט B מקבל 3,4,5 (אך לא מעדכן את `results` כי `current_task >= N_TASKS`).\n*   **מקסימלי (6)**: הסכום המקסימלי הוא `N_THREADS * N_TASKS` (6 במקרה זה). זה קורה כאשר יש את מירב תנאי המירוץ על `next_task_id`, כך שחוטים רבים מקבלים את אותו מזהה משימה נמוך. לדוגמה, בתזמון שבו כל 6 פעולות `next_task_id++` קוראות `0` (כפי שתואר בסעיף 1.1 עבור `next_task_id` מינימלי). כל החוטים יקבלו `current_task = 0`. כולם יבצעו `results[0]++`. בסיום, `results = {6,0,0}` והסכום יהיה `6`.\n\n**1.3: הערך המינימלי והמקסימלי האפשרי עבור הערך המקסימלי שנמצא בכל תא במערך `results`:**\n*   **מינימלי (1)**: זה קורה כאשר המשימות מחולקות באופן שווה ככל האפשר, וכל תא במערך `results` מקודם פעם אחת בלבד. לדוגמה, בתזמון שבו `next_task_id` מתקדם באופן מקסימלי (עד 6, כפי שתואר בסעיף 1.1), ומזהי המשימות `0, 1, 2` נלקחים כל אחד פעם אחת. במקרה כזה, `results = {1,1,1}` והערך המקסימלי בכל תא הוא `1`.\n*   **מקסימלי (6)**: זה קורה כאשר כל פעולות הקידום של `results` מתרכזות בתא אחד עקב תנאי מירוץ קיצוניים. לדוגמה, בתזמון שבו כל 6 פעולות `next_task_id++` קוראות `0`. כל החוטים יקבלו `current_task = 0`. כולם יבצעו `results[0]++`. בסיום, `results = {6,0,0}` והערך המקסימלי בתא כלשהו הוא `6`."
    },
    "difficulty_estimation": "Hard"
  }
}