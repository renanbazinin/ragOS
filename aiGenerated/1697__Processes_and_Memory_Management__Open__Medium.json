{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Processes and Memory Management",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-09 20:58:42",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1726,
      "output_tokens": 2025,
      "total_tokens": 7979
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Processes",
      "Memory Management",
      "Virtual Memory",
      "TLB"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת בזיכרון וירטואלי עם כתובות וירטואליות בגודל 32 ביטים וכתובות פיזיות בגודל 28 ביטים. גודל דף הוא 4KB. ה-MMU כולל TLB המכיל 128 רשומות והוא מסוג fully associative. נתון כי כל רשומה ב-TLB מכילה גם Process ID (PID) כדי למנוע ריקון TLB במעבר הקשר. ה-TLB מתרוקן רק כאשר תהליך חדש נוצר או כאשר דף מוסר מהזיכרון הפיזי.\n\nתהליך P1 ניגש לכתובות הווירטואליות הבאות (בסדר זה): 0x1000, 0x2000, 0x3000, 0x4000, 0x5000.\nלאחר מכן, מתבצע מעבר הקשר לתהליך P2. תהליך P2 ניגש לכתובות הווירטואליות הבאות: 0x1000, 0x2000, 0x3000, 0x4000, 0x5000.\nלבסוף, מתבצע מעבר הקשר חזרה לתהליך P1, אשר ניגש שוב לכתובת 0x1000.\n\nיש לנתח את הפעולות ולענות על השאלות הבאות, בהנחה שבתחילה ה-TLB ריק וטבלאות הדפים של P1 ו-P2 ריקות לחלוטין (כלומר, כל גישה דורשת יצירת PTE חדש ומסגרת חדשה בזיכרון הפיזי).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "מהו מספר הביטים המוקדש ל-VPN ול-Offset בכתובת וירטואלית, ול-PFN ול-Offset בכתובת פיזית?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "כמה TLB misses וכמה page faults יתרחשו במהלך כל רצף הגישות של P1, P2, וחזרה ל-P1?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "האם השימוש ב-PID ב-TLB אכן מונע את ריקון ה-TLB במעבר הקשר במקרה זה? נמק.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 20,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **פירוק כתובות:**\n    *   גודל כתובת וירטואלית: 32 ביטים.\n    *   גודל דף: 4KB = 2^12 בתים. לכן, ה-Offset בכתובת הוירטואלית הוא 12 ביטים.\n    *   מספר הביטים ל-VPN: 32 - 12 = 20 ביטים.\n    *   גודל כתובת פיזית: 28 ביטים.\n    *   ה-Offset בכתובת הפיזית זהה ל-Offset בכתובת הוירטואלית: 12 ביטים.\n    *   מספר הביטים ל-PFN: 28 - 12 = 16 ביטים.\n\n2.  **מספר TLB misses ו-Page Faults:**\n    *   **גישות P1:**\n        *   P1 ניגש ל-0x1000, 0x2000, 0x3000, 0x4000, 0x5000. אלו 5 דפים וירטואליים שונים (VPNs 0x1, 0x2, 0x3, 0x4, 0x5). \n        *   מכיוון שה-TLB ריק וטבלת הדפים של P1 ריקה, כל גישה תגרום ל-TLB miss וגם ל-page fault (צריך ליצור PTE חדש ולהקצות מסגרת פיזית). \n        *   סה\"כ עבור P1: 5 TLB misses, 5 page faults. ה-TLB יכיל כעת 5 רשומות עבור P1.\n    *   **מעבר הקשר ל-P2:**\n        *   ה-TLB אינו מתרוקן בזכות ה-PID tagging.\n    *   **גישות P2:**\n        *   P2 ניגש ל-0x1000, 0x2000, 0x3000, 0x4000, 0x5000. אלו 5 דפים וירטואליים שונים (VPNs 0x1, 0x2, 0x3, 0x4, 0x5). \n        *   למרות שה-VPNs זהים לאלה של P1, ה-PID שונה. לכן, כל גישה של P2 תהיה TLB miss (כי רשומות P1 ב-TLB אינן תואמות ל-P2). \n        *   מכיוון שטבלת הדפים של P2 ריקה, כל גישה תגרום גם ל-page fault. \n        *   סה\"כ עבור P2: 5 TLB misses, 5 page faults. ה-TLB יכיל כעת 5 רשומות עבור P1 ו-5 רשומות עבור P2 (סה\"כ 10 רשומות, ה-TLB עדיין לא מלא).\n    *   **מעבר הקשר חזרה ל-P1:**\n        *   ה-TLB אינו מתרוקן.\n    *   **גישת P1 נוספת:**\n        *   P1 ניגש שוב ל-0x1000 (VPN 0x1). \n        *   הרשומה (VPN 0x1, PID P1) כבר קיימת ב-TLB מגישותיו הקודמות של P1. \n        *   סה\"כ עבור גישה זו: 0 TLB misses, 0 page faults.\n    *   **סה\"כ כולל:** 10 TLB misses (5 מ-P1, 5 מ-P2), 10 page faults (5 מ-P1, 5 מ-P2).\n\n3.  **האם ה-PID ב-TLB מונע ריקון TLB?**\n    *   כן, השימוש ב-PID ב-TLB אכן מונע את ריקון ה-TLB במעבר הקשר במקרה זה, כפי שצוין בנתוני השאלה. ה-TLB לא רוקן בין P1 ל-P2 ולא בין P2 ל-P1. זהו היתרון העיקרי של TLB עם PID tagging – הוא מאפשר שמירת רשומות של מספר תהליכים בו-זמנית ב-TLB, ובכך חוסך את העלות של מילוי מחדש של ה-TLB עבור תהליכים שחוזרים לרוץ.\n    *   חשוב לציין כי למרות שה-TLB לא רוקן, עדיין היו TLB misses רבים כאשר P2 החל לרוץ (כי רשומות P1 לא תאמו ל-P2) וכאשר P1 חזר לרוץ (גישה ל-0x1000 היתה hit, אך אם P1 היה ניגש לדף אחר שטרם נטען ל-TLB עבור P1, זה היה miss). ה-PID tagging מונע את הצורך בריקון גורף, אך לא מונע misses עבור דפים שטרם נטענו ל-TLB עבור התהליך הספציפי."
    },
    "difficulty_estimation": "Medium"
  }
}