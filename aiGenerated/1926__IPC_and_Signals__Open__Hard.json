{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:54:33",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 6021,
      "total_tokens": 17076
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Process Communication"
    ],
    "content": {
      "text": "נתונה בעיית תיאום בין תהליכים המשתמשים בצינור (pipe) ובאותות (signals). תהליך אב (Parent) יוצר שני תהליכי בן (Child 1 ו-Child 2). האב כותב סדרת מספרים שלמים (מ-1 עד 100) לצינור. Child 1 קורא מספרים מהצינור וצובר את סכומם עד לקבלת האות `SIGUSR1` או עד לסגירת הצינור. Child 2 קורא מספרים מהצינור וצובר את סכומם עד לסגירת הצינור. האב, לאחר שכתב 50 מספרים ראשונים לצינור, שולח את האות `SIGUSR1` ל-Child 1, וממשיך לכתוב את יתר המספרים (51-100) לצינור. כל תהליך בן מדפיס את הסכום הסופי שחישב לפני יציאתו. האב ממתין לשני הבנים לפני יציאתו שלו.\n\nלהלן קטע קוד C המממש את התרחיש המתואר. עיין בקוד וענה על השאלות הבאות:",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#define NUM_TO_SEND 100\n\nint pipe_fd[2];\npid_t child1_pid, child2_pid;\nvolatile int sigusr1_received = 0; // Flag for signal handler\n\nvoid sigusr1_handler(int signum) {\n    sigusr1_received = 1;\n    fprintf(stderr, \"Child %d: SIGUSR1 received!\\n\", getpid());\n}\n\nvoid child_process_func(int child_id) {\n    close(pipe_fd[1]); // Close write end in children\n    int num;\n    long long sum = 0;\n\n    if (child_id == 1) {\n        // Child 1 sets up SIGUSR1 handler\n        signal(SIGUSR1, sigusr1_handler); // Using signal() for initial draft\n    }\n\n    while (read(pipe_fd[0], &num, sizeof(int)) > 0) {\n        if (child_id == 1 && sigusr1_received) {\n            fprintf(stderr, \"Child 1 (%d): Stopping read due to SIGUSR1. Current sum: %lld\\n\", getpid(), sum);\n            break; // Exit loop if SIGUSR1 was received\n        }\n        sum += num;\n    }\n    close(pipe_fd[0]); // Close read end\n\n    printf(\"Child %d (%d) final sum: %lld\\n\", child_id, getpid(), sum);\n    exit(0);\n}\n\nint main() {\n    if (pipe(pipe_fd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    child1_pid = fork();\n    if (child1_pid == -1) {\n        perror(\"fork child 1\");\n        exit(EXIT_FAILURE);\n    } else if (child1_pid == 0) {\n        child_process_func(1);\n    }\n\n    child2_pid = fork();\n    if (child2_pid == -1) {\n        perror(\"fork child 2\");\n        exit(EXIT_FAILURE);\n    } else if (child2_pid == 0) {\n        child_process_func(2);\n    }\n\n    // Parent process\n    close(pipe_fd[0]); // Close read end in parent\n\n    for (int i = 1; i <= NUM_TO_SEND; ++i) {\n        if (i == NUM_TO_SEND / 2 + 1) { // After writing 50 numbers (1-50)\n            printf(\"Parent (%d): Sending SIGUSR1 to Child 1 (%d)\\n\", getpid(), child1_pid);\n            if (kill(child1_pid, SIGUSR1) == -1) {\n                perror(\"kill SIGUSR1\");\n            }\n        }\n        if (write(pipe_fd[1], &i, sizeof(int)) == -1) {\n            perror(\"write to pipe\");\n            break;\n        }\n    }\n    close(pipe_fd[1]); // Close write end, signaling EOF to children\n\n    int status;\n    waitpid(child1_pid, &status, 0);\n    printf(\"Parent: Child 1 (%d) exited with status %d\\n\", child1_pid, WEXITSTATUS(status));\n    waitpid(child2_pid, &status, 0);\n    printf(\"Parent: Child 2 (%d) exited with status %d\\n\", child2_pid, WEXITSTATUS(status));\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "7.1",
        "text": "בהנחה שהקוד מתקמפל ומורץ בהצלחה, תאר את התפוקה הצפויה שלו (אילו הודעות יודפסו, ובאיזה סדר סביר) והסבר מדוע. האם קיימות בעיות פוטנציאליות בקוד (כגון תנאי מירוץ, deadlock, או טיפול לא נכון באותות) שיכולות להשפיע על התפוקה או על נכונות הסכומים?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.2",
        "text": "שנה את קטע הקוד הנתון כך שיטפל באות `SIGUSR1` באופן אמין (reliable) ויתמודד עם הפרעות קריאה (interrupted system calls) כתוצאה מקבלת אות. ודא כי Child 1 מסיים את קריאתו מהצינור ומדפיס את סכומו רק לאחר קבלת `SIGUSR1`, וכי Child 2 מדפיס את סכומו רק לאחר סגירת הצינור. הסבר את השינויים שביצעת ומדוע הם פותרים את הבעיות שציינת בסעיף הקודם.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.3",
        "text": "הסבר את ההבדלים בין שימוש בפונקציה `signal()` לבין שימוש בפונקציה `sigaction()` לטיפול באותות. באיזו מהן היית בוחר להשתמש בתרחיש זה ומדוע? פרט את היתרונות של הבחירה שלך בהקשר לבעיה זו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### 7.1 ניתוח תפוקה ובעיות\n\n**תפוקה צפויה:**\nהתפוקה הצפויה תכלול את ההודעות הבאות (הסדר בין הודעות של בנים שונים עשוי להשתנות, אך הסדר בתוך כל בן והודעות האב צפוי):\n1.  האב ידפיס: `Parent (PID): Sending SIGUSR1 to Child 1 (Child1_PID)` (לאחר כתיבת המספר ה-50). זה עשוי להופיע לפני או אחרי חלק מההדפסות של הבנים.\n2.  Child 1 יקרא את המספרים מ-1 עד 50 (או קרוב לכך). ברגע שיקבל את `SIGUSR1`, הוא ידפיס: `Child 1 (Child1_PID): SIGUSR1 received!` ולאחר מכן: `Child 1 (Child1_PID): Stopping read due to SIGUSR1. Current sum: 1275` (הסכום של 1 עד 50 הוא 1275).\n3.  Child 2 יקרא את כל המספרים (1 עד 100), כולל אלה ש-Child 1 לא קרא לאחר קבלת האות. Child 2 ידפיס: `Child 2 (Child2_PID) final sum: 5050` (הסכום של 1 עד 100 הוא 5050).\n4.  האב ידפיס: `Parent: Child 1 (Child1_PID) exited with status 0`.\n5.  האב ידפיס: `Parent: Child 2 (Child2_PID) exited with status 0`.\n\n**בעיות פוטנציאליות בקוד:**\n1.  **טיפול לא אמין באותות (`signal()`):** השימוש בפונקציה `signal()` בעייתית מכיוון שהתנהגותה אינה מוגדרת באופן אחיד בכל מערכות ה-UNIX/Linux. במערכות רבות, לאחר קבלת אות וביצוע ה-handler, ה-handler מתאפס לברירת המחדל (כלומר, יש לרשום אותו מחדש). אם אות `SIGUSR1` נוסף יישלח ל-Child 1 (תרחיש שלא קורה כאן, אך חושף בעיה), או אם ה-handler יופעל מספר פעמים, התהליך עלול להסתיים באופן בלתי צפוי. בנוסף, `signal()` אינה מאפשרת חסימה אוטומטית של האות המטופל בזמן שה-handler רץ, מה שעלול להוביל לבעיות אם אותות מגיעים במהירות.\n2.  **הפרעות קריאה (`EINTR`):** קריאה ממערכת קבצים (כמו צינור) באמצעות `read()` עלולה להיות מופרעת על ידי קבלת אות. במקרה כזה, `read()` תחזיר `-1` ותגדיר את `errno` ל-`EINTR`. קטע הקוד הנוכחי אינו מטפל במקרה זה. אם `SIGUSR1` יגיע בזמן ש-Child 1 חסום ב-`read()`, ה-`read()` יופרע, יחזיר `-1`, והלולאה `while (read(...) > 0)` תסתיים בטרם עת, מבלי שהדגל `sigusr1_received` נבדק לאחר קריאה מוצלחת. Child 1 עלול לצאת מהלולאה מבלי לקרוא את המספרים שטרם נקראו, או להדפיס סכום שגוי. הדגל נבדק רק לאחר קריאה מוצלחת, לא לאחר `EINTR`.\n3.  **תנאי מירוץ (פחות קריטי בתרחיש זה):** קיים תנאי מירוץ תיאורטי אם `SIGUSR1` יגיע ל-Child 1 לפני ש-Child 1 הספיק להגדיר את ה-handler שלו באמצעות `signal(SIGUSR1, sigusr1_handler)`. במקרה כזה, האות יטופל בהתאם לפעולת ברירת המחדל (סיום התהליך), מה שיגרום להתנהגות שונה לחלוטין. עם זאת, בתרחיש הנתון, האב שולח את האות רק לאחר כתיבת 50 מספרים, מה שנותן מספיק זמן ל-Child 1 להגדיר את ה-handler.\n\n### 7.2 תיקון ושיפור הקוד\n\nכדי לטפל בבעיות שצוינו, נשתמש בפונקציה `sigaction()` לטיפול אמין באותות ובדגל `SA_RESTART` כדי לטפל בהפרעות קריאה. בנוסף, נבצע בדיקה של `sigusr1_received` לפני כל קריאה חדשה כדי להבטיח תגובה מיידית לאות.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <errno.h> // For EINTR\n\n#define NUM_TO_SEND 100\n\nint pipe_fd[2];\npid_t child1_pid, child2_pid;\nvolatile sig_atomic_t sigusr1_received = 0; // Use sig_atomic_t for safety\n\nvoid sigusr1_handler(int signum) {\n    sigusr1_received = 1;\n    fprintf(stderr, \"Child %d: SIGUSR1 received!\\n\", getpid());\n}\n\nvoid child_process_func(int child_id) {\n    close(pipe_fd[1]); // Close write end in children\n    int num;\n    long long sum = 0;\n    ssize_t bytes_read;\n\n    if (child_id == 1) {\n        struct sigaction sa;\n        sa.sa_handler = sigusr1_handler;\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = SA_RESTART; // Automatically restart interrupted system calls\n        if (sigaction(SIGUSR1, &sa, NULL) == -1) {\n            perror(\"sigaction SIGUSR1\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    while (1) {\n        // Child 1 specific check: if signal received, stop reading immediately\n        if (child_id == 1 && sigusr1_received) {\n            fprintf(stderr, \"Child 1 (%d): Stopping read due to SIGUSR1. Current sum: %lld\\n\", getpid(), sum);\n            break;\n        }\n\n        bytes_read = read(pipe_fd[0], &num, sizeof(int));\n\n        if (bytes_read == -1) {\n            // With SA_RESTART, EINTR should cause read to restart automatically.\n            // This block is primarily for other non-restartable errors or older systems.\n            if (errno == EINTR) {\n                // If SIGUSR1 was received and SA_RESTART didn't work (unlikely with modern kernels),\n                // the flag would be set. Check again.\n                if (child_id == 1 && sigusr1_received) {\n                    fprintf(stderr, \"Child 1 (%d): Stopping read due to SIGUSR1 after EINTR. Current sum: %lld\\n\", getpid(), sum);\n                    break;\n                }\n                continue; // Retry read if interrupted by another signal\n            } else {\n                perror(\"read from pipe\");\n                break; // Other read error\n            }\n        } else if (bytes_read == 0) {\n            // EOF, pipe closed\n            break;\n        } else { // bytes_read > 0, successfully read a number\n            sum += num;\n        }\n    }\n    close(pipe_fd[0]); // Close read end\n\n    printf(\"Child %d (%d) final sum: %lld\\n\", child_id, getpid(), sum);\n    exit(0);\n}\n\nint main() {\n    if (pipe(pipe_fd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    child1_pid = fork();\n    if (child1_pid == -1) {\n        perror(\"fork child 1\");\n        exit(EXIT_FAILURE);\n    } else if (child1_pid == 0) {\n        child_process_func(1);\n    }\n\n    child2_pid = fork();\n    if (child2_pid == -1) {\n        perror(\"fork child 2\");\n        exit(EXIT_FAILURE);\n    } else if (child2_pid == 0) {\n        child_process_func(2);\n    }\n\n    // Parent process\n    close(pipe_fd[0]); // Close read end in parent\n\n    for (int i = 1; i <= NUM_TO_SEND; ++i) {\n        if (i == NUM_TO_SEND / 2 + 1) { // After writing 50 numbers (1-50)\n            printf(\"Parent (%d): Sending SIGUSR1 to Child 1 (%d)\\n\", getpid(), child1_pid);\n            if (kill(child1_pid, SIGUSR1) == -1) {\n                perror(\"kill SIGUSR1\");\n            }\n        }\n        if (write(pipe_fd[1], &i, sizeof(int)) == -1) {\n            perror(\"write to pipe\");\n            break;\n        }\n    }\n    close(pipe_fd[1]); // Close write end, signaling EOF to children\n\n    int status;\n    waitpid(child1_pid, &status, 0);\n    printf(\"Parent: Child 1 (%d) exited with status %d\\n\", child1_pid, WEXITSTATUS(status));\n    waitpid(child2_pid, &status, 0);\n    printf(\"Parent: Child 2 (%d) exited with status %d\\n\", child2_pid, WEXITSTATUS(status));\n\n    return 0;\n}\n```\n\n**הסבר השינויים:**\n1.  **שימוש ב-`sigaction()`:** במקום `signal()`, אנו משתמשים ב-`sigaction()` כדי להגדיר את ה-handler. זה מבטיח טיפול אמין באותות, שכן ה-handler אינו מתאפס אוטומטית לאחר הפעלה.\n2.  **`sa.sa_flags = SA_RESTART`:** דגל זה מורה למערכת ההפעלה להפעיל מחדש באופן אוטומטי קריאות מערכת שהופרעו על ידי אות (כמו `read()`). זה מפשט את הלוגיקה בלולאת הקריאה, שכן אין צורך לטפל באופן ידני ב-`EINTR` עבור `read()`.\n3.  **`volatile sig_atomic_t sigusr1_received`:** שינינו את סוג הדגל ל-`sig_atomic_t` והוספנו `volatile`. `sig_atomic_t` מבטיח שהגישה למשתנה תהיה אטומית (לא תופרע על ידי אות), ו-`volatile` מונע מהמהדר לבצע אופטימיזציות שעלולות למנוע מה-handler לראות את השינוי בדגל באופן מיידי. זה הכרחי לבטיחות בשימוש במשתנים גלובליים בין קוד רגיל ו-signal handler.\n4.  **בדיקת הדגל לפני `read()`:** הוספנו בדיקה של `sigusr1_received` בתחילת הלולאה, לפני הקריאה ל-`read()`. זה מבטיח ש-Child 1 יגיב לאות באופן מיידי ככל האפשר, ויפסיק לקרוא מהצינור ברגע שהאות התקבל (או לאחר שסיים לעבד את המספר האחרון שנקרא לפני הבדיקה). גם אם `read()` הייתה מופרעת עקב אות אחר ו-`SA_RESTART` לא היה מופעל, הבדיקה הזו תתפוס את הדגל ש-`SIGUSR1` הגדיר.\n5.  **טיפול ב-`EINTR` (למקרה חירום):** למרות `SA_RESTART`, השארנו טיפול ב-`EINTR` בתוך בדיקת השגיאות של `read()`. זהו אמצעי זהירות למקרים בהם `SA_RESTART` לא פועל כמצופה (לדוגמה, במערכות ישנות או עבור קריאות מערכת מסוימות שאינן ניתנות להפעלה מחדש). במקרה כזה, אם `read()` תחזיר `EINTR` ו-`sigusr1_received` יהיה מוגדר, התהליך ייצא מהלולאה כרצוי.\n\nשינויים אלה מבטיחים ש-Child 1 יגיב לאות `SIGUSR1` באופן אמין ומיידי, ויפסיק את קריאתו מהצינור כפי שנדרש, תוך התמודדות נכונה עם הפרעות קריאה.\n\n### 7.3 השוואת `signal()` ו-`sigaction()`\n\n**הבדלים בין `signal()` ל-`sigaction()`:**\n\n1.  **אמינות וסטנדרטיזציה:**\n    *   `signal()`: היא פונקציה ותיקה יותר, אך התנהגותה שונה בין גרסאות UNIX שונות (BSD לעומת System V). כתוצאה מכך, היא נחשבת פחות אמינה ופחות ניידת. במערכות רבות, ה-handler מתאפס לברירת המחדל לאחר הפעלתו, מה שמחייב רישום מחדש בתוך ה-handler.\n    *   `sigaction()`: היא הפונקציה המועדפת והסטנדרטית (POSIX) לטיפול באותות. היא מציעה התנהגות עקבית ואמינה בכל המערכות התואמות POSIX.\n\n2.  **שליטה על חסימת אותות:**\n    *   `signal()`: אינה מספקת מנגנון מובנה לחסימת אותות אחרים בזמן שה-handler רץ. זה עלול להוביל לבעיות אם אותות מרובים מגיעים במהירות, או אם ה-handler ארוך ומורכב.\n    *   `sigaction()`: מאפשרת להגדיר מסכת אותות (`sa_mask`) שתיחסם אוטומטית בזמן שה-handler רץ. זה מבטיח ש-handler ירוץ בסביבה בטוחה יותר, ללא הפרעות מאותות מסוימים.\n\n3.  **טיפול בקריאות מערכת מופרעות (`EINTR`):**\n    *   `signal()`: אינה מספקת שליטה ישירה על האם קריאות מערכת יופעלו מחדש לאחר הפרעה על ידי אות. בדרך כלל, קריאות מערכת מופרעות יחזירו `-1` עם `errno = EINTR`, ויש לטפל בכך ידנית.\n    *   `sigaction()`: מאפשרת להגדיר דגלים (`sa_flags`), כמו `SA_RESTART`, שמורים למערכת ההפעלה להפעיל מחדש אוטומטית קריאות מערכת שהופרעו. זה מפשט מאוד את קוד הטיפול בשגיאות.\n\n4.  **מידע נוסף באותות:**\n    *   `signal()`: ה-handler מקבל רק את מספר האות.\n    *   `sigaction()`: מאפשרת להגדיר handler עם חתימה מורחבת (`sa_sigaction`) שמקבל מידע נוסף על האות, כגון ה-PID של השולח, ערך נשלח (`si_value`), ועוד, באמצעות מבנה `siginfo_t`.\n\n**בחירה בתרחיש זה:**\nבתרחיש זה, הייתי בוחר להשתמש ב-`sigaction()` באופן חד משמעי.\n\n**יתרונות הבחירה ב-`sigaction()` בהקשר לבעיה זו:**\n1.  **טיפול אמין ב-`SIGUSR1`:** `sigaction()` מבטיחה שה-handler שהוגדר לא יתאפס לאחר הפעלתו, מה שמבטיח ש-Child 1 יגיב ל-`SIGUSR1` בכל פעם שהאות נשלח, ללא צורך ברישום מחדש.\n2.  **התמודדות עם `EINTR` באמצעות `SA_RESTART`:** זהו יתרון קריטי במיוחד כאן. על ידי הגדרת `sa.sa_flags = SA_RESTART`, אנו מורים למערכת ההפעלה להפעיל מחדש את קריאת ה-`read()` אם היא מופרעת על ידי `SIGUSR1` (או כל אות אחר שאינו מסיים את התהליך). זה פותר את בעיית הטיפול הידני ב-`EINTR` ומפשט את הלוגיקה בלולאת הקריאה של הבנים, מה שהופך את הקוד לנקי וחזק יותר.\n3.  **הימנעות מתנאי מירוץ (ברישום):** למרות שפחות קריטי בתרחיש הספציפי בשאלה, `sigaction()` מספקת פלטפורמה בטוחה יותר לטיפול כללי באותות, כולל שליטה טובה יותר במועדי חסימת אותות, מה שמקטין את הסיכון לתנאי מירוץ הקשורים לרישום/איפוס handlers."
    },
    "difficulty_estimation": "Hard"
  }
}