{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:51:33",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 6291,
      "total_tokens": 21710
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Shared Memory",
      "Semaphores",
      "Concurrency"
    ],
    "content": {
      "text": "מערכת מורכבת מתהליך אב (מנהל) ומספר תהליכי בן (עובדים). תהליך האב מניח 'יחידות עבודה' בזיכרון משותף. תהליכי הבן אוספים יחידות עבודה, מעבדים אותן, ומעדכנים סטטוס בזיכרון המשותף. תהליך האב נדרש להיות מסוגל לאותת לכל תהליכי הבן לסיים את עבודתם בצורה מסודרת (graceful shutdown). תהליכי הבן צריכים לסיים את המשימה הנוכחית שלהם, לנתק עצמם מהזיכרון המשותף, ואז לצאת. תהליך האב צריך להמתין לכל תהליכי הבן, ולאחר מכן לנקות את כל משאבי ה-IPC (זיכרון משותף וסמפורים).\n\nלהלן קטע קוד חלקי המדגים את המבנה הבסיסי. עליכם להשלים ולתקן את הקוד בהתאם לדרישות, ולענות על השאלות הבאות.",
      "code_snippet": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <sys/sem.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n\n#define NUM_WORKERS 3\n#define SHM_SIZE 1024\n#define SEM_KEY 1234\n#define SHM_KEY 5678\n\n// Shared memory structure\ntypedef struct {\n    int task_id;\n    int data[10];\n    int status[NUM_WORKERS]; // Status for each worker\n    int next_task_index;\n    volatile sig_atomic_t shutdown_flag; // Flag to indicate shutdown\n} shm_data_t;\n\nshm_data_t *shm_ptr;\nint shmid = -1;\nint semid = -1;\n\n// Semaphore operations\nstruct sembuf acquire_sem = {0, -1, SEM_UNDO};\nstruct sembuf release_sem = {0, 1, SEM_UNDO};\n\n// Global flag for child shutdown, should be sig_atomic_t for safety\nvolatile sig_atomic_t child_should_exit = 0;\n\n// Signal handler for graceful shutdown\nvoid shutdown_handler(int signum) {\n    // TODO: Implement shutdown logic for child process\n    printf(\"Worker %d received shutdown signal.\\n\", getpid());\n    // This handler needs to set a flag or mechanism for the main loop to exit.\n    // For simplicity, let's use a global flag, but usually, it's better to use sig_atomic_t\n    child_should_exit = 1;\n}\n\n// Signal handler for SIGCHLD in parent\nvoid sigchld_handler(int signum) {\n    // TODO: Implement SIGCHLD handling to reap children\n    pid_t pid;\n    int status;\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        printf(\"Parent reaped child %d\\n\", pid);\n    }\n}\n\nvoid cleanup_parent() {\n    printf(\"Parent cleaning up IPC resources.\\n\");\n    // TODO: Detach and delete shared memory, delete semaphores\n    if (shm_ptr != (shm_data_t *)-1 && shm_ptr != NULL) {\n        if (shmdt(shm_ptr) == -1) {\n            perror(\"parent shmdt\");\n        }\n    }\n    if (shmid != -1) {\n        if (shmctl(shmid, IPC_RMID, NULL) == -1) {\n            perror(\"parent shmctl IPC_RMID\");\n        }\n    }\n    if (semid != -1) {\n        if (semctl(semid, 0, IPC_RMID) == -1) {\n            perror(\"parent semctl IPC_RMID\");\n        }\n    }\n}\n\nvoid cleanup_child() {\n    printf(\"Worker %d cleaning up.\\n\", getpid());\n    // TODO: Detach shared memory\n    if (shm_ptr != (shm_data_t *)-1 && shm_ptr != NULL) {\n        if (shmdt(shm_ptr) == -1) {\n            perror(\"child shmdt\");\n        }\n    }\n}\n\nint main() {\n    pid_t pids[NUM_WORKERS];\n    struct sigaction sa_shutdown, sa_chld;\n\n    // Initialize signal handlers\n    sa_shutdown.sa_handler = shutdown_handler;\n    sigemptyset(&sa_shutdown.sa_mask);\n    sa_shutdown.sa_flags = 0; // No SA_RESTART to allow interrupted system calls\n\n    sa_chld.sa_handler = sigchld_handler;\n    sigemptyset(&sa_chld.sa_mask);\n    sa_chld.sa_flags = SA_RESTART; // Restart interrupted system calls\n\n    if (sigaction(SIGUSR1, &sa_shutdown, NULL) == -1) {\n        perror(\"sigaction SIGUSR1\");\n        exit(1);\n    }\n    if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(1);\n    }\n\n    // Parent creates shared memory and semaphores\n    shmid = shmget(SHM_KEY, sizeof(shm_data_t), IPC_CREAT | 0666);\n    if (shmid == -1) { perror(\"shmget\"); exit(1); }\n\n    shm_ptr = (shm_data_t *)shmat(shmid, NULL, 0);\n    if (shm_ptr == (shm_data_t *)-1) { perror(\"shmat\"); exit(1); }\n\n    semid = semget(SEM_KEY, 1, IPC_CREAT | 0666);\n    if (semid == -1) { perror(\"semget\"); exit(1); }\n\n    // Initialize semaphore to 1 (mutex)\n    if (semctl(semid, 0, SETVAL, 1) == -1) { perror(\"semctl SETVAL\"); exit(1); }\n\n    // Initialize shared data\n    shm_ptr->next_task_index = 0;\n    shm_ptr->shutdown_flag = 0;\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        shm_ptr->status[i] = 0; // 0 = idle, 1 = working, 2 = finished\n    }\n\n    printf(\"Parent (PID %d) created shared memory and semaphores.\\n\", getpid());\n\n    // Fork child processes\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        pids[i] = fork();\n        if (pids[i] == -1) {\n            perror(\"fork\");\n            exit(1);\n        }\n        if (pids[i] == 0) { // Child process\n            // Worker's main loop\n            printf(\"Worker %d (PID %d) started.\\n\", i, getpid());\n            // Child inherits shm_ptr. No need to re-attach unless explicitly desired.\n\n            int worker_id = i;\n            while (!child_should_exit) { // Loop until shutdown requested\n                // Acquire semaphore - needs to handle EINTR\n                while (semop(semid, &acquire_sem, 1) == -1) {\n                    if (errno == EINTR) {\n                        if (child_should_exit) { // Re-check shutdown flag after EINTR\n                            goto end_child_loop; // Exit gracefully\n                        }\n                        continue; // Try again if interrupted by non-shutdown signal\n                    }\n                    perror(\"semop acquire\");\n                    cleanup_child();\n                    exit(1);\n                }\n\n                // Critical section: Access shared memory\n                if (child_should_exit) { // Re-check after acquiring semaphore\n                    semop(semid, &release_sem, 1); // Release before exiting\n                    goto end_child_loop;\n                }\n\n                // Simulate task processing\n                int current_task = shm_ptr->next_task_index++;\n                if (current_task >= 10) { // Example: only 10 tasks available\n                    semop(semid, &release_sem, 1);\n                    goto end_child_loop; // No more tasks, child can exit even without shutdown signal\n                }\n                printf(\"Worker %d (PID %d) processing task %d.\\n\", worker_id, getpid(), current_task);\n                shm_ptr->status[worker_id] = 1; // Working\n                \n                // Release semaphore immediately after updating shared state\n                semop(semid, &release_sem, 1);\n\n                sleep(1 + (rand() % 2)); // Simulate work outside critical section\n                \n                // If status update is critical, it needs its own critical section or part of the existing one.\n                // For simplicity, let's say the status '1' (working) is temporary.\n            }\n        end_child_loop:\n            cleanup_child();\n            exit(0);\n        }\n    }\n\n    // Parent's main loop (manager)\n    // Simulate parent doing other work and then initiating shutdown\n    sleep(5);\n    printf(\"Parent initiating shutdown for workers.\\n\");\n    // Parent sets a global flag in shared memory (optional, but can be used for other logic)\n    shm_ptr->shutdown_flag = 1; \n\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        if (pids[i] > 0) {\n            printf(\"Parent sending SIGUSR1 to worker %d (PID %d).\\n\", i, pids[i]);\n            kill(pids[i], SIGUSR1);\n        }\n    }\n\n    // Parent waits for all children to terminate\n    // The SIGCHLD handler should take care of reaping, but parent still needs to wait\n    // for all children to ensure they've all exited before cleaning up IPC.\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        int status;\n        pid_t waited_pid;\n        while ((waited_pid = waitpid(pids[i], &status, 0)) == -1 && errno == EINTR) {\n            // Interrupted, try again\n        }\n        if (waited_pid == -1) {\n            perror(\"waitpid\");\n        }\n        printf(\"Parent collected worker %d (PID %d) with status %d.\\n\", i, pids[i], status);\n    }\n\n    cleanup_parent();\n\n    return 0;\n}\n```",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "השלימו את פונקציות הטיפול באותות (`shutdown_handler` ו-`sigchld_handler`) ואת לולאת העבודה של תהליכי הבן, כך שהם יטפלו באותות ויבצעו את המשימות כנדרש. ודאו טיפול נכון ב-`EINTR` עבור קריאות מערכת שיכולות להיקטע על ידי אותות. הסבירו מדוע בחירה מסוימת של `sa_flags` (לדוגמה, `SA_RESTART` לעומת 0) חשובה לכל אחד מהמטפלים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "כיצד הבטחתם את עקביות הזיכרון המשותף במהלך פעולות הכתיבה/קריאה (כולל במהלך תהליך הכיבוי), ומהם המנגנונים שבהם השתמשתם? הסבירו בקצרה מדוע הם נחוצים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "תארו תרחיש אפשרי ל-race condition או deadlock שעלול להתרחש במערכת כזו אם לא ננקטים אמצעי זהירות מתאימים, והסבירו כיצד הפתרון שהצעתם מונע אותו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.4",
        "text": "השלימו את פונקציות הניקוי (`cleanup_parent` ו-`cleanup_child`) וודאו שכל המשאבים (זיכרון משותף וסמפורים) משוחררים בצורה נכונה בסיום עבודת התהליכים.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### פתרון והסברים:\n\nהקוד המלא והמתוקן יכלול את ההשלמות כפי שמוצג בקטע הקוד לעיל.\n\n### הסברים מפורטים:\n\n#### 1.1 השלמת פונקציות הטיפול באותות ולולאת העבודה של הבן:\n\n*   **`shutdown_handler`**: הוגדר משתנה גלובלי `volatile sig_atomic_t child_should_exit = 0;`. המטפל רק משנה את ערכו ל-1. שימוש ב-`volatile` מבטיח שהמהדר לא יבצע אופטימיזציות שימנעו קריאה חוזרת של המשתנה מהזיכרון, ו-`sig_atomic_t` מבטיח שהכתיבה למשתנה היא אטומית (לא תיקטע באמצע). המטפל אינו מבצע פעולות מורכבות כמו `exit()` או `shmdt()` מכיוון שפונקציות אלו אינן Async-Signal-Safe ועלולות לגרום ל-deadlock או לשחיתות נתונים אם יופעלו בתוך מטפל אותות.\n*   **לולאת העבודה של הבן**: הלולאה הראשית של הבן (`while (!child_should_exit)`) בודקת את הדגל `child_should_exit`. כאשר `SIGUSR1` מתקבל, הדגל משתנה, והלולאה מסתיימת בצורה מסודרת לאחר סיום המשימה הנוכחית. בתוך הלולאה, יש בדיקה נוספת של הדגל לפני ואחרי כניסה לקטע הקריטי (לאחר רכישת הסמפור) כדי לוודא יציאה מהירה אם האות הגיע בזמן שהבן המתין לסמפור.\n*   **טיפול ב-`EINTR`**: קריאות מערכת כמו `semop` ו-`waitpid` עלולות להיקטע על ידי אותות (כאשר `sa_flags` אינו כולל `SA_RESTART`).\n    *   עבור `semop` בבן: המטפל של `SIGUSR1` הוגדר ללא `SA_RESTART`. לכן, אם `semop` נקטע על ידי `SIGUSR1`, הוא יחזיר `EINTR`. הקוד מטפל בכך על ידי לולאה שמנסה שוב את `semop` אם `errno` הוא `EINTR`, אך בודק את `child_should_exit` שוב כדי לאפשר יציאה אם האות שגרם ל-`EINTR` היה `SIGUSR1`.\n    *   עבור `waitpid` באב: המטפל של `SIGCHLD` הוגדר עם `SA_RESTART`. המשמעות היא שקריאות מערכת שנקטעו על ידי `SIGCHLD` יופעלו מחדש אוטומטית, מה שמפשט את הטיפול ב-`waitpid` באב (אם כי עדיין מומלץ לולאה לבטיחות). \n*   **הסבר על `sa_flags`**: \n    *   **`sa_shutdown` (עבור `SIGUSR1` בבן) עם `sa_flags = 0`**: בחירה זו מאפשרת לקריאות מערכת חוסמות (כמו `semop` או `sleep`) להיקטע על ידי `SIGUSR1` ולהחזיר `EINTR`. זה קריטי למנגנון ה-graceful shutdown: אם הבן תקוע ב-`semop` וממתין לסמפור, ה-`SIGUSR1` יקטע אותו, הוא יקבל `EINTR`, יבדוק את `child_should_exit`, ויוכל לצאת מהלולאה במקום להמשיך לחכות. אם היינו משתמשים ב-`SA_RESTART`, ה-`semop` היה מתחדש אוטומטית לאחר טיפול באות, והבן לא היה מגיב לבקשת הכיבוי עד שהיה משחרר את הסמפור באופן טבעי (או רוכש אותו).\n    *   **`sa_chld` (עבור `SIGCHLD` באב) עם `sa_flags = SA_RESTART`**: בחירה זו מתאימה ל-`SIGCHLD` מכיוון שהיא מבטיחה שקריאות מערכת כמו `waitpid` יופעלו מחדש באופן אוטומטי לאחר טיפול באות. זה מונע מצב שבו האב צריך לטפל ידנית ב-`EINTR` עבור `waitpid`, מה שמפשט את קוד האב. המטרה של `SIGCHLD` היא רק לאפשר לאב לאסוף את הסטטוס של הבנים שסיימו, ולא להפריע לפעולות אחרות שלו בצורה דרמטית.\n\n#### 1.2 עקביות הזיכרון המשותף ומנגנוני סנכרון:\n\n*   **סמפורים (Semaphores)**: השתמשנו בסמפור בינארי (mutex) יחיד (`semid`) כדי להגן על הגישה לזיכרון המשותף (`shm_ptr`).\n    *   `acquire_sem` (`sem_op = -1`): מוריד את ערך הסמפור ב-1. אם הערך היה 0, התהליך נחסם עד שהסמפור יתפנה. זה מבטיח שרק תהליך אחד יכול להיכנס לקטע הקריטי בכל פעם.\n    *   `release_sem` (`sem_op = 1`): מעלה את ערך הסמפור ב-1. זה משחרר תהליכים חסומים.\n*   **מיקום הסמפורים**: פעולות ה-`semop` עוטפות את כל הגישה לנתונים המשותפים בזיכרון (`shm_ptr->next_task_index`, `shm_ptr->status`, `shm_ptr->shutdown_flag` בעת בדיקה לאחר רכישה). לדוגמה, קריאת `next_task_index` והגדלתו, או בדיקת `shutdown_flag` לאחר רכישת הסמפור, מתבצעות בתוך הקטע הקריטי.\n*   **הצורך בהם**: ללא סמפורים, מספר תהליכי בן יכלו לנסות לגשת ולשנות את `shm_ptr->next_task_index` בו זמנית, מה שיוביל ל-race condition. למשל, שני בנים עלולים לקרוא את אותו `next_task_index` לפני שאחד מהם הספיק להגדיל אותו, וכתוצאה מכך יטפלו באותה משימה. סמפורים מבטיחים בלעדיות הדדית (mutual exclusion) לגישה לזיכרון המשותף.\n*   **`volatile sig_atomic_t shutdown_flag`**: דגל זה, למרות שהוא בזיכרון משותף, אינו מוגן ישירות על ידי הסמפור עבור כל גישה. הוא מוגדר על ידי האב ונקרא על ידי הבנים. האב משנה אותו לפני שליחת האותות, והבנים קוראים אותו בלולאה הראשית שלהם וגם בבדיקה בתוך הקטע הקריטי. הקריאה מהלולאה הראשית (לפני רכישת סמפור) היא דרך יעילה לבדוק אם צריך לצאת מבלי להיחסם על הסמפור. ה-`volatile` מבטיח שהקומפיילר לא יאחסן את ערך הדגל ברגיסטר ויקרא אותו שוב ושוב מהזיכרון המשותף, מה שחשוב למשתנה שמשתנה על ידי גורם חיצוני (אות).\n\n#### 1.3 תרחיש ל-race condition/deadlock ומניעתו:\n\n*   **תרחיש Race Condition**: \n    *   **דוגמה 1 (ללא סמפורים)**: שני תהליכי בן מנסים לקחת משימה חדשה. שניהם קוראים את `shm_ptr->next_task_index` (נניח 5). שניהם חושבים שהם צריכים לטפל במשימה 5. שניהם מגדילים את המונה ל-6, אבל משימה 5 טופלה פעמיים, ומשימה 6 לא טופלה כלל. הפתרון: סמפורים המגנים על הגישה ל-`next_task_index` מבטיחים שרק בן אחד יגדיל אותו בכל פעם.\n    *   **דוגמה 2 (עם אותות וקריטי סקשן)**: בן רוכש סמפור, נכנס לקטע קריטי, ואז האב שולח לו `SIGUSR1`. אם המטפל של `SIGUSR1` היה מנסה לשחרר את הסמפור או לבצע `exit()` ישירות, זה היה עלול לגרום ל-deadlock (אם ניסיון לשחרר סמפור בתוך מטפל אותות נכשל או מנסה לשחרר סמפור שכבר שוחרר) או לשחיתות נתונים (אם `exit()` נקרא כאשר המשאבים לא נוקו). הפתרון: המטפל של `SIGUSR1` רק מעדכן דגל (`child_should_exit`). הבן בודק את הדגל לפני כניסה לקטע הקריטי (ובמקרה של `EINTR`), וגם מיד לאחר רכישת הסמפור. זה מבטיח שהבן ייצא מהלולאה בצורה מסודרת, ישחרר את הסמפור אם רכש אותו, ואז יבצע ניקוי בטוח.\n\n*   **תרחיש Deadlock**: \n    *   **דוגמה (אם ה-`shutdown_handler` היה מנסה לנקות משאבים)**: נניח שה-`shutdown_handler` היה מנסה לבצע `shmdt(shm_ptr)` או `semctl(semid, 0, IPC_RMID)`. אם האות `SIGUSR1` מגיע בזמן שהבן נמצא בקטע הקריטי (מחזיק את הסמפור), והמטפל מנסה לבצע פעולות שאינן Async-Signal-Safe (כמו `shmdt` או `semctl`), זה עלול לגרום ל-deadlock או התנהגות בלתי צפויה. הסמפור עלול להישאר נעול לנצח אם התהליך מת בתוך המטפל ללא שחרור נכון, מה שמונע מכל תהליך אחר להמשיך. הפתרון: המטפל רק מעדכן דגל. הניקוי מתבצע בפונקציה `cleanup_child()` שמורצת לאחר שהלולאה הראשית של הבן יצאה בצורה מסודרת, וכל הסמפורים שוחררו.\n\n#### 1.4 השלמת פונקציות הניקוי:\n\n*   **`cleanup_parent()`**: פונקציה זו אחראית לנתק את הזיכרון המשותף (`shmdt`) ולמחוק את אובייקט הזיכרון המשותף (`shmctl` עם `IPC_RMID`). בנוסף, היא מוחקת את קבוצת הסמפורים (`semctl` עם `IPC_RMID`). יש לוודא שפעולות אלו מתבצעות רק אם המשאבים נוצרו בהצלחה (בדיקה ש-`shmid != -1` ו-`semid != -1`).\n*   **`cleanup_child()`**: פונקציה זו אחראית רק לנתק את הזיכרון המשותף (`shmdt`) עבור תהליך הבן. תהליכי הבן אינם מוחקים את אובייקטי ה-IPC, מכיוון שזהו תפקידו של תהליך האב, שרק הוא יודע מתי כל הבנים סיימו וניתן לנקות את המשאבים המשותפים באופן סופי.\n*   **סדר הניקוי**: חשוב שהאב ימתין לכל הבנים לפני ביצוע `cleanup_parent()`. אם האב היה מנקה את ה-IPC לפני שכל הבנים סיימו, הבנים עלולים היו לנסות לגשת לזיכרון משותף או סמפורים שכבר נמחקו, מה שיוביל לשגיאות או קריסה. `waitpid` מבטיח שהאב ממתין לבנים לפני ניקוי המשאבים."
    },
    "difficulty_estimation": "Hard"
  }
}