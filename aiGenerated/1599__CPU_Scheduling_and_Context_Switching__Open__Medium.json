{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling and Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 11:46:43",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2319,
      "output_tokens": 1845,
      "total_tokens": 7791
    }
  },
  "question": {
    "id": 5,
    "type": "Open",
    "topic": [
      "CPU Scheduling",
      "Context Switching",
      "Operating Systems"
    ],
    "content": {
      "text": "החלפות הקשר (Context Switches) הן מנגנון בסיסי במערכות הפעלה המאפשר ריבוי משימות וניצול יעיל של המעבד. עם זאת, הן כרוכות בעלות תקורה משמעותית. ענה/י על השאלות הבאות בנושא:",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "5.1",
        "text": "הגדירו מהי 'החלפת הקשר' (Context Switch) במערכת הפעלה, ופרטו אילו סוגי מידע נשמרים ומשוחזרים במהלך תהליך זה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "5.2",
        "text": "פרטו מהם הגורמים העיקריים התורמים לעלות התקורה של החלפת הקשר.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "5.3",
        "text": "במערכת בעלת מעבד יחיד המשתמשת באלגוריתם תזמון Round Robin, נניח שישנם תהליכים רבים בעלי אורך חיים קצר ואינטנסיביים מבחינת שימוש במעבד (CPU-bound). הסבירו כיצד בחירה לא נכונה של אורך פרוסת הזמן (time quantum) עלולה להוביל לירידה משמעותית בביצועי המערכת עקב החלפות הקשר מרובות מדי.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "5.4",
        "text": "כתבו קטע קוד פשוט ב-C/C++ המדגים מצב שעלול להוביל להחלפות הקשר תכופות במיוחד, והסבירו בקצרה מדוע. הניחו שישנם מספר חוטים נוספים במערכת שמוכנים לרוץ.",
        "code_snippet": " #include <stdio.h>\n #include <pthread.h>\n #include <unistd.h> // For usleep\n\n void *thread_func(void *arg) {\n     for (int i = 0; i < 5; ++i) {\n         printf(\"Thread %ld running iteration %d\\n\", (long)arg, i);\n         // Simulate a very short burst of work\n         usleep(100); // 100 microseconds\n         pthread_yield(); // Voluntarily yield the CPU\n     }\n     return NULL;\n }\n\n int main() {\n     pthread_t tid[2];\n     for (long i = 0; i < 2; ++i) {\n         pthread_create(&tid[i], NULL, thread_func, (void *)(i + 1));\n     }\n     for (int i = 0; i < 2; ++i) {\n         pthread_join(tid[i], NULL);\n     }\n     return 0;\n }",
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "5.1. החלפת הקשר היא תהליך שבו מערכת ההפעלה שומרת את מצבו של תהליך (או חוט) אחד, וטוענת את מצבו של תהליך (או חוט) אחר, על מנת לאפשר לו להשתמש במעבד. המידע שנשמר כולל בדרך כלל: ערכי אוגרים של המעבד (כולל אוגר המונה תוכניות - Program Counter), מצב המחסנית, מידע אודות מרחב הכתובות של התהליך (אם מדובר בהחלפה בין תהליכים), ומידע תזמוני/מצב של התהליך בטבלת התהליכים (Process Control Block - PCB).\n\n5.2. הגורמים התורמים לעלות התקורה כוללים:\n1.  **שמירה ושיחזור אוגרים:** פעולה זו דורשת גישה לזיכרון (או למחסנית) וכתיבה/קריאה של נתונים.\n2.  **עדכון מבני נתונים של מערכת ההפעלה:** עדכון ה-PCB של התהליך היוצא והנכנס (שינוי מצב, זמני ריצה וכו').\n3.  **טעינה מחדש של זיכרון מטמון (Cache):** נתוני מטמון (כולל TLB) של התהליך הקודם הופכים ללא רלוונטיים, ונדרש זמן למלא את המטמון מחדש עבור התהליך החדש. זהו גורם משמעותי במיוחד.\n4.  **שינוי מפות זיכרון (אם בין תהליכים):** אם מדובר בהחלפה בין תהליכים שונים, יש צורך לשנות את מפת הזיכרון הווירטואלי (לדוגמה, על ידי עדכון אוגר בקרת יחידת ניהול הזיכרון - MMU), מה שמוביל גם לריקון TLB.\n5.  **העברת שליטה לליבת מערכת ההפעלה ובחירת התהליך הבא:** זמן הנדרש למתזמן לבחור את התהליך הבא לריצה.\n\n5.3. במצב המתואר, אם אורך פרוסת הזמן (time quantum) קצר מדי ביחס לזמן הנדרש להשלמת 'פרץ' עבודה טיפוסי של תהליך, או קצר יותר מעלות התקורה של החלפת הקשר עצמה, המערכת תבזבז חלק ניכר מזמן המעבד על ביצוע החלפות הקשר במקום על עבודה שימושית. כל תהליך ירוץ לפרק זמן קצר מאוד, יופסק, ומערכת ההפעלה תבצע החלפת הקשר. אם ישנם תהליכים רבים, כל אחד מהם יקבל פרוסות זמן קצרות מאוד באופן תכוף, מה שיגרום לעלות תקורה גבוהה מאוד של החלפות הקשר ביחס לעבודה בפועל, ויפגע משמעותית בתפוקה (throughput) ובזמן התגובה (response time) הכוללים של המערכת.\n\n5.4. קטע הקוד מדגים שימוש ב-`pthread_yield()`. פונקציה זו מאפשרת לחוט לוותר מרצונו על המעבד, גם אם פרוסת הזמן שלו טרם הסתיימה. אם קיימים חוטים נוספים שמוכנים לרוץ, קריאה ל-`pthread_yield()` תוביל באופן מיידי להחלפת הקשר. בלולאה שבה `pthread_yield()` נקראת באופן תכוף (לאחר עבודה קטנה מאוד של `usleep(100)`), החוט יגרום להחלפות הקשר רבות ומהירות, במיוחד אם זמן ה-`usleep` קצר משמעותית מפרוסת הזמן שהיה מקבל באופן רזפטיבי, וכאשר יש תמיד חוטים נוספים שמוכנים לרוץ. זה מדמה מצב של תהליכים שזקוקים למשאבים אחרים לעיתים קרובות, או תהליכים שתוכננו לוותר על המעבד באופן יזום."
    },
    "difficulty_estimation": "Medium"
  }
}