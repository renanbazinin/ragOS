{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management and Page Replacement",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 10:57:13",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3221,
      "output_tokens": 4773,
      "total_tokens": 20442
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Paging",
      "Page Replacement",
      "Virtual Memory"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה עם מרחב כתובות וירטואלי של 64 ביט וגודל דף של 4KB. המערכת משתמשת בטבלת דפים דו-רמתית, כאשר כל כניסה בטבלת הדפים (PTE) היא בגודל 8 בתים. הזיכרון הפיזי במערכת מכיל 4 מסגרות בלבד.\nהמערכת מיישמת אלגוריתם החלפת דפים היברידי: כאשר מתרחשת פסיקת דף (Page Fault) וכל המסגרות בזיכרון הפיזי תפוסות, המערכת מחפשת תחילה את הדף ה\"נקי\" (Clean) שהיה בשימוש האחרון לפני זמן רב ביותר (LRU Clean). אם אין דפים נקיים זמינים, המערכת תפנה את הדף ה\"מלוכלך\" (Dirty) שהיה בשימוש האחרון לפני זמן רב ביותר (LRU Dirty). דף נהפך ל\"מלוכלך\" כאשר מתבצעת אליו גישת כתיבה. בתחילת הריצה, כל טבלאות הדפים טעונות בזיכרון הפיזי, ואין דפי נתונים של תהליכים טעונים.\nנתונה סדרת הגישות הבאה לדפים וירטואליים: P1 (קריאה), P2 (כתיבה), P3 (קריאה), P1 (קריאה), P4 (כתיבה), P5 (קריאה), P2 (קריאה), P6 (כתיבה), P3 (קריאה), P1 (כתיבה), P7 (קריאה), P8 (כתיבה), P4 (קריאה).\nיש להניח כי גישות קריאה אינן משנות את סטטוס ה-Dirty של הדף, וגישות כתיבה הופכות אותו ל-Dirty אם אינו כזה.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "101.1",
        "text": "פרטו את חלוקת הביטים של כתובת וירטואלית במערכת זו (מספר ביטים לאינדקס טבלת דפים רמה 1, אינדקס טבלת דפים רמה 2, והיסט בתוך הדף).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.2",
        "text": "כמה כניסות (PTEs) יכולות להיכנס לדף בודד? כמה כניסות יש בטבלת הדפים ברמה הראשונה (Page Directory)?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.3",
        "text": "עבור סדרת הגישות הנתונה, חשבו את מספר פסיקות הדף הכולל. הציגו את מצב המסגרות הפיזיות (מספר הדף הווירטואלי ואם הוא נקי/מלוכלך) ואת סדר ה-LRU (עבור דפים נקיים ועבור דפים מלוכלכים בנפרד, או סדר כללי עם סימון נקי/מלוכלך) לאחר כל פסיקת דף שגורמת לפינוי.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.4",
        "text": "הסבירו מדוע אלגוריתם החלפת דפים כזה עשוי להיות יעיל במערכות מסוימות, ומתי הוא עלול להיות פחות יעיל.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון שאלה 101:\n\n**1. חלוקת הביטים של כתובת וירטואלית:**\n*   גודל כתובת וירטואלית: 64 ביט.\n*   גודל דף: 4KB = 2^12 בתים. לכן, ההיסט (Offset) בתוך הדף הוא 12 ביטים.\n*   מספר הביטים הנותרים עבור מספר הדף הווירטואלי (VPN) הוא 64 - 12 = 52 ביטים.\n*   גודל כניסה בטבלת הדפים (PTE): 8 בתים.\n*   מספר כניסות PTE שיכולות להיכנס לדף בודד: 4KB / 8 בתים = 4096 / 8 = 512 כניסות.\n*   כדי לאנדקס 512 כניסות, נדרשים log2(512) = 9 ביטים.\n*   מכיוון שמדובר בטבלת דפים דו-רמתית, כל רמה משתמשת ב-9 ביטים לאינדקס.\n    *   אינדקס טבלת דפים רמה 1 (Page Directory Index): 9 ביטים.\n    *   אינדקס טבלת דפים רמה 2 (Page Table Index): 9 ביטים.\n*   סה\"כ ביטים המשמשים ל-VPN במערכת זו: 9 + 9 = 18 ביטים. הביטים הנותרים מתוך 52 ביטים עבור ה-VPN (52-18=34 ביטים) אינם בשימוש או משמשים לייצוג כתובות קאנוניות.\n\n**2. כניסות בטבלת הדפים:**\n*   כאמור בסעיף 1, מספר הכניסות (PTEs) שיכולות להיכנס לדף בודד הוא 512 כניסות.\n*   טבלת הדפים ברמה הראשונה (Page Directory) מאוחסנת בדף אחד. לכן, יש בה 512 כניסות.\n\n**3. חישוב פסיקות דף וטרייס:**\n*   מספר מסגרות פיזיות: 4.\n*   `frames`: מציין את הדף המאוחסן בכל מסגרת ואת מצבו (נקי/מלוכלך).\n*   `lru_queue`: רשימה של דפים בזיכרון, כאשר הדף בראש הרשימה הוא ה-LRU והדף בסוף הרשימה הוא ה-MRU. לכל דף מצוין גם מצבו (נקי/מלוכלך).\n*   `PF_count`: מונה פסיקות דף.\n\n**מצב התחלתי:** `frames = [empty, empty, empty, empty]`, `lru_queue = []`, `PF_count = 0`\n\n1.  **P1 (קריאה)**: פסיקת דף. `PF_count = 1`. טוען P1 למסגרת F0. P1 נקי.\n    *   `frames`: `[P1(C), empty, empty, empty]`\n    *   `lru_queue`: `[(P1,C)]`\n\n2.  **P2 (כתיבה)**: פסיקת דף. `PF_count = 2`. טוען P2 למסגרת F1. P2 הופך למלוכלך.\n    *   `frames`: `[P1(C), P2(D), empty, empty]`\n    *   `lru_queue`: `[(P1,C), (P2,D)]`\n\n3.  **P3 (קריאה)**: פסיקת דף. `PF_count = 3`. טוען P3 למסגרת F2. P3 נקי.\n    *   `frames`: `[P1(C), P2(D), P3(C), empty]`\n    *   `lru_queue`: `[(P1,C), (P2,D), (P3,C)]`\n\n4.  **P1 (קריאה)**: פגיעה (Hit). P1 נקי. מעביר P1 לסוף ה-LRU (MRU).\n    *   `frames`: `[P1(C), P2(D), P3(C), empty]`\n    *   `lru_queue`: `[(P2,D), (P3,C), (P1,C)]`\n\n5.  **P4 (כתיבה)**: פסיקת דף. `PF_count = 4`. טוען P4 למסגרת F3. P4 הופך למלוכלך.\n    *   `frames`: `[P1(C), P2(D), P3(C), P4(D)]`\n    *   `lru_queue`: `[(P2,D), (P3,C), (P1,C), (P4,D)]`\n    *   **מצב מסגרות מלא:** `F0:P1(C), F1:P2(D), F2:P3(C), F3:P4(D)`\n\n6.  **P5 (קריאה)**: פסיקת דף. `PF_count = 5`. המסגרות מלאות, יש לפנות דף.\n    *   דפים נקיים ב-`lru_queue`: `(P3,C)` (ה-LRU Clean), `(P1,C)`.\n    *   דפים מלוכלכים ב-`lru_queue`: `(P2,D)` (ה-LRU Dirty), `(P4,D)`.\n    *   האלגוריתם מפנה את ה-LRU Clean: P3. טוען P5 למסגרת F2 (שבה היה P3). P5 נקי.\n    *   `frames`: `[P1(C), P2(D), P5(C), P4(D)]`\n    *   `lru_queue`: `[(P2,D), (P1,C), (P4,D), (P5,C)]` (P3 יצא, P5 נכנס ל-MRU)\n\n7.  **P2 (קריאה)**: פגיעה. P2 מלוכלך. מעביר P2 לסוף ה-LRU (MRU).\n    *   `frames`: `[P1(C), P2(D), P5(C), P4(D)]`\n    *   `lru_queue`: `[(P1,C), (P4,D), (P5,C), (P2,D)]`\n\n8.  **P6 (כתיבה)**: פסיקת דף. `PF_count = 6`. המסגרות מלאות, יש לפנות דף. P6 הופך למלוכלך.\n    *   דפים נקיים ב-`lru_queue`: `(P1,C)` (ה-LRU Clean), `(P5,C)`.\n    *   דפים מלוכלכים ב-`lru_queue`: `(P4,D)` (ה-LRU Dirty), `(P2,D)`.\n    *   האלגוריתם מפנה את ה-LRU Clean: P1. טוען P6 למסגרת F0 (שבה היה P1). P6 מלוכלך.\n    *   `frames`: `[P6(D), P2(D), P5(C), P4(D)]`\n    *   `lru_queue`: `[(P4,D), (P5,C), (P2,D), (P6,D)]` (P1 יצא, P6 נכנס ל-MRU)\n\n9.  **P3 (קריאה)**: פסיקת דף. `PF_count = 7`. המסגרות מלאות, יש לפנות דף. P3 נקי.\n    *   דפים נקיים ב-`lru_queue`: `(P5,C)` (ה-LRU Clean).\n    *   דפים מלוכלכים ב-`lru_queue`: `(P4,D)` (ה-LRU Dirty), `(P2,D)`, `(P6,D)`.\n    *   האלגוריתם מפנה את ה-LRU Clean: P5. טוען P3 למסגרת F2 (שבה היה P5). P3 נקי.\n    *   `frames`: `[P6(D), P2(D), P3(C), P4(D)]`\n    *   `lru_queue`: `[(P4,D), (P2,D), (P6,D), (P3,C)]` (P5 יצא, P3 נכנס ל-MRU)\n\n10. **P1 (כתיבה)**: פסיקת דף. `PF_count = 8`. המסגרות מלאות, יש לפנות דף. P1 הופך למלוכלך.\n    *   דפים נקיים ב-`lru_queue`: `(P3,C)` (ה-LRU Clean).\n    *   דפים מלוכלכים ב-`lru_queue`: `(P4,D)` (ה-LRU Dirty), `(P2,D)`, `(P6,D)`.\n    *   האלגוריתם מפנה את ה-LRU Clean: P3. טוען P1 למסגרת F2 (שבה היה P3). P1 מלוכלך.\n    *   `frames`: `[P6(D), P2(D), P1(D), P4(D)]`\n    *   `lru_queue`: `[(P4,D), (P2,D), (P6,D), (P1,D)]` (P3 יצא, P1 נכנס ל-MRU).\n    *   **כל הדפים מלוכלכים כעת.**\n\n11. **P7 (קריאה)**: פסיקת דף. `PF_count = 9`. המסגרות מלאות, יש לפנות דף. P7 נקי.\n    *   דפים נקיים ב-`lru_queue`: אין.\n    *   דפים מלוכלכים ב-`lru_queue`: `(P4,D)` (ה-LRU Dirty), `(P2,D)`, `(P6,D)`, `(P1,D)`.\n    *   האלגוריתם מפנה את ה-LRU Dirty: P4. טוען P7 למסגרת F3 (שבה היה P4). P7 נקי.\n    *   `frames`: `[P6(D), P2(D), P1(D), P7(C)]`\n    *   `lru_queue`: `[(P2,D), (P6,D), (P1,D), (P7,C)]` (P4 יצא, P7 נכנס ל-MRU)\n\n12. **P8 (כתיבה)**: פסיקת דף. `PF_count = 10`. המסגרות מלאות, יש לפנות דף. P8 הופך למלוכלך.\n    *   דפים נקיים ב-`lru_queue`: `(P7,C)` (ה-LRU Clean).\n    *   דפים מלוכלכים ב-`lru_queue`: `(P2,D)` (ה-LRU Dirty), `(P6,D)`, `(P1,D)`.\n    *   האלגוריתם מפנה את ה-LRU Clean: P7. טוען P8 למסגרת F3 (שבה היה P7). P8 מלוכלך.\n    *   `frames`: `[P6(D), P2(D), P1(D), P8(D)]`\n    *   `lru_queue`: `[(P2,D), (P6,D), (P1,D), (P8,D)]` (P7 יצא, P8 נכנס ל-MRU).\n    *   **כל הדפים מלוכלכים שוב.**\n\n13. **P4 (קריאה)**: פסיקת דף. `PF_count = 11`. המסגרות מלאות, יש לפנות דף. P4 נקי.\n    *   דפים נקיים ב-`lru_queue`: אין.\n    *   דפים מלוכלכים ב-`lru_queue`: `(P2,D)` (ה-LRU Dirty), `(P6,D)`, `(P1,D)`, `(P8,D)`.\n    *   האלגוריתם מפנה את ה-LRU Dirty: P2. טוען P4 למסגרת F1 (שבה היה P2). P4 נקי.\n    *   `frames`: `[P6(D), P4(C), P1(D), P8(D)]`\n    *   `lru_queue`: `[(P6,D), (P1,D), (P8,D), (P4,C)]` (P2 יצא, P4 נכנס ל-MRU)\n\n**סה\"כ פסיקות דף:** 11\n\n**4. יעילות האלגוריתם:**\n*   **מדוע עשוי להיות יעיל?** אלגוריתם זה נועד להפחית את מספר פעולות הקלט/פלט (I/O) הנדרשות לכתיבת דפים לדיסק. פינוי דף מלוכלך (Dirty) דורש כתיבה שלו לדיסק לפני שניתן לטעון דף חדש למסגרת שלו. לעומת זאת, פינוי דף נקי (Clean) אינו דורש כתיבה לדיסק, מכיוון שהתוכן שלו זהה לגרסה המאוחסנת בדיסק. על ידי מתן עדיפות לפינוי דפים נקיים, המערכת יכולה לחסוך פעולות כתיבה יקרות לדיסק, ובכך לשפר את ביצועי המערכת הכוללים, במיוחד במצבים שבהם פעולות I/O הן צוואר בקבוק. זה יעיל במיוחד אם ישנם דפים רבים שנקראים אך לעיתים רחוקות נכתבים (למשל, קוד או נתונים לקריאה בלבד).\n*   **מתי עלול להיות פחות יעיל?**\n    *   **רוב הדפים מלוכלכים:** אם רוב הדפים בזיכרון הפיזי מלוכלכים, האלגוריתם יצטרך לפנות דפים מלוכלכים בכל מקרה. במצב זה, הוא למעשה מתנהג כמו LRU רגיל (או קרוב לכך), והיתרון של הימנעות מכתיבה לדיסק נעלם. ייתכן אף שדף מלוכלך מאוד ישן (LRU Dirty) יפונה לפני דף מלוכלך חדש יותר, מה שעלול להיות לא אופטימלי.\n    *   **פינוי חוזר של דף נקי חיוני:** אם יש דף נקי אחד או מעטים שהם גם ה-LRU Clean באופן עקבי, והם נדרשים שוב ושוב, האלגוריתם יפנה אותם שוב ושוב. הדבר יוביל לריבוי פסיקות דף (Thrashing) עבור אותם דפים נקיים, למרות שאולי ישנם דפים מלוכלכים אחרים שאינם בשימוש רב. במקרה כזה, עלולות להיות יותר פסיקות דף מאשר באלגוריתם LRU טהור, ובכך לפגוע בביצועים."
    },
    "difficulty_estimation": "Hard"
  }
}