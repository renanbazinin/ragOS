{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:39:05",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1032,
      "output_tokens": 772,
      "total_tokens": 4451
    }
  },
  "question": {
    "id": 4,
    "type": "MultipleChoice",
    "topic": [
      "Semaphores",
      "Concurrency",
      "Deadlock"
    ],
    "content": {
      "text": "נתון קטע הקוד הבא המשתמש בסמפור בינארי `mutex` להגנה על משאב משותף. מה תהיה התוצאה הסבירה ביותר כאשר שני תהליכים (threads) ינסו להריץ את `thread_func`?",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n\nsem_t mutex;\nint shared_data = 0;\n\nvoid* thread_func(void* arg) {\n    sem_wait(&mutex); // P operation\n    shared_data++;\n    printf(\"Thread %ld: shared_data = %d\\n\", (long)arg, shared_data);\n    sem_post(&mutex); // V operation\n    return NULL;\n}\n\nint main() {\n    sem_init(&mutex, 0, 0); // Initializing to 0\n    pthread_t t1, t2;\n    pthread_create(&t1, NULL, thread_func, (void*)1);\n    pthread_create(&t2, NULL, thread_func, (void*)2);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    sem_destroy(&mutex);\n    return 0;\n}",
      "options": [
        "א. שני התהליכים יגדילו את `shared_data` פעם אחת כל אחד, והערך הסופי יהיה 2.",
        "ב. אחד התהליכים יגדיל את `shared_data` ל-1, והתהליך השני ימתין ללא הגבלת זמן.",
        "ג. שני התהליכים יחסמו (block) וייכנסו למצב של קיפאון (deadlock) ולא יוכלו להתקדם.",
        "ד. התוכנית תקרוס עקב שימוש לא חוקי בסמפור.",
        "ה. אף אחת מהתשובות האחרות אינה נכונה."
      ]
    },
    "sub_questions": null,
    "points": 5,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ג",
      "explanation": "הסמפור `mutex` מאותחל לערך 0. כאשר תהליך מנסה לבצע פעולת `sem_wait` (P) על סמפור שערכו 0, הוא נחסם וממתין עד שערך הסמפור יהפוך לחיובי (על ידי פעולת `sem_post` - V). במקרה זה, שני התהליכים מנסים לבצע `sem_wait` על סמפור שערכו 0. שניהם ייחסמו באופן מיידי, ומכיוון שאף אחד מהם לא יצליח להגיע לפעולת `sem_post` כדי לשחרר את הסמפור, שניהם יישארו חסומים לעד. מצב זה מוביל לקיפאון (deadlock)."
    },
    "difficulty_estimation": "Medium"
  }
}