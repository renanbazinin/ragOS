{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:30:18",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3218,
      "output_tokens": 4278,
      "total_tokens": 14856
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Paging",
      "Segmentation",
      "Address Translation",
      "TLB"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת במודל ניהול זיכרון היברידי המשלב סגמנטציה ודפדוף (Segmented Paging). במערכת זו, מרחב הכתובות הווירטואלי הוא 64 ביט, ומרחב הכתובות הפיזי הוא 48 ביט. גודל דף הוא 4KB.\n\nלכל סגמנט במערכת יש טבלת דפים רב-שכבתית משלו, עצמאית לחלוטין. טבלת מתארי הסגמנטים (Segment Descriptor Table - SDT) מכילה כניסות עבור כל הסגמנטים של תהליך, כאשר כל כניסה (Segment Descriptor Entry - SDE) מצביעה על בסיס טבלת הדפים מהרמה הראשונה של הסגמנט המתאים. גודל כל SDE הוא 16 בתים. גודל כל כניסה בטבלת דפים (Page Table Entry - PTE) הוא 8 בתים.\n\nנדרש שכל טבלת דפים (בכל רמה) וכן טבלת מתארי הסגמנטים (SDT) יאוחסנו בדף אחד בדיוק.\n\nיש לענות על השאלות הבאות:",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "תארו בפירוט את תהליך תרגום הכתובת המלא מכתובת וירטואלית (המורכבת מבורר סגמנט והיסט בתוך הסגמנט) לכתובת פיזית. ציינו את כל הגישות הנדרשות לזיכרון הראשי ול-TLB במקרה הגרוע ביותר (worst-case).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "חשבו את הפרטים הבאים:\nא. כמה רמות של טבלאות דפים נדרשות עבור כל סגמנט?\nב. מהו המספר המקסימלי של סגמנטים שתהליך יכול להכיל?\nג. מהו הגודל המקסימלי של סגמנט בבתים?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "דונו ביתרונות ובחסרונות של מודל ניהול זיכרון זה בהשוואה למערכת המשתמשת בדפדוף בלבד (Pure Paging) או סגמנטציה בלבד (Pure Segmentation). התייחסו למורכבות המימוש, ניצול הזיכרון (פנימי וחיצוני) והשפעה על ביצועים (כגון זמן גישה לזיכרון).",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\n**נתונים ראשוניים:**\n*   מרחב כתובות וירטואלי: 64 ביט.\n*   מרחב כתובות פיזי: 48 ביט.\n*   גודל דף: 4KB = 2^12 בתים. מכאן שההיסט בתוך הדף (offset) הוא 12 ביטים.\n*   גודל SDE: 16 בתים.\n*   גודל PTE: 8 בתים.\n*   כל טבלה (SDT או טבלת דפים) מאוחסנת בדף אחד בדיוק.\n\n**1.1 תהליך תרגום הכתובת:**\nכתובת וירטואלית מורכבת מבורר סגמנט (Segment Selector) והיסט בתוך הסגמנט (Offset). ההיסט בתוך הסגמנט מתורגם באמצעות טבלאות הדפים של הסגמנט.\n\n**שלבי התרגום:**\n1.  **פיצול הכתובת הווירטואלית:** המעבד מקבל כתובת וירטואלית של 64 ביט. יש לפצל אותה לבורר סגמנט (Segment Selector) ולהיסט בתוך הסגמנט (Segment Offset).\n2.  **גישה ל-SDT:**\n    *   בורר הסגמנט משמש כאינדקס לטבלת מתארי הסגמנטים (SDT). ה-SDT היא טבלה הממוקמת בזיכרון הראשי (בכתובת בסיס הידועה למערכת ההפעלה, למשל, מתוך רגיסטר).\n    *   המעבד ניגש ל-SDT כדי למצוא את ה-SDE המתאים.\n    *   **במקרה הגרוע ביותר (החטאות ב-TLB וב-Cache):** גישה ל-TLB (עבור מיפוי דף ה-SDT) – החטאה (miss), ואז גישה לזיכרון הראשי כדי להביא את ה-SDE. ה-SDE מכיל את כתובת הבסיס של טבלת הדפים מהרמה הראשונה של הסגמנט, וכן מידע על זכויות גישה, גודל הסגמנט וכו'.\n3.  **תרגום בתוך טבלת הדפים של הסגמנט:**\n    *   ההיסט בתוך הסגמנט (Segment Offset) מפולח למספרי דפים עבור כל רמה של טבלת הדפים, ולבסוף להיסט בתוך הדף (Page Offset).\n    *   **רמה 1:** ה-SDE נותן את כתובת הבסיס של טבלת הדפים ברמה הראשונה (לדוגמה, Page Directory Pointer Table). מספר הדף הראשון מתוך ה-Segment Offset משמש כאינדקס לטבלה זו.\n        *   **במקרה הגרוע ביותר:** גישה ל-TLB (עבור מיפוי דף טבלת הדפים ברמה 1) – החטאה, ואז גישה לזיכרון הראשי כדי להביא את ה-PTE ברמה 1. ה-PTE מצביע על טבלת הדפים ברמה הבאה.\n    *   **רמה 2:** מספר הדף השני משמש כאינדקס לטבלת הדפים ברמה השנייה.\n        *   **במקרה הגרוע ביותר:** גישה לזיכרון הראשי כדי להביא את ה-PTE ברמה 2. ה-PTE מצביע על טבלת הדפים ברמה הבאה.\n    *   **... עד לרמה האחרונה (6):** מספר הדף האחרון משמש כאינדקס לטבלת הדפים ברמה האחרונה.\n        *   **במקרה הגרוע ביותר:** גישה לזיכרון הראשי כדי להביא את ה-PTE ברמה האחרונה. ה-PTE הזה מכיל את מספר המסגרת הפיזית (Page Frame Number - PFN).\n    *   **בכל שלב:** יש לבדוק את ביט ה-Present (P) ב-PTE. אם P=0, מתרחשת Page Fault. אם ה-PTE אינו Valid (V=0), זו שגיאה. יש גם לבדוק את זכויות הגישה.\n4.  **הרכבת הכתובת הפיזית:** מספר המסגרת הפיזית (PFN) שהתקבל מה-PTE האחרון, יחד עם ההיסט בתוך הדף (Page Offset) מתוך הכתובת הווירטואלית המקורית, מרכיבים את הכתובת הפיזית הסופית.\n\n**מספר גישות לזיכרון הראשי ול-TLB במקרה הגרוע ביותר (Cache/TLB Miss):**\n*   **גישות ל-TLB:** 2 (אחת עבור מיפוי דף ה-SDT, ואחת עבור מיפוי דף הנתונים הסופי). כל גישה ל-TLB מניחה החטאה.\n*   **גישות לזיכרון הראשי:**\n    *   1 גישה ל-SDT כדי לקרוא את ה-SDE.\n    *   N גישות לטבלאות הדפים (אחת לכל רמה), כאשר N הוא מספר רמות טבלאות הדפים (6, כפי שיחושב בסעיף 1.2.א).\n    *   1 גישה עבור הנתון עצמו לאחר תרגום הכתובת.\n    *   **סה\"כ:** 1 (SDE) + 6 (PTEs) + 1 (נתון) = 8 גישות לזיכרון הראשי.\n\n**1.2 חישובים:**\n*   **גודל דף:** 4KB = 2^12 בתים.\n*   **מספר כניסות בדף:**\n    *   עבור SDEs: גודל דף / גודל SDE = 4096 / 16 = 256 כניסות.\n    *   עבור PTEs: גודל דף / גודל PTE = 4096 / 8 = 512 כניסות.\n*   **היסט בתוך הדף (Offset):** 12 ביטים.\n\n**א. כמה רמות של טבלאות דפים נדרשות עבור כל סגמנט?**\n*   מרחב כתובות וירטואלי 64 ביט. ההיסט בתוך הדף הוא 12 ביטים.\n*   לכן, מספר הביטים עבור ה-VPN (Virtual Page Number) הוא 64 - 12 = 52 ביטים.\n*   כל רמה של טבלת דפים יכולה למפות 512 כניסות, כלומר 2^9 דפים.\n*   לכן, כל רמה 'בולעת' 9 ביטים ממספר ה-VPN.\n*   מספר הרמות הנדרשות: ceil(52 ביטים / 9 ביטים לרמה) = ceil(5.77) = 6 רמות.\n*   **תשובה:** 6 רמות של טבלאות דפים.\n\n**ב. מהו המספר המקסימלי של סגמנטים שתהליך יכול להכיל?**\n*   טבלת מתארי הסגמנטים (SDT) מאוחסנת בדף אחד בדיוק.\n*   כל דף יכול להכיל 256 כניסות SDE.\n*   לכן, תהליך יכול להכיל מקסימום 256 סגמנטים.\n*   **תשובה:** 256 סגמנטים.\n\n**ג. מהו הגודל המקסימלי של סגמנט בבתים?**\n*   מספר ביטים עבור ה-VPN בתוך סגמנט הוא 52 ביטים (64 ביט וירטואלי - 12 ביט היסט).\n*   הגודל המקסימלי של סגמנט נקבע על ידי מרחב הכתובות הווירטואלי שניתן למפות. מאחר שה-VPN הוא 52 ביטים, ניתן למפות 2^52 דפים.\n*   גודל מקסימלי של סגמנט = מספר דפים * גודל דף = 2^52 * 2^12 = 2^64 בתים.\n*   **תשובה:** הגודל המקסימלי של סגמנט הוא 2^64 בתים (כל מרחב הכתובות הווירטואלי).\n\n**1.3 יתרונות וחסרונות בהשוואה למודלים אחרים:**\n\n**יתרונות:**\n1.  **הגנה מוגברת וגמישות:**\n    *   **הגנה:** סגמנטציה מאפשרת הגנה ברמת יחידות לוגיות (קוד, נתונים, מחסנית), כאשר כל סגמנט יכול לקבל הרשאות גישה שונות (קריאה, כתיבה, הרצה). בנוסף, ניתן להגדיר גודל מקסימלי לכל סגמנט.\n    *   **שיתוף קל יותר:** סגמנטים מאפשרים שיתוף קל יותר של אזורי זיכרון בין תהליכים, למשל, סגמנט קוד משותף. כל תהליך יכול למפות את אותו סגמנט לתוך מרחב הכתובות שלו עם טבלת דפים משלו (או משותפת), מה שמפשט את הניהול.\n    *   **ניהול זיכרון לוגי:** המפתחים יכולים לחשוב על הזיכרון כיחידות לוגיות משמעותיות, במקום רצף ליניארי של דפים.\n2.  **טיפול בפירבור (Fragmentation):**\n    *   **פירבור חיצוני:** הדפדוף מטפל ביעילות בפירבור חיצוני. סגמנטים לא צריכים להיות רציפים בזיכרון הפיזי, וגם הדפים בתוך סגמנט לא צריכים להיות רציפים.\n    *   **פירבור פנימי:** נשאר פירבור פנימי ברמת הדף האחרון של כל סגמנט.\n\n**חסרונות:**\n1.  **מורכבות מימוש גבוהה:**\n    *   המערכת דורשת ניהול של שתי רמות של טבלאות: טבלת מתארי סגמנטים (SDT) וטבלאות דפים רב-שכבתיות לכל סגמנט. זה מגדיל את מורכבות מערכת ההפעלה הן במימוש והן בתחזוקה.\n    *   תהליך תרגום הכתובת ארוך ומורכב יותר (ראו סעיף 1.1), ודורש יותר גישות לזיכרון הראשי.\n2.  **עלויות ביצועים (Performance Overhead):**\n    *   **זמן גישה לזיכרון:** כל גישה לכתובת וירטואלית דורשת מספר רב של גישות לזיכרון הראשי (SDT + N רמות של טבלאות דפים). זהו חיסרון משמעותי בהשוואה לדפדוף בלבד, שבו נדרשות N גישות בלבד, או סגמנטציה בלבד (שבה נדרשת גישה אחת לטבלת הסגמנטים). גם עם TLB, מספר ההחטאות ל-TLB עלול להיות גבוה יותר, והעלות של כל החטאה יקרה יותר.\n    *   **TLB:** ה-TLB חייב להיות גדול ומורכב יותר כדי לטפל גם במיפויי סגמנטים וגם במיפויי דפים, או שיהיו שני TLBs נפרדים. החטאות ב-TLB יהיו יקרות יותר בגלל המספר הרב של גישות לזיכרון הראשי הנדרשות כדי לטעון מיפוי חדש.\n3.  **ניצול זיכרון (Memory Overhead):**\n    *   **טבלאות:** ישנה עלות זיכרון משמעותית עבור טבלאות הדפים וה-SDT. לכל סגמנט יש היררכיית טבלאות דפים משלו, מה שיכול לצרוך כמות גדולה של זיכרון, במיוחד אם יש הרבה סגמנטים קטנים או סגמנטים עם מרחב כתובות דליל. אמנם כל טבלה מאוחסנת בדף אחד, אך מספר הטבלאות הכולל יכול להיות גדול.\n    *   **פירבור פנימי:** עדיין קיים פירבור פנימי בדפים האחרונים של כל סגמנט.\n\n**בהשוואה למודלים אחרים:**\n*   **דפדוף בלבד (Pure Paging):** פשוט יותר למימוש, תרגום כתובת מהיר יותר (פחות גישות לזיכרון אם אין סגמנטים), וניצול זיכרון טוב יותר עבור טבלאות (לרוב טבלת דפים אחת לכל תהליך). החיסרון הוא שאין תמיכה מובנית במבנה לוגי של התוכנית (סגמנטים) ופחות גמישות בהגנה ובשיתוף יחידות לוגיות.\n*   **סגמנטציה בלבד (Pure Segmentation):** תומך במבנה לוגי ובהגנה ברמת סגמנטים, אך סובל מפירבור חיצוני (External Fragmentation) ודורש אלגוריתמי הקצאת זיכרון מורכבים יותר עבור הסגמנטים. תרגום כתובת מהיר יותר (גישה אחת לטבלת סגמנטים).\n\n**לסיכום:** מודל Segmented Paging מציע שילוב של יתרונות משני המודלים (הגנה לוגית וטיפול בפירבור חיצוני), אך מגיע עם עלות משמעותית במורכבות המימוש, במספר גישות הזיכרון הנדרשות לתרגום כתובת, ובצריכת זיכרון עבור מבני הנתונים. הוא מתאים למערכות שבהן דרישות הגנה וארגון לוגי הן קריטיות, ומוכנות לשלם מחיר בביצועים ובמורכבות."
    },
    "difficulty_estimation": "Hard"
  }
}