{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 20:20:29",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2951,
      "output_tokens": 1352,
      "total_tokens": 8799
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Threads",
      "Mutexes",
      "Concurrency",
      "Race Condition"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה, המשתמשת בשני תהליכונים (threads) כדי לעדכן מונה משותף:\n\nמהו טווח הערכים האפשריים עבור המשתנה הגלובלי `shared_counter` בסיום ריצת התוכנית? נמקו את תשובתכם.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h> // For usleep\n\nint shared_counter = 0;\npthread_mutex_t counter_mutex;\n\nvoid* thread_func(void* arg) {\n    int iterations = *((int*)arg);\n    \n    for (int i = 0; i < iterations; ++i) {\n        usleep(10); // מדמה עבודה כלשהי\n\n        if (i % 2 == 0) { // תנאי המגן על המונה רק בחלק מהאיטרציות\n            pthread_mutex_lock(&counter_mutex);\n            shared_counter++;\n            pthread_mutex_unlock(&counter_mutex);\n        } else {\n            shared_counter++; // כאן עלול להתרחש מצב מרוץ (race condition)\n        }\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2;\n    int iterations = 10000; \n\n    pthread_mutex_init(&counter_mutex, NULL);\n\n    pthread_create(&tid1, NULL, thread_func, &iterations);\n    pthread_create(&tid2, NULL, thread_func, &iterations);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    pthread_mutex_destroy(&counter_mutex);\n\n    printf(\"Final counter value: %d\\n\", shared_counter);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הערך הצפוי של המונה בסיום ריצה ללא תקלות במקרה של שני תהליכונים המבצעים כל אחד 10,000 איטרציות הוא 2 * 10,000 = 20,000.\n\nעם זאת, בתוכנית זו קיים מצב מרוץ (race condition). נשים לב שבתוך הלולאה, המונה `shared_counter` מוגן על ידי מנעול (mutex) רק כאשר `i` הוא מספר זוגי. כאשר `i` הוא מספר אי-זוגי, הפעולה `shared_counter++` מתבצעת ללא הגנה.\n\nכל תהליכון מבצע 10,000 איטרציות. מתוכן:\n*   כ-5,000 איטרציות (כאשר `i` זוגי) מוגנות על ידי המנעול. סך הכל 10,000 העלאות מוגנות על ידי שני התהליכונים.\n*   כ-5,000 איטרציות (כאשר `i` אי-זוגי) אינן מוגנות. סך הכל 10,000 העלאות לא מוגנות על ידי שני התהליכונים.\n\nהעלאות המוגנות תמיד יתבצעו כהלכה ויוסיפו בדיוק 10,000 למונה.\n\nהעלאות הלא מוגנות חשופות למצב מרוץ. כאשר שני תהליכונים מנסים לעדכן את `shared_counter` בו-זמנית ללא מנעול, ייתכן מצב שבו שניהם קוראים את אותו ערך, שניהם מגדילים אותו ב-1, ושניהם כותבים את הערך החדש (הזהה), וכך למעשה רק העלאה אחת נרשמת במקום שתיים (Lost Update). \n\n*   **הערך המקסימלי האפשרי:** 20,000. זה יקרה אם, במקרה, כל 10,000 ההעלאות הלא מוגנות יתבצעו באופן סדרתי או ללא התנגשות, כך שאף אחת מהן לא תאבד. מצב כזה הוא בלתי סביר בריצה אמתית אך תיאורטית אפשרי לחלוטין.\n*   **הערך המינימלי האפשרי:** 15,000. זה יקרה במצב הגרוע ביותר עבור ההעלאות הלא מוגנות, שבו כל זוג של העלאות לא מוגנות המתנגשות ביניהן יגרום לאיבוד של העלאה אחת, כך שרק כ-5,000 מתוך 10,000 ההעלאות הלא מוגנות יצליחו בפועל (בממוצע, בערך מחצית מהן). לכן, 10,000 (ממוגנות) + 5,000 (לא ממוגנות) = 15,000.\n\nלסיכום, טווח הערכים האפשריים עבור `shared_counter` הוא **[15,000, 20,000]**."
    },
    "difficulty_estimation": "Medium"
  }
}