{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Race Conditions",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 01:09:43",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2154,
      "output_tokens": 1979,
      "total_tokens": 5984
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Race Conditions",
      "Synchronization"
    ],
    "content": {
      "text": "נתון קטע קוד בשפת C המדמה מצב בו מספר תהליכונים (threads) מעדכנים מונה גלובלי משותף. קטע הקוד מיועד להדגים בעיה נפוצה במערכות הפעלה מרובות תהליכונים.\n\nעיין בקטע הקוד הבא וענה על השאלות:\n1. מהי הבעיה המרכזית בקטע הקוד הזה בהקשר של מערכות מרובות תהליכונים?\n2. הסבר מדוע הבעיה מתרחשת וכיצד היא יכולה להשפיע על התוצאה הסופית של המונה.\n3. הצג פתרון מתוקן לקטע הקוד באמצעות מנגנון סנכרון מתאים (כמו מיוטקס), והסבר כיצד הפתרון המוצע מונע את הבעיה.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n\n#define NUM_THREADS 5\n#define INCREMENTS_PER_THREAD 100000\n\nlong long global_counter = 0;\n\nvoid* increment_counter(void* arg) {\n    for (int i = 0; i < INCREMENTS_PER_THREAD; ++i) {\n        global_counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    printf(\"Initial counter value: %lld\\n\", global_counter);\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        if (pthread_create(&threads[i], NULL, increment_counter, NULL) != 0) {\n            perror(\"Failed to create thread\");\n            return 1;\n        }\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        if (pthread_join(threads[i], NULL) != 0) {\n            perror(\"Failed to join thread\");\n            return 1;\n        }\n    }\n\n    printf(\"Final counter value: %lld\\n\", global_counter);\n    printf(\"Expected counter value: %lld\\n\", (long long)NUM_THREADS * INCREMENTS_PER_THREAD);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. הבעיה המרכזית בקטע הקוד היא **תנאי מירוץ (Race Condition)**. מספר תהליכונים מנסים לגשת ולשנות משאב משותף (המונה הגלובלי `global_counter`) בו-זמנית ללא מנגנון סנכרון מתאים.\n\n2. הבעיה מתרחשת מכיוון שהפעולה `global_counter++` אינה פעולה אטומית (atomic). היא מורכבת למעשה משלוש פעולות ברמת המעבד:\n   א. קריאת הערך הנוכחי של `global_counter` לתוך אוגר.\n   ב. הגדלת הערך באוגר באחד.\n   ג. כתיבת הערך החדש מהאוגר בחזרה לזיכרון בכתובת של `global_counter`.\n   \n   כאשר מספר תהליכונים מבצעים את הפעולות הללו במקביל, סדר הפעולות יכול להשתבש. לדוגמה, תהליכון A ותהליכון B יכולים שניהם לקרוא את אותו ערך של `global_counter` (למשל 100). שניהם יגדילו את הערך באוגרים שלהם ל-101. ואז, שניהם יכתבו בחזרה את הערך 101 ל-`global_counter`. במקרה כזה, אף על פי שבוצעו שתי פעולות הגדלה, המונה גדל בפועל רק באחד. כתוצאה מכך, הערך הסופי של `global_counter` יהיה נמוך מהערך הצפוי (`NUM_THREADS * INCREMENTS_PER_THREAD`).\n\n3. כדי לפתור את בעיית תנאי המירוץ, יש להגן על הקטע הקריטי (הפעולה `global_counter++`) באמצעות מנגנון סנכרון. פתרון נפוץ הוא שימוש ב**מיוטקס (Mutex)**. מיוטקס מבטיח שרק תהליכון אחד יוכל להיכנס לקטע הקריטי בכל רגע נתון.\n\n**פתרון מתוקן:**\n```c\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n\n#define NUM_THREADS 5\n#define INCREMENTS_PER_THREAD 100000\n\nlong long global_counter = 0;\npthread_mutex_t counter_mutex; // הצהרה על מיוטקס\n\nvoid* increment_counter(void* arg) {\n    for (int i = 0; i < INCREMENTS_PER_THREAD; ++i) {\n        pthread_mutex_lock(&counter_mutex);   // נעל את המיוטקס לפני הכניסה לקטע הקריטי\n        global_counter++;\n        pthread_mutex_unlock(&counter_mutex); // שחרר את המיוטקס לאחר היציאה מהקטע הקריטי\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    // אתחל את המיוטקס\n    if (pthread_mutex_init(&counter_mutex, NULL) != 0) {\n        perror(\"Failed to initialize mutex\");\n        return 1;\n    }\n\n    printf(\"Initial counter value: %lld\\n\", global_counter);\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        if (pthread_create(&threads[i], NULL, increment_counter, NULL) != 0) {\n            perror(\"Failed to create thread\");\n            return 1;\n        }\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        if (pthread_join(threads[i], NULL) != 0) {\n            perror(\"Failed to join thread\");\n            return 1;\n        }\n    }\n\n    printf(\"Final counter value: %lld\\n\", global_counter);\n    printf(\"Expected counter value: %lld\\n\", (long long)NUM_THREADS * INCREMENTS_PER_THREAD);\n\n    // הרס את המיוטקס\n    pthread_mutex_destroy(&counter_mutex);\n\n    return 0;\n}\n```\n\n**הסבר הפתרון:**\nהפתרון המתוקן מציג משתנה `pthread_mutex_t counter_mutex` שהוא מיוטקס. לפני שכל תהליכון ניגש לבצע את הפעולה `global_counter++`, הוא קורא לפונקציה `pthread_mutex_lock(&counter_mutex)`. פונקציה זו מנסה לנעול את המיוטקס. אם המיוטקס כבר נעול על ידי תהליכון אחר, התהליכון הנוכחי ימתין עד שהמיוטקס ישוחרר. לאחר שהתהליכון סיים את הפעולה בקטע הקריטי (הגדלת המונה), הוא קורא לפונקציה `pthread_mutex_unlock(&counter_mutex)` כדי לשחרר את המיוטקס ולאפשר לתהליכונים אחרים לגשת לקטע הקריטי. באופן זה, מובטח שבכל רגע נתון רק תהליכון אחד יבצע את פעולת ההגדלה של המונה, ובכך נמנעים תנאי המירוץ ומובטחת תוצאה נכונה של המונה."
    },
    "difficulty_estimation": "Medium"
  }
}