{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 21:14:19",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 6065,
      "total_tokens": 17829
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Process Management"
    ],
    "content": {
      "text": "נתונה מערכת בה תהליך אב (Parent) מפעיל N תהליכי בן (Child). כל תהליך בן אחראי לייצר K מספרים שלמים אקראיים (random integers) ולשלוח אותם לתהליך האב באמצעות צינור (pipe). תהליך האב צריך לקבל את כל המספרים מכל הבנים ולחשב את סכומם הכולל. בנוסף, תהליך האב צריך להיות מסוגל לסיים את כל תהליכי הבן באופן יזום וגרייספולי (gracefully) בכל עת, למשל כאשר הוא מקבל אות `SIGINT` (לחיצה על Ctrl+C). תהליכי הבן, מצידם, צריכים לטפל באות `SIGTERM` (שיישלח אליהם מהאב) או `SIGINT` (במקרה שהאב נהרג לפני שהספיק לשלוח `SIGTERM`), ולבצע ניקוי משאבים מתאים (למשל, סגירת קצוות הצינור) לפני יציאתם.\n\n**דרישות:**\n1.  **תכנון IPC וטיפול באותות:** תארו את תכנון מנגנון ה-IPC (סוג הצינור, כמה צינורות) ואת אופן הטיפול באותות `SIGINT` ו-`SIGCHLD` בתהליך האב, ו-`SIGINT` ו-`SIGTERM` בתהליכי הבן. נמקו את הבחירות שלכם.\n2.  **מימוש קוד:** כתבו קוד C/C++ מלא המדגים את המערכת המתוארת. הקוד צריך לכלול את תהליך האב ותהליך הבן, תוך שימוש במנגנוני ה-IPC והאותות שתכננתם. יש להשתמש ב-`sigaction` לטיפול באותות.\n3.  **ניתוח בעיות ופתרונות:** זהו ונתחו לפחות שלוש בעיות פוטנציאליות (למשל, Race Conditions, Deadlock, Zombie Processes, או בעיות עם `EINTR` ו-Reentrancy של Signal Handlers) שעלולות להתעורר בתכנון כזה, והסבירו כיצד הקוד שלכם מתמודד איתן או כיצד ניתן למנוע אותן.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <errno.h>\n\n#define NUM_CHILDREN 3\n#define NUM_INTEGERS_PER_CHILD 5\n\n// Global variables for signal handling (parent)\nvolatile sig_atomic_t parent_sigint_received = 0;\nvolatile sig_atomic_t children_reaped_count = 0;\nPid_t *child_pids = NULL; // To store PIDs of children\n\n// Global variable for signal handling (child)\nvolatile sig_atomic_t child_signal_received = 0;\n\nvoid parent_sigint_handler(int signum) {\n    parent_sigint_received = 1;\n}\n\nvoid parent_sigchld_handler(int signum) {\n    int status;\n    pid_t pid;\n    // Reap all terminated children\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        children_reaped_count++;\n        // In a more complex scenario, you might also remove pid from child_pids array here\n    }\n}\n\nvoid child_signal_handler(int signum) {\n    child_signal_received = 1;\n}\n\nint main() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    child_pids = (pid_t *)malloc(NUM_CHILDREN * sizeof(pid_t));\n    if (child_pids == NULL) {\n        perror(\"malloc\");\n        close(pipefd[0]);\n        close(pipefd[1]);\n        exit(EXIT_FAILURE);\n    }\n\n    // Set up signal handlers for parent\n    struct sigaction sa_int_parent, sa_chld_parent;\n\n    sa_int_parent.sa_handler = parent_sigint_handler;\n    sigemptyset(&sa_int_parent.sa_mask);\n    sa_int_parent.sa_flags = SA_RESTART; // Restart interrupted system calls\n    if (sigaction(SIGINT, &sa_int_parent, NULL) == -1) {\n        perror(\"sigaction SIGINT parent\");\n        free(child_pids);\n        close(pipefd[0]);\n        close(pipefd[1]);\n        exit(EXIT_FAILURE);\n    }\n\n    sa_chld_parent.sa_handler = parent_sigchld_handler;\n    sigemptyset(&sa_chld_parent.sa_mask);\n    sa_chld_parent.sa_flags = SA_RESTART | SA_NOCLDSTOP; // SA_NOCLDSTOP prevents signal on child stop\n    if (sigaction(SIGCHLD, &sa_chld_parent, NULL) == -1) {\n        perror(\"sigaction SIGCHLD parent\");\n        free(child_pids);\n        close(pipefd[0]);\n        close(pipefd[1]);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Parent (PID %d): Starting %d children.\\n\", getpid(), NUM_CHILDREN);\n\n    for (int i = 0; i < NUM_CHILDREN; i++) {\n        pid_t pid = fork();\n        if (pid == -1) {\n            perror(\"fork\");\n            // Attempt to terminate previously forked children before exiting\n            for (int j = 0; j < i; j++) {\n                kill(child_pids[j], SIGTERM);\n            }\n            free(child_pids);\n            close(pipefd[0]);\n            close(pipefd[1]);\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) {\n            // Child process\n            srand(getpid() * time(NULL)); // Seed random number generator\n            close(pipefd[0]); // Child closes read end of pipe\n\n            // Set up signal handlers for child\n            struct sigaction sa_child;\n            sa_child.sa_handler = child_signal_handler;\n            sigemptyset(&sa_child.sa_mask);\n            sa_child.sa_flags = SA_RESTART;\n            if (sigaction(SIGINT, &sa_child, NULL) == -1 || sigaction(SIGTERM, &sa_child, NULL) == -1) {\n                perror(\"sigaction child\");\n                close(pipefd[1]);\n                exit(EXIT_FAILURE);\n            }\n\n            printf(\"Child (PID %d): Started.\\n\", getpid());\n            for (int j = 0; j < NUM_INTEGERS_PER_CHILD; j++) {\n                if (child_signal_received) {\n                    printf(\"Child (PID %d): Signal received, exiting gracefully.\\n\", getpid());\n                    break;\n                }\n                int num = rand() % 100;\n                printf(\"Child (PID %d): Sending %d\\n\", getpid(), num);\n                // Write integer to pipe\n                ssize_t bytes_written = write(pipefd[1], &num, sizeof(int));\n                if (bytes_written == -1) {\n                    if (errno == EINTR) {\n                        // Interrupted by signal, re-check flag\n                        if (child_signal_received) {\n                            printf(\"Child (PID %d): Write interrupted by signal, exiting.\\n\", getpid());\n                            break;\n                        }\n                        // Otherwise, retry write or handle error differently\n                        j--; // Retry current write\n                        continue;\n                    } else if (errno == EPIPE) {\n                        printf(\"Child (PID %d): Parent pipe closed, exiting.\\n\", getpid());\n                        break;\n                    } else {\n                        perror(\"child write\");\n                        break;\n                    }\n                } else if (bytes_written != sizeof(int)) {\n                    fprintf(stderr, \"Child (PID %d): Partial write detected!\\n\", getpid());\n                    break;\n                }\n                sleep(1); // Simulate work\n            }\n            close(pipefd[1]); // Child closes write end of pipe\n            printf(\"Child (PID %d): Exited.\\n\", getpid());\n            exit(EXIT_SUCCESS);\n        } else {\n            // Parent process\n            child_pids[i] = pid;\n        }\n    }\n\n    close(pipefd[1]); // Parent closes write end of pipe\n\n    int total_sum = 0;\n    int received_num;\n    ssize_t bytes_read;\n\n    printf(\"Parent (PID %d): Waiting for data and children...\\n\", getpid());\n\n    while (children_reaped_count < NUM_CHILDREN) {\n        if (parent_sigint_received) {\n            printf(\"Parent (PID %d): SIGINT received. Terminating children.\\n\", getpid());\n            for (int i = 0; i < NUM_CHILDREN; i++) {\n                if (child_pids[i] != 0) { // 0 could indicate child already reaped or not forked (not the case here)\n                    kill(child_pids[i], SIGTERM);\n                    printf(\"Parent (PID %d): Sent SIGTERM to child %d.\\n\", getpid(), child_pids[i]);\n                }\n            }\n            // Now wait for them to actually exit and be reaped by SIGCHLD handler\n            break; // Exit the loop and go to final wait\n        }\n\n        bytes_read = read(pipefd[0], &received_num, sizeof(int));\n        if (bytes_read == -1) {\n            if (errno == EINTR) {\n                // Read interrupted by signal, continue loop to re-check sigint_received flag\n                continue;\n            } else {\n                perror(\"parent read\");\n                break;\n            }\n        } else if (bytes_read == 0) {\n            // End of file (all write ends closed)\n            printf(\"Parent (PID %d): End of pipe. All children finished writing or terminated.\\n\", getpid());\n            break;\n        } else {\n            total_sum += received_num;\n            printf(\"Parent (PID %d): Received %d. Current sum: %d\\n\", getpid(), received_num, total_sum);\n        }\n    }\n\n    // Final wait for any remaining children if SIGINT was received or loop broke prematurely\n    while (children_reaped_count < NUM_CHILDREN) {\n        printf(\"Parent (PID %d): Waiting for remaining children to terminate... (reaped: %d/%d)\\n\", getpid(), children_reaped_count, NUM_CHILDREN);\n        sleep(1); // Give children time to process SIGTERM and exit\n        // The SIGCHLD handler will increment children_reaped_count\n    }\n\n    close(pipefd[0]); // Parent closes read end of pipe\n    free(child_pids);\n\n    printf(\"Parent (PID %d): All children reaped. Final sum: %d\\n\", getpid(), total_sum);\n    printf(\"Parent (PID %d): Exited.\\n\", getpid());\n\n    return 0;\n}\n"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### ניתוח ופתרון:\n\n#### 1. תכנון מנגנון IPC (צינורות) וטיפול באותות:\n*   **בחירת IPC:** נשתמש בצינור אנונימי (unnamed pipe) יחיד. זהו מנגנון פשוט ויעיל לתקשורת חד-כיוונית בין תהליכים בעלי יחסי אב-בן. כל תהליכי הבן יכתבו לצינור, ותהליך האב יקרא ממנו.\n*   **הקמה וסגירת צינורות:**\n    *   האב ייצור את הצינור באמצעות `pipe()` לפני יצירת הבנים.\n    *   לאחר ה-`fork`, כל בן יקבל עותקים של קצוות הצינור.\n    *   **באב:** יש לסגור את קצה הכתיבה (`pipefd[1]`) מיד לאחר יצירת הבנים, שכן האב רק קורא מהצינור. קצה זה נשאר פתוח רק אצל הבנים.\n    *   **בבן:** יש לסגור את קצה הקריאה (`pipefd[0]`) מיד לאחר ה-`fork`, שכן הבן רק כותב לצינור.\n    *   **בסיום:** כל תהליך צריך לסגור את הקצה שנותר אצלו כאשר הוא מסיים את השימוש בו. האב יסגור את קצה הקריאה (`pipefd[0]`) רק לאחר שקיבל את כל הנתונים (או הופסק). הבנים יסגרו את קצה הכתיבה (`pipefd[1]`) לפני יציאתם. סגירת כל קצוות הכתיבה היא קריטית כדי שהאב יקבל `EOF` (End-of-File) וידע שאין יותר נתונים לקרוא.\n\n*   **טיפול באותות בתהליך האב:**\n    *   **`SIGINT` (Ctrl+C):** כאשר האב מקבל `SIGINT`, הוא צריך להפסיק את פעילותו ולסיים את כל תהליכי הבן בגרייספוליות. לשם כך:\n        1.  **הגדרת Handler:** נגדיר `parent_sigint_handler` שיגדיר דגל גלובלי (מסוג `volatile sig_atomic_t`) ל-1. שימוש ב-`volatile sig_atomic_t` הכרחי כדי להבטיח שהדגל נגיש ומתעדכן באופן אטומי ובטוח מתוך ה-signal handler, ושהקומפיילר לא יבצע אופטימיזציות שימנעו מהלולאה הראשית לראות את השינוי.\n        2.  **לולאה ראשית:** הלולאה הראשית של האב, שקוראת מהצינור, תבדוק את הדגל `parent_sigint_received`. כאשר הדגל מוגדר, האב יצא מלולאת הקריאה, ישלח `SIGTERM` לכל תהליכי הבן שנוצרו (תוך שימוש ברשימת ה-PIDs שלהם), וימשיך להמתין ליציאתם.\n        3.  **מדוע לא לשלוח `kill` מתוך ה-handler?** פונקציית `kill()` אינה `async-signal-safe`, ולכן אסור לקרוא לה ישירות מתוך ה-signal handler. שימוש בדגל גלובלי הוא הדרך הנכונה והבטוחה.\n    *   **`SIGCHLD`:** אות זה נשלח לאב כאשר תהליך בן משנה סטטוס (מסיים, מושהה וכו').\n        1.  **הגדרת Handler:** נגדיר `parent_sigchld_handler` שיקרא `waitpid(-1, &status, WNOHANG)` בלולאה. `WNOHANG` מבטיח שה-`waitpid` לא יחסום אם אין בנים שסיימו, והלולאה תטפל בכל הבנים שסיימו. זה מונע מצבי זומבי (zombie processes) ומאפשר לאב לדעת כמה בנים עדיין פעילים.\n        2.  **מעקב:** נשתמש במונה גלובלי (`children_reaped_count`) כדי לעקוב אחר מספר הבנים שסיימו.\n\n*   **טיפול באותות בתהליכי הבן:**\n    *   **`SIGINT` / `SIGTERM`:** הבנים צריכים לטפל בשני האותות באותה צורה, שכן שניהם מצביעים על בקשת סיום. `SIGTERM` יישלח על ידי האב, ו-`SIGINT` יכול להגיע אם המשתמש לוחץ Ctrl+C והאב לא הספיק לטפל או אם האב עצמו קרס.\n        1.  **הגדרת Handler:** נגדיר `child_signal_handler` שיגדיר דגל גלובלי (מסוג `volatile sig_atomic_t`) ל-1.\n        2.  **לולאה ראשית:** הלולאה הראשית של הבן, שיוצרת מספרים וכותבת לצינור, תבדוק את הדגל `child_signal_received`. כאשר הדגל מוגדר, הבן יסגור את קצה הכתיבה של הצינור ויצא (`exit`) בגרייספוליות.\n\n#### 2. מימוש קוד:\nהקוד המלא מסופק בסעיף `code_snippet` לעיל. הוא מדגים את העקרונות שתוארו וכולל:\n*   יצירת צינור (`pipe`).\n*   הגדרת `sigaction` עבור `SIGINT` ו-`SIGCHLD` באב, ועבור `SIGINT`/`SIGTERM` בבנים. דגל `SA_RESTART` משמש לנסות להפעיל מחדש קריאות מערכת שנקטעו על ידי אות.\n*   לולאת `fork` ליצירת בנים ואיסוף ה-PIDs שלהם במערך `child_pids`.\n*   סגירת קצוות צינור מיותרים באב ובבן מיד לאחר ה-`fork`.\n*   לולאה באב לקריאת נתונים מהצינור וחישוב סכום כולל, תוך בדיקה מתמדת של הדגל `parent_sigint_received`.\n*   לולאה בבן ליצירת מספרים אקראיים וכתיבה לצינור, תוך בדיקה מתמדת של הדגל `child_signal_received`.\n*   טיפול ב-`EINTR` (קריאת מערכת שנקטעה על ידי אות) בקריאה/כתיבה לצינור.\n*   המתנה סופית של האב לכל הבנים באמצעות המונה `children_reaped_count` המתעדכן ב-`SIGCHLD` handler, כדי להבטיח שכל הבנים נאספים.\n*   שחרור זיכרון שהוקצה דינמית (`free(child_pids)`).\n\n#### 3. ניתוח בעיות פוטנציאליות ודרכי התמודדות:\n\n*   **1. Race Condition ב-`SIGINT` באב במהלך יצירת בנים:**\n    *   **הבעיה:** אם אות `SIGINT` מגיע לאב בזמן שהוא עדיין יוצר בנים (בלולאת ה-`fork`), רשימת ה-PIDs של הבנים (`child_pids`) לא תהיה מלאה. כתוצאה מכך, כאשר האב מנסה לשלוח `SIGTERM` לכל הבנים, חלק מהבנים שטרם נוצרו או ש-PID שלהם טרם נשמר במערך, לא יקבלו את האות ולא יסיימו באופן גרייספולי.\n    *   **התמודדות בקוד:** הקוד הנוכחי מתמודד עם זה חלקית: גם אם `SIGINT` מגיע מוקדם, האב עדיין ממשיך ללולאת ההמתנה הסופית (`while (children_reaped_count < NUM_CHILDREN)`). ה-`SIGCHLD` handler יאסוף את הבנים שכן נוצרו וסיימו. עם זאת, הבנים שלא קיבלו `SIGTERM` (כי האב לא ידע עליהם) ימשיכו לרוץ עד שיסיימו את עבודתם או יקבלו `SIGINT` ישירות מהטרמינל.\n    *   **פתרון חזק יותר:** ניתן לחסום את `SIGINT` באב באמצעות `sigprocmask` במהלך לולאת ה-`fork`, ולשחרר אותו רק לאחר שכל הבנים נוצרו ו-PIDs שלהם נשמרו במערך. זה מבטיח שכל הבנים ייכללו ברשימת ה-PIDs לפני שהאב יכול לקבל `SIGINT` ולפעול לסיומם.\n\n*   **2. קריאות מערכת שנקטעו על ידי אות (`EINTR`) ו-Reentrancy של Signal Handlers:**\n    *   **הבעיה:** קריאות מערכת חוסמות כמו `read()` ו-`write()` יכולות להיקטע על ידי אות לפני שהן מסיימות את פעולתן. במקרה כזה, הפונקציה מחזירה -1 ו-`errno` מוגדר ל-`EINTR`. אם לא מטפלים בכך, הקריאה תיכשל והתהליך עלול לצאת בטרם עת או להיכנס למצב לא יציב. בנוסף, פונקציות בתוך signal handler חייבות להיות `async-signal-safe` (כלומר, כאלה שניתן לקרוא להן בבטחה מכל נקודה בתוכנית). `printf()`, `malloc()`, `kill()` ועוד רבות אינן כאלה.\n    *   **התמודדות בקוד:**\n        *   **`EINTR`:** ה-`sigaction` הוגדר עם דגל `SA_RESTART` שינסה להפעיל מחדש קריאות מערכת רבות באופן אוטומטי. למרות זאת, הקוד כולל בדיקה מפורשת ל-`EINTR` בלולאות הקריאה והכתיבה. במקרה של `EINTR`, הקוד בודק את דגל האות הגלובלי (אם הגיע אות סיום) כדי להחליט אם לצאת בגרייספוליות או לנסות שוב את פעולת הקריאה/כתיבה.\n        *   **Reentrancy:** ה-signal handlers בקוד (גם באב וגם בבנים) רק מגדירים דגל `volatile sig_atomic_t`. הלוגיקה המורכבת יותר (כמו שליחת `SIGTERM` או סגירת קצוות צינור) מתבצעת בלולאה הראשית של התהליך, מחוץ ל-handler, לאחר בדיקת הדגל. גישה זו מבטיחה שה-handlers בטוחים לשימוש (async-signal-safe).\n\n*   **3. Zombie Processes ו-Deadlock בצינור:**\n    *   **הבעיה:**\n        *   **Zombie Processes:** בנים שמסיימים את פעולתם אך לא נאספים על ידי האב (באמצעות `wait()` או `waitpid()`) הופכים לתהליכי זומבי וצורכים משאבי מערכת (כמו ערכי PID, זיכרון בטבלת התהליכים).\n        *   **Deadlock בצינור:** אם האב לא יסגור את קצה הכתיבה (`pipefd[1]`) שלו, הוא לעולם לא יקבל `EOF` מהצינור כאשר הבנים יסיימו. במצב כזה, קריאת ה-`read()` שלו עשויה לחסום באופן אינסופי אם הבנים סיימו מוקדם או אם האב מנסה לקרוא לאחר שכל הבנים סגרו את קצוות הכתיבה שלהם.\n    *   **התמודדות בקוד:**\n        *   **Zombie Processes:** ה-`SIGCHLD` handler באב מטפל בבעיה זו באופן מלא. הוא קורא ל-`waitpid(-1, &status, WNOHANG)` בלולאה, ובכך אוסף את כל הבנים שסיימו את פעולתם באופן מיידי ומונע יצירת זומבים. המונה `children_reaped_count` מאפשר לאב לעקוב אחר מספר הבנים שנותרו.\n        *   **Deadlock בצינור:** הקוד מבטיח שהאב סוגר את קצה הכתיבה של הצינור (`pipefd[1]`) מיד לאחר יצירת הבנים, מכיוון שהאב אינו כותב. הבנים סוגרים את קצה הקריאה (`pipefd[0]`) מיד לאחר ה-`fork` ואת קצה הכתיבה (`pipefd[1]`) לפני היציאה. סגירה נכונה של כל קצוות הכתיבה מבטיחה שהאב יקבל `EOF` כאשר כל הבנים סיימו (או נהרגו) וסגרו את קצוות הכתיבה שלהם, ובכך מונעת חסימה אינסופית."
    },
    "difficulty_estimation": "Hard"
  }
}