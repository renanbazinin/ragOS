{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:50:29",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4278,
      "output_tokens": 2318,
      "total_tokens": 16570
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Producer-Consumer",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה מערכת המטפלת בתהליכי יצרן-צרכן עם חיץ מעגלי חסום בגודל `BUFFER_SIZE`.\nקיימים `P` תהליכי יצרן ו-`C` תהליכי צרכן.\nבנוסף למגבלות הסטנדרטיות של חיץ חסום, קיימת הגבלה נוספת:\nבכל רגע נתון, לכל היותר `MAX_ACTIVE_PRODUCERS` תהליכי יצרן יכולים להיות פעילים במקביל (כלומר, נמצאים בתוך הקטע הקריטי שלהם לייצור פריט, לפני ניסיון הכנסתו לחיץ).\n\nיש לממש את הפונקציות `producer_thread_func()` ו-`consumer_thread_func()` תוך שימוש בסמפורים בלבד, על מנת להבטיח:\n1. גישה בטוחה לחיץ המשותף.\n2. מניעת גלישה (overflow) ותת-גלישה (underflow) בחיץ.\n3. אכיפת המגבלה על מספר היצרנים הפעילים.\n4. מניעת מצבי קיפאון (deadlock) ורעב (starvation).\n\nיש להניח כי `BUFFER_SIZE` ו-`MAX_ACTIVE_PRODUCERS` הם קבועים גלובליים חיוביים, וכי הסמפורים הותחלו כראוי. אין צורך לממש את `produce_item()` או `consume_item()`, אלא רק את לוגיקת הסמפורים.",
      "code_snippet": "/* Global declarations for buffer and semaphores */\n#include <semaphore.h>\n#include <stdlib.h>\n\n#define BUFFER_SIZE 10\n#define MAX_ACTIVE_PRODUCERS 3\n\nint buffer[BUFFER_SIZE];\nint in = 0;\nint out = 0;\n\nsem_t mutex; /* For mutual exclusion to buffer */\nsem_t empty; /* Counts empty slots in buffer */\nsem_t full;  /* Counts full slots in buffer */\nsem_t active_producers_limit; /* Limits concurrent active producers */\n\n/* Assume semaphores are initialized as follows:\n * sem_init(&mutex, 0, 1);\n * sem_init(&empty, 0, BUFFER_SIZE);\n * sem_init(&full, 0, 0);\n * sem_init(&active_producers_limit, 0, MAX_ACTIVE_PRODUCERS);\n */\n\nvoid *producer_thread_func(void *arg) {\n    int item;\n    while (1) {\n        // Step 1: Limit active producers\n        // Acquire a slot to be an active producer for item production\n        sem_wait(&active_producers_limit);\n\n        // Simulate item production (critical section for production)\n        // This is the phase where the producer is \"actively trying to produce\"\n        item = rand() % 100; // Placeholder for produce_item()\n\n        // Release the active producer slot once item is produced.\n        // This allows another producer to start producing while this one waits for buffer space.\n        sem_post(&active_producers_limit);\n\n        // Step 2: Add item to buffer (standard bounded buffer logic)\n        sem_wait(&empty); // Wait for an empty slot in the buffer\n        sem_wait(&mutex); // Acquire buffer access lock\n\n        buffer[in] = item;\n        in = (in + 1) % BUFFER_SIZE;\n\n        sem_post(&mutex); // Release buffer access lock\n        sem_post(&full);  // Signal that a slot is now full\n\n        // Simulate some delay or other work after adding to buffer\n    }\n    return NULL;\n}\n\nvoid *consumer_thread_func(void *arg) {\n    int item;\n    while (1) {\n        // Step 1: Remove item from buffer (standard bounded buffer logic)\n        sem_wait(&full);  // Wait for a full slot in the buffer\n        sem_wait(&mutex); // Acquire buffer access lock\n\n        item = buffer[out];\n        out = (out + 1) % BUFFER_SIZE;\n\n        sem_post(&mutex); // Release buffer access lock\n        sem_post(&empty); // Signal that a slot is now empty\n\n        // Simulate some delay or other work after consuming\n    }\n    return NULL;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון משתמש בארבעה סמפורים:\n\n1.  `mutex` (סמפור בינארי, מאותחל ל-1): מגן על הגישה לחיץ המשותף (`buffer`, `in`, `out`) כדי להבטיח בלעדיות הדדית (mutual exclusion) בזמן הוספה או הוצאה של פריטים.\n2.  `empty` (סמפור סופר, מאותחל ל-`BUFFER_SIZE`): סופר את מספר המקומות הפנויים בחיץ. יצרנים מבצעים `sem_wait` עליו לפני הוספת פריט, וצרכנים מבצעים `sem_post` עליו לאחר הוצאת פריט.\n3.  `full` (סמפור סופר, מאותחל ל-0): סופר את מספר המקומות התפוסים בחיץ. צרכנים מבצעים `sem_wait` עליו לפני הוצאת פריט, ויצרנים מבצעים `sem_post` עליו לאחר הוספת פריט.\n4.  `active_producers_limit` (סמפור סופר, מאותחל ל-`MAX_ACTIVE_PRODUCERS`): סמפור זה אוכף את המגבלה על מספר היצרנים שיכולים להיות פעילים במקביל בשלב ייצור הפריט. יצרן מבצע `sem_wait` עליו לפני תחילת ייצור הפריט, ומבצע `sem_post` עליו מיד לאחר סיום הייצור, אך לפני הניסיון להכניס את הפריט לחיץ.\n\n**הסבר למימוש ולעמידה בדרישות:**\n\n*   **גישה בטוחה לחיץ המשותף (Mutual Exclusion):** הסמפור `mutex` מבטיח שרק תהליך אחד (יצרן או צרכן) יוכל לגשת לחיץ (`buffer`, `in`, `out`) בכל רגע נתון. הסדר של `sem_wait(&mutex)` ו-`sem_post(&mutex)` מבטיח שהקטע הקריטי (הוספה/הוצאה מהחיץ) מוגן.\n\n*   **מניעת גלישה ותת-גלישה (Overflow/Underflow):**\n    *   הסמפור `empty` מונע מיצרנים להוסיף פריטים לחיץ מלא. יצרן ייחסם על `sem_wait(&empty)` אם אין מקומות פנויים.\n    *   הסמפור `full` מונע מצרכנים להוציא פריטים מחיץ ריק. צרכן ייחסם על `sem_wait(&full)` אם אין פריטים בחיץ.\n\n*   **אכיפת המגבלה על מספר היצרנים הפעילים (`MAX_ACTIVE_PRODUCERS`):**\n    *   הסמפור `active_producers_limit` מאותחל ל-`MAX_ACTIVE_PRODUCERS`. כל יצרן שרוצה להתחיל לייצר פריט מבצע `sem_wait(&active_producers_limit)`. אם מספר היצרנים הפעילים הגיע למגבלה, יצרנים נוספים ייחסמו עד שיצרן פעיל ישחרר את הסמפור.\n    *   המיקום של `sem_post(&active_producers_limit)` מיד לאחר ייצור הפריט ולפני הגישה לחיץ הוא קריטי. הוא מאפשר ליצרן אחר להתחיל לייצר פריט חדש, גם אם היצרן הנוכחי ממתין למקום פנוי בחיץ. זה מגביר את המקביליות וממקסם את ניצולת המעבד עבור שלב הייצור.\n\n*   **מניעת מצבי קיפאון (Deadlock) ורעב (Starvation):**\n    *   הסדר הנכון של פעולות הסמפורים (`sem_wait` לפני `sem_post`, וסדר ספציפי עבור `mutex` ביחס ל-`empty`/`full`) בתבנית יצרן-צרכן הסטנדרטית מונע מצבי קיפאון.\n    *   הוספת הסמפור `active_producers_limit` אינה מציגה מצב קיפאון חדש מכיוון שהוא נרכש ומשוחרר לפני הגישה לסמפורי החיץ (`empty`, `mutex`, `full`), ובכך לא יוצר תלות מעגלית במשאבים.\n    *   השימוש בסמפורים, בהנחה שיישום `sem_wait` הוא הוגן (לרוב FIFO), מסייע במניעת רעב בכך שהוא מבטיח שבסופו של דבר כל תהליך ממתין יקבל גישה למשאב."
    },
    "difficulty_estimation": "Hard"
  }
}