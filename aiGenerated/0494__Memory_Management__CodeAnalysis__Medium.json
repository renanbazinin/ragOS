{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 22:07:26",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2670,
      "output_tokens": 1538,
      "total_tokens": 8140
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Memory Management",
      "Paging",
      "Page Faults",
      "Locality of Reference"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת במערך דו-ממדי גדול. המערכת ההפעלה משתמשת בזיכרון וירטואלי עם דפים בגודל 4KB. נניח שהמערך `int arr[1024][1024];` (כאשר כל `int` הוא בגודל 4 בתים) מאוחסן בזיכרון רציף ומתחיל בכתובת המיושרת לגבול דף.\n\nיש לנתח את שני קטעי הקוד הבאים ולחשב את המספר המינימלי של כשלים בדף (page faults) שיתרחשו עבור כל אחד מהם, בהנחה שכל הדפים של המערך אינם טעונים לזיכרון הפיזי בתחילת הריצה.",
      "code_snippet": "// Assume int is 4 bytes\n// Array: int arr[1024][1024];\n// Total array size: 1024 * 1024 * 4 bytes = 4,194,304 bytes = 4MB\n// Page size: 4KB = 4096 bytes\n\n// Access Pattern A (row-major)\nvoid pattern_A_access(int arr[1024][1024]) {\n    for (int i = 0; i < 1024; ++i) {\n        for (int j = 0; j < 1024; ++j) {\n            arr[i][j] = i * j;\n        }\n    }\n}\n\n// Access Pattern B (column-major)\nvoid pattern_B_access(int arr[1024][1024]) {\n    for (int j = 0; j < 1024; ++j) {\n        for (int i = 0; i < 1024; ++i) {\n            arr[i][j] = i * j;\n        }\n    }\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "חישובים מקדימים:\nגודל המערך הכולל: 1024 שורות * 1024 עמודות * 4 בתים/int = 4,194,304 בתים = 4MB.\nגודל דף: 4KB = 4096 בתים.\nמספר הדפים הכולל הנדרש למערך: 4MB / 4KB = 1024 דפים.\n\n**ניתוח תבנית גישה A (שורות):**\nב-C, מערכים דו-ממדיים מאוחסנים בזיכרון בסדר שורות (row-major). כלומר, כל האלמנטים של שורה `i` (`arr[i][0]` עד `arr[i][1023]`) מאוחסנים באופן רציף בזיכרון.\nגודל שורה אחת: 1024 איברים * 4 בתים/איבר = 4096 בתים = 1 דף.\nכאשר הלולאה החיצונית קובעת את `i` (מספר השורה), והלולאה הפנימית עוברת על `j` (מספר העמודה), הגישה לאיבר `arr[i][0]` תגרום לכשל דף (page fault) מכיוון שהדף של שורה `i` אינו בזיכרון. הדף הזה (שגודלו 4KB) ייטען לזיכרון הפיזי.\nלאחר מכן, כל הגישות הבאות לאיברים `arr[i][1]` עד `arr[i][1023]` יהיו באותו דף שכבר נטען, ולכן לא יגרמו לכשלי דף נוספים עבור שורה זו.\nכאשר הלולאה החיצונית עוברת לשורה הבאה (`i+1`), הגישה לאיבר `arr[i+1][0]` תגרום שוב לכשל דף, מכיוון שזוהי שורה חדשה הממוקמת בדף חדש.\nמכיוון שיש 1024 שורות במערך, וכל שורה תופסת בדיוק דף אחד, יהיו בסך הכל **1024 כשלי דף** עבור תבנית גישה זו.\n\n**ניתוח תבנית גישה B (עמודות):**\nכאשר הלולאה החיצונית קובעת את `j` (מספר העמודה), והלולאה הפנימית עוברת על `i` (מספר השורה), סדר הגישה הוא `arr[0][j], arr[1][j], ..., arr[1023][j]`.\nמכיוון שמערכים מאוחסנים בסדר שורות, האיבר `arr[i][j]` והאיבר `arr[i+1][j]` נמצאים בשורות שונות לגמרי. למעשה, `arr[i+1][j]` ממוקם 1024 * 4 = 4096 בתים (דף שלם) אחרי `arr[i][j]` בזיכרון.\nלכן, כל גישה לאיבר `arr[i][j]` עבור `i` שונה (עבור `j` קבוע) תהיה לכתובת בזיכרון הנמצאת בדף שונה.\nכתוצאה מכך, עבור כל איטרציה של הלולאה הפנימית (כלומר, עבור כל `i` מ-0 עד 1023), תתרחש ככל הנראה כשל דף חדש.\nבסך הכל, עבור עמודה אחת (`j` קבוע), יהיו 1024 כשלי דף.\nמכיוון שיש 1024 עמודות, המספר הכולל של כשלי דף יהיה 1024 עמודות * 1024 כשלי דף/עמודה = **1,048,576 כשלי דף**."
    },
    "difficulty_estimation": "Medium"
  }
}