{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 19:58:59",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3383,
      "output_tokens": 2718,
      "total_tokens": 23581
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Deadlocks",
      "Resource Management"
    ],
    "content": {
      "text": "מערכת הפעלה מנהלת שלושה תהליכים, P1, P2 ו-P3, ושני סוגי משאבים, R1 ו-R2. קיימים 2 מופעים של משאב R1 ו-2 מופעים של משאב R2. כל תהליך מבצע את סדרת הפעולות הבאה:\n\n*   **P1:**\n    1.  בקש מופע אחד של R1.\n    2.  בקש מופע אחד של R2.\n    3.  שחרר מופע אחד של R1.\n    4.  שחרר מופע אחד של R2.\n*   **P2:**\n    1.  בקש מופע אחד של R2.\n    2.  בקש מופע אחד של R1.\n    3.  שחרר מופע אחד של R2.\n    4.  שחרר מופע אחד של R1.\n*   **P3:**\n    1.  בקש מופע אחד של R1.\n    2.  בקש מופע אחד של R2.\n    3.  שחרר מופע אחד של R1.\n    4.  שחרר מופע אחד של R2.\n\nהמערכת משתמשת במתזמן שאינו דורסני (non-preemptive). כלומר, ברגע שתהליך מקבל את המעבד, הוא רץ עד שהוא נחסם (ממתין למשאב) או מסיים את פרץ המעבד שלו. בקשות משאבים מטופלות בסדר שהן מגיעות.\n\n**שאלות:**\n1.  **ניתוח מצב קיפאון:** נניח שהמתזמן מריץ את התהליכים בסדר הבא: P1, ואז P2, ואז P3. תאר מצב אפשרי בו יתרחש קיפאון (deadlock), והסבר מדוע. פרט את מצב המערכת (מי מחזיק איזה משאב, מי ממתין לאיזה משאב) בכל שלב קריטי.\n2.  **מדיניות מניעת קיפאון:** הצע מדיניות תזמון או הקצאת משאבים עבור מערכת זו שתבטיח מניעה מוחלטת של קיפאונות, תוך שאיפה למקסם את ניצול המשאבים ולמנוע הרעבה (starvation) ככל האפשר. הסבר את המדיניות שבחרת ואת עקרונותיה.\n3.  **עלויות המדיניות:** נתח את העלויות (overhead) של המדיניות שהצעת בסעיף 2 מבחינת ביצועים וסיבוכיות.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **ניתוח מצב קיפאון:**\n    מצב התחלתי: R1_זמין=2, R2_זמין=2. כל התהליכים מוכנים.\n    \n    נניח את סדר הפעולות הבא (המתזמן מריץ כל תהליך מספיק זמן לביצוע בקשת משאב אחת, ואז מתבצע מיתוג הקשר):\n    א.  **P1 רץ:** P1 מבקש מופע אחד של R1. (P1 מקבל R1. R1_זמין=1).\n    ב.  **המתזמן עובר ל-P2:** P2 מבקש מופע אחד של R2. (P2 מקבל R2. R2_זמין=1).\n    ג.  **המתזמן עובר ל-P3:** P3 מבקש מופע אחד של R1. (P3 מקבל את מופע R1 הנותר. R1_זמין=0).\n    \n    **מצב המערכת לאחר הבקשות הראשוניות:**\n    *   P1 מחזיק מופע אחד של R1, וממתין ל-R2.\n    *   P2 מחזיק מופע אחד של R2, וממתין ל-R1.\n    *   P3 מחזיק מופע אחד של R1, וממתין ל-R2.\n    *   משאבים זמינים: R1=0, R2=1.\n    \n    כעת, המתזמן יבחר באחד מהתהליכים שאינם חסומים (P1 או P3). נניח שהמתזמן בוחר ב-P1:\n    ד.  **P1 רץ:** P1 מבקש R2. (R2_זמין=1). P1 מקבל R2. (R2_זמין=0).\n        *   P1 מחזיק כעת את R1 (1) ו-R2 (1).\n    \n    ה.  **המתזמן עובר ל-P3:** P3 מבקש R2. (R2_זמין=0). P3 נחסם, ממתין ל-R2.\n        *   P3 מחזיק R1 (1), וממתין ל-R2.\n    \n    ו.  **המתזמן עובר ל-P2:** P2 מבקש R1. (R1_זמין=0). P2 נחסם, ממתין ל-R1.\n        *   P2 מחזיק R2 (1), וממתין ל-R1.\n    \n    **מצב קיפאון סופי:**\n    *   P1 מחזיק R1 (1), R2 (1). (P1 אינו חסום, ויסיים בסופו של דבר וישחרר את המשאבים).\n    *   P2 מחזיק R2 (1), וממתין ל-R1.\n    *   P3 מחזיק R1 (1), וממתין ל-R2.\n    *   משאבים זמינים: R1=0, R2=0.\n    \n    **הסבר:**\n    קיפאון מתרחש בין P2 ל-P3. P2 מחזיק מופע אחד של R2 וממתין ל-R1. P3 מחזיק מופע אחד של R1 וממתין ל-R2. נוצר כאן מעגל המתנה (Circular Wait): P2 ממתין למשאב שמוחזק על ידי P3, ו-P3 ממתין למשאב שמוחזק על ידי P2. כל ארבעת התנאים לקיפאון מתקיימים: מניעה הדדית (Mutual Exclusion), החזק והמתן (Hold and Wait), אי-דריסות (No Preemption), ומעגל המתנה (Circular Wait). אף אחד מהתהליכים הללו לא יוכל להתקדם ולשחרר את המשאבים שהוא מחזיק, והם יישארו חסומים ללא הגבלת זמן. למרות ש-P1 אינו חלק מהמעגל החסום ויסיים את פעולתו, הקיפאון בין P2 ל-P3 יישאר.\n\n2.  **מדיניות מניעת קיפאון:**\n    מדיניות יעילה למניעת קיפאון היא **הקצאת סדר גלובלי למשאבים (Resource Ordering)**. נגדיר סדר קבוע לרכישת משאבים: לדוגמה, R1 מקבל סדר 1 ו-R2 מקבל סדר 2. כל התהליכים חייבים לבקש משאבים בסדר עולה של המספר הסידורי שלהם. \n    \n    **יישום המדיניות:**\n    *   P1: סדר הפעולות (בקש R1, בקש R2) תקין, שכן 1 < 2.\n    *   P2: סדר הפעולות המקורי (בקש R2, בקש R1) אינו תקין. יש לשנות אותו ל-(בקש R1, בקש R2).\n    *   P3: סדר הפעולות (בקש R1, בקש R2) תקין, שכן 1 < 2.\n    \n    **עקרונות המדיניות:**\n    מדיניות זו מונעת קיפאונות על ידי שבירת תנאי מעגל ההמתנה (Circular Wait). אם כל התהליכים רוכשים משאבים בסדר לינארי קבוע, לא ייתכן שיתפתח מעגל המתנה, מכיוון שתהליך הממתין למשאב בעל מספר סידורי נמוך יותר מתהליך אחר המחזיק אותו, לא יוכל לבקש אותו כלל (הוא כבר ביקש משאבים בעלי מספרים סידוריים גבוהים יותר או שהוא עדיין לא הגיע לשלב זה). בכך, נמנע מעגל המתנה באופן מוחלט. מדיניות זו גם שואפת למקסם את ניצול המשאבים מכיוון שהיא מאפשרת רכישת משאבים באופן סדרתי, ולא מחייבת רכישת כל המשאבים מראש (מה שפוגע בניצול). היא גם מונעת הרעבה, בהנחה שהמתזמן הוגן וכל בקשה בסופו של דבר תקבל מענה כאשר המשאב הנדרש ישוחרר על ידי תהליך אחר.\n\n3.  **עלויות המדיניות:**\n    *   **עלויות פיתוח (Implementation Overhead):** דורשת הקפדה על כללי סדר המשאבים בקוד התוכנה. כל קריאה לבקשת משאב חייבת לוודא שהתהליך אינו מבקש משאב בסדר יורד. ייתכן שיהיה צורך לשנות קוד קיים בתהליכים שאינם עומדים בכלל זה (כמו P2 בדוגמה). \n    *   **עלויות זמן ריצה (Runtime Overhead):** מינימליות. בדיקת הסדר של המשאב המבוקש מול המשאבים שהתהליך כבר מחזיק היא פעולה פשוטה ומהירה (השוואת מספרים סידוריים). אין צורך באלגוריתמים מורכבים של זיהוי קיפאונות או בדיקות בטיחות כמו באלגוריתם הבנקאי.\n    *   **עלויות ביצועים (Performance Overhead):** עשויה להוביל לירידה מסוימת במקביליות או בניצול משאבים במקרים מסוימים. תהליכים עשויים להיאלץ לבקש משאבים מוקדם יותר ממה שהם באמת צריכים אותם, או בסדר שאינו אופטימלי עבורם מבחינת זרימת העבודה הטבעית שלהם. למשל, אם P2 באמת צריך את R2 לפני R1, הכפייה לבקש R1 קודם עלולה לעכב את התקדמותו אם R1 אינו זמין. עם זאת, בדרך כלל, עלות זו נחשבת סבירה בהשוואה למורכבות והסיכונים של התמודדות עם קיפאונות לאחר התרחשותם."
    },
    "difficulty_estimation": "Hard"
  }
}