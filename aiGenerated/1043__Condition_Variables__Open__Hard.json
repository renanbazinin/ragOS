{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Condition Variables",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:37:22",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3816,
      "output_tokens": 3120,
      "total_tokens": 11983
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Condition Variables",
      "Producer-Consumer",
      "Concurrency",
      "Mutexes"
    ],
    "content": {
      "text": "נתון קטע קוד המממש בנקאי (Producer) וצרכן (Consumer) המשתפים ביניהם תור (Queue) בעל קיבולת מוגבלת. הבנקאי מוסיף פריטים לתור, והצרכן מסיר פריטים ממנו. קטע הקוד משתמש במנעול (mutex) ובמשתני תנאי (condition variables) לסנכרון. עליך לבחון את קטע הקוד המצורף, לזהות בעיות סנכרון אפשריות, להסביר אותן בפירוט, ולהציע פתרון מתוקן. יש להתייחס במיוחד למצבי מירוץ (race conditions) או קיפאון (deadlock) שעלולים להיווצר.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h> // For sleep\n\n#define BUFFER_SIZE 5\n\nint buffer[BUFFER_SIZE];\nint count = 0;\nint in = 0;\nint out = 0;\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond_empty = PTHREAD_COND_INITIALIZER; // Signaled when buffer becomes non-empty\npthread_cond_t cond_full = PTHREAD_COND_INITIALIZER;  // Signaled when buffer becomes non-full\n\nvoid *producer(void *arg) {\n    int item_produced = 0;\n    while (1) {\n        pthread_mutex_lock(&mutex);\n        if (count == BUFFER_SIZE) { // Problem: Should be while, not if\n            printf(\"Producer: Buffer full, waiting...\\n\");\n            pthread_cond_wait(&cond_full, &mutex);\n        }\n        \n        // Simulate production\n        item_produced++;\n        buffer[in] = item_produced;\n        in = (in + 1) % BUFFER_SIZE;\n        count++;\n        printf(\"Producer: Produced %d, count = %d\\n\", item_produced, count);\n\n        pthread_cond_signal(&cond_empty); // Signal consumers\n        pthread_mutex_unlock(&mutex);\n        sleep(1); // Simulate work outside critical section\n    }\n    return NULL;\n}\n\nvoid *consumer(void *arg) {\n    int item_consumed;\n    while (1) {\n        pthread_mutex_lock(&mutex);\n        if (count == 0) { // Problem: Should be while, not if\n            printf(\"Consumer: Buffer empty, waiting...\\n\");\n            pthread_cond_wait(&cond_empty, &mutex);\n        }\n\n        // Simulate consumption\n        item_consumed = buffer[out];\n        out = (out + 1) % BUFFER_SIZE;\n        count--;\n        printf(\"Consumer: Consumed %d, count = %d\\n\", item_consumed, count);\n\n        pthread_cond_signal(&cond_full); // Signal producers\n        pthread_mutex_unlock(&mutex);\n        sleep(2); // Simulate work outside critical section\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t prod_thread, cons_thread;\n\n    pthread_create(&prod_thread, NULL, producer, NULL);\n    pthread_create(&cons_thread, NULL, consumer, NULL);\n\n    pthread_join(prod_thread, NULL);\n    pthread_join(cons_thread, NULL);\n\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond_empty);\n    pthread_cond_destroy(&cond_full);\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הקוד המצורף מכיל שתי בעיות סנכרון מרכזיות, הנובעות משימוש שגוי במשתני תנאי:\n\n1.  **שימוש ב-`if` במקום ב-`while` לבדיקת התנאי לפני המתנה**:\n    *   **הסבר הבעיה**: בקוד הנוכחי, הבנקאי והצרכן משתמשים בפקודת `if` כדי לבדוק האם עליהם להמתין (הבנקאי אם התור מלא, הצרכן אם התור ריק). `pthread_cond_wait` יכולה לחזור (spurious wakeup) גם ללא קריאה ל-`pthread_cond_signal` או `pthread_cond_broadcast`, או שייתכן ש-`pthread_cond_signal` הופעלה אך התנאי המקורי השתנה שוב לפני שהחוט הממתין הצליח לרוץ (לדוגמה, במערכת עם מספר בנקאים/צרכנים, חוט אחר לקח את הפריט/מקום בתור). אם משתמשים ב-`if`, לאחר שהחוט התעורר הוא ימשיך בביצוע ללא בדיקה חוזרת של התנאי.\n        *   **תרחיש לדוגמה (צרכן)**: נניח שהתור ריק. צרכן 1 נכנס לאזור הקריטי, בודק `if (count == 0)`, מוצא שהתור ריק, ומחליט להמתין. הוא קורא ל-`pthread_cond_wait(&cond_empty, &mutex)`. כעת, נניח שמתרחש \"wakeup כוזב\" (spurious wakeup) או שבנקאי אחר מפעיל `pthread_cond_signal` (למרות שהתור עדיין ריק). צרכן 1 יתעורר, ייצא מה-`if` וינסה לצרוך פריט מתור ריק, מה שיוביל לשגיאה או התנהגות בלתי צפויה.\n        *   **תרחיש לדוגמה (בנקאי)**: דומה לצרכן, אם התור מלא, בנקאי עלול להתעורר מ-`pthread_cond_wait` בגלל wakeup כוזב, לצאת מה-`if` ולנסות להוסיף פריט לתור מלא.\n    *   **בעיית \"איתות אבוד\" (Lost Signal)**: בעיה חמורה יותר עלולה להתרחש במצב מירוץ עדין. נניח שהתור ריק. צרכן 1 נכנס לאזור הקריטי, בודק `if (count == 0)`, מוצא שהתור ריק. לפני שהוא מספיק לקרוא ל-`pthread_cond_wait`, הוא נקטע. כעת, בנקאי רץ, מוסיף פריט לתור, וקורא ל-`pthread_cond_signal(&cond_empty)`. מכיוון שצרכן 1 לא היה עדיין במצב המתנה, האיתות \"אובד\". כאשר צרכן 1 יחזור לרוץ ויקרא ל-`pthread_cond_wait`, הוא ימתין באופן אינסופי, למרות שיש פריט בתור. שימוש ב-`while` מסייע להפחית את הסיכון הזה בכך שהוא מבטיח שהתנאי נבדק שוב ברגע שהחוט מתעורר, ואם הוא כבר השתנה, החוט לא ימתין לחינם.\n\n2.  **פוטנציאל לקיפאון (Deadlock) או חוסר יעילות במצבים מורכבים יותר (אם היו מספר בנקאים/צרכנים)**:\n    *   בעוד שבקוד הנתון עם בנקאי וצרכן יחידים, הבעיה העיקרית היא ה-`if` במקום `while`, חשוב לציין שבמערכות מרובות בנקאים ו/או מרובות צרכנים, שימוש ב-`pthread_cond_signal` במקום `pthread_cond_broadcast` במצבים מסוימים עלול לגרום לקיפאון. לדוגמה, אם כל הצרכנים ממתינים על `cond_empty` ובנקאי אחד מוסיף פריט וקורא ל-`pthread_cond_signal`, רק צרכן אחד יתעורר. אם צרכן זה אינו יכול להמשיך (לדוגמה, בגלל תנאי נוסף שלא מתקיים), ושאר הצרכנים נשארים רדומים, המערכת עלולה להיתקע. במקרה שלנו, `signal` מספיק מכיוון שיש רק בנקאי אחד וצרכן אחד שמעוניינים בפריט/מקום.\n\n**פתרון מתוקן:**\nהתיקון העיקרי הוא להחליף את פקודות ה-`if` ב-`while` בתוך הפונקציות `producer` ו-`consumer` לפני הקריאה ל-`pthread_cond_wait`. זוהי הדרך הבטוחה והנכונה ביותר להשתמש במשתני תנאי.\n\n**קוד מתוקן:**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h> // For sleep\n\n#define BUFFER_SIZE 5\n\nint buffer[BUFFER_SIZE];\nint count = 0;\nint in = 0;\nint out = 0;\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond_empty = PTHREAD_COND_INITIALIZER; // Signaled when buffer becomes non-empty\npthread_cond_t cond_full = PTHREAD_COND_INITIALIZER;  // Signaled when buffer becomes non-full\n\nvoid *producer(void *arg) {\n    int item_produced = 0;\n    while (1) {\n        pthread_mutex_lock(&mutex);\n        while (count == BUFFER_SIZE) { // Corrected: use while instead of if\n            printf(\"Producer: Buffer full, waiting...\\n\");\n            pthread_cond_wait(&cond_full, &mutex);\n        }\n        \n        // Simulate production\n        item_produced++;\n        buffer[in] = item_produced;\n        in = (in + 1) % BUFFER_SIZE;\n        count++;\n        printf(\"Producer: Produced %d, count = %d\\n\", item_produced, count);\n\n        pthread_cond_signal(&cond_empty); // Signal consumers\n        pthread_mutex_unlock(&mutex);\n        sleep(1); // Simulate work outside critical section\n    }\n    return NULL;\n}\n\nvoid *consumer(void *arg) {\n    int item_consumed;\n    while (1) {\n        pthread_mutex_lock(&mutex);\n        while (count == 0) { // Corrected: use while instead of if\n            printf(\"Consumer: Buffer empty, waiting...\\n\");\n            pthread_cond_wait(&cond_empty, &mutex);\n        }\n\n        // Simulate consumption\n        item_consumed = buffer[out];\n        out = (out + 1) % BUFFER_SIZE;\n        count--;\n        printf(\"Consumer: Consumed %d, count = %d\\n\", item_consumed, count);\n\n        pthread_cond_signal(&cond_full); // Signal producers\n        pthread_mutex_unlock(&mutex);\n        sleep(2); // Simulate work outside critical section\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t prod_thread, cons_thread;\n\n    pthread_create(&prod_thread, NULL, producer, NULL);\n    pthread_create(&cons_thread, NULL, consumer, NULL);\n\n    pthread_join(prod_thread, NULL);\n    pthread_join(cons_thread, NULL);\n\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond_empty);\n    pthread_cond_destroy(&cond_full);\n\n    return 0;\n}\n```\n\n**הסבר התיקון**:\nעל ידי שימוש ב-`while`, אנו מבטיחים שברגע שחוט מתעורר מ-`pthread_cond_wait`, הוא בודק שוב את התנאי (לדוגמה, האם התור עדיין ריק עבור צרכן). אם התנאי עדיין לא מתקיים (לדוגמה, בגלל wakeup כוזב, או שחוט אחר לקח את המשאב), החוט יחזור למצב המתנה. זהו התרשים הנכון והבטוח לשימוש במשתני תנאי, והוא מגן מפני spurious wakeups ומפני מצבים שבהם התנאי השתנה שוב בין האיתות לבין חידוש הריצה של החוט הממתין."
    },
    "difficulty_estimation": "Hard"
  }
}