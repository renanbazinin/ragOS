{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-08 07:43:08",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3452,
      "output_tokens": 2334,
      "total_tokens": 10148
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Producer-Consumer",
      "Synchronization",
      "Semaphores"
    ],
    "content": {
      "text": "נתונה בעיית יצרן-צרכן קלאסית. ישנו חיץ משותף בגודל N (מחסן) בו היצרנים מכניסים פריטים והצרכנים מוציאים פריטים. היצרנים מוסיפים פריטים לחיץ רק כשיש מקום פנוי, והצרכנים מוציאים פריטים רק כשיש פריטים בחיץ. יש למנוע מצבי מירוץ (race conditions) ולהבטיח סנכרון נכון בין החוטים.\n\nממשו את פונקציות ה-`producer` ו-`consumer` תוך שימוש בסמפורים בלבד. ניתן להניח שהחיץ הוא מערך בגודל קבוע N.\n\nיש לכלול את הגדרות הסמפורים המשתנים הגלובליים וערכי האתחול שלהם.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון משתמש בשלושה סמפורים ושני אינדקסים לניהול החיץ: \n\n```c\n#include <semaphore.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#define N 10 // גודל החיץ - ניתן לשנות\n\nint buffer[N]; // החיץ המשותף\nint in = 0;    // אינדקס להכנסת פריטים\nint out = 0;   // אינדקס להוצאת פריטים\n\nsem_t mutex;   // סמפור להגנה על הגישה לחיץ (אתחול: 1)\nsem_t empty;   // סמפור לספירת מקומות פנויים בחיץ (אתחול: N)\nsem_t full;    // סמפור לספירת פריטים מלאים בחיץ (אתחול: 0)\n\n// הערה: יש לאתחל את הסמפורים לפני יצירת החוטים, לדוגמה בפונקציה הראשית (main):\n// int main() {\n//     sem_init(&mutex, 0, 1); // 0 עבור סמפור בתהליך מקומי, 1 עבור ערך אתחול\n//     sem_init(&empty, 0, N); // N עבור מספר המקומות הפנויים בחיץ\n//     sem_init(&full, 0, 0);  // 0 עבור מספר הפריטים המלאים בהתחלה\n//     // ... יצירת חוטים וכו'\n//     return 0;\n// }\n\nvoid *producer(void *arg) {\n    int item;\n    while (1) {\n        // ייצור פריט (לדוגמה, מספר אקראי)\n        item = rand() % 100;\n        printf(\"Producer produced: %d\\n\", item);\n\n        sem_wait(&empty);   // ממתין אם החיץ מלא (אין מקומות פנויים)\n        sem_wait(&mutex);   // נכנס לאזור קריטי לגישה לחיץ\n\n        buffer[in] = item;  // מוסיף פריט לחיץ\n        in = (in + 1) % N;  // מעדכן את אינדקס ההכנסה (חיץ מעגלי)\n\n        sem_post(&mutex);   // משחרר את המנעול מהאזור הקריטי\n        sem_post(&full);    // מאותת שיש פריט זמין לצריכה\n\n        // ניתן להוסיף השהייה לדוגמה: sleep(1);\n    }\n    return NULL;\n}\n\nvoid *consumer(void *arg) {\n    int item;\n    while (1) {\n        sem_wait(&full);    // ממתין אם החיץ ריק (אין פריטים לצריכה)\n        sem_wait(&mutex);   // נכנס לאזור קריטי לגישה לחיץ\n\n        item = buffer[out]; // מוציא פריט מהחיץ\n        out = (out + 1) % N; // מעדכן את אינדקס ההוצאה (חיץ מעגלי)\n\n        sem_post(&mutex);   // משחרר את המנעול מהאזור הקריטי\n        sem_post(&empty);   // מאותת שהתפנה מקום בחיץ\n\n        // צריכת הפריט (לדוגמה, הדפסה)\n        printf(\"Consumer consumed: %d\\n\", item);\n\n        // ניתן להוסיף השהייה לדוגמה: sleep(2);\n    }\n    return NULL;\n}\n```\n\n**הסבר מפורט:**\n\nהפתרון לבעיית יצרן-צרכן הקלאסית משתמש בשלושה סמפורים ובמבנה נתונים של חיץ מעגלי כדי להבטיח סנכרון נכון ולמנוע מצבי מירוץ: \n\n1.  **`mutex`**: זהו סמפור בינארי (מנעול) המאותחל ל-1. תפקידו להבטיח הדרה הדדית (mutual exclusion) כאשר מספר חוטים (יצרנים וצרכנים) ניגשים למשאבים המשותפים: החיץ (`buffer`) והאינדקסים שלו (`in`, `out`). רק חוט אחד יכול להחזיק במנעול זה בכל רגע נתון, ובכך נמנעים מצבי מירוץ בעת עדכון החיץ או האינדקסים.\n\n2.  **`empty`**: זהו סמפור מונה המאותחל לגודל החיץ `N`. הוא מייצג את מספר המקומות הפנויים בחיץ. היצרן מבצע עליו `sem_wait` לפני הוספת פריט; אם הסמפור מגיע ל-0, פירוש הדבר שהחיץ מלא, והיצרן ימתין עד שיתפנה מקום. הצרכן מבצע עליו `sem_post` לאחר הוצאת פריט, ובכך מאותת שהתפנה מקום בחיץ ומעלה את ספירת המקומות הפנויים.\n\n3.  **`full`**: זהו סמפור מונה המאותחל ל-0. הוא מייצג את מספר הפריטים הקיימים בחיץ שמוכנים לצריכה. הצרכן מבצע עליו `sem_wait` לפני הוצאת פריט; אם הסמפור מגיע ל-0, פירוש הדבר שהחיץ ריק, והצרכן ימתין עד שיהיה פריט זמין. היצרן מבצע עליו `sem_post` לאחר הוספת פריט, ובכך מאותת שיש פריט חדש זמין לצריכה ומעלה את ספירת הפריטים המלאים.\n\n**פעולת היצרן (`producer`):**\n*   היצרן מייצר פריט חדש. \n*   **`sem_wait(&empty)`**: היצרן מנסה להוריד את ערך סמפור `empty`. אם אין מקומות פנויים (empty=0), היצרן נחסם וממתין עד שהצרכן יפנה מקום. \n*   **`sem_wait(&mutex)`**: לאחר שהובטח שיש מקום, היצרן רוכש את המנעול `mutex` כדי להיכנס לאזור הקריטי ולגשת בבטחה לחיץ המשותף. \n*   הפריט מתווסף למיקום הבא בחיץ (`buffer[in]`), והאינדקס `in` מתעדכן (באופן מעגלי) למיקום ההכנסה הבא. \n*   **`sem_post(&mutex)`**: היצרן משחרר את המנעול `mutex`, ומאפשר לחוטים אחרים לגשת לאזור הקריטי. \n*   **`sem_post(&full)`**: היצרן מעלה את ערך סמפור `full`, ובכך מאותת לצרכנים שיש פריט חדש זמין לצריכה.\n\n**פעולת הצרכן (`consumer`):**\n*   **`sem_wait(&full)`**: הצרכן מנסה להוריד את ערך סמפור `full`. אם אין פריטים בחיץ (full=0), הצרכן נחסם וממתין עד שהיצרן יוסיף פריט. \n*   **`sem_wait(&mutex)`**: לאחר שהובטח שיש פריט, הצרכן רוכש את המנעול `mutex` כדי להיכנס לאזור הקריטי ולגשת בבטחה לחיץ המשותף. \n*   הפריט מוצא מהמיקום הבא לצריכה בחיץ (`buffer[out]`), והאינדקס `out` מתעדכן (באופן מעגלי) למיקום ההוצאה הבא. \n*   **`sem_post(&mutex)`**: הצרכן משחרר את המנעול `mutex`. \n*   **`sem_post(&empty)`**: הצרכן מעלה את ערך סמפור `empty`, ובכך מאותת ליצרנים שהתפנה מקום בחיץ.\n*   הפריט שהוצא נצרך."
    },
    "difficulty_estimation": "Easy"
  }
}