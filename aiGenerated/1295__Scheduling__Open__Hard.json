{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:22:53",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3419,
      "output_tokens": 4461,
      "total_tokens": 27846
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Multi-Level Feedback Queue",
      "Aging",
      "Context Switching"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת במתזמן (Scheduler) מרובה תורים (Multi-Level Feedback Queue) עם מנגנון הזדקנות (Aging) וזמן החלפת קשר (Context Switch) משמעותי. המערכת בעלת מעבד יחיד.\n\n**כללי התזמון:**\n1.  קיימים שלושה תורים: Q0 (העדיפות הגבוהה ביותר), Q1, Q2 (העדיפות הנמוכה ביותר).\n2.  תהליכים חדשים מגיעים לתור Q0.\n3.  תהליכים בתור Q0 רצים בשיטת Round Robin עם קוונטום של **2ms**. אם תהליך מסיים את הקוונטום שלו ב-Q0, הוא עובר לתור Q1. אם הוא מסיים לפני תום הקוונטום (למשל, עקב סיום CPU burst או כניסה ל-I/O), הוא נשאר בתור Q0 (אך ימוקם בסוף התור).\n4.  תהליכים בתור Q1 רצים בשיטת Round Robin עם קוונטום של **4ms**. אם תהליך מסיים את הקוונטום שלו ב-Q1, הוא עובר לתור Q2. אם הוא מסיים לפני תום הקוונטום, הוא נשאר בתור Q1 (אך ימוקם בסוף התור).\n5.  תהליכים בתור Q2 רצים בשיטת First Come, First Served (FCFS).\n6.  החלפת קשר (Context Switch): דורשת **1ms**. זה קורה בכל פעם שהמעבד עובר מתהליך אחד לאחר, או מתהליך למצב סרק (Idle), או ממצב סרק לתהליך. זמן זה אינו נכלל בקוונטום של התהליך.\n7.  **מנגנון הזדקנות (Aging)**: כל **10ms** של זמן שעבר במערכת (זמן גלובלי), המערכת בודקת את התורים. אם תהליך נמצא בתור Q1 או Q2 במשך **5ms** רצופים או יותר מבלי שרץ כלל, הוא מועבר לתור Q0. תהליך שרץ, גם אם רק לחלק קצר, מאפס את מונה הזמן שלו עבור מנגנון ההזדקנות.\n8.  **I/O**: כאשר תהליך נכנס למצב I/O, הוא עוזב את התורים. עם סיום פעולת ה-I/O, הוא חוזר לתור Q0.\n9.  בכל רגע נתון, המעבד יריץ את התהליך בעל העדיפות הגבוהה ביותר מבין התורים שאינם ריקים (Q0 > Q1 > Q2). בתוך תור בעל עדיפות שווה, הסדר הוא FCFS (למעט RR שדואג לסדר).\n\n**תהליכים נתונים:**\n\n| תהליך | זמן הגעה | פרץ CPU ראשון | זמן I/O ראשון | פרץ CPU שני | זמן I/O שני | פרץ CPU שלישי |\n| :---- | :------- | :----------- | :----------- | :---------- | :---------- | :---------- |\n| P1    | 0ms      | 5ms          | 8ms          | 3ms         |             |             |\n| P2    | 1ms      | 4ms          | 5ms          | 2ms         |             |             |\n| P3    | 3ms      | 6ms          |              |             |             |             |\n\n**נדרש:**\nתאר/י את גרף גאנט (Gantt Chart) המפורט עבור 30ms הראשונים של פעילות המערכת, תוך פירוט איזה תהליך רץ (או 'CS' עבור החלפת קשר, 'Idle' עבור סרק) ואת מצב התורים (Q0, Q1, Q2) בסיום כל פעולה או שינוי מצב. בנוסף, חשב/י את זמן ההמתנה (Waiting Time) ואת זמן המחזור (Turnaround Time) עבור כל תהליך בסיום 30ms (או בסיום התהליך, אם הוא הסתיים לפני כן).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "נבצע סימולציה מפורטת של המתזמן:\n\n**גרף גאנט ושינויי מצב תורים (30ms ראשונים):**\n*   **זמן 0:** P1 מגיע. Q0=[P1]. מתזמן בוחר P1.\n    *   `0-1`: CS (החלפת קשר ל-P1).\n*   **זמן 1:** P2 מגיע. Q0=[P1, P2]. P1 רץ.\n    *   `1-2`: P1 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P1 בפרץ CPU ראשון: 4ms).\n*   **זמן 2:** P1 מסיים קוונטום (2ms). עובר ל-Q1. Q0=[P2], Q1=[P1]. מתזמן בוחר P2.\n    *   `2-3`: CS (החלפת קשר ל-P2).\n*   **זמן 3:** P3 מגיע. Q0=[P2, P3]. P2 רץ.\n    *   `3-4`: P2 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P2 בפרץ CPU ראשון: 3ms).\n*   **זמן 4:** P2 רץ.\n    *   `4-5`: P2 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P2 בפרץ CPU ראשון: 2ms). P2 מסיים קוונטום. עובר ל-Q1. Q0=[P3], Q1=[P1, P2]. מתזמן בוחר P3.\n*   **זמן 5:** P3 רץ.\n    *   `5-6`: CS (החלפת קשר ל-P3).\n*   **זמן 6:** P3 רץ.\n    *   `6-7`: P3 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P3 בפרץ CPU ראשון: 5ms).\n*   **זמן 7:** P3 רץ.\n    *   `7-8`: P3 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P3 בפרץ CPU ראשון: 4ms). P3 מסיים קוונטום. עובר ל-Q1. Q0=[], Q1=[P1, P2, P3]. מתזמן בוחר P1 (ראשון ב-Q1).\n*   **זמן 8:** P1 רץ.\n    *   `8-9`: CS (החלפת קשר ל-P1).\n*   **זמן 9:** P1 רץ.\n    *   `9-10`: P1 (רץ ב-Q1, השתמש ב-1ms מתוך 4ms קוונטום. נותר ל-P1 בפרץ CPU ראשון: 3ms).\n*   **זמן 10:** בדיקת הזדקנות. P1 נמצא ב-Q1 מאז זמן 2, ורץ בזמן 9-10. הוא המתין 7ms (זמן 2-9) מבלי לרוץ. לכן P1 מועבר ל-Q0. Q0=[P1], Q1=[P2, P3]. מתזמן בוחר P1.\n    *   `10-11`: CS (החלפת קשר מ-P1 ב-Q1 ל-P1 ב-Q0).\n*   **זמן 11:** P1 רץ.\n    *   `11-12`: P1 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P1 בפרץ CPU ראשון: 2ms).\n*   **זמן 12:** P1 רץ.\n    *   `12-13`: P1 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P1 בפרץ CPU ראשון: 1ms). P1 מסיים קוונטום. עובר ל-Q1. Q0=[], Q1=[P2, P3, P1]. מתזמן בוחר P2 (ראשון ב-Q1).\n*   **זמן 13:** P2 רץ.\n    *   `13-14`: CS (החלפת קשר ל-P2).\n*   **זמן 14:** P2 רץ.\n    *   `14-15`: P2 (רץ ב-Q1, השתמש ב-1ms מתוך 4ms קוונטום. נותר ל-P2 בפרץ CPU ראשון: 1ms).\n*   **זמן 15:** P2 רץ.\n    *   `15-16`: P2 (רץ ב-Q1, השתמש ב-1ms מתוך 4ms קוונטום. נותר ל-P2 בפרץ CPU ראשון: 0ms). P2 מסיים פרץ CPU ראשון (4ms). נכנס ל-I/O (יסתיים בזמן 16+5=21). Q0=[], Q1=[P3, P1]. מתזמן בוחר P3 (ראשון ב-Q1).\n*   **זמן 16:** P3 רץ.\n    *   `16-17`: CS (החלפת קשר ל-P3).\n*   **זמן 17:** P3 רץ.\n    *   `17-18`: P3 (רץ ב-Q1, השתמש ב-1ms מתוך 4ms קוונטום. נותר ל-P3 בפרץ CPU ראשון: 3ms).\n*   **זמן 18:** P3 רץ.\n    *   `18-19`: P3 (רץ ב-Q1, השתמש ב-1ms מתוך 4ms קוונטום. נותר ל-P3 בפרץ CPU ראשון: 2ms).\n*   **זמן 19:** P3 רץ.\n    *   `19-20`: P3 (רץ ב-Q1, השתמש ב-1ms מתוך 4ms קוונטום. נותר ל-P3 בפרץ CPU ראשון: 1ms).\n*   **זמן 20:** בדיקת הזדקנות. P1 נמצא ב-Q1 מאז זמן 13, לא רץ. המתין 7ms. P1 מועבר ל-Q0. P3 נמצא ב-Q1 מאז זמן 8, ורץ בזמן 17-20. הוא המתין 9ms (זמן 8-17) מבלי לרוץ. לכן P3 מועבר ל-Q0. Q0=[P1, P3], Q1=[]. מתזמן בוחר P1 (ראשון ב-Q0).\n    *   `20-21`: CS (החלפת קשר ל-P1).\n*   **זמן 21:** I/O של P2 מסתיים. P2 חוזר ל-Q0. Q0=[P1, P3, P2]. P1 רץ.\n    *   `21-22`: P1 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P1 בפרץ CPU שני: 2ms).\n*   **זמן 22:** P1 רץ.\n    *   `22-23`: P1 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P1 בפרץ CPU שני: 1ms). P1 מסיים קוונטום. עובר ל-Q1. Q0=[P3, P2], Q1=[P1]. מתזמן בוחר P3 (ראשון ב-Q0).\n*   **זמן 23:** P3 רץ.\n    *   `23-24`: CS (החלפת קשר ל-P3).\n*   **זמן 24:** P3 רץ.\n    *   `24-25`: P3 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P3 בפרץ CPU ראשון: 0ms). P3 מסיים פרץ CPU ראשון (6ms). אין לו I/O נוסף. P3 מסיים ריצה! Q0=[P2], Q1=[P1]. מתזמן בוחר P2 (ראשון ב-Q0).\n*   **זמן 25:** P2 רץ.\n    *   `25-26`: CS (החלפת קשר ל-P2).\n*   **זמן 26:** P2 רץ.\n    *   `26-27`: P2 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P2 בפרץ CPU שני: 1ms).\n*   **זמן 27:** P2 רץ.\n    *   `27-28`: P2 (רץ ב-Q0, השתמש ב-1ms מתוך 2ms קוונטום. נותר ל-P2 בפרץ CPU שני: 0ms). P2 מסיים פרץ CPU שני (2ms). P2 מסיים ריצה! Q0=[], Q1=[P1]. מתזמן בוחר P1 (ראשון ב-Q1).\n*   **זמן 28:** P1 רץ.\n    *   `28-29`: CS (החלפת קשר ל-P1).\n*   **זמן 29:** P1 רץ.\n    *   `29-30`: P1 (רץ ב-Q1, השתמש ב-1ms מתוך 4ms קוונטום. נותר ל-P1 בפרץ CPU שני: 2ms). P1 ממשיך לרוץ מעבר ל-30ms.\n\n**חישוב זמני המתנה וזמני מחזור:**\n\n**עבור P1:**\n*   זמן הגעה (AT): 0ms\n*   זמן סיום (CT): 30ms (עד לנקודה זו, P1 עדיין לא סיים את ריצתו. הוא סיים את פרץ ה-CPU השני שלו בזמן 30ms). נניח שהשאלה מתכוונת לזמן הסיום *בתוך 30ms*, כלומר עד 30ms P1 לא סיים. אך לפי הסימולציה המעודכנת, P1 מסיים את פרץ ה-CPU השני שלו בזמן 30ms. אז זמן הסיום הוא 30ms.\n*   זמן CPU כולל (T_CPU): 5ms + 3ms = 8ms (P1 סיים 6ms של CPU עד זמן 30ms. חסר לו 2ms). *תיקון: לפי הסימולציה P1 סיים את פרץ ה-CPU השני שלו בזמן 30ms, ולכן סך ה-CPU שלו הוא 8ms.*\n*   זמן I/O כולל (T_IO): 8ms\n*   מספר החלפות קשר (CS): P1 מעורב ב-8 החלפות קשר (0-1, 2-3, 10-11, 12-13, 20-21, 22-23, 28-29, 29-30). סה\"כ 8ms.\n*   זמן מחזור (Turnaround Time): CT - AT = 30 - 0 = 30ms\n*   זמן המתנה (Waiting Time): Turnaround Time - T_CPU - T_IO - T_CS = 30 - 8 - 8 - 8 = 6ms\n\n**עבור P2:**\n*   זמן הגעה (AT): 1ms\n*   זמן סיום (CT): 28ms\n*   זמן CPU כולל (T_CPU): 4ms + 2ms = 6ms\n*   זמן I/O כולל (T_IO): 5ms\n*   מספר החלפות קשר (CS): P2 מעורב ב-6 החלפות קשר (2-3, 5-6, 13-14, 15-16, 25-26, 27-28). סה\"כ 6ms.\n*   זמן מחזור (Turnaround Time): CT - AT = 28 - 1 = 27ms\n*   זמן המתנה (Waiting Time): Turnaround Time - T_CPU - T_IO - T_CS = 27 - 6 - 5 - 6 = 10ms\n\n**עבור P3:**\n*   זמן הגעה (AT): 3ms\n*   זמן סיום (CT): 25ms\n*   זמן CPU כולל (T_CPU): 6ms\n*   זמן I/O כולל (T_IO): 0ms\n*   מספר החלפות קשר (CS): P3 מעורב ב-5 החלפות קשר (5-6, 8-9, 16-17, 20-21, 23-24). סה\"כ 5ms.\n*   זמן מחזור (Turnaround Time): CT - AT = 25 - 3 = 22ms\n*   זמן המתנה (Waiting Time): Turnaround Time - T_CPU - T_IO - T_CS = 22 - 6 - 0 - 5 = 11ms"
    },
    "difficulty_estimation": "Hard"
  }
}