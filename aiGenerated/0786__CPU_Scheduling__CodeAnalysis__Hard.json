{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 00:22:49",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4397,
      "output_tokens": 2810,
      "total_tokens": 14081
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "CPU Scheduling",
      "Processes",
      "System Calls",
      "Priorities"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה המשתמשת במערכת קריאות `fork` ו-`nice` ליצירת תהליכים בעלי עדיפויות שונות. התוכנית מיועדת לרוץ על מעבד יחיד. יש להניח שכל קריאות המערכת מצליחות.\n\n`nice` values: ערך נמוך יותר מציין עדיפות גבוהה יותר. ערך ברירת מחדל הוא 0.\n`setbuf(stdout, NULL)` מבטיח הדפסה מיידית ללא חיץ.\n\nנתון כי מערכת ההפעלה משתמשת באלגוריתם תזמון מונע (preemptive) מבוסס עדיפויות, כאשר תהליכים בעלי עדיפות גבוהה יותר יקבלו את המעבד לפני תהליכים בעלי עדיפות נמוכה יותר. בין תהליכים בעלי אותה עדיפות, התזמון הוא Round Robin. תהליך יקבל את המעבד ויבצע כמה איטרציות בלולאה לפני שיוחלף (context switch) רק אם יש תהליך בעל עדיפות גבוהה יותר שמוכן לריצה, או לאחר שמיצה את קוואנטום הזמן שלו (אם יש תהליכים אחרים באותה רמת עדיפות). לצורך הניתוח, נניח שכל הדפסה של תו נחשבת ל\"יחידת עבודה\" קטנה מאוד, ושזמן הקוואנטום מספיק לביצוע מספר קטן של הדפסות, אך קצר מ-`ITERATIONS`.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n\n#define NUM_CHILDREN 3\n#define ITERATIONS   10\n\nvoid child_task(char id_char, int nice_value) {\n    if (nice_value != 0) {\n        if (nice(nice_value) == -1 && errno != 0) {\n            perror(\"nice\");\n            exit(1);\n        }\n    }\n    for (int i = 0; i < ITERATIONS; ++i) {\n        printf(\"%c\", id_char);\n        fflush(stdout);\n    }\n    exit(0);\n}\n\nint main() {\n    pid_t pids[NUM_CHILDREN];\n    char id_chars[NUM_CHILDREN] = {'A', 'B', 'C'};\n    int nice_values[NUM_CHILDREN] = {0, 5, -5}; // A: default, B: lower priority, C: higher priority\n\n    setbuf(stdout, NULL);\n\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        pids[i] = fork();\n        if (pids[i] == -1) {\n            perror(\"fork\");\n            exit(1);\n        } else if (pids[i] == 0) { // Child process\n            child_task(id_chars[i], nice_values[i]);\n        }\n    }\n\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        wait(NULL);\n    }\n\n    printf(\"\\nParent finished.\\n\");\n    return 0;\n}"
    },
    "sub_questions": [
      {
        "id": "101.1",
        "text": "תארו פלט אפשרי אחד של התוכנית. הסבירו מדוע פלט זה אפשרי, תוך התייחסות לעדיפויות התהליכים וכיצד אלגוריתם התזמון ישפיע על סדר ההדפסות.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.2",
        "text": "אם נשנה את המערך `nice_values` לשורה `int nice_values[NUM_CHILDREN] = {5, 0, -5};` (כלומר תהליך A מקבל עדיפות נמוכה יותר, B ברירת מחדל, C נשאר הגבוה ביותר), כיצד ישתנה הפלט בהשוואה למקרה המקורי? התייחסו למאפיינים הכלליים של הפלט (למשל, מי יסיים קודם, האם סדר ההדפסות יהיה מעורב יותר או פחות).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.3",
        "text": "אם אלגוריתם התזמון היה FIFO לא מונע (non-preemptive), ובהנחה שכל תהליך ירוץ עד סיום הלולאה שלו ברגע שקיבל את המעבד, תארו את כל הפלטים האפשריים. הסבירו את ההבדל המהותי מהמקרה המקורי.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\n**סעיף 101.1: פלט אפשרי במקרה המקורי**\nהפלט הסביר ביותר הוא:\n`CCCCCCCCCCAAAAAAAAAABBBBBBBBBB\nParent finished.\n`\n**הסבר:**\n1.  **קביעת עדיפויות:**\n    *   תהליך C נוצר עם `nice -5`, זוהי העדיפות הגבוהה ביותר.\n    *   תהליך A נוצר עם `nice 0`, זוהי עדיפות בינונית.\n    *   תהליך B נוצר עם `nice 5`, זוהי העדיפות הנמוכה ביותר.\n2.  **תזמון מונע מבוסס עדיפויות:** מאחר ותהליך C בעל העדיפות הגבוהה ביותר, הוא יקבל את המעבד מיד כשהוא מוכן לריצה. מכיוון שאין תהליכים אחרים בעלי עדיפות גבוהה יותר או שווה לו שמתחרים איתו על המעבד, והוא לא חסום, הוא ירוץ ברציפות עד שיסיים את כל 10 ההדפסות שלו ('C').\n3.  **לאחר סיום C:** לאחר שתהליך C מסיים ויוצא, המעבד יהיה פנוי לתהליכים A ו-B. תהליך A (עדיפות 0) גבוה יותר מתהליך B (עדיפות 5), ולכן תהליך A יקבל את המעבד וירוץ ברציפות עד שיסיים את כל 10 ההדפסות שלו ('A').\n4.  **לאחר סיום A:** לבסוף, תהליך B יקבל את המעבד ויסיים את 10 ההדפסות שלו ('B').\n5.  **תהליך אב:** תהליך האב ימתין לכל התהליכים הבנים שיסיימו לפני שידפיס את הודעת הסיום שלו.\n\n**סעיף 101.2: שינוי במערך `nice_values` ל-`{5, 0, -5}`**\nהפלט הסביר ביותר יהיה:\n`CCCCCCCCCCBBBBBBBBBBAAAAAAAAAA\nParent finished.\n`\n**הסבר לשינוי:**\n1.  **קביעת עדיפויות חדשה:**\n    *   תהליך C נשאר עם `nice -5` (העדיפות הגבוהה ביותר).\n    *   תהליך B מקבל כעת `nice 0` (עדיפות בינונית).\n    *   תהליך A מקבל כעת `nice 5` (העדיפות הנמוכה ביותר).\n2.  **השפעה על הפלט:** העיקרון של תזמון מבוסס עדיפויות נשאר זהה. תהליך C בעל העדיפות הגבוהה ביותר עדיין ירוץ ויסיים ראשון, וידפיס את כל ה-'C'ים שלו. לאחר מכן, מבין תהליכים A ו-B, תהליך B (עם `nice 0`) הוא בעל עדיפות גבוהה יותר מתהליך A (עם `nice 5`). לכן, B ירוץ ויסיים את הדפסותיו לפני A, ולאחר מכן A ירוץ ויסיים. השינוי הוא שבלוק ההדפסות של 'B' יופיע לפני בלוק ההדפסות של 'A', במקום להיפך כמו במקרה המקורי.\n\n**סעיף 101.3: אלגוריתם תזמון FIFO לא מונע**\nבמצב של FIFO לא מונע, ברגע שתהליך מקבל את המעבד, הוא ירוץ עד לסיום משימתו (כלומר, עד שיצא מהלולאה ב-`child_task`) מבלי להיקטע. סדר ההדפסות יהיה תלוי בסדר שבו התהליכים הבנים נוצרו והוכנסו לתור המוכנים לריצה.\n\n**פלטים אפשריים:**\nהפלט היחיד האפשרי הוא:\n`AAAAAAAAAABBBBBBBBBBCCCCCCCCCC\nParent finished.\n`\n\n**הסבר:**\n1.  **סדר יצירת תהליכים:** בלולאה ב-`main`, התהליכים נוצרים בסדר הבא: A (עבור `i=0`), B (עבור `i=1`), ואז C (עבור `i=2`).\n2.  **הוספה לתור מוכנים (Ready Queue):** באופן טיפוסי, תהליכים חדשים שנוצרו (ילדים) מתווספים לסוף תור המוכנים. לכן, A יתווסף ראשון, ואחריו B, ואחריו C.\n3.  **תזמון FIFO לא מונע:** כאשר המעבד מתפנה (למשל, לאחר שתהליך האב מסיים את לולאת ה-`fork` שלו), הוא יבחר את התהליך הראשון בתור המוכנים. זה יהיה A. A ירוץ וישלים את כל 10 הדפסותיו ('A') ברצף. לאחר ש-A מסיים, המעבד יבחר את התהליך הבא בתור, שהוא B. B ירוץ וישלים את כל 10 הדפסותיו ('B') ברצף. לבסוף, C ירוץ וישלים את כל 10 הדפסותיו ('C') ברצף.\n4.  **הבדל מהותי:** במקרה המקורי, אלגוריתם התזמון היה מונע ומבוסס עדיפויות, ולכן העדיפויות קבעו את סדר ההרצה והשלמת המשימות. במקרה של FIFO לא מונע, העדיפויות שהוגדרו באמצעות `nice` אינן רלוונטיות כלל. סדר ההרצה נקבע אך ורק על פי סדר ההגעה לתור המוכנים (First-Come, First-Served), וברגע שתהליך מתחיל לרוץ הוא אינו נקטע (non-preemptive).",
      "difficulty_estimation": "Hard"
    }
  }
}