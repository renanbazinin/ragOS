{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 07:09:08",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2388,
      "output_tokens": 1381,
      "total_tokens": 6256
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "Context Switching"
    ],
    "content": {
      "text": "הסבירו בפירוט את ההבדלים העיקריים בביצוע החלפת הקשר (Context Switch) בין שני תהליכים (processes) שונים לבין החלפת הקשר בין שני חוטים (threads) השייכים לאותו תהליך. יש להתייחס למרכיבי ה-CPU השונים הנשמרים ומשוחזרים בכל אחד מהמקרים, ולדון בהשלכות הביצועים (performance implications) של הבדלים אלו.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "החלפת הקשר (Context Switch) היא תהליך שבו מערכת ההפעלה שומרת את מצבו של התהליך או החוט הרץ כעת, וטוענת את מצבו של תהליך או חוט אחר שצריך לרוץ. מטרתה היא לאפשר למספר משימות לרוץ במקביל למראית עין על מעבד יחיד.\n\n**הבדלים בין החלפת הקשר בין תהליכים (Processes) להחלפת הקשר בין חוטים (Threads) באותו תהליך:**\n\n1.  **זיכרון ומרחב כתובות:**\n    *   **החלפת קשר בין תהליכים:** כל תהליך פועל במרחב כתובות וירטואלי משלו, נפרד ומבודד. כאשר מתבצעת החלפת קשר בין תהליכים, מערכת ההפעלה חייבת לשמור ולשחזר את מצב יחידת ניהול הזיכרון (MMU), ובפרט את רגיסטר בסיס טבלת הדפים (Page Table Base Register). שינוי זה כרוך לרוב בניקוי מטמון ה-TLB (Translation Lookaside Buffer) ולעיתים גם השפעה על מטמון הנתונים/הוראות (CPU cache) עקב גישה למרחבי זיכרון שונים לחלוטין.\n    *   **החלפת קשר בין חוטים (באותו תהליך):** חוטים באותו תהליך חולקים את אותו מרחב כתובות וירטואלי. לכן, בעת החלפת קשר בין חוטים, אין צורך לשמור ולשחזר את רגיסטר בסיס טבלת הדפים או את מצב ה-MMU. ה-TLB וה-CPU cache נשארים רלוונטיים במידה רבה יותר.\n\n2.  **מצב CPU הנשמר ומשוחזר:**\n    *   **בשני המקרים (תהליכים וחוטים):** יש לשמור ולשחזר את המצב הספציפי לביצוע, הכולל:\n        *   **מונה התוכנית (Program Counter - PC):** כתובת ההוראה הבאה לביצוע.\n        *   **מצביע המחסנית (Stack Pointer - SP):** מצביע לראש המחסנית של התהליך/חוט.\n        *   **אוגרים כלליים (General Purpose Registers):** ערכי האוגרים ששימשו את התהליך/חוט.\n        *   **מילה מצב התוכנית (Program Status Word - PSW):** מכילה דגלים ומצב המעבד.\n    *   **נוסף עבור תהליכים (ולא חוטים):**\n        *   **מצב MMU / רגיסטר בסיס טבלת דפים:** כפי שתואר לעיל.\n        *   **מידע נוסף הקשור למשאבי מערכת:** כמו קבצים פתוחים, מזהי משתמש, מסכות אותות (signal masks) וכו'. חוטים חולקים את משאבי המערכת הללו בתוך התהליך.\n\n3.  **השלכות ביצועים:**\n    *   **החלפת קשר בין תהליכים יקרה יותר:** בגלל הצורך לשמור ולשחזר יותר מצב (במיוחד מצב ה-MMU וניקוי ה-TLB/cache), החלפת קשר בין תהליכים דורשת יותר זמן CPU. זה מוביל ל-\"Overhead\" גבוה יותר.\n    *   **החלפת קשר בין חוטים קלה ומהירה יותר:** מכיוון שחוטים חולקים את רוב משאבי התהליך (כולל מרחב הכתובות), פחות מצב צריך להישמר ולשחזר. זה הופך את החלפת הקשר למהירה ויעילה יותר, ולכן חוטים נחשבים למנגנון קל יותר (lightweight) ליישום מקביליות.\n    *   **השפעה על המערכת:** תדירות גבוהה של החלפות קשר, במיוחד בין תהליכים, עלולה להפחית את התפוקה הכללית של המערכת (throughput) ולהגדיל את זמן התגובה (latency) של משימות, מכיוון שחלק ניכר מזמן המעבד מבוזבז על ניהול ולא על ביצוע עבודה שימושית.\n\nלסיכום, ההבדל המרכזי בעלות הביצועים נובע מכך שתהליכים דורשים שינוי מלא של הקשר הזיכרון, בעוד שחוטים באותו תהליך חולקים אותו קשר זיכרון. לכן, חוטים מספקים דרך יעילה יותר לניצול מקביליות בתוך תהליך יחיד."
    },
    "difficulty_estimation": "Medium"
  }
}