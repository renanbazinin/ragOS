{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 00:06:52",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2316,
      "output_tokens": 2638,
      "total_tokens": 9678
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "CPU Scheduling",
      "Scheduling Algorithms",
      "Performance Analysis"
    ],
    "content": {
      "text": "נתונים ארבעה תהליכים (P1, P2, P3, P4) עם זמני הגעה, זמני ריצה (burst time) ורמות עדיפות, כפי שמוצג בטבלה הבאה. יש להניח שרמת עדיפות נמוכה יותר מצביעה על עדיפות גבוהה יותר (לדוגמה, עדיפות 1 גבוהה מעדיפות 2). בנוסף, כל תהליך דורש גישה למשאב משותף (למשל, קטע קריטי) למשך כל זמן הריצה שלו, ורק תהליך אחד יכול לגשת למשאב זה בכל רגע נתון.\n\n| תהליך | זמן הגעה | זמן ריצה | עדיפות |\n|--------|----------|----------|--------|\n| P1     | 0        | 8        | 3      |\n| P2     | 1        | 4        | 1      |\n| P3     | 2        | 9        | 4      |\n| P4     | 3        | 5        | 2      |\n\n1. חשבו את זמן ההמתנה הממוצע (Average Waiting Time) ואת זמן המחזור הממוצע (Average Turnaround Time) עבור התהליכים באמצעות אלגוריתם תזמון Priority Preemptive (עדיפות עם דריסה).\n2. חשבו את זמן ההמתנה הממוצע ואת זמן המחזור הממוצע עבור התהליכים באמצעות אלגוריתם תזמון Round Robin (RR) עם קוונטום זמן של 2 יחידות.\n3. בהתחשב בתוצאות שחישבתם, ובמגבלת המשאב המשותף, נתחו איזה אלגוריתם עשוי להיות עדיף במערכת עם תקורה גבוהה של החלפת הקשר (context switch overhead). נמקו את תשובתכם.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\n**1. אלגוריתם Priority Preemptive (עדיפות עם דריסה):**\n\n*   **זמן 0:** P1 מגיע (זמן ריצה=8, עדיפות=3). P1 מתחיל לרוץ.\n*   **זמן 1:** P2 מגיע (זמן ריצה=4, עדיפות=1). P2 בעל עדיפות גבוהה יותר מ-P1. P1 נדרס (רץ יחידת זמן אחת). P2 מתחיל לרוץ.\n*   **זמן 1-5:** P2 רץ את כל זמן הריצה שלו (4 יחידות). P2 מסיים בזמן 5.\n    *   P2: זמן מחזור = 5 - 1 = 4. זמן המתנה = 4 - 4 = 0.\n*   **זמן 2:** P3 מגיע (זמן ריצה=9, עדיפות=4).\n*   **זמן 3:** P4 מגיע (זמן ריצה=5, עדיפות=2).\n*   **זמן 5:** P2 מסיים. תהליכים מוכנים: P4 (עדיפות=2), P1 (עדיפות=3), P3 (עדיפות=4). P4 בעל העדיפות הגבוהה ביותר. P4 מתחיל לרוץ.\n*   **זמן 5-10:** P4 רץ את כל זמן הריצה שלו (5 יחידות). P4 מסיים בזמן 10.\n    *   P4: זמן מחזור = 10 - 3 = 7. זמן המתנה = 7 - 5 = 2.\n*   **זמן 10:** P4 מסיים. תהליכים מוכנים: P1 (עדיפות=3), P3 (עדיפות=4). P1 בעל העדיפות הגבוהה ביותר. P1 מתחיל לרוץ.\n*   **זמן 10-17:** P1 רץ את יתרת זמן הריצה שלו (7 יחידות, לאחר שרץ יחידה אחת בזמן 0-1). P1 מסיים בזמן 17.\n    *   P1: זמן מחזור = 17 - 0 = 17. זמן המתנה = 17 - 8 = 9.\n*   **זמן 17:** P1 מסיים. תהליכים מוכנים: P3 (עדיפות=4). P3 מתחיל לרוץ.\n*   **זמן 17-26:** P3 רץ את כל זמן הריצה שלו (9 יחידות). P3 מסיים בזמן 26.\n    *   P3: זמן מחזור = 26 - 2 = 24. זמן המתנה = 24 - 9 = 15.\n\n**סיכום Priority Preemptive:**\n*   P1: זמן המתנה = 9, זמן מחזור = 17\n*   P2: זמן המתנה = 0, זמן מחזור = 4\n*   P3: זמן המתנה = 15, זמן מחזור = 24\n*   P4: זמן המתנה = 2, זמן מחזור = 7\n\n**זמן המתנה ממוצע:** (9 + 0 + 15 + 2) / 4 = 26 / 4 = 6.5\n**זמן מחזור ממוצע:** (17 + 4 + 24 + 7) / 4 = 52 / 4 = 13\n\n**2. אלגוריתם Round Robin (RR) עם קוונטום זמן של 2 יחידות:**\n\n**תרשים גאנט:**\n0-2: P1 (נותר=6)\n2-4: P2 (נותר=2)\n4-6: P3 (נותר=7)\n6-8: P1 (נותר=4)\n8-10: P4 (נותר=3)\n10-12: P2 (נותר=0) -> P2 מסיים בזמן 12.\n    *   P2: זמן מחזור = 12 - 1 = 11. זמן המתנה = 11 - 4 = 7.\n12-14: P3 (נותר=5)\n14-16: P1 (נותר=2)\n16-18: P4 (נותר=1)\n18-20: P3 (נותר=3)\n20-22: P1 (נותר=0) -> P1 מסיים בזמן 22.\n    *   P1: זמן מחזור = 22 - 0 = 22. זמן המתנה = 22 - 8 = 14.\n22-23: P4 (נותר=0) -> P4 מסיים בזמן 23 (רץ יחידת זמן אחת).\n    *   P4: זמן מחזור = 23 - 3 = 20. זמן המתנה = 20 - 5 = 15.\n23-26: P3 (נותר=0) -> P3 מסיים בזמן 26 (רץ 3 יחידות זמן).\n    *   P3: זמן מחזור = 26 - 2 = 24. זמן המתנה = 24 - 9 = 15.\n\n**סיכום Round Robin:**\n*   P1: זמן המתנה = 14, זמן מחזור = 22\n*   P2: זמן המתנה = 7, זמן מחזור = 11\n*   P3: זמן המתנה = 15, זמן מחזור = 24\n*   P4: זמן המתנה = 15, זמן מחזור = 20\n\n**זמן המתנה ממוצע:** (14 + 7 + 15 + 15) / 4 = 51 / 4 = 12.75\n**זמן מחזור ממוצע:** (22 + 11 + 24 + 20) / 4 = 77 / 4 = 19.25\n\n**3. ניתוח והשוואה בהתחשב בתקורה של החלפת הקשר:**\n\nאלגוריתם Priority Preemptive הניב זמני המתנה ומחזור ממוצעים טובים יותר בדוגמה זו (6.5 ו-13 בהתאמה, לעומת 12.75 ו-19.25 ב-RR). במערכת עם תקורה גבוהה של החלפת הקשר (context switch overhead), אלגוריתם Priority Preemptive עשוי להיות עדיף.\n\nהסיבה לכך היא ש-Priority Preemptive מבצע החלפות הקשר רק כאשר מתקיים אחד משני תנאים עיקריים:\n1.  תהליך בעל עדיפות גבוהה יותר מגיע למערכת.\n2.  התהליך הנוכחי מסיים את ריצתו.\n\nלעומת זאת, Round Robin מבצע החלפת הקשר באופן מחזורי בתום כל קוונטום זמן, גם אם אין תהליך בעל עדיפות גבוהה יותר או תהליך אחר שדורש את המעבד. במקרה של קוונטום קטן (כמו 2 יחידות בדוגמה זו), מספר החלפות הקשר ב-Round Robin יהיה גבוה משמעותית. כל החלפת הקשר כרוכה בתקורה (זמן CPU מבוזבז על שמירת וטעינת הקשר של תהליכים), וכאשר התקורה גבוהה, מספר רב של החלפות קשר יגרום לבזבוז משאבי CPU משמעותי ויפגע בביצועים הכוללים של המערכת.\n\nלגבי מגבלת המשאב המשותף: באלגוריתם Priority Preemptive, קיימת סכנה למצב של היפוך עדיפויות (priority inversion) אם תהליך בעל עדיפות נמוכה מחזיק במשאב קריטי שתהליך בעל עדיפות גבוהה יותר ממתין לו, ולא קיימים מנגנונים מתאימים (כמו priority inheritance או priority ceiling protocol) לפתור זאת. במקרה כזה, היתרון בעדיפות נפגע. עם זאת, בהתייחס לשאלת תקורת החלפת הקשר בלבד, Priority Preemptive עדיין מבצע פחות החלפות קשר מבחינה תכנונית מאשר Round Robin עם קוונטום קטן, ולכן עשוי להיות עדיף במערכות רגישות לתקורה זו."
    },
    "difficulty_estimation": "Medium"
  }
}