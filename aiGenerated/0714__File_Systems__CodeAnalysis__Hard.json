{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 23:49:33",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3062,
      "output_tokens": 3070,
      "total_tokens": 14803
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "File Systems",
      "Hard Links",
      "Processes",
      "System Calls"
    ],
    "content": {
      "text": "נתונה תוכנית C הבאה המדגימה יצירת קובץ, קישורים קשיחים (hard links), פעולות מחיקה (unlink) וגישה לקובץ מתהליכים שונים.\nקראו את הקוד בעיון וענו על השאלות הבאות.\nיש להניח שכל קריאות המערכת מצליחות, ואין שגיאות I/O.\nיש להתייחס למערכת הפעלה מבוססת POSIX.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <sys/wait.h>\n\n#define FILENAME_ORIG \"exam_file_orig.txt\"\n#define FILENAME_LINK \"exam_file_link.txt\"\n#define BUF_SIZE 10\n\nint main() {\n    int fd_parent;\n    char buffer[BUF_SIZE];\n    pid_t pid;\n\n    // 1. Create a file and write initial content\n    fd_parent = open(FILENAME_ORIG, O_CREAT | O_TRUNC | O_RDWR, 0644);\n    if (fd_parent == -1) {\n        perror(\"open FILENAME_ORIG\");\n        return EXIT_FAILURE;\n    }\n    write(fd_parent, \"AAAABBBBCC\", BUF_SIZE); // Write 10 bytes\n    printf(\"Parent[%d]: Wrote 'AAAABBBBCC' to %s, fd_parent = %d\\n\", getpid(), FILENAME_ORIG, fd_parent);\n    fflush(stdout);\n\n    // 2. Create a hard link\n    if (link(FILENAME_ORIG, FILENAME_LINK) == -1) {\n        perror(\"link\");\n        close(fd_parent);\n        unlink(FILENAME_ORIG); // Clean up if link fails\n        return EXIT_FAILURE;\n    }\n    printf(\"Parent[%d]: Created hard link %s to %s\\n\", getpid(), FILENAME_LINK, FILENAME_ORIG);\n    fflush(stdout);\n\n    // 3. Unlink the original path name\n    if (unlink(FILENAME_ORIG) == -1) {\n        perror(\"unlink FILENAME_ORIG\");\n        close(fd_parent);\n        unlink(FILENAME_LINK); // Clean up\n        return EXIT_FAILURE;\n    }\n    printf(\"Parent[%d]: Unlinked original file path %s\\n\", getpid(), FILENAME_ORIG);\n    fflush(stdout);\n    // At this point, the file's link count is 1 (due to FILENAME_LINK)\n    // and it's still open via fd_parent.\n\n    // 4. Fork a child process\n    pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork\");\n        close(fd_parent);\n        unlink(FILENAME_LINK); // Clean up\n        return EXIT_FAILURE;\n    }\n\n    if (pid == 0) { // Child process\n        int fd_child;\n        printf(\"Child[%d]: Starting.\\n\", getpid());\n        fflush(stdout);\n\n        // Child closes its inherited fd_parent to ensure it opens a new one\n        close(fd_parent);\n\n        // Child opens the file via the hard link path\n        fd_child = open(FILENAME_LINK, O_RDWR);\n        if (fd_child == -1) {\n            perror(\"Child: open FILENAME_LINK\");\n            exit(EXIT_FAILURE);\n        }\n        printf(\"Child[%d]: Opened %s, fd_child = %d\\n\", getpid(), FILENAME_LINK, fd_child);\n        fflush(stdout);\n\n        // Child seeks and writes\n        lseek(fd_child, 0, SEEK_SET); // Seek to beginning\n        write(fd_child, \"XXXX\", 4);   // Overwrite first 4 bytes\n        printf(\"Child[%d]: Wrote 'XXXX' to file via fd_child\\n\", getpid());\n        fflush(stdout);\n\n        lseek(fd_child, 8, SEEK_SET); // Seek to offset 8\n        write(fd_child, \"YY\", 2);     // Overwrite bytes at offset 8, 9\n        printf(\"Child[%d]: Wrote 'YY' to file via fd_child\\n\", getpid());\n        fflush(stdout);\n\n        close(fd_child);\n        printf(\"Child[%d]: Closed fd_child.\\n\", getpid());\n        fflush(stdout);\n        exit(EXIT_SUCCESS);\n\n    } else { // Parent process\n        printf(\"Parent[%d]: Forked child with PID = %d\\n\", getpid(), pid);\n        fflush(stdout);\n\n        // Parent waits for child to finish\n        wait(NULL);\n        printf(\"Parent[%d]: Child finished.\\n\", getpid());\n        fflush(stdout);\n\n        // Parent writes to the file *after* child is done\n        // Parent's fd_parent still points to the file. Its offset is still at BUF_SIZE (10).\n        lseek(fd_parent, 4, SEEK_SET); // Seek to offset 4\n        write(fd_parent, \"ZZZ\", 3);    // Overwrite bytes at offset 4, 5, 6\n        printf(\"Parent[%d]: Wrote 'ZZZ' to file via fd_parent\\n\", getpid());\n        fflush(stdout);\n\n        // Parent reads the final content of the file\n        lseek(fd_parent, 0, SEEK_SET); // Seek to beginning to read\n        ssize_t bytes_read = read(fd_parent, buffer, BUF_SIZE);\n        if (bytes_read == -1) {\n            perror(\"Parent: read final content\");\n        } else {\n            buffer[bytes_read] = '\\0';\n            printf(\"Parent[%d]: Final content of the file: '%s'\\n\", getpid(), buffer);\n            fflush(stdout);\n        }\n\n        // 5. Unlink the hard link path\n        if (unlink(FILENAME_LINK) == -1) {\n            perror(\"unlink FILENAME_LINK\");\n        }\n        printf(\"Parent[%d]: Unlinked hard link path %s.\\n\", getpid(), FILENAME_LINK);\n        fflush(stdout);\n        // Now link count is 0. File data will be deallocated upon closing all FDs.\n\n        // 6. Close the parent's file descriptor\n        close(fd_parent);\n        printf(\"Parent[%d]: Closed fd_parent. File data should now be deallocated.\\n\", getpid());\n        fflush(stdout);\n\n        // Try to open the file paths to confirm they are gone\n        if (open(FILENAME_ORIG, O_RDONLY) == -1) {\n            printf(\"Parent[%d]: Confirmed %s is gone.\\n\", getpid(), FILENAME_ORIG);\n            fflush(stdout);\n        }\n        if (open(FILENAME_LINK, O_RDONLY) == -1) {\n            printf(\"Parent[%d]: Confirmed %s is gone.\\n\", getpid(), FILENAME_LINK);\n            fflush(stdout);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n**שאלות:**\n1.  מה יהיה התוכן הסופי של הקובץ כפי שייקרא על ידי תהליך האב בסוף הריצה (שורות 68-75)?\n2.  באיזה שלב, אם בכלל, נתוני הקובץ יפונו מהדיסק? הסבירו מדוע.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": 20,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "1.  **תוכן הקובץ הסופי:**\n    התוכן הסופי של הקובץ יהיה \"XXXXZZZBYY\".\n    \n    **הסבר מפורט:**\n    *   **אתחול (שורה 21):** הקובץ נוצר עם התוכן \"AAAABBBBCC\".\n        מצב הקובץ: `AAAABBBBCC`\n    *   **תהליך בן (Child process):**\n        *   הבן סוגר את `fd_parent` שירש ופותח מחדש את הקובץ דרך הקישור הקשיח `FILENAME_LINK` ומקבל `fd_child` (שורות 40-47). לכן, ל-`fd_parent` של האב ול-`fd_child` של הבן יש מצבי היסט קריאה/כתיבה (file offset) בלתי תלויים, למרות שהם מצביעים על אותו קובץ פיזי (אותו inode).\n        *   הבן מבצע `lseek(fd_child, 0, SEEK_SET)` וממקם את ההיסט בתחילת הקובץ. לאחר מכן כותב `\"XXXX\"` (שורה 50).\n            מצב הקובץ: `XXXXBBBBCC`\n        *   הבן מבצע `lseek(fd_child, 8, SEEK_SET)` וממקם את ההיסט במיקום 8. לאחר מכן כותב `\"YY\"` (שורה 54).\n            מצב הקובץ: `XXXXBBBBYY` (תווים 'C','C' נדרסים על ידי 'Y','Y').\n        *   הבן סוגר את `fd_child` ויוצא.\n    *   **תהליך אב (Parent process):**\n        *   האב ממתין שהבן יסיים (שורה 62).\n        *   האב מבצע `lseek(fd_parent, 4, SEEK_SET)` וממקם את ההיסט במיקום 4 (ההיסט של `fd_parent` נשאר 10 מהכתיבה הראשונית). לאחר מכן כותב `\"ZZZ\"` (שורה 66).\n            מצב הקובץ: `XXXXZZZBYY` (תווים 'B','B','B' נדרסים על ידי 'Z','Z','Z').\n        *   האב קורא את התוכן הסופי (שורות 68-75).\n\n2.  **פינוי נתוני הקובץ מהדיסק:**\n    נתוני הקובץ יפונו מהדיסק רק כאשר שני התנאים הבאים מתקיימים:\n    א.  מונה הקישורים (link count) של הקובץ מגיע ל-0.\n    ב.  אין יותר file descriptors פתוחים המצביעים על הקובץ.\n    \n    **ניתוח שלבי הפינוי בקוד:**\n    *   **שורה 32 (`unlink(FILENAME_ORIG)`):** קריאה זו מסירה את השם המקורי של הקובץ מספריית הקבצים. מונה הקישורים של הקובץ יורד מ-2 ל-1 (כי עדיין קיים הקישור הקשיח `FILENAME_LINK`). הקובץ עדיין נגיש דרך `FILENAME_LINK` ודרך `fd_parent` הפתוח.\n    *   **שורה 80 (`unlink(FILENAME_LINK)`):** קריאה זו מסירה גם את הקישור הקשיח `FILENAME_LINK` מספריית הקבצים. כעת, מונה הקישורים של הקובץ מגיע ל-0. אולם, נתוני הקובץ **עדיין לא מפוּנים מהדיסק** מכיוון ש-`fd_parent` עדיין פתוח בתהליך האב.\n    *   **שורה 86 (`close(fd_parent)`):** קריאה זו סוגרת את ה-file descriptor הפתוח האחרון המצביע על הקובץ. ברגע זה, מכיוון שגם מונה הקישורים הוא 0 וגם אין file descriptors פתוחים, מערכת ההפעלה תפנה את ה-inode ואת בלוקי הנתונים של הקובץ מהדיסק. כלומר, הקובץ מפונה רק בשלב זה."
    },
    "difficulty_estimation": "Hard"
  }
}