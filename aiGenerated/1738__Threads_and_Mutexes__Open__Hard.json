{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:26:02",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4527,
      "output_tokens": 2752,
      "total_tokens": 17950
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Threads",
      "Mutexes",
      "Synchronization",
      "Deadlock"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בחוטים (threads) ובמנעולים (mutexes) כדי לגשת ולעדכן שני משאבים משותפים: מונה (shared_counter) ורשימה מקושרת (shared_list). קוד התוכנית מוצג מטה. התוכנית מריצה מספר חוטים מסוג thread_A ומספר חוטים מסוג thread_B במקביל.\n\nא. זהה את הבעיה המרכזית בתוכנית הנתונה הנוגעת לטיפול במשאבים המשותפים.\nב. הסבר בפירוט מדוע בעיה זו עלולה להתרחש ומהם התנאים להופעתה.\nג. הצע פתרון לקוד הנתון כדי למנוע את הבעיה, והצג את השינויים הנדרשים בקוד (אין צורך להציג את כל הקוד מחדש, רק את הפונקציות שהשתנו).",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n\n// Shared resources\nint shared_counter = 0;\n\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\nNode* shared_list = NULL;\n\n// Mutexes for shared resources\npthread_mutex_t mutex_counter;\npthread_mutex_t mutex_list;\n\n// Function to add a node to the list\nvoid add_to_list(int val) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    if (new_node == NULL) {\n        perror(\"Failed to allocate node\");\n        exit(EXIT_FAILURE);\n    }\n    new_node->data = val;\n    new_node->next = shared_list;\n    shared_list = new_node;\n}\n\n// Function to remove a node from the list\nint remove_from_list() {\n    if (shared_list == NULL) {\n        return -1; // List is empty\n    }\n    Node* temp = shared_list;\n    int val = temp->data;\n    shared_list = shared_list->next;\n    free(temp);\n    return val;\n}\n\n// Thread A function: increments counter, then adds to list\nvoid* thread_A_func(void* arg) {\n    for (int i = 0; i < 5; ++i) {\n        pthread_mutex_lock(&mutex_counter);\n        shared_counter++;\n        printf(\"Thread A: Counter incremented to %d\\n\", shared_counter);\n        \n        pthread_mutex_lock(&mutex_list);\n        add_to_list(shared_counter);\n        printf(\"Thread A: Added %d to list\\n\", shared_counter);\n        pthread_mutex_unlock(&mutex_list);\n        \n        pthread_mutex_unlock(&mutex_counter);\n        usleep(100000); // Simulate work\n    }\n    return NULL;\n}\n\n// Thread B function: removes from list, then decrements counter\nvoid* thread_B_func(void* arg) {\n    for (int i = 0; i < 5; ++i) {\n        pthread_mutex_lock(&mutex_list);\n        int val = remove_from_list();\n        if (val != -1) {\n            printf(\"Thread B: Removed %d from list\\n\", val);\n            \n            pthread_mutex_lock(&mutex_counter);\n            shared_counter--;\n            printf(\"Thread B: Counter decremented to %d\\n\", shared_counter);\n            pthread_mutex_unlock(&mutex_counter);\n        } else {\n            printf(\"Thread B: List was empty, no decrement.\\n\");\n        }\n        pthread_mutex_unlock(&mutex_list);\n        usleep(100000); // Simulate work\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[4];\n    \n    pthread_mutex_init(&mutex_counter, NULL);\n    pthread_mutex_init(&mutex_list, NULL);\n\n    // Create two Thread A and two Thread B\n    pthread_create(&threads[0], NULL, thread_A_func, NULL);\n    pthread_create(&threads[1], NULL, thread_A_func, NULL);\n    pthread_create(&threads[2], NULL, thread_B_func, NULL);\n    pthread_create(&threads[3], NULL, thread_B_func, NULL);\n\n    for (int i = 0; i < 4; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final Counter: %d\\n\", shared_counter);\n    // Clean up remaining list nodes\n    while (shared_list != NULL) {\n        remove_from_list();\n    }\n\n    pthread_mutex_destroy(&mutex_counter);\n    pthread_mutex_destroy(&mutex_list);\n\n    return 0;\n}\n"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. הבעיה המרכזית בתוכנית הנתונה היא פוטנציאל ל**קיפאון (Deadlock)**.\n\nב. **הסבר לבעיה ותנאים להופעתה:**\nקיפאון יכול להתרחש במערכות מרובות חוטים המשתמשות במנעולים כאשר מתקיימים ארבעת התנאים ההכרחיים של הופעת קיפאון (תנאי קופמן):\n1.  **הדדיות (Mutual Exclusion):** המנעולים (`mutex_counter`, `mutex_list`) מאפשרים רק לחוט אחד להחזיק בהם בכל רגע נתון. תנאי זה מתקיים.\n2.  **החזק והמתן (Hold and Wait):** חוט יכול להחזיק במנעול אחד (או יותר) ובמקביל להמתין לרכישת מנעולים נוספים. תנאי זה מתקיים בקוד הנתון: חוט A רוכש את `mutex_counter` ומחזיק בו בזמן שהוא ממתין ל-`mutex_list`. חוט B רוכש את `mutex_list` ומחזיק בו בזמן שהוא ממתין ל-`mutex_counter`.\n3.  **אי-הפקעה (No Preemption):** מנעול שנרכש על ידי חוט לא יכול להילקח ממנו בכוח; הוא חייב להיות משוחרר מרצון על ידי החוט המחזיק בו. תנאי זה מתקיים על ידי ה-mutexes של POSIX Threads.\n4.  **המתנה מעגלית (Circular Wait):** קיימת שרשרת של שני חוטים או יותר, כאשר כל חוט בשרשרת ממתין למשאב שמוחזק על ידי החוט הבא בשרשרת. תנאי זה מתקיים בקוד הנתון:\n    *   חוט A רוכש את `mutex_counter` ואז מנסה לרכוש את `mutex_list`.\n    *   חוט B רוכש את `mutex_list` ואז מנסה לרכוש את `mutex_counter`.\n    \n    אם חוט A ירכוש את `mutex_counter` וחוט B ירכוש את `mutex_list` בו-זמנית (או בסמיכות זמנים), חוט A ימתין ל-`mutex_list` שמוחזק על ידי חוט B, וחוט B ימתין ל-`mutex_counter` שמוחזק על ידי חוט A. נוצר מעגל המתנה אינסופי, והתוכנית תיתקע.\n\nג. **פתרון מוצע ושינויים בקוד:**\nהדרך הנפוצה והיעילה ביותר למנוע קיפאון כזה היא לשבור את תנאי \"המתנה מעגלית\" על ידי הבטחה שכל החוטים ירכשו את המנעולים תמיד באותו סדר קבוע. במקרה זה, נבחר סדר קבוע: קודם `mutex_counter` ואז `mutex_list` (ניתן גם לבחור בסדר ההפוך, העיקר שיהיה עקבי בכל המקומות בהם נדרשים שני המנעולים).\n\n**שינויים נדרשים בפונקציית `thread_B_func`:**\nיש לשנות את סדר רכישת המנעולים בפונקציית `thread_B_func` כך שתתאים לסדר בפונקציית `thread_A_func`. כלומר, תחילה לרכוש את `mutex_counter` ולאחר מכן את `mutex_list`. יש לשחרר את המנעולים בסדר הפוך לסדר רכישתם.\n\n```c\n// Thread B function: removes from list, then decrements counter (FIXED ORDER)\nvoid* thread_B_func(void* arg) {\n    for (int i = 0; i < 5; ++i) {\n        pthread_mutex_lock(&mutex_counter); // Lock counter first (consistent order)\n        pthread_mutex_lock(&mutex_list);    // Then lock list (consistent order)\n        \n        int val = remove_from_list(); // Access list while both mutexes are held\n        if (val != -1) {\n            printf(\"Thread B: Removed %d from list\\n\", val);\n            shared_counter--; // Access counter while both mutexes are held\n            printf(\"Thread B: Counter decremented to %d\\n\", shared_counter);\n        } else {\n            printf(\"Thread B: List was empty, no decrement.\\n\");\n        }\n        \n        pthread_mutex_unlock(&mutex_list);    // Unlock list first (reverse order of locking)\n        pthread_mutex_unlock(&mutex_counter); // Then unlock counter\n        usleep(100000); // Simulate work\n    }\n    return NULL;\n}\n```\n\n**הסבר לפתרון:**\nעל ידי אכיפת סדר רכישת מנעולים עקבי (לדוגמה, תמיד קודם `mutex_counter` ואז `mutex_list`), אנו מונעים את התנאי ההכרחי לקיפאון של \"המתנה מעגלית\". כעת, אם חוט A מחזיק ב-`mutex_counter` וממתין ל-`mutex_list`, אף חוט B לא יוכל לרכוש את `mutex_counter` (כי הוא כבר תפוס) ולכן ימתין בתור. ברגע שחוט A ישחרר את שני המנעולים, חוט B יוכל לרכוש את `mutex_counter` ורק אז לנסות לרכוש את `mutex_list`. באופן זה, לא יכול להיווצר מצב שבו חוט A ממתין למנעול שמוחזק על ידי חוט B, בזמן שחוט B ממתין למנעול שמוחזק על ידי חוט A. זה מבטיח שהתוכנית תתקדם ותימנע מקיפאון."
    },
    "difficulty_estimation": "Hard"
  }
}