{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 11:55:43",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 4455,
      "total_tokens": 20034
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "Inter-process Communication",
      "Synchronization"
    ],
    "content": {
      "text": "מערכת ההפעלה מטילה עלינו משימה: עלינו לכתוב שני תהליכים, הורה וילד, אשר יתקשרו ביניהם באמצעות אותות (signals). תהליך הילד יבצע עבודה בלולאה אינסופית, מדפיס הודעה בכל איטרציה וממתין זמן קצר. תהליך ההורה אחראי לשלוט על ביצוע הילד באופן הבא:\n1.  ההורה ישלח אות לילד כדי להשהות את עבודתו.\n2.  לאחר שהילד ישהה את עצמו, הוא ישלח אות אישור חזרה להורה.\n3.  ההורה, לאחר קבלת האישור, ישלח אות נוסף לילד כדי שימשיך בעבודתו.\n4.  לאחר שהילד ימשיך, הוא ישלח אות אישור חזרה להורה.\n5.  מחזור השהיה-המשכה זה יחזור על עצמו מספר פעמים (לדוגמה, 3 פעמים).\n6.  בסיום המחזורים, ההורה ישלח אות לילד כדי לסיים את עבודתו באופן מבוקר (graceful termination).\n7.  ההורה ימתין לסיום הילד.\n\nיש להשתמש באותות `SIGUSR1`, `SIGUSR2` ו-`SIGTERM`.\n`SIGUSR1` ישמש לאותות השהיה/המשכה מההורה לילד.\n`SIGUSR2` ישמש לאותות אישור מהילד להורה.\n`SIGTERM` ישמש לאות סיום מבוקר מההורה לילד.\n\n**דרישות:**\n*   יש לממש את שני התהליכים (הורה וילד) בקובץ C/C++ יחיד.\n*   יש להשתמש בקריאות מערכת `fork()`, `kill()`, `sigaction()`, `sigprocmask()` ו-`sigsuspend()`.\n*   יש לוודא שהתהליכים ממתינים לאותות בצורה יעילה (ללא busy-waiting).\n*   יש לטפל במצבי מירוץ פוטנציאליים בין שליחת אותות לבין מוכנות התהליכים לקבלם, ולוודא סנכרון נכון.\n*   הילד צריך לצאת בצורה נקייה (gracefully) לאחר קבלת `SIGTERM`.\n\n**ממשו את הקוד המלא עבור שני התהליכים.**",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**הסבר כללי:**\nהפתרון כולל שני תהליכים: הורה וילד. ההורה יוצר את הילד ומשתמש באותות כדי לשלוט על מחזור העבודה שלו (השהיה, המשכה, סיום). הילד, מצידו, מטפל באותות אלו ומשתמש באותות אישור כדי ליידע את ההורה על מצבו. סנכרון בין התהליכים מושג באמצעות חסימת אותות ושימוש ב-`sigsuspend()` להמתנה יעילה.\n\n**תהליך ההורה:**\n1.  **יצירת ילד:** ההורה קורא ל-`fork()` ליצירת תהליך הילד.\n2.  **טיפול באותות אישור:** ההורה מגדיר מטפל לאות `SIGUSR2` (האות שהילד שולח לאישור). המטפל פשוט מעלה דגל גלובלי (`child_ack_received`).\n3.  **חסימת `SIGUSR2`:** ההורה חוסם את `SIGUSR2` בתחילה באמצעות `sigprocmask()` כדי לוודא שאינו מפספס אותות אישור מהילד לפני שהוא מוכן לטפל בהם, ובכדי ש-`sigsuspend()` יעבוד כהלכה. המסכה המקורית נשמרת לשחזור בסיום התהליך.\n4.  **מחזור השהיה-המשכה:**\n    *   ההורה שולח `SIGUSR1` לילד כדי להשהות אותו.\n    *   ההורה מנקה את דגל האישור ומשתמש בלולאת `while` עם `sigsuspend()` כדי להמתין לאות `SIGUSR2` מהילד. `sigsuspend()` מבטל זמנית את חסימת `SIGUSR2` בזמן ההמתנה, וחוזר לחסום אותו לאחר קבלת האות. כדי להמתין רק ל-`SIGUSR2`, ה-`sigsuspend()` מופעל עם מסכה שחוסמת את כל האותות פרט ל-`SIGUSR2`.\n    *   לאחר קבלת אישור ההשהיה, ההורה שולח שוב `SIGUSR1` לילד כדי להמשיך אותו.\n    *   ההורה שוב מנקה את דגל האישור ומשתמש בלולאת `while` עם `sigsuspend()` להמתין לאות `SIGUSR2` מהילד.\n5.  **סיום הילד:** לאחר מספר מחזורים, ההורה שולח `SIGTERM` לילד וממתין לסיומו באמצעות `waitpid()`.\n\n**תהליך הילד:**\n1.  **טיפול באותות:** הילד מגדיר מטפלים לאותות `SIGUSR1` ו-`SIGTERM`.\n    *   **מטפל `SIGUSR1`:** מטפל זה משנה דגל גלובלי (`is_paused`) בין מצב 'מושהה' ל'רץ'. לאחר שינוי המצב, הוא שולח `SIGUSR2` להורה לאישור.\n    *   **מטפל `SIGTERM`:** מטפל זה מדפיס הודעת סיום ויוצא מהתהליך באמצעות `_exit(0)`. חשוב להשתמש ב-`_exit()` ולא ב-`exit()` בתוך מטפל אותות כדי למנוע בעיות עם פלאשינג באפרים או קריאות לא בטוחות.\n2.  **חסימת אותות:** הילד חוסם את `SIGUSR1` ו-`SIGTERM` בתחילה. זה חשוב כדי למנוע קבלת אותות לפני שהמטפלים הוגדרו, וכן כדי לשלוט מתי הילד יכול לקבל אותות אלו (לדוגמה, לא לקבל אותות השהיה/המשכה באמצע קטע קריטי אם היה כזה).\n3.  **לולאת עבודה ראשית:**\n    *   הלולאה מדפיסה הודעה וממתינה שניה.\n    *   בכל איטרציה, לפני ביצוע העבודה בפועל, הילד בודק את הדגל `is_paused`.\n    *   אם `is_paused` הוא `true`, הילד נכנס ללולאת המתנה: הוא משתמש ב-`sigsuspend()` כדי להמתין לאות `SIGUSR1` שישנה את מצב ה-`is_paused` בחזרה ל-`false`. `sigsuspend()` יבטל זמנית את חסימת `SIGUSR1` (ו-`SIGTERM` כדי לאפשר סיום גם במצב השהיה) בזמן ההמתנה. לאחר קבלת האות, המסכה המקורית (שחוסמת את `SIGUSR1` ו-`SIGTERM`) משוחזרת.\n    *   לאחר שהילד יוצא ממצב השהיה, הוא ממשיך בלולאה. המסכה שחוסמת את `SIGUSR1` ו-`SIGTERM` משוחזרת כדי להגן על קטע העבודה.\n\n**נקודות חשובות לפתרון בעיות סנכרון ומרוץ:**\n*   **`sig_atomic_t`:** השימוש במשתנים מסוג `sig_atomic_t` עבור דגלים המשותפים בין הקוד הראשי למטפלי אותות מבטיח שגישה אליהם תהיה אטומית ולא תיפסק על ידי אות.\n*   **`sigsuspend()`:** קריאת מערכת זו חיונית להמתנה יעילה לאותות. היא משנה את מסיכת האותות באופן אטומי, ממתינה לאות שאינו חסום, ואז משחזרת את המסיכה המקורית. זה מונע מצב של מרוץ שבו אות נשלח בדיוק בין בדיקת דגל לבין קריאה ל-`pause()`.\n*   **חסימת אותות ראשונית:** חסימת האותות בתחילת שני התהליכים מבטיחה שהם לא יקבלו אותות לפני שהם מוכנים לטפל בהם, ובכך מונעת התנהגות בלתי צפויה.\n*   **`_exit()` במטפל:** שימוש ב-`_exit()` במטפל של `SIGTERM` הוא קריטי כדי למנוע קריאות לפונקציות לא בטוחות בתוך מטפל אותות, מה שעלול להוביל ל-deadlocks או קריסות.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n\n// Global flags for signal handling\nvolatile sig_atomic_t child_ack_received = 0; // Parent uses this to wait for child's ack\nvolatile sig_atomic_t is_paused = 0;          // Child uses this to toggle pause state\n\n// Signal handler for parent (SIGUSR2 from child)\nvoid parent_sigusr2_handler(int signum) {\n    printf(\"[Parent] Received SIGUSR2 (ACK) from child.\\n\");\n    child_ack_received = 1;\n}\n\n// Signal handler for child (SIGUSR1 from parent)\nvoid child_sigusr1_handler(int signum) {\n    if (is_paused) {\n        printf(\"[Child] Received SIGUSR1 - Resuming work.\\n\");\n        is_paused = 0; // Toggle to resume\n    } else {\n        printf(\"[Child] Received SIGUSR1 - Pausing work.\\n\");\n        is_paused = 1; // Toggle to pause\n    }\n    // Send confirmation to parent\n    kill(getppid(), SIGUSR2);\n}\n\n// Signal handler for child (SIGTERM from parent)\nvoid child_sigterm_handler(int signum) {\n    printf(\"[Child] Received SIGTERM - Terminating gracefully.\\n\");\n    _exit(0); // Use _exit for signal handlers\n}\n\nint main() {\n    pid_t pid;\n    int i;\n    int num_cycles = 3;\n\n    // --- Setup signal handlers for parent --- \n    struct sigaction sa_parent_usr2;\n    sa_parent_usr2.sa_handler = parent_sigusr2_handler;\n    sigemptyset(&sa_parent_usr2.sa_mask);\n    sa_parent_usr2.sa_flags = 0;\n    if (sigaction(SIGUSR2, &sa_parent_usr2, NULL) == -1) {\n        perror(\"sigaction parent SIGUSR2\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Block SIGUSR2 in parent initially\n    sigset_t parent_block_mask, old_parent_mask;\n    sigemptyset(&parent_block_mask);\n    sigaddset(&parent_block_mask, SIGUSR2);\n    if (sigprocmask(SIG_BLOCK, &parent_block_mask, &old_parent_mask) == -1) {\n        perror(\"sigprocmask parent initial block\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        exit(EXIT_FAILURE);\n    } else if (pid == 0) { // Child process\n        // --- Setup signal handlers for child ---\n        struct sigaction sa_child_usr1, sa_child_term;\n\n        // Handler for SIGUSR1 (pause/resume)\n        sa_child_usr1.sa_handler = child_sigusr1_handler;\n        sigemptyset(&sa_child_usr1.sa_mask);\n        sa_child_usr1.sa_flags = 0;\n        if (sigaction(SIGUSR1, &sa_child_usr1, NULL) == -1) {\n            perror(\"sigaction child SIGUSR1\");\n            _exit(EXIT_FAILURE);\n        }\n\n        // Handler for SIGTERM (terminate)\n        sa_child_term.sa_handler = child_sigterm_handler;\n        sigemptyset(&sa_child_term.sa_mask);\n        sa_child_term.sa_flags = 0;\n        if (sigaction(SIGTERM, &sa_child_term, NULL) == -1) {\n            perror(\"sigaction child SIGTERM\");\n            _exit(EXIT_FAILURE);\n        }\n\n        // Block SIGUSR1 and SIGTERM in child initially\n        sigset_t child_block_mask;\n        sigemptyset(&child_block_mask);\n        sigaddset(&child_block_mask, SIGUSR1);\n        sigaddset(&child_block_mask, SIGTERM);\n        if (sigprocmask(SIG_BLOCK, &child_block_mask, NULL) == -1) {\n            perror(\"sigprocmask child initial block\");\n            _exit(EXIT_FAILURE);\n        }\n\n        printf(\"[Child] Child process started (PID: %d). Parent PID: %d\\n\", getpid(), getppid());\n\n        while (1) {\n            // Prepare mask for sigsuspend: unblock SIGUSR1 and SIGTERM\n            // This mask will temporarily replace the current mask during sigsuspend\n            sigset_t suspend_unblock_mask;\n            sigfillset(&suspend_unblock_mask); // Block all signals initially\n            sigdelset(&suspend_unblock_mask, SIGUSR1); // Unblock SIGUSR1 to allow pause/resume\n            sigdelset(&suspend_unblock_mask, SIGTERM); // Unblock SIGTERM to allow termination even while paused\n\n            // Critical section: check if paused. If so, wait for SIGUSR1.\n            while (is_paused) {\n                printf(\"[Child] Paused. Waiting for resume/terminate signal...\\n\");\n                sigsuspend(&suspend_unblock_mask); // Atomically replace mask and wait\n            }\n            \n            // Re-block SIGUSR1 and SIGTERM while working, to avoid interruptions\n            sigprocmask(SIG_BLOCK, &child_block_mask, NULL);\n\n            printf(\"[Child] Working... (PID: %d)\\n\", getpid());\n            sleep(1);\n        }\n\n    } else { // Parent process\n        printf(\"[Parent] Parent process started (PID: %d). Child PID: %d\\n\", getpid(), pid);\n\n        // Give child a moment to set up its signal handlers\n        sleep(1); // Important for child to be ready to receive signals\n\n        for (i = 0; i < num_cycles; i++) {\n            printf(\"[Parent] Sending SIGUSR1 to child (PID: %d) to PAUSE.\\n\", pid);\n            child_ack_received = 0; // Reset flag\n            kill(pid, SIGUSR1);\n            \n            // Prepare mask for sigsuspend: unblock SIGUSR2\n            // This mask will temporarily replace the current mask during sigsuspend\n            sigset_t suspend_unblock_ack_mask;\n            sigfillset(&suspend_unblock_ack_mask); // Block all signals initially\n            sigdelset(&suspend_unblock_ack_mask, SIGUSR2); // Unblock SIGUSR2 to allow ACK\n\n            // Wait for child's ACK (SIGUSR2)\n            while (!child_ack_received) {\n                printf(\"[Parent] Waiting for child to confirm PAUSE...\\n\");\n                sigsuspend(&suspend_unblock_ack_mask); // Atomically replace mask and wait\n            }\n            printf(\"[Parent] Child confirmed PAUSE.\\n\");\n            sleep(1); // Give some time for observation\n\n            printf(\"[Parent] Sending SIGUSR1 to child (PID: %d) to RESUME.\\n\", pid);\n            child_ack_received = 0; // Reset flag\n            kill(pid, SIGUSR1);\n\n            // Wait for child's ACK (SIGUSR2)\n            while (!child_ack_received) {\n                printf(\"[Parent] Waiting for child to confirm RESUME...\\n\");\n                sigsuspend(&suspend_unblock_ack_mask); // Atomically replace mask and wait\n            }\n            printf(\"[Parent] Child confirmed RESUME.\\n\");\n            sleep(1); // Give some time for observation\n        }\n\n        printf(\"[Parent] All pause/resume cycles completed. Sending SIGTERM to child (PID: %d).\\n\", pid);\n        kill(pid, SIGTERM);\n\n        // Wait for child to terminate\n        int status;\n        if (waitpid(pid, &status, 0) == -1) {\n            perror(\"waitpid\");\n            exit(EXIT_FAILURE);\n        }\n\n        if (WIFEXITED(status)) {\n            printf(\"[Parent] Child (PID: %d) terminated with status %d.\\n\", pid, WEXITSTATUS(status));\n        } else if (WIFSIGNALED(status)) {\n            printf(\"[Parent] Child (PID: %d) terminated by signal %d.\\n\", pid, WTERMSIG(status));\n        }\n\n        // Restore original signal mask for parent (good practice)\n        if (sigprocmask(SIG_SETMASK, &old_parent_mask, NULL) == -1) {\n            perror(\"sigprocmask parent restore\");\n            exit(EXIT_FAILURE);\n        }\n\n        printf(\"[Parent] Parent process exiting.\\n\");\n    }\n\n    return 0;\n}\n```",
      "difficulty_estimation": "Hard"
    }
  }
}