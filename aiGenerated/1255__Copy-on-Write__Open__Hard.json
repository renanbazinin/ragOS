{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:00:40",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4965,
      "output_tokens": 3901,
      "total_tokens": 20032
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Memory Management",
      "File Systems",
      "Copy-on-Write"
    ],
    "content": {
      "text": "במערכת קבצים היפותטית בשם CoWFS, מיושם מנגנון Copy-on-Write (CoW) הן להעתקת קבצים והן לניהול זיכרון של קבצים ממופים (memory-mapped files) באמצעות `mmap` ו-`fork`. גודל בלוק במערכת הוא 4KB.\n\nלכל בלוק נתונים (DATA) בדיסק, נשמר מונה הפניות (reference count) באזור נפרד בדיסק, כאשר כל מונה תופס 2 בתים (ומאפשר עד 65,535 הפניות). פעולות על מוני הפניות דורשות קריאה וכתיבה לבלוקים המתאימים באזור זה.\n\n**התנהגות CoWFS:**\n*   **העתקת קובץ:** יוצרת inode חדש, מעתיקה את מצביעי הבלוקים מהקובץ המקורי, ומגדילה את מוני ההפניות לכל בלוקי הנתונים המשותפים. אין שיבוט פיזי של בלוקי הנתונים. אם הקובץ המקורי היה פתוח ב-`mmap` במצב CoW, הקובץ החדש גם יחלוק את אותם בלוקים פיזיים.\n*   **מחיקת קובץ:** מקטינה את מוני ההפניות לכל הבלוקים אליהם מצביע ה-inode. אם מונה הפניות של בלוק מגיע ל-0, הבלוק משוחרר וניתן לשימוש חוזר.\n*   **עדכון נתוני קובץ (דרך כתיבה רגילה או `msync` מקובץ ממופה):**\n    *   אם בלוק הנתונים שאליו מתייחסת הכתיבה משותף (מונה הפניות > 1), מוקצה בלוק נתונים חדש בדיסק. נתוני הבלוק המעודכנים נכתבים לבלוק החדש. מונה ההפניות של הבלוק המקורי מופחת ב-1. מונה ההפניות של הבלוק החדש מוגדר ל-1. ה-inode של הקובץ המעודכן מתעדכן להצביע לבלוק החדש.\n    *   אם בלוק הנתונים אינו משותף (מונה הפניות = 1), נתוני הבלוק המעודכנים נכתבים ישירות לבלוק הקיים.\n*   **`mmap` ו-`fork`:** כאשר קובץ ממופה לזיכרון (`mmap`) או כאשר תהליך עובר `fork` והזיכרון משוכפל ב-CoW, נוצרות מפות CoW ברמת זיכרון פיזי (דפים פיזיים). שינויים בדף כזה על ידי תהליך מסוים גורמים להקצאת דף פיזי חדש בזיכרון RAM עבור התהליך המבצע את הכתיבה (CoW ברמת הזיכרון). שינויים אלו אינם משפיעים מיד על הדיסק או על מוני ההפניות של בלוקי הנתונים בדיסק, אלא רק בעת קריאה ל-`msync` או `munmap`.\n\n**נתונים נוספים:**\n*   inode מכיל 10 מצביעים ישירים, מצביע אחד עקיף, ומצביע אחד עקיף כפול. גודל מצביע הוא 4 בתים.\n*   יש להניח קיום של data bitmap נפרד המשמש לאיתור בלוקים פנויים והקצאתם. (פעולות על ה-bitmap דורשות קריאה וכתיבה לבלוק מתאים).\n*   בחישוב I/O, יש להניח שאין cache (למעט דפי זיכרון פרטיים של תהליכים).\n\n**תרחיש:**\n1.  יוצרים קובץ בשם `fileA` בגודל 8KB.\n2.  מעתיקים את `fileA` ל-`fileB`.\n3.  תהליך P1 מבצע `mmap` ל-`fileA` במצב קריאה/כתיבה.\n4.  P1 מבצע `fork` ויוצר את תהליך P2.\n5.  P1 כותב בית בודד לבלוק הנתונים הראשון של `fileA` דרך המיפוי שלו.\n6.  P2 כותב בית בודד לבלוק הנתונים הראשון של `fileA` דרך המיפוי שלו.\n7.  P1 קורא ל-`msync` על האזור ששונה.\n8.  P2 קורא ל-`msync` על האזור ששונה.\n9.  מוחקים את `fileB`.\n\nיש לפרט ולנמק את כל החישובים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "כמה בלוקי נתונים פיזיים בדיסק נמצאים בשימוש לאחר כל הפעולות בתרחיש? פרט את מצב הבלוקים ומוני ההפניות שלהם.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "עבור פעולת ה-`msync` של תהליך P1 (שלב 7 בתרחיש), מהו המספר המקסימלי של פעולות קריאה וכתיבה לדיסק הנדרשות? יש לפרט את כל הבלוקים הנקראים ונכתבים (inode block, reference count block, data bitmap block, data block) ולהניח את המקרה הגרוע ביותר (ללא cache).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "תאר את מצב דפי הזיכרון הפיזיים (RAM) המתאימים לבלוק הנתונים הראשון של `fileA` עבור תהליכים P1 ו-P2, *מיד לפני* ש-P1 קורא ל-`msync` (כלומר, לאחר שלב 6). כמה דפים פיזיים קיימים, ולאיזה תהליך הם שייכים (אם בכלל)?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פירוט מצב המערכת לאורך התרחיש:\n*   **התחלה:** 0 בלוקי נתונים.\n*   **1. יצירת `fileA` (8KB):** `fileA` מקבל inode. מוקצים שני בלוקי נתונים (נקרא להם DB1 ו-DB2). מוני הפניות: RC(DB1)=1, RC(DB2)=1. סה\"כ: 2 בלוקי נתונים.\n*   **2. העתקת `fileA` ל-`fileB`:** `fileB` מקבל inode חדש. מצביעי ה-inode של `fileB` מצביעים ל-DB1 ו-DB2. מוני הפניות: RC(DB1)=2, RC(DB2)=2. סה\"כ: 2 בלוקי נתונים.\n*   **3. P1 `mmap` ל-`fileA`:** מערכת ההפעלה ממפה את DB1 ו-DB2 למרחב הזיכרון הווירטואלי של P1 כדפים מסומנים CoW. אין שינוי בבלוקי דיסק או מוני הפניות.\n*   **4. P1 `fork` P2:** P2 מקבל עותק CoW של מרחב הזיכרון הווירטואלי של P1, כולל המיפויים ל-DB1 ו-DB2. אין שינוי בבלוקי דיסק או מוני הפניות.\n*   **5. P1 כותב בית בודד לבלוק הנתונים הראשון של `fileA`:** מתרחשת תקלת דף (page fault). דף זיכרון פיזי חדש (נקרא לו PM1_priv) מוקצה עבור P1. תוכן DB1 מועתק אליו (אם לא היה ב-cache). P1 כותב ל-PM1_priv. PM1_priv שייך ל-P1. אין שינוי בבלוקי דיסק או מוני הפניות.\n*   **6. P2 כותב בית בודד לבלוק הנתונים הראשון של `fileA`:** מתרחשת תקלת דף. דף זיכרון פיזי חדש (נקרא לו PM2_priv) מוקצה עבור P2. תוכן DB1 מועתק אליו (אם לא היה ב-cache). P2 כותב ל-PM2_priv. PM2_priv שייך ל-P2. אין שינוי בבלוקי דיסק או מוני הפניות.\n\n**1.1: בלוקי נתונים פיזיים לאחר כל הפעולות:**\n*   **7. P1 קורא ל-`msync`:** PM1_priv נכתב לדיסק. הבלוק המקביל ב-`fileA` הוא DB1. RC(DB1)=2 (משותף עם `fileB`). לכן, מוקצה בלוק נתונים חדש (נקרא לו DB3). תוכן PM1_priv נכתב ל-DB3. RC(DB1) יורד ל-1. RC(DB3) נקבע ל-1. ה-inode של `fileA` מתעדכן להצביע ל-DB3 במקום DB1 עבור הבלוק הראשון. מצב בלוקים: DB1, DB2, DB3. מוני הפניות: RC(DB1)=1, RC(DB2)=2, RC(DB3)=1. סה\"כ: 3 בלוקי נתונים.\n*   **8. P2 קורא ל-`msync`:** PM2_priv נכתב לדיסק. הבלוק המקביל ב-`fileA` עבור הבלוק הראשון הוא כעת DB3 (לאחר ה-`msync` של P1). RC(DB3)=1 (לא משותף). לכן, תוכן PM2_priv נכתב ישירות ל-DB3, תוך דריסת השינויים של P1. אין הקצאת בלוקים חדשים או שינוי מוני הפניות. מצב בלוקים: DB1, DB2, DB3. מוני הפניות: RC(DB1)=1, RC(DB2)=2, RC(DB3)=1. סה\"כ: 3 בלוקי נתונים.\n*   **9. מחיקת `fileB`:** ה-inode של `fileB` נמחק. מוני ההפניות לבלוקים ש-`fileB` הצביע אליהם (DB1 ו-DB2) מופחתים ב-1. RC(DB1) יורד ל-0, ולכן DB1 משוחרר. RC(DB2) יורד ל-1. מצב בלוקים: DB2, DB3. מוני הפניות: RC(DB2)=1, RC(DB3)=1. סה\"כ: 2 בלוקי נתונים.\n\n**תשובה סופית ל-1.1:** לאחר כל הפעולות, ישנם **2** בלוקי נתונים פיזיים בשימוש בדיסק (DB2 ו-DB3).\n\n**1.2: I/O מקסימלי עבור `msync` של P1:**\nהפעולות הנדרשות: (הנחה: כל קריאה/כתיבה לבלוק נפרד נחשבת כפעולת I/O אחת)\n1.  **קריאת בלוק ה-inode של `fileA`:** כדי לדעת לאיזה בלוק נתונים (DB1) הוא מצביע כעת. (1 קריאה)\n2.  **קריאת בלוק מוני הפניות המכיל את RC(DB1):** כדי לבדוק אם DB1 משותף. (1 קריאה)\n3.  **הקצאת בלוק נתונים חדש (DB3):**\n    *   קריאת בלוק ה-data bitmap כדי למצוא מקום פנוי. (1 קריאה)\n    *   כתיבת בלוק ה-data bitmap כדי לסמן את DB3 כתפוס. (1 כתיבה)\n4.  **כתיבת נתונים מ-PM1_priv ל-DB3:** (1 כתיבה)\n5.  **עדכון RC(DB1) ל-1:**\n    *   קריאת בלוק מוני הפניות המכיל את RC(DB1). (1 קריאה - נניח ללא cache)\n    *   כתיבת בלוק מוני הפניות המכיל את RC(DB1) המעודכן. (1 כתיבה)\n6.  **עדכון RC(DB3) ל-1:**\n    *   קריאת בלוק מוני הפניות המכיל את RC(DB3). (1 קריאה)\n    *   כתיבת בלוק מוני הפניות המכיל את RC(DB3) המעודכן. (1 כתיבה)\n7.  **עדכון בלוק ה-inode של `fileA`:** שינוי המצביע מ-DB1 ל-DB3.\n    *   קריאת בלוק ה-inode של `fileA`. (1 קריאה - נניח ללא cache)\n    *   כתיבת בלוק ה-inode של `fileA` המעודכן. (1 כתיבה)\n\n**תשובה סופית ל-1.2:** סה\"כ **6** פעולות קריאה ו-**5** פעולות כתיבה לדיסק.\n\n**1.3: מצב דפי הזיכרון הפיזיים לאחר שלב 6:**\nלאחר שגם P1 וגם P2 כתבו לבלוק הנתונים הראשון של `fileA` (שבמקור היה DB1 בדיסק), נוצרו שלושה דפי זיכרון פיזיים ב-RAM הקשורים לנתונים אלו:\n1.  **דף פיזי מקורי (PM_DB1_shared):** דף זה מכיל את התוכן המקורי, הבלתי משונה, של DB1. הוא נשמר במטמון הדפים של הליבה (kernel page cache) ואינו ממופה עוד למרחב הזיכרון הווירטואלי של P1 או P2 עבור בלוק זה במצב כתיבה. הוא עדיין יכול להיות נגיש למטרות קריאה או לתהליכים אחרים שטרם שינו את הבלוק.\n2.  **דף פיזי פרטי של P1 (PM1_priv):** דף זה מכיל את העותק של P1 לתוכן DB1, בתוספת השינויים ש-P1 ביצע. הוא ממופה למרחב הזיכרון הווירטואלי של P1 עבור הבלוק הראשון של `fileA`. דף זה שייך באופן בלעדי ל-P1.\n3.  **דף פיזי פרטי של P2 (PM2_priv):** דף זה מכיל את העותק של P2 לתוכן DB1, בתוספת השינויים ש-P2 ביצע. הוא ממופה למרחב הזיכרון הווירטואלי של P2 עבור הבלוק הראשון של `fileA`. דף זה שייך באופן בלעדי ל-P2.\n\n**תשובה סופית ל-1.3:** קיימים **3** דפים פיזיים ב-RAM הקשורים לבלוק הנתונים הראשון של `fileA`. דף אחד מכיל את התוכן המקורי (PM_DB1_shared), ואינו שייך באופן בלעדי לאף תהליך. דף אחד (PM1_priv) שייך ל-P1, ודף אחד (PM2_priv) שייך ל-P2."
    },
    "difficulty_estimation": "Hard"
  }
}