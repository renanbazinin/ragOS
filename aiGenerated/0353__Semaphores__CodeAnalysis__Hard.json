{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 21:46:43",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3751,
      "output_tokens": 1892,
      "total_tokens": 13032
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Semaphores",
      "Deadlock",
      "Concurrency",
      "Resource Management"
    ],
    "content": {
      "text": "נתונה מערכת המכילה N יחידות ממשאב A ו-M יחידות ממשאב B (כאשר N, M > 0). קיימים K חוטי עבודה (worker threads) המנסים במקביל לרכוש יחידה אחת מכל משאב (גם A וגם B) על מנת לבצע משימה כלשהי. לאחר סיום המשימה, החוטים משחררים את המשאבים. הקוד הבא מציג את לוגיקת הרכישה והשחרור של המשאבים עבור חוט עבודה יחיד.",
      "code_snippet": "// גלובליים:\n// sem_t sem_A; // מאותחל ל-N\n// sem_t sem_B; // מאותחל ל-M\n\nvoid worker_thread_func_type1() {\n    // שלב 1: רכישת משאבים\n    sem_wait(&sem_A);\n    sem_wait(&sem_B);\n\n    // שלב 2: ביצוע המשימה (משתמש במשאבים A ו-B)\n    do_task(); // פונקציה המייצגת את העבודה, אינה משפיעה על הסנכרון\n\n    // שלב 3: שחרור משאבים\n    sem_post(&sem_B);\n    sem_post(&sem_A);\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "הניחו שכל K חוטי העבודה מריצים את הפונקציה `worker_thread_func_type1` בלבד. האם במצב זה עלול להיווצר קיפאון (Deadlock)? נמקו את תשובתכם.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "כעת הניחו שבמערכת קיימים שני סוגים של חוטי עבודה: סוג 1 מריץ את `worker_thread_func_type1` (כפי שמוצג לעיל), וסוג 2 מריץ את הפונקציה `worker_thread_func_type2` הבאה:\n```c\nvoid worker_thread_func_type2() {\n    sem_wait(&sem_B);\n    sem_wait(&sem_A);\n    do_task();\n    sem_post(&sem_A);\n    sem_post(&sem_B);\n}\n```\nהאם במצב זה (כאשר שני הסוגים של החוטים רצים במקביל) עלול להיווצר קיפאון? אם כן, תארו תרחיש ספציפי המוביל לקיפאון והסבירו מדוע הוא מתרחש. אם לא, נמקו מדוע.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "הציעו שינוי מינימלי בקוד של אחת הפונקציות (למשל, `worker_thread_func_type2`), או הוספת סמפור/מנעול נוסף, על מנת למנוע קיפאון במערכת המתוארת בסעיף 2, מבלי לפגוע ביעילות ובמקביליות מעבר לנדרש. הציגו את הקוד המתוקן והסבירו כיצד הוא מונע קיפאון.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון שאלה 10:\n\n**סעיף 10.1:**\nלא, במצב זה לא עלול להיווצר קיפאון. קיפאון (Deadlock) דורש קיום של ארבעה תנאים בו-זמנית: מניעה הדדית (Mutual Exclusion), החזקה והמתנה (Hold and Wait), אי-יכולת לדרוס (No Preemption), והמתנה מעגלית (Circular Wait). במקרה זה, כל חוטי העבודה רוכשים את המשאבים באותו סדר קבוע (קודם A, אחר כך B). סדר רכישה עקבי זה מונע את התנאי של המתנה מעגלית, ולכן לא יכול להתרחש קיפאון.\n\n**סעיף 10.2:**\nכן, במצב זה עלול להיווצר קיפאון. התרחיש הבא מדגים זאת:\n1. חוט עבודה מסוג 1 (T1) מבצע `sem_wait(&sem_A)` ומצליח לרכוש יחידה מ-A.\n2. חוט עבודה מסוג 2 (T2) מבצע `sem_wait(&sem_B)` ומצליח לרכוש יחידה מ-B.\n3. כעת, T1 מנסה לבצע `sem_wait(&sem_B)` אך נחסם מכיוון ש-B נרכש על ידי T2.\n4. במקביל, T2 מנסה לבצע `sem_wait(&sem_A)` אך נחסם מכיוון ש-A נרכש על ידי T1.\nשני החוטים נמצאים כעת במצב של המתנה הדדית (T1 ממתין ל-B שמוחזק על ידי T2, ו-T2 ממתין ל-A שמוחזק על ידי T1), ובכך נוצרת המתנה מעגלית והמערכת נכנסת לקיפאון.\n\n**סעיף 10.3:**\nהפתרון היעיל ביותר והמינימלי ביותר למניעת קיפאון במקרה זה הוא לכפות סדר רכישה גלובלי אחיד על כל חוטי העבודה. נתקן את הפונקציה `worker_thread_func_type2` כך שתבצע את רכישת המשאבים באותו סדר כמו `worker_thread_func_type1` (כלומר, קודם A ואז B).\n\nקוד מתוקן עבור `worker_thread_func_type2`:\n```c\nvoid worker_thread_func_type2_fixed() {\n    // שלב 1: רכישת משאבים (סדר מתוקן)\n    sem_wait(&sem_A);\n    sem_wait(&sem_B);\n\n    // שלב 2: ביצוע המשימה\n    do_task();\n\n    // שלב 3: שחרור משאבים\n    sem_post(&sem_B);\n    sem_post(&sem_A);\n}\n```\nהסבר: על ידי אכיפת סדר רכישה גלובלי אחיד (A ואז B) לכל סוגי החוטים, אנו מבטלים את האפשרות להיווצרות תנאי ההמתנה המעגלית. אם כל החוטים מנסים לרכוש את A ואז את B, חוט אחד עשוי להחזיק ב-A ולהמתין ל-B, אך אף חוט אחר לא יחזיק ב-B וימתין ל-A, מכיוון שכולם ינסו לרכוש את A תחילה. בכך נמנע הקיפאון תוך שמירה על רמת מקביליות גבוהה יחסית, שכן חוטים עדיין יכולים לעבוד במקביל כל עוד הם לא מתחרים על אותם משאבים באופן שיוצר מעגל."
    },
    "difficulty_estimation": "Hard"
  }
}