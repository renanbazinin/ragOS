{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:34:40",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4395,
      "output_tokens": 3644,
      "total_tokens": 14812
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Deadlocks",
      "Concurrency",
      "Synchronization"
    ],
    "content": {
      "text": "נתונה מערכת המורכבת מ-N תהליכונים (threads) ומ-N משאבים (resources) ממוספרים מ-0 עד N-1. כל משאב מוגן על ידי סמפור בינארי. כל תהליכון `P_i` (כאשר `i` הוא מזהה התהליכון בין 0 ל-N-1) נדרש לרכוש את משאב `R_i` ואת משאב `R_{(i+1)%N` על מנת לבצע את עבודתו. לאחר סיום העבודה, התהליכון משחרר את שני המשאבים שרכש. להלן מימוש ראשוני של פונקציית התהליכון `thread_func`:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep\n\n#define N_THREADS 5 // דוגמה ל-N\n\nsem_t resources[N_THREADS]; // סמפור אחד לכל משאב\n\nvoid *thread_func_deadlock_prone(void *arg) {\n    long thread_id = (long)arg;\n    int res1 = thread_id;\n    int res2 = (thread_id + 1) % N_THREADS;\n\n    printf(\"Thread %ld: Trying to acquire R%d\\n\", thread_id, res1);\n    sem_wait(&resources[res1]);\n    printf(\"Thread %ld: Acquired R%d. Trying to acquire R%d\\n\", thread_id, res1, res2);\n    sleep(1); // מדמה עבודה/השהיה להגברת סיכוי לקיפאון\n    sem_wait(&resources[res2]);\n    printf(\"Thread %ld: Acquired R%d and R%d. Working...\\n\", thread_id, res1, res2);\n\n    // מדמה עבודה\n    sleep(2);\n\n    printf(\"Thread %ld: Releasing R%d and R%d\\n\", thread_id, res2, res1);\n    sem_post(&resources[res2]);\n    sem_post(&resources[res1]);\n    printf(\"Thread %ld: Released both resources. Done.\\n\", thread_id);\n\n    return NULL;\n}\n\n// פונקציית main תאתחל את הסמפורים, תיצור N_THREADS תהליכונים ותצטרף אליהם.\n// לצורך השאלה, רק הפונקציה thread_func נדרשת.\n```\n\n**חלק א: ניתוח קיפאון**\n1.  הסבירו מדוע המימוש הנתון עלול להוביל למצב של קיפאון (deadlock).\n2.  תארו רצף אירועים ספציפי (לדוגמה, עבור N=3) שבו אכן מתרחש קיפאון.\n\n**חלק ב: מניעת קיפאון**\n1.  שנו את פונקציית התהליכון `thread_func_deadlock_prone` כך שתמנע קיפאון, תוך שמירה על רמת מקביליות גבוהה ככל האפשר. הציגו את הקוד המעודכן.\n2.  הסבירו מהי אסטרטגיית מניעת הקיפאון שבחרתם ומדוע היא מבטיחה חופש מקיפאון.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "--- פתרון --- \n\n**חלק א: ניתוח קיפאון**\n1.  **הסבר למה קיפאון עלול להתרחש:**\n    המערכת הנתונה מקיימת את ארבעת התנאים ההכרחיים לקיפאון:\n    *   **מניעה הדדית (Mutual Exclusion):** כל משאב מוגן על ידי סמפור בינארי, מה שאומר שרק תהליכון אחד יכול להחזיק משאב מסוים בכל רגע נתון. זהו תנאי הכרחי לקיפאון.\n    *   **החזקה והמתנה (Hold and Wait):** כל תהליכון `P_i` רוכש את משאב `R_i` ולאחר מכן מנסה לרכוש את משאב `R_{(i+1)%N`. בשלב זה, הוא מחזיק במשאב אחד (`R_i`) בזמן שהוא ממתין למשאב אחר (`R_{(i+1)%N`).\n    *   **אי-הפקעה (No Preemption):** משאבים אינם נלקחים בכוח מתהליכון שמחזיק בהם. תהליכון משחרר משאב רק לאחר שסיים את השימוש בו.\n    *   **המתנה מעגלית (Circular Wait):** זהו התנאי המרכזי שמוביל לקיפאון במימוש הנתון. אם כל התהליכונים ירכשו את המשאב הראשון שלהם (`R_i`) לפני שינסו לרכוש את המשאב השני (`R_{(i+1)%N`), נוצרת שרשרת המתנה מעגלית. לדוגמה, `P_0` מחזיק ב-`R_0` וממתין ל-`R_1`, `P_1` מחזיק ב-`R_1` וממתין ל-`R_2`, ..., `P_{N-1}` מחזיק ב-`R_{N-1}` וממתין ל-`R_0`. כל תהליכון ממתין למשאב שמוחזק על ידי התהליכון הבא בשרשרת, והתהליכון האחרון ממתין למשאב שמוחזק על ידי התהליכון הראשון, מה שיוצר מעגל.\n\n2.  **רצף אירועים ספציפי לקיפאון (N=3):**\n    נניח N=3, כלומר ישנם תהליכונים `P_0, P_1, P_2` ומשאבים `R_0, R_1, R_2`. \n    רצף אירועים שמוביל לקיפאון:\n    *   `P_0` מתחיל ומבצע `sem_wait(&resources[0])`. `P_0` רוכש את `R_0`.\n    *   `P_1` מתחיל ומבצע `sem_wait(&resources[1])`. `P_1` רוכש את `R_1`.\n    *   `P_2` מתחיל ומבצע `sem_wait(&resources[2])`. `P_2` רוכש את `R_2`.\n    *   כעת, כל תהליכון מחזיק במשאב אחד:\n        *   `P_0` מחזיק ב-`R_0`.\n        *   `P_1` מחזיק ב-`R_1`.\n        *   `P_2` מחזיק ב-`R_2`.\n    *   `P_0` מנסה לרכוש את `R_1` (`sem_wait(&resources[1])`). `P_0` נחסם וממתין, כיוון ש-`R_1` מוחזק על ידי `P_1`.\n    *   `P_1` מנסה לרכוש את `R_2` (`sem_wait(&resources[2])`). `P_1` נחסם וממתין, כיוון ש-`R_2` מוחזק על ידי `P_2`.\n    *   `P_2` מנסה לרכוש את `R_0` (`sem_wait(&resources[0])`). `P_2` נחסם וממתין, כיוון ש-`R_0` מוחזק על ידי `P_0`.\n    בשלב זה, כל שלושת התהליכונים חסומים וממתינים למשאב שמוחזק על ידי תהליכון אחר במעגל, ואין שום דרך לשחרר את המשאבים המוחזקים. זהו מצב של קיפאון.\n\n**חלק ב: מניעת קיפאון**\n1.  **קוד מעודכן למניעת קיפאון:**\n    נשתמש באסטרטגיית 'סדר משאבים' (Resource Ordering) כדי למנוע המתנה מעגלית. במקום שכל תהליכון ינסה לרכוש את `R_i` ואז את `R_{(i+1)%N`, נקבע סדר גלובלי לרכישת משאבים: תמיד לרכוש קודם את המשאב בעל האינדקס הנמוך יותר, ורק אחר כך את המשאב בעל האינדקס הגבוה יותר. \n    המקרה היחיד שבו אינדקס המשאב השני (`(thread_id + 1) % N_THREADS`) קטן מאינדקס המשאב הראשון (`thread_id`) הוא עבור התהליכון `P_{N-1}`, שכן הוא צריך את `R_{N-1}` ואת `R_0`. במקרה זה, `R_0` הוא בעל האינדקס הנמוך יותר. כל שאר התהליכונים `P_i` (עבור `i < N-1`) צריכים את `R_i` ואת `R_{i+1}`, כאשר `R_i` הוא בעל האינדקס הנמוך יותר.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h>\n\n#define N_THREADS 5\n\nsem_t resources[N_THREADS];\n\nvoid *thread_func_deadlock_free(void *arg) {\n    long thread_id = (long)arg;\n    int res_a = thread_id;\n    int res_b = (thread_id + 1) % N_THREADS;\n\n    // קביעת סדר רכישת משאבים: תמיד קודם את המשאב עם האינדקס הקטן יותר\n    int first_res_to_acquire, second_res_to_acquire;\n\n    if (res_a < res_b) {\n        first_res_to_acquire = res_a;\n        second_res_to_acquire = res_b;\n    } else { // This handles P_{N-1} acquiring R_0 then R_{N-1}\n        first_res_to_acquire = res_b;\n        second_res_to_acquire = res_a;\n    }\n\n    printf(\"Thread %ld: Trying to acquire R%d (first)\\n\", thread_id, first_res_to_acquire);\n    sem_wait(&resources[first_res_to_acquire]);\n    printf(\"Thread %ld: Acquired R%d. Trying to acquire R%d (second)\\n\", thread_id, first_res_to_acquire, second_res_to_acquire);\n    sleep(1);\n    sem_wait(&resources[second_res_to_acquire]);\n    printf(\"Thread %ld: Acquired R%d and R%d. Working...\\n\", thread_id, first_res_to_acquire, second_res_to_acquire);\n\n    // מדמה עבודה\n    sleep(2);\n\n    printf(\"Thread %ld: Releasing R%d and R%d\\n\", thread_id, second_res_to_acquire, first_res_to_acquire);\n    sem_post(&resources[second_res_to_acquire]);\n    sem_post(&resources[first_res_to_acquire]);\n    printf(\"Thread %ld: Released both resources. Done.\\n\", thread_id);\n\n    return NULL;\n}\n```\n\n2.  **הסבר אסטרטגיית מניעת הקיפאון:**\n    האסטרטגיה שבחרנו היא **סדר משאבים (Resource Ordering)**. אסטרטגיה זו מונעת את התנאי ההכרחי של המתנה מעגלית. על ידי קביעת סדר גלובלי לרכישת משאבים (לדוגמה, תמיד לרכוש קודם את המשאב בעל האינדקס הנמוך יותר), אנו מבטיחים שלעולם לא תוכל להיווצר שרשרת המתנה מעגלית.\n\n    **מדוע זה עובד?**\n    *   תהליכון `P_i` תמיד ינסה לרכוש את המשאב בעל האינדקס הנמוך ביותר מבין שני המשאבים שהוא צריך. אם הוא זקוק למשאבים `R_x` ו-`R_y`, כאשר `x < y`, הוא ינסה לרכוש את `R_x` ואז את `R_y`. \n    *   היוצא מן הכלל היחיד הוא התהליכון `P_{N-1}` שזקוק למשאבים `R_{N-1}` ו-`R_0`. על פי הכלל, הוא ירכוש קודם את `R_0` (האינדקס הנמוך יותר) ולאחר מכן את `R_{N-1}`.\n    *   בכך, אנו מבטיחים ששום תהליכון לא יחזיק משאב בעל אינדקס גבוה יותר וימתין למשאב בעל אינדקס נמוך יותר, שעלול להיות מוחזק על ידי תהליכון אחר (שגם הוא מחזיק במשאב עם אינדקס נמוך יותר וכו', ויוצר מעגל). כל תהליכון שמחזיק משאב `R_x` וממתין למשאב `R_y` ימתין תמיד למשאב `R_y` כאשר `y > x`. כתוצאה מכך, לא ייתכן מצב שבו `P_0` ממתין ל-`R_1` שמוחזק על ידי `P_1`, ו-`P_1` ממתין ל-`R_2` שמוחזק על ידי `P_2`, ו-... ו-`P_{N-1}` ממתין ל-`R_0` שמוחזק על ידי `P_0`. שרשרת כזו נמנעת כי `P_{N-1}` ירכוש את `R_0` קודם, ובכך לא יחכה ל-`R_0` בזמן שהוא מחזיק ב-`R_{N-1}`.\n    *   הסדר הגלובלי מונע היווצרות של גרף הקצאת משאבים (resource allocation graph) בעל מחזורים, ובכך מונע קיפאון."
    },
    "difficulty_estimation": "Hard"
  }
}