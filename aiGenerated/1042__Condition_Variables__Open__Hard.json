{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Condition Variables",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:36:49",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3816,
      "output_tokens": 3708,
      "total_tokens": 16269
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Condition Variables",
      "Synchronization",
      "Producer-Consumer",
      "Starvation",
      "Deadlock"
    ],
    "content": {
      "text": "נתונה מחלקה `ResourceManager` המנהלת מאגר של `MAX_RESOURCES` משאבים זהים. המחלקה מספקת פונקציות לרכישת משאב בודד (`acquire`), שחרור משאב בודד (`release`), רכישת כל המשאבים (`acquire_all`), ושחרור כל המשאבים (`release_all`).\n\nחוטים מסוג 'Worker' משתמשים בפונקציות `acquire` ו-`release`. חוטים מסוג 'Manager' משתמשים בפונקציות `acquire_all` ו-`release_all`.\n\nהקוד הבא מציג מימוש ראשוני של המחלקה. נתחו את הקוד וענו על השאלות הבאות:",
      "code_snippet": "#include <pthread.h>\n\nclass ResourceManager {\npublic:\n    ResourceManager(int max_res) : MAX_RESOURCES(max_res), available_resources(max_res) {\n        pthread_mutex_init(&mutex, NULL);\n        pthread_cond_init(&cond_single_resource, NULL);\n        pthread_cond_init(&cond_all_resources, NULL);\n    }\n\n    ~ResourceManager() {\n        pthread_mutex_destroy(&mutex);\n        pthread_cond_destroy(&cond_single_resource);\n        pthread_cond_destroy(&cond_all_resources);\n    }\n\n    void acquire() {\n        pthread_mutex_lock(&mutex);\n        while (available_resources == 0) {\n            pthread_cond_wait(&cond_single_resource, &mutex);\n        }\n        available_resources--;\n        pthread_mutex_unlock(&mutex);\n    }\n\n    void release() {\n        pthread_mutex_lock(&mutex);\n        available_resources++;\n        pthread_cond_signal(&cond_single_resource);\n        pthread_mutex_unlock(&mutex);\n    }\n\n    void acquire_all() {\n        pthread_mutex_lock(&mutex);\n        while (available_resources != MAX_RESOURCES) {\n            pthread_cond_wait(&cond_all_resources, &mutex);\n        }\n        available_resources = 0;\n        pthread_mutex_unlock(&mutex);\n    }\n\n    void release_all() {\n        pthread_mutex_lock(&mutex);\n        available_resources = MAX_RESOURCES;\n        pthread_cond_signal(&cond_single_resource);\n        pthread_cond_signal(&cond_all_resources);\n        pthread_mutex_unlock(&mutex);\n    }\n\nprivate:\n    const int MAX_RESOURCES;\n    int available_resources;\n    pthread_mutex_t mutex;\n    pthread_cond_t cond_single_resource;\n    pthread_cond_t cond_all_resources;\n};"
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "זהו והסבירו את כל הבעיות הפוטנציאליות במימוש הנוכחי של המחלקה `ResourceManager`, כולל בעיות נכונות, קיפאון (deadlock) או הרעבה (starvation). התייחסו במיוחד לשימוש ב-`pthread_cond_signal` לעומת `pthread_cond_broadcast`.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "הציעו תיקונים נדרשים לקוד כדי לפתור את הבעיות שזיהיתם, והציגו את המימוש המתוקן של המחלקה `ResourceManager`. הסבירו מדוע התיקונים שלכם פותרים את הבעיות.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### פתרון לשאלה 1\n\n#### 1.1 זיהוי והסבר הבעיות במימוש המקורי:\n\n1.  **הרעבה (Starvation) של חוטי 'Manager'**: \n    חוטים הקוראים ל-`acquire_all()` עשויים לסבול מהרעבה. אם ישנם חוטים רבים מסוג 'Worker' שקוראים ל-`acquire()` ו-`release()` ברצף, מספר המשאבים הפנויים (`available_resources`) עשוי לעולם לא להגיע ל-`MAX_RESOURCES` במצב יציב, או להגיע לשם רק לרגע קצר לפני שחוט 'Worker' אחר תופס משאב. במצב כזה, חוט 'Manager' הממתין ב-`cond_all_resources` עלול להמתין ללא סוף.\n\n2.  **שימוש לא נכון ב-`pthread_cond_signal` ב-`release()`**: \n    כאשר חוט 'Worker' משחרר משאב ב-`release()`, הוא קורא ל-`pthread_cond_signal(&cond_single_resource)`. \n    *   **בעיה 1 (החמצת התעוררות של Manager)**: אם שחרור המשאב מוביל לכך ש-`available_resources` מגיע ל-`MAX_RESOURCES`, וחוט 'Manager' ממתין ב-`cond_all_resources`, ה-`signal` הנוכחי לא יעיר אותו. חוט ה-'Manager' ימשיך להמתין למרות שהתנאי שלו מתקיים.\n    *   **בעיה 2 (יעילות והרעבה של Workers אחרים)**: אם מספר משאבים הופך לזמין (למשל, מ-0 ל-2), וחוטים מרובים מסוג 'Worker' ממתינים ב-`cond_single_resource`, ה-`signal` יעיר רק אחד מהם. שאר החוטים ימשיכו להמתין גם אם יש מספיק משאבים עבורם. במימוש `acquire()` הנוכחי, חוט שהתעורר יקח משאב אחד ואז ישחרר את המוטקס, אבל לא יהיה `signal` נוסף שיעיר את הממתינים האחרים. זה יכול להוביל להרעבה של חוטי Worker אחרים או לפחות ליעילות נמוכה.\n\n3.  **שימוש לא נכון ב-`pthread_cond_signal` ב-`release_all()`**: \n    כאשר חוט 'Manager' משחרר את כל המשאבים ב-`release_all()`, הוא קורא לשני `pthread_cond_signal`ים. \n    *   **בעיה 1 (יעילות והרעבה של Workers)**: `pthread_cond_signal(&cond_single_resource)` יעיר רק חוט 'Worker' אחד, למרות שכל `MAX_RESOURCES` משאבים זמינים כעת ועשויים להיות הרבה חוטי 'Worker' שממתינים. שוב, זה פוגע ביעילות ויכול לגרום להרעבה.\n    *   **בעיה 2 (יעילות והרעבה של Managers)**: `pthread_cond_signal(&cond_all_resources)` יעיר רק חוט 'Manager' אחד, למרות שאם היו מספר חוטי 'Manager' שממתינים, כולם היו יכולים (תיאורטית) להתעורר ולבדוק את התנאי (אם כי רק אחד מהם יצליח לתפוס את כולם). עדיף להשתמש ב-`broadcast` במקרה זה כדי לוודא שכל הממתינים הרלוונטיים מתעוררים ובודקים את התנאי מחדש.\n\n4.  **חוסר שימוש ב-`while` לטיפול ב-spurious wakeups**: קוד ה-`acquire()` ו-`acquire_all()` משתמשים ב-`while` עבור תנאי ההמתנה, וזהו שימוש נכון וחשוב למניעת `spurious wakeups` ולוודא שהתנאי אכן מתקיים לאחר ההתעוררות. בנקודה זו אין בעיה במימוש הנוכחי.\n\n#### 1.2 תיקונים נדרשים ומימוש מתוקן:\n\nכדי לפתור את הבעיות, נצטרך: \nא. למנוע הרעבה של 'Manager' על ידי מתן עדיפות. \nב. להשתמש ב-`pthread_cond_broadcast` במקום `signal` כאשר מספר חוטים עשויים להיות מעוניינים במשאבים. \nג. לוודא שכל סוגי החוטים הממתינים מקבלים התראה כאשר התנאי שלהם מתקיים.\n\nנוסיף משתנה בוליאני `manager_waiting` שיציין אם חוט 'Manager' ממתין לתפוס את כל המשאבים. \n\n```c++\n#include <pthread.h>\n\nclass ResourceManager {\npublic:\n    ResourceManager(int max_res) : MAX_RESOURCES(max_res), available_resources(max_res), manager_waiting(false) {\n        pthread_mutex_init(&mutex, NULL);\n        pthread_cond_init(&cond_single_resource, NULL);\n        pthread_cond_init(&cond_all_resources, NULL);\n    }\n\n    ~ResourceManager() {\n        pthread_mutex_destroy(&mutex);\n        pthread_cond_destroy(&cond_single_resource);\n        pthread_cond_destroy(&cond_all_resources);\n    }\n\n    void acquire() {\n        pthread_mutex_lock(&mutex);\n        // Worker threads wait if no resources are available OR if a Manager is waiting (to prevent Manager starvation)\n        while (available_resources == 0 || manager_waiting) {\n            pthread_cond_wait(&cond_single_resource, &mutex);\n        }\n        available_resources--;\n        pthread_mutex_unlock(&mutex);\n    }\n\n    void release() {\n        pthread_mutex_lock(&mutex);\n        available_resources++;\n        // If a Manager is waiting and all resources are now available, wake up the Manager.\n        // Otherwise, if no Manager is waiting, wake up all Worker threads.\n        if (manager_waiting && available_resources == MAX_RESOURCES) {\n            pthread_cond_signal(&cond_all_resources); // Signal because only one Manager can acquire_all at a time\n        } else if (!manager_waiting) {\n            pthread_cond_broadcast(&cond_single_resource); // Broadcast to all waiting Worker threads\n        }\n        pthread_mutex_unlock(&mutex);\n    }\n\n    void acquire_all() {\n        pthread_mutex_lock(&mutex);\n        manager_waiting = true; // Indicate that a Manager is waiting for ALL resources\n        while (available_resources != MAX_RESOURCES) {\n            pthread_cond_wait(&cond_all_resources, &mutex);\n        }\n        available_resources = 0; // All resources acquired\n        manager_waiting = false; // Manager is no longer waiting\n        // Now that the Manager has acquired, allow Worker threads to proceed if resources become available later.\n        // We broadcast to cond_single_resource here in case Worker threads were blocked by manager_waiting flag.\n        pthread_cond_broadcast(&cond_single_resource);\n        pthread_mutex_unlock(&mutex);\n    }\n\n    void release_all() {\n        pthread_mutex_lock(&mutex);\n        available_resources = MAX_RESOURCES; // All resources released\n        manager_waiting = false; // Reset manager_waiting as the Manager has finished its task\n        // All resources are free. Both types of threads could potentially proceed.\n        // Broadcast to both condition variables to ensure all relevant waiting threads are woken.\n        pthread_cond_broadcast(&cond_single_resource); // Wake up all waiting Worker threads\n        pthread_cond_broadcast(&cond_all_resources);   // Wake up all waiting Manager threads (if any)\n        pthread_mutex_unlock(&mutex);\n    }\n\nprivate:\n    const int MAX_RESOURCES;\n    int available_resources;\n    bool manager_waiting; // New flag to prevent Manager starvation\n    pthread_mutex_t mutex;\n    pthread_cond_t cond_single_resource;\n    pthread_cond_t cond_all_resources;\n};\n```\n\n**הסבר לתיקונים:**\n\n1.  **מניעת הרעבה של 'Manager'**: \n    *   הוספנו את המשתנה `bool manager_waiting`. חוט 'Manager' שקורא ל-`acquire_all()` מציב את `manager_waiting` ל-`true` לפני שהוא נכנס למצב המתנה. \n    *   בפונקציה `acquire()`, חוטי 'Worker' ימתינו לא רק כאשר `available_resources == 0` אלא גם כאשר `manager_waiting == true`. זה מבטיח שאם 'Manager' ממתין, חוטי 'Worker' לא יתפסו משאבים בודדים ויאפשרו ל-`available_resources` להגיע ל-`MAX_RESOURCES` עבור ה-'Manager'.\n    *   לאחר שחוט 'Manager' תפס את כל המשאבים (ב-`acquire_all()`) או שחרר את כולם (ב-`release_all()`), הוא מאפס את `manager_waiting` ל-`false`. לאחר מכן, הוא קורא ל-`pthread_cond_broadcast(&cond_single_resource)` כדי להעיר את כל חוטי ה-'Worker' הממתינים, שיוכלו כעת להמשיך.\n\n2.  **שימוש נכון ב-`pthread_cond_broadcast`**: \n    *   ב-`release()`: \n        *   אם `manager_waiting` נכון ו-`available_resources` הגיע ל-`MAX_RESOURCES`, אנו מעירים רק את חוט ה-'Manager' (באמצעות `signal`) מכיוון שרק הוא יכול לקחת את כל המשאבים. חוטי 'Worker' עדיין חסומים על ידי הדגל `manager_waiting`.\n        *   אחרת (אם אין 'Manager' ממתין), אנו משתמשים ב-`pthread_cond_broadcast(&cond_single_resource)` כדי להעיר את כל חוטי ה-'Worker' הממתינים. זאת מכיוון שכאשר משאב משוחרר, ייתכן שיותר מחוט 'Worker' אחד יוכל כעת לתפוס משאב, ו-`broadcast` מבטיח שכולם יבדקו את התנאי מחדש.\n    *   ב-`release_all()`: \n        *   כאשר כל המשאבים משוחררים, אנו קוראים ל-`pthread_cond_broadcast` עבור שתי ה-`cond_variable`ים. זה מבטיח שכל חוטי 'Worker' הממתינים (שיוכלו כעת לקחת משאב בודד) וכל חוטי 'Manager' הממתינים (שיוכלו כעת לקחת את כל המשאבים) יתעוררו ויבדקו את התנאים שלהם. זהו המנגנון הנכון ביותר ליעילות ומניעת הרעבה במצב זה.\n\nהתיקונים הללו מבטיחים נכונות, מונעים הרעבה של חוטי 'Manager' ומשפרים את היעילות על ידי העלאת מספר החוטים המתאימים לתנאי בכל פעם שמתאפשר."
    },
    "difficulty_estimation": "Hard"
  }
}