{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores and Deadlocks",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:45:51",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4285,
      "output_tokens": 2931,
      "total_tokens": 11200
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Semaphores",
      "Deadlocks",
      "Concurrency",
      "Threads"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בשני סמפורים בינאריים ושני תהליכונים (threads). התוכנית מנסה לסנכרן גישה לשני משאבים (שאינם מפורטים בקוד, אך מוגנים על ידי הסמפורים). נתחו את הקוד המצורף וענו על השאלות הבאות:\n\n1. האם קיימת אפשרות לקיפאון (deadlock) בתוכנית זו? אם כן, תארו מצב ספציפי (כולל סדר פעולות של התהליכונים) שבו מתרחש קיפאון. נמקו את תשובתכם בהתייחס לתנאי קופמן לקיפאון.\n2. הציעו תיקון לקוד המונע קיפאון, תוך שימוש בסמפורים בלבד, ושמרו על יעילות ככל האפשר. הציגו את הקוד המתוקן והסבירו מדוע התיקון שלכם מונע קיפאון.",
      "code_snippet": "#include <pthread.h>\n#include <semaphore.h>\n#include <stdio.h>\n#include <unistd.h> // For sleep\n\nsem_t sem_A; // Protects Resource A\nsem_t sem_B; // Protects Resource B\n\nvoid* thread_func1(void* arg) {\n    printf(\"Thread 1: Trying to acquire sem_A...\\n\");\n    sem_wait(&sem_A);\n    printf(\"Thread 1: Acquired sem_A. Trying to acquire sem_B...\\n\");\n    // Simulate some work or delay to increase deadlock probability\n    sleep(1); \n    sem_wait(&sem_B);\n    printf(\"Thread 1: Acquired sem_B. Critical section...\\n\");\n    // Critical section\n    sem_post(&sem_B);\n    printf(\"Thread 1: Released sem_B.\\n\");\n    sem_post(&sem_A);\n    printf(\"Thread 1: Released sem_A.\\n\");\n    return NULL;\n}\n\nvoid* thread_func2(void* arg) {\n    printf(\"Thread 2: Trying to acquire sem_B...\\n\");\n    sem_wait(&sem_B);\n    printf(\"Thread 2: Acquired sem_B. Trying to acquire sem_A...\\n\");\n    // Simulate some work or delay\n    sleep(1);\n    sem_wait(&sem_A);\n    printf(\"Thread 2: Acquired sem_A. Critical section...\\n\");\n    // Critical section\n    sem_post(&sem_A);\n    printf(\"Thread 2: Released sem_A.\\n\");\n    sem_post(&sem_B);\n    printf(\"Thread 2: Released sem_B.\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2;\n\n    sem_init(&sem_A, 0, 1); // Initialize sem_A to 1 (binary semaphore)\n    sem_init(&sem_B, 0, 1); // Initialize sem_B to 1 (binary semaphore)\n\n    pthread_create(&tid1, NULL, thread_func1, NULL);\n    pthread_create(&tid2, NULL, thread_func2, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    sem_destroy(&sem_A);\n    sem_destroy(&sem_B);\n\n    printf(\"Main: Program finished.\\n\");\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "חלק 1: ניתוח קיפאון\n\nכן, קיים סיכוי לקיפאון (deadlock) בתוכנית זו. קיפאון יכול להתרחש כאשר ארבעת התנאים של קופמן מתקיימים:\n1.  **הדרה הדדית (Mutual Exclusion):** לכל משאב (מוגן על ידי סמפור) יש גישה בלעדית. רק תהליכון אחד יכול לתפוס סמפור בינארי (ערכו 1) בכל רגע נתון. תנאי זה מתקיים.\n2.  **החזקה והמתנה (Hold and Wait):** תהליכון מחזיק במשאב אחד לפחות (תפס סמפור) וממתין למשאב נוסף שתפוס על ידי תהליכון אחר.\n    *   תהליכון 1 תופס את `sem_A` וממתין ל-`sem_B`.\n    *   תהליכון 2 תופס את `sem_B` וממתין ל-`sem_A`.\n    תנאי זה מתקיים.\n3.  **אין דריסה (No Preemption):** משאבים לא ניתנים לדריסה; הם יכולים להשתחרר רק באופן יזום על ידי התהליכון שמחזיק בהם. תנאי זה מתקיים עם סמפורים.\n4.  **המתנה מעגלית (Circular Wait):** קיימת שרשרת של תהליכונים, כאשר כל תהליכון בשרשרת ממתין למשאב המוחזק על ידי התהליכון הבא בשרשרת.\n    *   תהליכון 1 מחזיק ב-`sem_A` וממתין ל-`sem_B`.\n    *   תהליכון 2 מחזיק ב-`sem_B` וממתין ל-`sem_A`.\n    נוצרת המתנה מעגלית: T1 ממתין ל-T2, ו-T2 ממתין ל-T1. תנאי זה מתקיים.\n\n**תרחיש קיפאון ספציפי:**\n1.  **תהליכון 1** מתחיל וקורא `sem_wait(&sem_A)`. הוא תופס בהצלחה את `sem_A`.\n2.  **תהליכון 2** מתחיל וקורא `sem_wait(&sem_B)`. הוא תופס בהצלחה את `sem_B`.\n3.  **תהליכון 1** מנסה כעת לקרוא `sem_wait(&sem_B)`. אך `sem_B` תפוס על ידי תהליכון 2, ולכן תהליכון 1 נחסם.\n4.  **תהליכון 2** מנסה כעת לקרוא `sem_wait(&sem_A)`. אך `sem_A` תפוס על ידי תהליכון 1, ולכן תהליכון 2 נחסם.\n\nשני התהליכונים חסומים כעת באופן הדדי וממתינים זה לזה לשחרר את המשאבים שהם צריכים. זהו מצב קיפאון.\n\nחלק 2: תיקון למניעת קיפאון\n\nכדי למנוע קיפאון, יש לשבור לפחות אחד מתנאי קופמן. הדרך הנפוצה והיעילה ביותר במקרים כאלה היא למנוע המתנה מעגלית על ידי הטלת סדר כולל (total ordering) על תפיסת המשאבים. כלומר, כל התהליכונים חייבים לתפוס את המשאבים באותו סדר.\n\n**קוד מתוקן:**\n```c\n#include <pthread.h>\n#include <semaphore.h>\n#include <stdio.h>\n#include <unistd.h> // For sleep\n\nsem_t sem_A; // Protects Resource A\nsem_t sem_B; // Protects Resource B\n\nvoid* thread_func1_fixed(void* arg) {\n    printf(\"Thread 1: Trying to acquire sem_A...\\n\");\n    sem_wait(&sem_A);\n    printf(\"Thread 1: Acquired sem_A. Trying to acquire sem_B...\\n\");\n    sleep(1); \n    sem_wait(&sem_B);\n    printf(\"Thread 1: Acquired sem_B. Critical section...\\n\");\n    // Critical section\n    sem_post(&sem_B);\n    printf(\"Thread 1: Released sem_B.\\n\");\n    sem_post(&sem_A);\n    printf(\"Thread 1: Released sem_A.\\n\");\n    return NULL;\n}\n\nvoid* thread_func2_fixed(void* arg) {\n    printf(\"Thread 2: Trying to acquire sem_A...\\n\"); // Changed order\n    sem_wait(&sem_A); // Changed order\n    printf(\"Thread 2: Acquired sem_A. Trying to acquire sem_B...\\n\"); // Changed order\n    sleep(1);\n    sem_wait(&sem_B);\n    printf(\"Thread 2: Acquired sem_B. Critical section...\\n\");\n    // Critical section\n    sem_post(&sem_B);\n    printf(\"Thread 2: Released sem_B.\\n\");\n    sem_post(&sem_A);\n    printf(\"Thread 2: Released sem_A.\\n\");\n    return NULL;\n}\n\nint main_fixed() { // main_fixed to distinguish from original main\n    pthread_t tid1, tid2;\n\n    sem_init(&sem_A, 0, 1);\n    sem_init(&sem_B, 0, 1);\n\n    pthread_create(&tid1, NULL, thread_func1_fixed, NULL);\n    pthread_create(&tid2, NULL, thread_func2_fixed, NULL); \n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    sem_destroy(&sem_A);\n    sem_destroy(&sem_B);\n\n    printf(\"Main: Program finished (fixed).\\n\");\n    return 0;\n}\n```\n\n**הסבר על התיקון:**\nהתיקון מתבצע על ידי שינוי סדר תפיסת הסמפורים ב-`thread_func2_fixed` כך שתהליכון זה יתפוס גם הוא את `sem_A` לפני `sem_B`, בדומה ל-`thread_func1_fixed`.\nעל ידי כך, אנו מטילים סדר גלובלי על תפיסת המשאבים: כל תהליכון שזקוק לשני המשאבים יתפוס תמיד את `sem_A` ולאחר מכן את `sem_B`.\nמצב של המתנה מעגלית לא יכול להתרחש יותר:\n*   אם תהליכון 1 תופס את `sem_A`, ותהליכון 2 ינסה לתפוס את `sem_A`, הוא יחסם עד שתהליכון 1 ישחרר אותו (לאחר שסיים את הקטע הקריטי ושיחרר את `sem_B` ו-`sem_A`).\n*   תהליכון 1 לעולם לא ימתין ל-`sem_B` כאשר `sem_B` מוחזק על ידי תהליכון 2, אם תהליכון 2 עצמו ממתין ל-`sem_A` (שמוחזק על ידי תהליכון 1). תהליכון 2 יצטרך לתפוס את `sem_A` קודם, וכך לא יוכל להחזיק ב-`sem_B` ולחסום את תהליכון 1 בעת ובעונה אחת.\nהתיקון שובר את תנאי \"המתנה מעגלית\", ובכך מונע קיפאון."
    },
    "difficulty_estimation": "Hard"
  }
}