{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:35:12",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3218,
      "output_tokens": 3490,
      "total_tokens": 14429
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Virtual Memory",
      "Paging",
      "Memory Management",
      "TLB",
      "Copy-on-Write",
      "Performance Analysis"
    ],
    "content": {
      "text": "נתונה מערכת 64 ביט המממשת זיכרון וירטואלי עם טבלת דפים בעלת 4 רמות עבור מרחב כתובות וירטואלי בגודל 48 ביט. גודל דף הוא 4KB. כל כניסה בטבלת הדפים (PTE) היא בגודל 8 בתים.\nהמערכת כוללת TLB עם 128 כניסות, בארגון 4-way set associative, המשתמש באלגוריתם החלפה LRU. זמן גישה ל-TLB הוא 1 מחזור שעון, זמן גישה לזיכרון הראשי הוא 100 מחזורי שעון, וזמן גישה לדיסק הוא 10,000,000 מחזורי שעון.\n\nתהליך במערכת מבצע פעולה הכוללת איטרציה על מערך גדול מסוג `int arr[10^9];` כאשר `sizeof(int)` הוא 4 בתים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מבנה טבלת הדפים וגודלה:\n1. כמה ביטים משמשים למספר דף וירטואלי (VPN) וכמה להיסט (offset)?\n2. פרט את חלוקת הביטים של ה-VPN לאינדקסים עבור 4 הרמות של טבלת הדפים.\n3. חשב את הגודל המקסימלי (בבתים) של טבלת דפים עבור תהליך בודד המנצל את כל מרחב הכתובות הוירטואלי שלו, בהנחה שכל הדפים נמצאים בזיכרון הראשי (resident).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "ניתוח ביצועים עבור דפוס גישה ספציפי:\nנתבונן בלולאה הבאה המבוצעת על ידי תהליך:\n```c\nfor (long i = 0; i < N; i++) { // N הוא מספר גדול מאוד, נניח 10^8 איטרציות\n    arr[i * (1 << 12)] = i;\n}\n```\nהנח שהמערך `arr` מתחיל בכתובת מיושרת לדף (page-aligned address).\n1. נתח את מספר ה-TLB misses ואת מספר ה-page faults שיקרו לכל איטרציה (בממוצע, לאחר שלב ה-\"חימום\" הראשוני שבו ה-TLB וטבלת הדפים מתייצבים), בהינתן גודל ה-TLB, האסוציאטיביות ומדיניות ההחלפה. הנח שה-TLB ריק בתחילה ושאין דפים בזיכרון.\n2. מהו זמן הגישה הממוצע לזיכרון עבור לולאה זו, לאחר שלב ה-\"חימום\" הראשוני?",
        "code_snippet": "for (long i = 0; i < N; i++) { // N הוא מספר גדול מאוד, נניח 10^8 איטרציות\n    arr[i * (1 << 12)] = i;\n}",
        "options": null
      },
      {
        "id": "1.3",
        "text": "השפעת Copy-on-Write עם `fork()`:\nאם התהליך יוצר תהליך בן (child process) באמצעות `fork()` מיד לפני ביצוע הלולאה הנ\"ל, ורק תהליך הבן מבצע את הלולאה, כיצד מנגנון Copy-on-Write (CoW) ישפיע על צריכת הזיכרון ועל מספר ה-page faults הפוטנציאליים עבור תהליך האב ותהליך הבן?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1. מבנה טבלת הדפים וגודלה:\n1. כתובת וירטואלית: 48 ביטים. גודל דף: 4KB = 2^12 בתים.\n   לכן, ההיסט (offset) הוא 12 ביטים.\n   מספר הדף הוירטואלי (VPN) הוא 48 - 12 = 36 ביטים.\n2. כל כניסה בטבלת הדפים (PTE) היא בגודל 8 בתים. גודל דף הוא 4KB = 4096 בתים.\n   מספר הכניסות בכל דף טבלה הוא 4096 בתים / 8 בתים/כניסה = 512 כניסות = 2^9 כניסות.\n   לכן, כל רמה בטבלת הדפים דורשת log2(512) = 9 ביטים עבור האינדקס שלה.\n   חלוקת ה-VPN (36 ביטים) ל-4 רמות תהיה: 9 ביטים עבור L4, 9 ביטים עבור L3, 9 ביטים עבור L2, 9 ביטים עבור L1 (סה\"כ 36 ביטים).\n3. הגודל המקסימלי של טבלת דפים עבור תהליך המנצל את כל מרחב הכתובות הוירטואלי (48 ביט, כלומר 2^36 דפים): \n   * רמה 4 (PGD): דף אחד (השורש).\n   * רמה 3 (PUD): 2^9 דפים (512 דפים, כל אחד מהם מצביע על דפים ברמה L2).\n   * רמה 2 (PMD): 2^9 * 2^9 = 2^18 דפים (262,144 דפים, כל אחד מהם מצביע על דפים ברמה L1).\n   * רמה 1 (PTE): 2^9 * 2^9 * 2^9 = 2^27 דפים (134,217,728 דפים, כל אחד מהם מכיל PTEs המצביעים על מסגרות פיזיות).\n   סה\"כ מספר דפים עבור טבלת הדפים: 1 + 2^9 + 2^18 + 2^27 דפים.\n   הגודל הכולל (בבתים) הוא: (1 + 2^9 + 2^18 + 2^27) * 4KB.\n   זהו בקירוב 2^27 * 4KB = 2^27 * 2^12 בתים = 2^39 בתים = 512GB.\n\n1.2. ניתוח ביצועים עבור דפוס גישה ספציפי:\n1. גודל המערך `arr` הוא 10^9 * 4 בתים = 4GB. גודל דף הוא 4KB.\n   הלולאה ניגשת לאלמנטים בכתובות: `BaseAddr`, `BaseAddr + 4096*4`, `BaseAddr + 2*4096*4`, וכו'.\n   ההפרש בין גישות עוקבות הוא 4096 * 4 בתים = 16KB.\n   מכיוון שגודל דף הוא 4KB, כל גישה בלולאה מתייחסת לדף וירטואלי חדש ושונה לחלוטין מהדף הקודם (הגישה מדלגת על 3 דפים מלאים ונוחתת על הדף הרביעי הבא).\n   *   **TLB Misses:** ה-TLB מכיל 128 כניסות. מכיוון שכל גישה היא לדף חדש, וכמות הדפים הייחודיים שאליהם ניגשים (4GB / 16KB = 2^18) גדולה בהרבה מכמות הכניסות ב-TLB, כל גישה תגרום ל-TLB miss לאחר שלב ה-\"חימום\" הראשוני. מדיניות LRU לא תעזור במקרה זה כי אין שימוש חוזר בדפים בטווח ה-TLB. לכן, שיעור ה-TLB misses הוא 100%.\n   *   **Page Faults:** באופן דומה, מכיוון שכל גישה היא לדף וירטואלי חדש, וכמות הדפים הייחודיים גדולה בהרבה מכל כמות סבירה של מסגרות זיכרון פיזיות שיכולות להיות זמינות לתהליך, כל גישה צפויה לגרום ל-page fault לאחר שלב ה-\"חימום\" הראשוני (כלומר, לאחר שהזיכרון הפיזי הזמין לתהליך התמלא והדפים הישנים מפונים). לכן, שיעור ה-page faults הוא 100% (במקרה הגרוע ביותר).\n2. **זמן הגישה הממוצע לזיכרון (AMAT):**\n   בכל גישה מתרחשים: TLB Miss -> Page Table Walk (4 רמות) -> Page Fault -> Disk I/O (לטעינת דף) -> עדכון טבלת דפים ו-TLB -> גישה לנתון.\n   *   עלות TLB miss (חיפוש ב-TLB שנופל): 1 מחזור שעון.\n   *   הליכה בטבלת הדפים (Page Table Walk): 4 רמות * 100 מחזורי שעון/רמה (גישה לזיכרון ראשי) = 400 מחזורי שעון.\n   *   Page Fault: \n      *   גישה לדיסק כדי לטעון את הדף המבוקש (page-in): 10,000,000 מחזורי שעון.\n      *   במקרה הגרוע ביותר, אם יש צורך לפנות דף מלוכלך מהזיכרון לדיסק (page-out): 10,000,000 מחזורי שעון נוספים.\n      *   עדכון טבלת הדפים וה-TLB.\n   *   גישה לנתון עצמו (לאחר שהדף בזיכרון): 100 מחזורי שעון.\n   לכן, AMAT (במקרה הגרוע ביותר עם page-out) = 1 (TLB miss) + 400 (PT walk) + 10,000,000 (page-in) + 10,000,000 (page-out) + 100 (גישת נתון) ≈ 20,000,000 מחזורי שעון.\n\n1.3. השפעת Copy-on-Write עם `fork()`:\n*   **לפני ה-fork():** תהליך האב מחזיק את המערך `arr` במרחב הכתובות הוירטואלי שלו, והדפים הפיזיים המכילים את המערך ממופים אליו.\n*   **לאחר ה-fork():**\n    *   תהליך האב ותהליך הבן חולקים את אותם דפים פיזיים עבור המערך `arr`. כניסות טבלת הדפים (PTEs) המצביעות על דפים אלו מסומנות כקריאה בלבד (read-only) בשני התהליכים.\n    *   בתחילה, אף אחד מהתהליכים לא צורך זיכרון פיזי נוסף עבור `arr`.\n    *   **כאשר תהליך הבן מבצע את הלולאה וכותב ל-`arr`:**\n        *   כל ניסיון כתיבה של תהליך הבן לכתובת `arr[i * (1 << 12)]` יגרום ל-**Copy-on-Write (CoW) fault**, מכיוון שהדף מסומן כקריאה בלבד.\n        *   מערכת ההפעלה תטפל בתקלה: היא תקצה דף פיזי חדש, תעתיק אליו את התוכן של הדף המקורי המשותף, ותעדכן את כניסת טבלת הדפים של תהליך הבן כך שתצביע על הדף הפיזי החדש והפרטי הזה, ותסמן אותו כניתן לכתיבה. ה-PTE של תהליך האב ימשיך להצביע על הדף המקורי (או עותק שלו אם היה משותף עם תהליכים נוספים).\n        *   **השפעה על Page Faults:** מכיוון שכל גישה בלולאה היא לדף חדש וייחודי (כפי שנותח בסעיף 1.2), כל גישה ראשונה לדף כזה על ידי תהליך הבן תגרור CoW fault. בנוסף, אם הדף אינו נמצא בזיכרון הפיזי (page fault רגיל), הוא יטען קודם מהדיסק, ורק אז יתבצע ה-CoW (או שה-CoW fault handler יטפל בטעינה ובהעתקה). לכן, תהליך הבן יחווה שיעור גבוה מאוד של CoW faults, בנוסף ל-page faults רגילים אם הדפים אינם בזיכרון.\n        *   **השפעה על צריכת זיכרון:** תהליך הבן יצרוך בהדרגה זיכרון פיזי פרטי חדש ככל שיבצע פעולות CoW. עבור הלולאה כולה, אם הוא כותב ל-2^18 דפים ייחודיים, הוא יצרוך בסופו של דבר 2^18 * 4KB = 2^30 בתים = 1GB של זיכרון פיזי *פרטי* עבור הדפים ששונו במערך `arr`.\n        *   תהליך האב לא משנה את המערך, ולכן צריכת הזיכרון שלו עבור `arr` לא תשתנה. הדפים שלו יישארו מצביעים על הדפים המקוריים (המשותפים) או על עותקים שלהם, והם יישארו במצב קריאה בלבד (אלא אם כן גם האב ינסה לכתוב)."
    },
    "difficulty_estimation": "Hard"
  }
}