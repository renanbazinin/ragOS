{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Deadlocks",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 21:32:09",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3900,
      "output_tokens": 2486,
      "total_tokens": 13500
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Deadlocks",
      "Synchronization",
      "Concurrency",
      "Mutexes"
    ],
    "content": {
      "text": "מערכת בנקאית מנהלת מספר חשבונות בנק. כל חשבון מיוצג על ידי מבנה BankAccount הכולל יתרה (balance) ומנעול (mutex) להגנה על היתרה. פונקציית transfer_money מיועדת להעביר סכום כסף מחשבון מקור לחשבון יעד. כדי להבטיח עקביות ושלמות הנתונים, הפונקציה נועלת את שני החשבונות המעורבים לפני ביצוע ההעברה ומשחררת אותם לאחריה. נתון קוד המימוש הבא:\n\nבחנו את הקוד לעיל.\n1. האם קיימת אפשרות לקיפאון (Deadlock) במימוש הפונקציה transfer_money? אם כן, תארו את התרחיש המדויק שיוביל לקיפאון ואת תנאי הקיפאון המתקיימים (Mutual Exclusion, Hold and Wait, No Preemption, Circular Wait).\n2. הציעו פתרון לבעיית הקיפאון וכתבו מחדש את פונקציית transfer_money כך שתמנע קיפאונות, תוך שמירה על נכונות וביצועים סבירים.",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For usleep\n\n// Define a BankAccount structure\ntypedef struct {\n    int id;\n    long balance;\n    pthread_mutex_t mutex;\n} BankAccount;\n\n// Function to initialize a bank account\nvoid init_account(BankAccount* account, int id, long initial_balance) {\n    account->id = id;\n    account->balance = initial_balance;\n    pthread_mutex_init(&account->mutex, NULL);\n}\n\n// Function to destroy a bank account\nvoid destroy_account(BankAccount* account) {\n    pthread_mutex_destroy(&account->mutex);\n}\n\n// Function to transfer money between two accounts (BUGGY VERSION)\nvoid transfer_money(BankAccount* source, BankAccount* destination, long amount) {\n    if (source == destination) {\n        return; // Cannot transfer to self\n    }\n\n    // Acquire locks in a potentially problematic order\n    pthread_mutex_lock(&source->mutex);\n    printf(\"Thread %lu locked account %d (source)\\n\", pthread_self(), source->id);\n    \n    // Simulate some work or delay to increase deadlock probability\n    usleep(10000); // 10ms delay\n\n    pthread_mutex_lock(&destination->mutex);\n    printf(\"Thread %lu locked account %d (destination)\\n\", pthread_self(), destination->id);\n\n    if (source->balance >= amount) {\n        source->balance -= amount;\n        destination->balance += amount;\n        printf(\"Transfer %ld from %d to %d successful. Balances: %d=%ld, %d=%ld\\n\", \n               amount, source->id, destination->id, source->id, source->balance, destination->id, destination->balance);\n    } else {\n        printf(\"Transfer %ld from %d to %d failed: insufficient funds.\\n\", amount, source->id, destination->id);\n    }\n\n    pthread_mutex_unlock(&destination->mutex);\n    printf(\"Thread %lu unlocked account %d (destination)\\n\", pthread_self(), destination->id);\n    pthread_mutex_unlock(&source->mutex);\n    printf(\"Thread %lu unlocked account %d (source)\\n\", pthread_self(), source->id);\n}\n",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "כן, קיימת אפשרות לקיפאון (Deadlock) במימוש הנוכחי של transfer_money.\n\n**תרחיש הקיפאון:**\nנניח שני חוטים, Thread 1 ו-Thread 2, ושני חשבונות, Account A ו-Account B.\n*   Thread 1 מנסה להעביר כסף מ-Account A ל-Account B (קורא ל-transfer_money(A, B, amount1)).\n*   Thread 2 מנסה להעביר כסף מ-Account B ל-Account A (קורא ל-transfer_money(B, A, amount2)).\n\n**השתלשלות אירועים אפשרית לקיפאון:**\n1.  Thread 1 נועל את mutex של Account A.\n2.  Thread 2 נועל את mutex של Account B.\n3.  Thread 1 מנסה כעת לנעול את mutex של Account B, אך הוא כבר נעול על ידי Thread 2. Thread 1 נחסם וממתין.\n4.  Thread 2 מנסה כעת לנעול את mutex של Account A, אך הוא כבר נעול על ידי Thread 1. Thread 2 נחסם וממתין.\n\nבשלב זה, שני החוטים חסומים וממתינים זה לזה לשחרור המשאב שהם צריכים, ונוצר קיפאון.\n\n**תנאי הקיפאון המתקיימים:**\n*   **מניעה הדדית (Mutual Exclusion):** כל מנעול (mutex) יכול להיות מוחזק על ידי חוט אחד בלבד בכל רגע נתון.\n*   **החזקה והמתנה (Hold and Wait):** כל חוט מחזיק במנעול אחד (למשל, Thread 1 מחזיק ב-mutex של Account A) וממתין למנעול נוסף (למשל, Thread 1 ממתין ל-mutex של Account B).\n*   **אי-הפקעה (No Preemption):** מנעול שהוחזק על ידי חוט לא יכול להילקח ממנו בכוח; הוא חייב לשחרר אותו מרצונו.\n*   **המתנה מעגלית (Circular Wait):** קיים מעגל של חוטים, כאשר כל חוט במעגל ממתין למשאב המוחזק על ידי החוט הבא במעגל. בתרחיש לעיל, Thread 1 ממתין ל-mutex של Account B שמוחזק על ידי Thread 2, ו-Thread 2 ממתין ל-mutex של Account A שמוחזק על ידי Thread 1.\n\n**פתרון מוצע:**\nכדי למנוע קיפאון במקרה של צורך בנעילת מספר משאבים, הגישה הנפוצה היא להבטיח שכל החוטים ירכשו את המשאבים באותו סדר קבוע (Global Ordering). במקרה זה, ניתן להחליט על סדר רכישת מנעולים לפי כתובות הזיכרון של אובייקטי BankAccount, או לפי מזהה ייחודי (ID) אם קיים. הפתרון יכלול השוואה בין כתובות הזיכרון של חשבונות המקור והיעד, ונעילה תמיד של החשבון בעל הכתובת הנמוכה יותר תחילה, ולאחר מכן את החשבון בעל הכתובת הגבוהה יותר.\n\n**מימוש מתוקן של transfer_money:**\n```c\nvoid transfer_money_safe(BankAccount* source, BankAccount* destination, long amount) {\n    if (source == destination) {\n        printf(\"Cannot transfer to self (account %d).\\n\", source->id);\n        return; \n    }\n\n    pthread_mutex_t *first_mutex, *second_mutex;\n    BankAccount *first_account, *second_account;\n\n    // Determine a consistent locking order based on memory addresses\n    // This ensures that all threads attempting to lock these two specific accounts\n    // will always try to acquire them in the same sequence, preventing circular wait.\n    if (source < destination) { // Compare memory addresses of the account objects\n        first_mutex = &source->mutex;\n        second_mutex = &destination->mutex;\n        first_account = source;\n        second_account = destination;\n    } else {\n        first_mutex = &destination->mutex;\n        second_mutex = &source->mutex;\n        first_account = destination;\n        second_account = source;\n    }\n\n    // Acquire locks in the consistent order\n    pthread_mutex_lock(first_mutex);\n    printf(\"Thread %lu locked account %d (first in order)\\n\", pthread_self(), first_account->id);\n\n    // Simulate some work or delay\n    usleep(10000); // 10ms delay\n\n    pthread_mutex_lock(second_mutex);\n    printf(\"Thread %lu locked account %d (second in order)\\n\", pthread_self(), second_account->id);\n\n    // Perform the transfer logic with both locks held\n    // The source and destination pointers remain as they were passed to the function,\n    // only the order of mutex acquisition changes.\n    if (source->balance >= amount) {\n        source->balance -= amount;\n        destination->balance += amount;\n        printf(\"Transfer %ld from %d to %d successful. Balances: %d=%ld, %d=%ld\\n\", \n               amount, source->id, destination->id, source->id, source->balance, destination->id, destination->balance);\n    } else {\n        printf(\"Transfer %ld from %d to %d failed: insufficient funds. Balances: %d=%ld, %d=%ld\\n\", \n               amount, source->id, destination->id, source->id, source->balance, destination->id, destination->balance);\n    }\n\n    // Release locks in reverse order of acquisition (or simply both, order doesn't matter for unlock)\n    pthread_mutex_unlock(second_mutex);\n    printf(\"Thread %lu unlocked account %d (second in order)\\n\", pthread_self(), second_account->id);\n    pthread_mutex_unlock(first_mutex);\n    printf(\"Thread %lu unlocked account %d (first in order)\\n\", pthread_self(), first_account->id);\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}