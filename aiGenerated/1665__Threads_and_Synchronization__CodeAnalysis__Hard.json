{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Synchronization",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 19:53:17",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3826,
      "output_tokens": 3466,
      "total_tokens": 17240
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Threads",
      "Synchronization",
      "Bounded Buffer",
      "Priority Queue",
      "Condition Variables",
      "Mutexes"
    ],
    "content": {
      "text": "נתונה מערכת מרובת חוטים המממשת חוצץ חסום (bounded buffer) בעל יכולת `BUFFER_SIZE`. מספר חוטים יצרנים (producers) מוסיפים מספרים שלמים אקראיים לחוצץ, ומספר חוטים צרכנים (consumers) מסירים מספרים שלמים מהחוצץ. המאפיין הייחודי של מערכת זו הוא שחוט צרכן רשאי להסיר מהחוצץ אך ורק את המספר השלם ה *קטן ביותר* מבין כל המספרים הנמצאים כרגע בחוצץ. אם החוצץ ריק, או שהמספר הקטן ביותר אינו זמין (למשל, כבר נלקח על ידי צרכן אחר), הצרכן ממתין.\nיש לממש את הפונקציות `put_item` (עבור יצרנים) ו-`get_smallest_item` (עבור צרכנים) תוך שימוש במנעולים (mutexes) ומשתני תנאי (condition variables) בלבד. יש להבטיח את הדרישות הבאות:\n1.  **נכונות**: יצרנים יוכלו להוסיף פריטים רק כשיש מקום, וצרכנים יוכלו להסיר פריטים רק כשהחוצץ אינו ריק ורק את הפריט הקטן ביותר.\n2.  **מניעת קיפאון (Deadlock-free)**: המערכת לא תגיע למצב שבו חוטים ממתינים זה לזה באופן אינסופי.\n3.  **מניעת הרעבה (Starvation-free)**: אף חוט לא ימתין ללא הגבלה אם התנאים מאפשרים לו להתקדם.\n4.  **יעילות**: אין שימוש ב-spinning.\n\nהקוד הבא מהווה תבנית ליישום. יש להשלים את הפונקציות `put_item` ו-`get_smallest_item` ולהוסיף את המשתנים הגלובליים הדרושים (יש לציין את ערכי האתחול בהערה).",
      "code_snippet": "#include <iostream>\n#include <set>\n#include <mutex>\n#include <condition_variable>\n#include <thread>\n#include <vector>\n#include <random>\n#include <chrono>\n\n#define BUFFER_SIZE 5\n#define NUM_PRODUCERS 2\n#define NUM_CONSUMERS 2\n#define ITEMS_PER_PRODUCER 10\n\n// Global shared resources\n// TO BE COMPLETED: Add global variables here (mutexes, condition variables, buffer, etc.)\n// Example: std::set<int> buffer; // Initialized: empty\n// Example: std::mutex mtx; // Initialized: unlocked\n// Example: std::condition_variable cv_producer; // Initialized: default\n// Example: std::condition_variable cv_consumer; // Initialized: default\n// Example: int total_items_produced = 0; // Initialized: 0\n// Example: int total_items_consumed = 0; // Initialized: 0\n// Example: bool producers_done = false; // Initialized: false\n\nvoid put_item(int item) {\n    // TO BE COMPLETED: Implement producer logic\n}\n\nint get_smallest_item() {\n    // TO BE COMPLETED: Implement consumer logic\n    return -1; // Placeholder for compilation\n}\n\nvoid producer_func(int id, std::mt19937& rng) {\n    std::uniform_int_distribution<int> dist(1, 1000);\n    for (int i = 0; i < ITEMS_PER_PRODUCER; ++i) {\n        int item = dist(rng);\n        put_item(item);\n        std::this_thread::sleep_for(std::chrono::milliseconds(rand() % 50 + 10));\n    }\n}\n\nvoid consumer_func(int id) {\n    while (true) {\n        int item = get_smallest_item();\n        if (item == -1) {\n            std::cout << \"Consumer \" << std::this_thread::get_id() << \" terminating.\" << std::endl;\n            break;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(rand() % 70 + 20));\n    }\n}\n\nint main() {\n    std::vector<std::thread> producers;\n    std::vector<std::thread> consumers;\n\n    std::vector<std::mt19937> rngs;\n    for (int i = 0; i < NUM_PRODUCERS; ++i) {\n        rngs.emplace_back(std::chrono::system_clock::now().time_since_epoch().count() + i);\n    }\n\n    for (int i = 0; i < NUM_PRODUCERS; ++i) {\n        producers.emplace_back(producer_func, i, std::ref(rngs[i]));\n    }\n    for (int i = 0; i < NUM_CONSUMERS; ++i) {\n        consumers.emplace_back(consumer_func, i);\n    }\n\n    for (auto& p : producers) {\n        p.join();\n    }\n\n    // After all producers finish, signal consumers\n    {\n        // TO BE COMPLETED: Signal consumers that producers are done\n        // Example: std::unique_lock<std::mutex> lock(mtx);\n        // Example: all_producers_finished = true;\n        // Example: cv_consumer.notify_all();\n    }\n\n    for (auto& c : consumers) {\n        c.join();\n    }\n\n    std::cout << \"Main finished. Total items produced: (TODO) , Total items consumed: (TODO) \" << std::endl;\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון משתמש באובייקטים הגלובליים הבאים:\n*   `std::set<int> buffer; // Initialized: empty`: המאגר המשותף. `std::set` נבחר מכיוון שהוא שומר את האלמנטים ממוינים באופן אוטומטי ומאפשר גישה קלה לאלמנט הקטן ביותר (באמצעות `*buffer.begin()`) והסרה יעילה שלו (באמצעות `buffer.erase(buffer.begin())`).\n*   `std::mutex mtx; // Initialized: unlocked`: מנעול להגנה על הגישה למאגר `buffer` ולמשתנים גלובליים אחרים (כמו `all_producers_finished`).\n*   `std::condition_variable cv_producer; // Initialized: default`: משתנה תנאי עבור היצרנים. יצרנים ממתינים עליו כאשר המאגר מלא.\n*   `std::condition_variable cv_consumer; // Initialized: default`: משתנה תנאי עבור הצרכנים. צרכנים ממתינים עליו כאשר המאגר ריק או כאשר כל היצרנים סיימו את עבודתם (כדי לבדוק אם יש פריטים אחרונים או לסיים).\n*   `int total_items_produced_count = 0; // Initialized: 0`: מונה עזר למעקב אחר פריטים שנוצרו. מוגן על ידי המנעול.\n*   `int total_items_consumed_count = 0; // Initialized: 0`: מונה עזר למעקב אחר פריטים שנצרכו. מוגן על ידי המנעול.\n*   `bool all_producers_finished = false; // Initialized: false`: דגל גלובלי שמסמן מתי כל היצרנים סיימו להוסיף פריטים למאגר. משמש לאיתות לצרכנים שאין יותר פריטים חדשים שיגיעו, והם יכולים לסיים לאחר עיבוד כל הפריטים הקיימים.\n\n**השלמת הקוד:**\n\n**משתנים גלובליים (יש לציין ערכי אתחול בהערה):**\n```cpp\nstd::set<int> buffer; // Initialized: empty\nstd::mutex mtx; // Initialized: unlocked\nstd::condition_variable cv_producer; // Initialized: default\nstd::condition_variable cv_consumer; // Initialized: default\nint total_items_produced_count = 0; // Initialized: 0\nint total_items_consumed_count = 0; // Initialized: 0\nbool all_producers_finished = false; // Initialized: false\n```\n\n**פונקציית `put_item` (יצרן)**:\n```cpp\nvoid put_item(int item) {\n    std::unique_lock<std::mutex> lock(mtx);\n    cv_producer.wait(lock, []{ return buffer.size() < BUFFER_SIZE; }); // המתן אם המאגר מלא\n\n    buffer.insert(item);\n    std::cout << \"Producer \" << std::this_thread::get_id() << \" added: \" << item << \". Buffer size: \" << buffer.size() << std::endl;\n    total_items_produced_count++;\n    cv_consumer.notify_all(); // הודע לכל הצרכנים שהמאגר אינו ריק וכנראה פריט קטן חדש זמין\n}\n```\n\n**פונקציית `get_smallest_item` (צרכן)**:\n```cpp\nint get_smallest_item() {\n    std::unique_lock<std::mutex> lock(mtx);\n    cv_consumer.wait(lock, []{ return !buffer.empty() || all_producers_finished; }); // המתן אם המאגר ריק וגם היצרנים לא סיימו\n\n    if (buffer.empty() && all_producers_finished) {\n        // אם המאגר ריק וכל היצרנים סיימו, הצרכן יכול לסיים.\n        return -1; // ערך מיוחד המסמן סיום\n    }\n\n    int smallest_item = *buffer.begin();\n    buffer.erase(buffer.begin());\n    std::cout << \"Consumer \" << std::this_thread::get_id() << \" removed smallest: \" << smallest_item << \". Buffer size: \" << buffer.size() << std::endl;\n    total_items_consumed_count++;\n    cv_producer.notify_one(); // הודע ליצרן אחד שיש מקום פנוי\n    return smallest_item;\n}\n```\n\n**השלמה ב-`main` עבור סיום הצרכנים וסטטיסטיקות:**\n```cpp\n    // ... אחרי לולאת ה-join של היצרנים ...\n    {\n        std::unique_lock<std::mutex> lock(mtx);\n        all_producers_finished = true;\n        std::cout << \"All producers finished their work.\" << std::endl;\n        cv_consumer.notify_all(); // העיר את כל הצרכנים הממתינים לבדוק את תנאי הסיום\n    }\n\n    // ... אחרי לולאת ה-join של הצרכנים ...\n    std::cout << \"Main finished. Total items produced: \" << total_items_produced_count\n              << \", Total items consumed: \" << total_items_consumed_count << std::endl;\n```\n\n**ניתוח דרישות:**\n1.  **נכונות**: \n    *   **יצרנים**: ממתינים כשהמאגר מלא (באמצעות `cv_producer.wait` ותנאי הלמבדה `buffer.size() < BUFFER_SIZE`).\n    *   **צרכנים**: ממתינים כשהמאגר ריק (באמצעות `cv_consumer.wait` ותנאי הלמבדה `!buffer.empty() || all_producers_finished`). הם תמיד מסירים את הפריט הקטן ביותר הודות לשימוש ב-`std::set` ובגישה ל-`*buffer.begin()`. \n    *   **בלעדיות**: הגישה למאגר מוגנת על ידי `mtx`, מה שמבטיח שרק חוט אחד יכול לשנות את המאגר בכל רגע נתון.\n2.  **מניעת קיפאון (Deadlock-free)**:\n    *   אין סדר נעילה מעגלי (`circular lock dependency`). קיים מנעול יחיד `mtx` שכל החוטים נועלים ומשחררים.\n    *   השימוש ב-`std::unique_lock` ו-`condition_variable::wait` עם פרדיקטים (למבדות) מונע קיפאון כתוצאה מ-spurious wakeups או תזמונים לא נכונים. החוטים תמיד בודקים את התנאי *לאחר* ההתעוררות.\n3.  **מניעת הרעבה (Starvation-free)**:\n    *   **יצרנים**: אם יש מקום במאגר, יצרן יצליח להוסיף פריט. `notify_one` מספיק כי כל מקום פנוי יכול לשמש כל יצרן.\n    *   **צרכנים**: אם יש פריט במאגר, במיוחד הפריט הקטן ביותר, צרכן יצליח להסירו. `notify_all` לצרכנים מבטיח שכל צרכן שממתין יתעורר ויבדוק את התנאי, ובכך מונע מצב שבו צרכן יחיד מוזנח.\n4.  **יעילות (No spinning)**:\n    *   השימוש ב-`condition_variable::wait` מבטיח שחוטים ממתינים נרדמים ולא צורכים משאבי CPU בלולאת בדיקה פעילה (spinning), אלא מתעוררים רק כאשר הם מקבלים איתות מחוט אחר."
    },
    "difficulty_estimation": "Hard"
  }
}