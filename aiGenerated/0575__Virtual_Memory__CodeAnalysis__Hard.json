{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:24:03",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3618,
      "output_tokens": 4916,
      "total_tokens": 15503
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Copy-on-Write",
      "fork()",
      "Page Faults"
    ],
    "content": {
      "text": "נתון קטע הקוד הבא ב-C, המדגים שימוש במנגנון fork() וגישה לזיכרון משותף (סטטי גלובלי) על ידי תהליך אב ותהליך בן. אנו מניחים שגודל דף זיכרון (PAGE_SIZE) הוא 4KB (4096 בתים) ושכל פעולת כתיבה לדף שטרם נכתב אליו מאז ה-fork תגרום ל-Page Fault אחד לצורך העתקת הדף (Copy-on-Write).\n\nענו על השאלות הבאות בהתבסס על ניתוח הקוד והבנת מנגנון Copy-on-Write:\n\n1. מהו הפלט המדויק של התוכנית? ספקו את הפלט של תהליך האב ושל תהליך הבן בנפרד, כולל ה-PIDs שלהם.\n2. כמה Page Faults סך הכל יתרחשו במהלך ריצת התוכנית עקב פעולות כתיבה שהובילו להפעלת מנגנון Copy-on-Write? נמקו את תשובתכם עבור כל דף.\n3. עבור כל אחד מארבעת הדפים של המערך shared_array, תארו את מצבו הסופי (משותף, פרטי לאב, פרטי לבן) ואת הערכים הסופיים של shared_array[index] עבור האינדקסים שהוגדרו בתהליך האב והבן, כפי שהם נראים מנקודת מבטם של תהליך האב ותהליך הבן לאחר סיום ריצתם.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define PAGE_SIZE 4096 // Assume 4KB page size\n#define ARRAY_ELEMENTS (4 * PAGE_SIZE / sizeof(int)) // Total elements for 4 pages\n\n// Global array, will be part of the data segment\nstatic int shared_array[ARRAY_ELEMENTS];\n\nint main() {\n    pid_t pid;\n\n    // Initialize specific elements to easily track changes\n    shared_array[0] = 10; // Page 0\n    shared_array[PAGE_SIZE / sizeof(int)] = 20; // Page 1\n    shared_array[2 * PAGE_SIZE / sizeof(int)] = 30; // Page 2\n    shared_array[3 * PAGE_SIZE / sizeof(int)] = 40; // Page 3\n\n    printf(\"Parent (PID %d) - Initial state:\\n\", getpid());\n    printf(\"  shared_array[0] = %d (Page 0)\\n\", shared_array[0]);\n    printf(\"  shared_array[PAGE_SIZE/sizeof(int)] = %d (Page 1)\\n\", shared_array[PAGE_SIZE/sizeof(int)]);\n    printf(\"  shared_array[2*PAGE_SIZE/sizeof(int)] = %d (Page 2)\\n\", shared_array[2*PAGE_SIZE/sizeof(int)]);\n    printf(\"  shared_array[3*PAGE_SIZE/sizeof(int)] = %d (Page 3)\\n\", shared_array[3*PAGE_SIZE/sizeof(int)]);\n\n    pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        return 1;\n    } else if (pid == 0) { // Child process\n        printf(\"\\nChild (PID %d) - Before modification:\\n\", getpid());\n        printf(\"  shared_array[0] = %d (Page 0)\\n\", shared_array[0]); // Should be 10\n        printf(\"  shared_array[PAGE_SIZE/sizeof(int)] = %d (Page 1)\\n\", shared_array[PAGE_SIZE/sizeof(int)]); // Should be 20\n\n        // Child modifies an element in Page 1\n        shared_array[PAGE_SIZE / sizeof(int)] = 200; // This should trigger CoW for Page 1\n\n        printf(\"\\nChild (PID %d) - After modification:\\n\", getpid());\n        printf(\"  shared_array[0] = %d (Page 0) - (Expected 10)\\n\", shared_array[0]);\n        printf(\"  shared_array[PAGE_SIZE/sizeof(int)] = %d (Page 1) - (Expected 200)\\n\", shared_array[PAGE_SIZE/sizeof(int)]);\n        printf(\"  shared_array[2*PAGE_SIZE/sizeof(int)] = %d (Page 2) - (Expected 30)\\n\", shared_array[2*PAGE_SIZE/sizeof(int)]);\n        printf(\"  shared_array[3*PAGE_SIZE/sizeof(int)] = %d (Page 3) - (Expected 40)\\n\", shared_array[3*PAGE_SIZE/sizeof(int)]);\n\n    } else { // Parent process\n        wait(NULL); // Wait for child to finish\n\n        printf(\"\\nParent (PID %d) - After child finished, before parent modification:\\n\", getpid());\n        printf(\"  shared_array[0] = %d (Page 0) - (Expected 10)\\n\", shared_array[0]);\n        printf(\"  shared_array[PAGE_SIZE/sizeof(int)] = %d (Page 1) - (Expected 20)\\n\", shared_array[PAGE_SIZE/sizeof(int)]); // Should still be 20 for parent\n        printf(\"  shared_array[2*PAGE_SIZE/sizeof(int)] = %d (Page 2) - (Expected 30)\\n\", shared_array[2*PAGE_SIZE/sizeof(int)]);\n        printf(\"  shared_array[3*PAGE_SIZE/sizeof(int)] = %d (Page 3) - (Expected 40)\\n\", shared_array[3*PAGE_SIZE/sizeof(int)]);\n\n        // Parent modifies an element in Page 2\n        shared_array[2 * PAGE_SIZE / sizeof(int)] = 300; // This should trigger CoW for Page 2\n\n        printf(\"\\nParent (PID %d) - After parent modification:\\n\", getpid());\n        printf(\"  shared_array[0] = %d (Page 0) - (Expected 10)\\n\", shared_array[0]);\n        printf(\"  shared_array[PAGE_SIZE/sizeof(int)] = %d (Page 1) - (Expected 20)\\n\", shared_array[PAGE_SIZE/sizeof(int)]); // Should still be 20 for parent\n        printf(\"  shared_array[2*PAGE_SIZE/sizeof(int)] = %d (Page 2) - (Expected 300)\\n\", shared_array[2*PAGE_SIZE/sizeof(int)]);\n        printf(\"  shared_array[3*PAGE_SIZE/sizeof(int)] = %d (Page 3) - (Expected 40)\\n\", shared_array[3*PAGE_SIZE/sizeof(int)]);\n    }\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**הסבר מפורט:**\n\n**רקע - מנגנון Copy-on-Write (CoW):**\nכאשר תהליך אב יוצר תהליך בן באמצעות `fork()`, מערכת ההפעלה אינה מעתיקה מיד את כל מרחב הכתובות של האב לבן. במקום זאת, היא משתפת את דפי הזיכרון בין האב לבן ומסמנת אותם כ'לקריאה בלבד'. רק כאשר אחד מהתהליכים (האב או הבן) מנסה לכתוב לדף משותף, מתרחשת Page Fault. ה-OS מזהה שהדף מסומן כ'לקריאה בלבד' למרות שהתהליך מנסה לכתוב אליו, ואז היא מעתיקה את הדף הזה, מעניקה לכל תהליך עותק פרטי משלו, ומשנה את הרשאת הדף החדש ל'קריאה וכתיבה'. הדף המקורי נשאר ללא שינוי עבור התהליך השני. דפים שלא נכתבו אליהם על ידי אף אחד מהתהליכים נשארים משותפים.\n\n**ניתוח הקוד:**\nהמערך `shared_array` מוגדר כ-`static` גלובלי, ולכן הוא ממוקם במקטע הנתונים (data segment) של התוכנית. גודל המערך הוא `4 * PAGE_SIZE`, כלומר הוא משתרע על פני 4 דפי זיכרון (נניח דפים 0, 1, 2, 3). בתחילת `main`, אנו מאתחלים אינדקסים ספציפיים בכל אחד מארבעת הדפים:\n- `shared_array[0]` (דף 0) = 10\n- `shared_array[PAGE_SIZE / sizeof(int)]` (דף 1) = 20\n- `shared_array[2 * PAGE_SIZE / sizeof(int)]` (דף 2) = 30\n- `shared_array[3 * PAGE_SIZE / sizeof(int)]` (דף 3) = 40\n\nלאחר מכן, מתבצעת קריאה ל-`fork()`.\n\n**מצב לאחר `fork()`:**\nמיד לאחר ה-`fork()`, כל 4 הדפים של `shared_array` משותפים בין האב לבן ומסומנים כ-CoW (קריאה בלבד). עדיין לא אירעו Page Faults עקב CoW.\n\n**תהליך הבן (pid == 0):**\n1. **קריאה ל-`shared_array[0]` ו-`shared_array[PAGE_SIZE/sizeof(int)]`:** הבן קורא מהדפים 0 ו-1. מכיוון שזו פעולת קריאה, הדפים נשארים משותפים (CoW) ואין Page Faults. הפלט יהיה הערכים המקוריים: 10 ו-20.\n2. **כתיבה ל-`shared_array[PAGE_SIZE / sizeof(int)] = 200`:** זוהי הפעם הראשונה שהבן כותב לדף 1. פעולה זו תגרום ל-**Page Fault 1**:\n   - מערכת ההפעלה תעתיק את דף 1 (שמכיל כעת את הערך המקורי 20) למקום פיזי חדש עבור הבן.\n   - דף 1 במרחב הכתובות של הבן יצביע כעת על העותק הפרטי שלו.\n   - הבן יכתוב 200 ל-`shared_array[PAGE_SIZE / sizeof(int)]` בעותק הפרטי שלו.\n   - דף 1 במרחב הכתובות של האב עדיין מצביע על הדף המקורי עם הערך 20.\n3. **קריאה ל-`shared_array[0]`, `shared_array[PAGE_SIZE/sizeof(int)]`, `shared_array[2*PAGE_SIZE/sizeof(int)]`, `shared_array[3*PAGE_SIZE/sizeof(int)]`:**\n   - `shared_array[0]` (דף 0): נשאר משותף. הבן רואה 10.\n   - `shared_array[PAGE_SIZE/sizeof(int)]` (דף 1): הבן רואה את הערך בעותק הפרטי שלו: 200.\n   - `shared_array[2*PAGE_SIZE/sizeof(int)]` (דף 2): נשאר משותף. הבן רואה 30.\n   - `shared_array[3*PAGE_SIZE/sizeof(int)]` (דף 3): נשאר משותף. הבן רואה 40.\n   \n**תהליך האב (pid > 0):**\n1. **`wait(NULL)`:** האב ממתין שהבן יסיים.\n2. **קריאה ל-`shared_array[0]`, `shared_array[PAGE_SIZE/sizeof(int)]`, `shared_array[2*PAGE_SIZE/sizeof(int)]`, `shared_array[3*PAGE_SIZE/sizeof(int)]`:**\n   - `shared_array[0]` (דף 0): נשאר משותף. האב רואה 10.\n   - `shared_array[PAGE_SIZE/sizeof(int)]` (דף 1): האב רואה את הערך המקורי (שלא שונה עבורו): 20.\n   - `shared_array[2*PAGE_SIZE/sizeof(int)]` (דף 2): נשאר משותף. האב רואה 30.\n   - `shared_array[3*PAGE_SIZE/sizeof(int)]` (דף 3): נשאר משותף. האב רואה 40.\n3. **כתיבה ל-`shared_array[2 * PAGE_SIZE / sizeof(int)] = 300`:** זוהי הפעם הראשונה שהאב כותב לדף 2. פעולה זו תגרום ל-**Page Fault 2**:\n   - מערכת ההפעלה תעתיק את דף 2 (שמכיל כעת את הערך המקורי 30) למקום פיזי חדש עבור האב.\n   - דף 2 במרחב הכתובות של האב יצביע כעת על העותק הפרטי שלו.\n   - האב יכתוב 300 ל-`shared_array[2 * PAGE_SIZE / sizeof(int)]` בעותק הפרטי שלו.\n   - דף 2 במרחב הכתובות של הבן עדיין מצביע על הדף המקורי עם הערך 30.\n4. **קריאה ל-`shared_array[0]`, `shared_array[PAGE_SIZE/sizeof(int)]`, `shared_array[2*PAGE_SIZE/sizeof(int)]`, `shared_array[3*PAGE_SIZE/sizeof(int)]`:**\n   - `shared_array[0]` (דף 0): נשאר משותף. האב רואה 10.\n   - `shared_array[PAGE_SIZE/sizeof(int)]` (דף 1): האב רואה את הערך המקורי: 20.\n   - `shared_array[2*PAGE_SIZE/sizeof(int)]` (דף 2): האב רואה את הערך בעותק הפרטי שלו: 300.\n   - `shared_array[3*PAGE_SIZE/sizeof(int)]` (דף 3): נשאר משותף. האב רואה 40.\n\n**סיכום - תשובות:**\n\n**1. פלט התוכנית (ה-PIDs יהיו דינמיים, נסמן אותם כ-PARENT_PID ו-CHILD_PID):**\n```\nParent (PID PARENT_PID) - Initial state:\n  shared_array[0] = 10 (Page 0)\n  shared_array[PAGE_SIZE/sizeof(int)] = 20 (Page 1)\n  shared_array[2*PAGE_SIZE/sizeof(int)] = 30 (Page 2)\n  shared_array[3*PAGE_SIZE/sizeof(int)] = 40 (Page 3)\n\nChild (PID CHILD_PID) - Before modification:\n  shared_array[0] = 10 (Page 0)\n  shared_array[PAGE_SIZE/sizeof(int)] = 20 (Page 1)\n\nChild (PID CHILD_PID) - After modification:\n  shared_array[0] = 10 (Page 0) - (Expected 10)\n  shared_array[PAGE_SIZE/sizeof(int)] = 200 (Page 1) - (Expected 200)\n  shared_array[2*PAGE_SIZE/sizeof(int)] = 30 (Page 2) - (Expected 30)\n  shared_array[3*PAGE_SIZE/sizeof(int)] = 40 (Page 3) - (Expected 40)\n\nParent (PID PARENT_PID) - After child finished, before parent modification:\n  shared_array[0] = 10 (Page 0) - (Expected 10)\n  shared_array[PAGE_SIZE/sizeof(int)] = 20 (Page 1) - (Expected 20)\n  shared_array[2*PAGE_SIZE/sizeof(int)] = 30 (Page 2) - (Expected 30)\n  shared_array[3*PAGE_SIZE/sizeof(int)] = 40 (Page 3) - (Expected 40)\n\nParent (PID PARENT_PID) - After parent modification:\n  shared_array[0] = 10 (Page 0) - (Expected 10)\n  shared_array[PAGE_SIZE/sizeof(int)] = 20 (Page 1) - (Expected 20)\n  shared_array[2*PAGE_SIZE/sizeof(int)] = 300 (Page 2) - (Expected 300)\n  shared_array[3*PAGE_SIZE/sizeof(int)] = 40 (Page 3) - (Expected 40)\n```\n\n**2. מספר Page Faults עקב CoW:**\nסך הכל יתרחשו **2** Page Faults עקב Copy-on-Write:\n- **Page Fault 1:** כאשר תהליך הבן כותב ל-`shared_array[PAGE_SIZE / sizeof(int)]` (בדף 1). דף 1 מועתק עבור הבן.\n- **Page Fault 2:** כאשר תהליך האב כותב ל-`shared_array[2 * PAGE_SIZE / sizeof(int)]` (בדף 2). דף 2 מועתק עבור האב.\nדפים 0 ו-3 לעולם אינם נכתבים על ידי אף תהליך לאחר ה-`fork`, ולכן הם נשארים משותפים (CoW) ואינם גורמים ל-Page Faults.\n\n**3. מצב סופי של הדפים והערכים:**\n- **דף 0 (מכיל את `shared_array[0]`):**\n  - **מצב:** משותף (Shared). אף תהליך לא כתב לדף זה לאחר ה-`fork`.\n  - **ערך באב:** 10\n  - **ערך בבן:** 10\n\n- **דף 1 (מכיל את `shared_array[PAGE_SIZE / sizeof(int)]`):**\n  - **מצב:** פרטי לבן (Private to Child) לאחר כתיבת הבן. נשאר משותף עבור האב.\n  - **ערך באב:** 20 (הערך המקורי)\n  - **ערך בבן:** 200 (הערך שהבן כתב)\n\n- **דף 2 (מכיל את `shared_array[2 * PAGE_SIZE / sizeof(int)]`):**\n  - **מצב:** פרטי לאב (Private to Parent) לאחר כתיבת האב. נשאר משותף עבור הבן.\n  - **ערך באב:** 300 (הערך שהאב כתב)\n  - **ערך בבן:** 30 (הערך המקורי)\n\n- **דף 3 (מכיל את `shared_array[3 * PAGE_SIZE / sizeof(int)]`):**\n  - **מצב:** משותף (Shared). אף תהליך לא כתב לדף זה לאחר ה-`fork`.\n  - **ערך באב:** 40\n  - **ערך בבן:** 40"
    },
    "difficulty_estimation": "Hard"
  }
}