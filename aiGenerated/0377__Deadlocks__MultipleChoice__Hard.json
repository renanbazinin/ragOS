{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Deadlocks",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 21:09:55",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 969,
      "output_tokens": 1210,
      "total_tokens": 4301
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 10,
    "type": "MultipleChoice",
    "topic": [
      "Deadlocks",
      "Concurrency",
      "Synchronization"
    ],
    "content": {
      "text": "נתון קטע הקוד הבא בשפת C++ המשתמש בשני מנעולים (mutexes) ובשני תהליכונים (threads). האם קיים סיכון למבוי סתום (deadlock) בקוד זה, ואם כן, מדוע?",
      "code_snippet": "#include <iostream>\n#include <thread>\n#include <mutex>\n#include <chrono>\n\nstd::mutex mutex_A;\nstd::mutex mutex_B;\n\nvoid thread_func1() {\n    std::cout << \"Thread 1: Trying to acquire mutex_A...\\n\";\n    mutex_A.lock();\n    std::cout << \"Thread 1: Acquired mutex_A. Trying to acquire mutex_B...\\n\";\n    std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Simulate some work/delay\n    mutex_B.lock();\n    std::cout << \"Thread 1: Acquired mutex_B. Doing work...\\n\";\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    mutex_B.unlock();\n    std::cout << \"Thread 1: Released mutex_B.\\n\";\n    mutex_A.unlock();\n    std::cout << \"Thread 1: Released mutex_A.\\n\";\n}\n\nvoid thread_func2() {\n    std::cout << \"Thread 2: Trying to acquire mutex_B...\\n\";\n    mutex_B.lock();\n    std::cout << \"Thread 2: Acquired mutex_B. Trying to acquire mutex_A...\\n\";\n    std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Simulate some work/delay\n    mutex_A.lock();\n    std::cout << \"Thread 2: Acquired mutex_A. Doing work...\\n\";\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    mutex_A.unlock();\n    std::cout << \"Thread 2: Released mutex_A.\\n\";\n    mutex_B.unlock();\n    std::cout << \"Thread 2: Released mutex_B.\\n\";\n}\n\n// Example usage (not part of the snippet for the question):\n// int main() {\n//     std::thread t1(thread_func1);\n//     std::thread t2(thread_func2);\n//     t1.join();\n//     t2.join();\n//     return 0;\n// }",
      "options": [
        "א. לא, מכיוון שכל תהליכון משחרר את המנעולים שהוא תפס בסופו של דבר.",
        "ב. כן, מכיוון ששני התהליכונים מנסים לתפוס את אותם מנעולים בסדר שונה, מה שעלול ליצור מצב של המתנה מעגלית.",
        "ג. לא, מכיוון שמערכת ההפעלה תזהה ותמנע מבוי סתום באופן אוטומטי.",
        "ד. כן, אך רק אם אחד התהליכונים יבצע פעולת I/O ארוכה בין תפיסת המנעול הראשון לשני.",
        "ה. לא, מכיוון ששימוש במנעולים (mutexes) תמיד מונע מבוי סתום."
      ]
    },
    "sub_questions": null,
    "points": 5,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "התשובה הנכונה היא ב'. מבוי סתום (deadlock) יכול להתרחש בקוד זה. תהליכון 1 מנסה לתפוס את mutex_A ואז את mutex_B. תהליכון 2 מנסה לתפוס את mutex_B ואז את mutex_A. אם תהליכון 1 יתפוס את mutex_A ותהליכון 2 יתפוס את mutex_B בו-זמנית (או בסמיכות זמנים), אז תהליכון 1 ימתין ל-mutex_B שתפוס על ידי תהליכון 2, ותהליכון 2 ימתין ל-mutex_A שתפוס על ידי תהליכון 1. זהו מצב קלאסי של המתנה מעגלית (circular wait) הממלא את כל ארבעת התנאים למבוי סתום: הדרה הדדית (mutual exclusion), אחיזה והמתנה (hold and wait), אי-הפקעה (no preemption), והמתנה מעגלית. זמן ההמתנה הקצר (sleep_for) אינו הכרחי כדי ליצור את התנאים למבוי סתום, אלא רק מגדיל את הסיכוי שהוא יתרחש בפועל."
    },
    "difficulty_estimation": "Hard"
  }
}