{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Synchronization",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:05:23",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4129,
      "output_tokens": 4160,
      "total_tokens": 24918
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Threads",
      "Condition Variables",
      "Deadlock",
      "Starvation"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה, המנהלת מונה משותף `counter` בין מספר סוגי חוטים. המונה מאותחל ל-0. ישנם שלושה סוגים של חוטים:\n*   **Incrementer**: מגדיל את המונה ב-1.\n*   **Decrementer**: מקטין את המונה ב-1.\n*   **Monitor**: מדפיס את ערך המונה.\n\nהתוכנית מנסה ליישם את דרישות הסנכרון הבאות:\n1.  **מניעת ירידה מתחת לאפס**: המונה `counter` לעולם לא יירד מתחת ל-0. חוט Decrementer שמנסה להקטין את המונה כשהוא 0, ימתין.\n2.  **צפייה רק בערכים זוגיים**: חוט Monitor ידפיס את ערך המונה רק אם הוא זוגי. אם המונה אי-זוגי, הוא ימתין.\n3.  **מניעת הרעבה למקטינים (Decrementers)**: אם המונה הוא 0 וישנם חוטי Decrementer שממתינים, חוטי Incrementer צריכים להיחסם באופן זמני עד שהמונה יהפוך לחיובי ולפחות חוט Decrementer אחד יוכל לרוץ.\n\nענו על השאלות הבאות בהתבסס על הקוד הנתון. יש להניח שכל קריאות המערכת הצליחו.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h> // for sleep\n\n#define NUM_INCREMENTERS 2\n#define NUM_DECREMENTERS 2\n#define NUM_MONITORS 1\n#define ITERATIONS 5\n\nint counter = 0;\npthread_mutex_t mutex;\npthread_cond_t can_decrement; // For decrementers to wait if counter is 0\npthread_cond_t counter_is_even; // For monitors to wait if counter is odd\n\n// To handle starvation for decrementers\nint waiting_decrementers = 0; // Number of decrementers waiting\npthread_cond_t incrementers_block; // For incrementers to wait if decrementers are starving\n\nvoid* incrementer_thread(void* arg) {\n    for (int i = 0; i < ITERATIONS; ++i) {\n        pthread_mutex_lock(&mutex);\n        // FLAW related to starvation avoidance for decrementers.\n        // If there are waiting decrementers and counter is 0, incrementers should wait.\n        // But what if counter is > 0 and decrementers are waiting? They should run first.\n        while (waiting_decrementers > 0 && counter == 0) {\n            printf(\"Incrementer: Waiting due to starving decrementers. Counter: %d\\n\", counter);\n            pthread_cond_wait(&incrementers_block, &mutex);\n        }\n\n        counter++;\n        printf(\"Incrementer: Counter is now %d\\n\", counter);\n        \n        // Signal decrementers if counter became positive\n        pthread_cond_signal(&can_decrement); \n\n        // Signal monitors if counter became even\n        if (counter % 2 == 0) {\n            pthread_cond_broadcast(&counter_is_even);\n        }\n        pthread_mutex_unlock(&mutex);\n        usleep(50000); // Simulate work\n    }\n    return NULL;\n}\n\nvoid* decrementer_thread(void* arg) {\n    for (int i = 0; i < ITERATIONS; ++i) {\n        pthread_mutex_lock(&mutex);\n        waiting_decrementers++; \n\n        while (counter == 0) {\n            printf(\"Decrementer: Waiting, counter is %d\\n\", counter);\n            // Signal incrementers that we are waiting.\n            pthread_cond_signal(&incrementers_block); \n            pthread_cond_wait(&can_decrement, &mutex);\n        }\n        waiting_decrementers--; \n\n        counter--;\n        printf(\"Decrementer: Counter is now %d\\n\", counter);\n\n        // Signal monitors if counter became even (or odd, which means they might need to wait again)\n        if (counter % 2 == 0) {\n            pthread_cond_broadcast(&counter_is_even);\n        }\n        // If decrementer allowed an incrementer to run, signal it.\n        if (waiting_decrementers == 0) { \n            pthread_cond_signal(&incrementers_block);\n        }\n        pthread_mutex_unlock(&mutex);\n        usleep(70000); // Simulate work\n    }\n    return NULL;\n}\n\nvoid* monitor_thread(void* arg) {\n    for (int i = 0; i < (NUM_INCREMENTERS + NUM_DECREMENTERS) * ITERATIONS / 2 + 1; ++i) { // Run for a bit longer\n        pthread_mutex_lock(&mutex);\n        while (counter % 2 != 0) {\n            printf(\"Monitor: Waiting, counter is %d (odd)\\n\", counter);\n            pthread_cond_wait(&counter_is_even, &mutex);\n        }\n        printf(\"Monitor: Current counter is %d (even)\\n\", counter);\n        pthread_mutex_unlock(&mutex);\n        usleep(100000); // Simulate work\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t incrementers[NUM_INCREMENTERS];\n    pthread_t decrementers[NUM_DECREMENTERS];\n    pthread_t monitors[NUM_MONITORS];\n\n    pthread_mutex_init(&mutex, NULL);\n    pthread_cond_init(&can_decrement, NULL);\n    pthread_cond_init(&counter_is_even, NULL);\n    pthread_cond_init(&incrementers_block, NULL);\n\n    for (int i = 0; i < NUM_INCREMENTERS; ++i) {\n        pthread_create(&incrementers[i], NULL, incrementer_thread, NULL);\n    }\n    for (int i = 0; i < NUM_DECREMENTERS; ++i) {\n        pthread_create(&decrementers[i], NULL, decrementer_thread, NULL);\n    }\n    for (int i = 0; i < NUM_MONITORS; ++i) {\n        pthread_create(&monitors[i], NULL, monitor_thread, NULL);\n    }\n\n    for (int i = 0; i < NUM_INCREMENTERS; ++i) {\n        pthread_join(incrementers[i], NULL);\n    }\n    for (int i = 0; i < NUM_DECREMENTERS; ++i) {\n        pthread_join(decrementers[i], NULL);\n    }\n    pthread_join(monitors[0], NULL); // Join monitors[0] assuming only one monitor\n\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&can_decrement);\n    pthread_cond_destroy(&counter_is_even);\n    pthread_cond_destroy(&incrementers_block);\n\n    printf(\"Final counter: %d\\n\", counter);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "זהו את כל בעיות הסנכרון (מצבי מרוץ, קיפאון, הרעבה, או התנהגות שגויה לפי הדרישות) בקוד הנתון. עבור כל בעיה, הסבירו מדוע היא מתרחשת ומהן השלכותיה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "כתבו גרסה מתוקנת לפונקציה `incrementer_thread` אשר פותרת את כל הבעיות שזוהו בסעיף 1.1 הנוגעות להתנהגותה. ניתן להוסיף משתנים גלובליים ואובייקטי סנכרון במידת הצורך (יש לציין את ערכי האתחול בהערה).",
        "code_snippet": "void* incrementer_thread(void* arg) {\n    // הקוד המתוקן יבוא כאן\n}",
        "options": null
      },
      {
        "id": "1.3",
        "text": "כתבו גרסה מתוקנת לפונקציה `decrementer_thread` אשר פותרת את כל הבעיות שזוהו בסעיף 1.1 הנוגעות להתנהגותה. ניתן להוסיף משתנים גלובליים ואובייקטי סנכרון במידת הצורך (יש לציין את ערכי האתחול בהערה).",
        "code_snippet": "void* decrementer_thread(void* arg) {\n    // הקוד המתוקן יבוא כאן\n}",
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1.1. **הרעבת מקטינים (Decrementers) בגלל `pthread_cond_signal` במקום `pthread_cond_broadcast`:**\n    *   **הבעיה**: בפונקציה `incrementer_thread`, נעשה שימוש ב-`pthread_cond_signal(&can_decrement)`. אם מספר חוטי Decrementer ממתינים כשהמונה הוא 0, וחוט Incrementer אחד מגדיל את המונה (למשל ל-1), רק חוט Decrementer אחד יתעורר. אם מספר חוטי Decrementer יכולים כעת לרוץ (לדוגמה, המונה הוגדל ל-2 וכל Decrementer מקטין ב-1), שאר חוטי ה-Decrementer יישארו רדומים ויסבלו מהרעבה, גם אם התנאי עבורם התקיים.\n    *   **השלכות**: הרעבה של חוטי Decrementer, שאינם מתעוררים לטפל במונה גם כאשר הוא חיובי ומאפשר זאת.\n\n1.1.2. **לוגיקה שגויה ופוטנציאל לקיפאון (Deadlock) או הרעבה בטיפול במניעת הרעבת מקטינים (דרישה 3):**\n    *   **הבעיה 1 (ב-`decrementer_thread`):** המשתנה `waiting_decrementers` מוגדל לפני הכניסה ללולאת ה-`while` ובאופן כללי לפני שהחוט אכן ממתין. הוא מוקטן רק אחרי היציאה מהלולאה ולפני ההקטנה בפועל. מצב זה יכול להוביל לכך ש-`waiting_decrementers` יכיל ערך שגוי של חוטים שממתינים בפועל. בנוסף, `pthread_cond_signal(&incrementers_block)` נקרא כשהחוט נכנס למצב המתנה, אך זהו `signal` ולא `broadcast`, כך שאם מספר Incrementers ממתינים, רק אחד מהם יתעורר. יתרה מכך, האיתות הזה יכול להיות מוקדם מדי או מאוחר מדי.\n    *   **הבעיה 2 (ב-`decrementer_thread`):** התנאי `if (waiting_decrementers == 0)` שבו נקרא `pthread_cond_signal(&incrementers_block)` בסוף הפונקציה הוא שגוי. חוט Incrementer צריך להיות מסוגל לרוץ לא רק כאשר אין יותר Decrementers ממתינים, אלא גם כאשר המונה חיובי (גם אם יש Decrementers ממתינים, כי הם ממתינים רק אם המונה 0). לוגיקת האיתות כאן לא מכסה את כל המקרים שבהם Incrementers יכולים להמשיך.\n    *   **הבעיה 3 (ב-`incrementer_thread`):** התנאי `while (waiting_decrementers > 0 && counter == 0)` עבור חוטי Incrementer הוא נכון עקרונית מבחינת התזמון, אך בהינתן הבעיות בניהול `waiting_decrementers` ובאיתות, הוא עלול להוביל לקיפאון. לדוגמה, אם כל חוטי ה-Decrementer ממתינים (כי `counter` הוא 0) ו-`waiting_decrementers` נספר באופן שגוי (לדוגמה, הוא נשאר 0 למרות שיש חוטים שממתינים), וכל חוטי ה-Incrementer נחסמים על `incrementers_block` (כי `waiting_decrementers > 0 && counter == 0` מתקיים במקרה אחר), ואין חוט שיכול לאותת להם, תתרחש הרעבה או קיפאון.\n    *   **השלכות**: קיפאון (Deadlock) פוטנציאלי כאשר Incrementers ו-Decrementers חוסמים זה את זה באופן הדדי, או הרעבה של Incrementers כאשר הם נחסמים שלא לצורך או הרעבה של Decrementers אם אין מי שיעיר את Incrementers.\n\n1.1.3. **אי-דיוק בספירת `waiting_decrementers`:**\n    *   **הבעיה**: כפי שתואר בסעיף הקודם, `waiting_decrementers` מוגדל לפני שחוט ה-Decrementer נכנס ל-`pthread_cond_wait` ומוקטן רק אחרי שהוא מתעורר. זה יכול להוביל למצב שבו `waiting_decrementers` כולל חוטים שכרגע לא ממתינים בפועל, או חוטים שרק התעוררו אבל עדיין לא ביצעו את פעולת ההקטנה. זה פוגע באמינות המשתנה.\n    *   **השלכות**: קבלת החלטות שגויות בטיפול בהרעבה, כפי שתואר לעיל, ובכך פגיעה בדרישה 3.\n\n1.2. **גרסה מתוקנת של `incrementer_thread`:**\n```c\nvoid* incrementer_thread(void* arg) {\n    for (int i = 0; i < ITERATIONS; ++i) {\n        pthread_mutex_lock(&mutex);\n        \n        // Incrementers wait ONLY if there are decrementers waiting AND counter is 0.\n        // This gives priority to decrementers when the counter is at its minimum.\n        while (waiting_decrementers > 0 && counter == 0) {\n            printf(\"Incrementer: Waiting due to starving decrementers. Counter: %d\\n\", counter);\n            pthread_cond_wait(&incrementers_block, &mutex);\n        }\n\n        counter++;\n        printf(\"Incrementer: Counter is now %d\\n\", counter);\n        \n        // Use broadcast for can_decrement because multiple decrementers might be able to run now.\n        pthread_cond_broadcast(&can_decrement); \n\n        // Use broadcast for counter_is_even because multiple monitors might be waiting.\n        if (counter % 2 == 0) {\n            pthread_cond_broadcast(&counter_is_even);\n        }\n        pthread_mutex_unlock(&mutex);\n        usleep(50000); // Simulate work\n    }\n    return NULL;\n}\n```\n\n1.3. **גרסה מתוקנת של `decrementer_thread`:**\n```c\nvoid* decrementer_thread(void* arg) {\n    for (int i = 0; i < ITERATIONS; ++i) {\n        pthread_mutex_lock(&mutex);\n        \n        // Increment count BEFORE potentially waiting.\n        waiting_decrementers++; \n        \n        // Signal to potentially blocked incrementers using broadcast.\n        // This is important if this decrementer is the first one to arrive at counter == 0,\n        // and an incrementer might be trying to proceed. It ensures incrementers re-evaluate their condition.\n        pthread_cond_broadcast(&incrementers_block); \n\n        while (counter == 0) {\n            printf(\"Decrementer: Waiting, counter is %d\\n\", counter);\n            pthread_cond_wait(&can_decrement, &mutex);\n        }\n        // Decrement count AFTER being woken up and before actually changing 'counter'.\n        waiting_decrementers--; \n\n        counter--;\n        printf(\"Decrementer: Counter is now %d\\n\", counter);\n\n        // After a decrementer runs, it might have changed the conditions for incrementers.\n        // If 'counter' is now positive OR there are no more decrementers waiting,\n        // incrementers are no longer blocked by the starvation avoidance rule. So, broadcast to them.\n        if (counter > 0 || waiting_decrementers == 0) {\n            pthread_cond_broadcast(&incrementers_block);\n        }\n\n        // Use broadcast for counter_is_even because multiple monitors might be waiting.\n        if (counter % 2 == 0) {\n            pthread_cond_broadcast(&counter_is_even);\n        }\n        pthread_mutex_unlock(&mutex);\n        usleep(70000); // Simulate work\n    }\n    return NULL;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}