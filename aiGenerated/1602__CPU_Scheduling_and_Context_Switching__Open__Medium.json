{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling and Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 11:48:03",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2319,
      "output_tokens": 2163,
      "total_tokens": 7526
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "CPU Scheduling",
      "Context Switching",
      "Round Robin"
    ],
    "content": {
      "text": "נתונה מערכת המשתמשת באלגוריתם תזמון Round Robin.\n1. הסבירו מהי החלפת הקשר (Context Switch) ותארו את השלבים העיקריים המעורבים כאשר מערכת ההפעלה מבצעת החלפת הקשר בין שני תהליכים.\n2. דנו כיצד בחירת גודל יחידת הזמן (time quantum) באלגוריתם תזמון Round Robin משפיעה על ביצועי המערכת, תוך התייחסות ספציפית לתקורה (overhead) של החלפות הקשר. תנו דוגמאות לתרחישים שבהם קוונטום קטן מדי יהיה מזיק, ותרחישים שבהם קוונטום גדול מדי עלול להיות בעייתי.\n3. הניחו תרחיש בו תהליך מבצע לעיתים קרובות פעולות קלט/פלט (לדוגמה, קריאה מדיסק). כיצד ניתן לייעל את אלגוריתם התזמון או את מנגנון החלפת הקשר כדי לטפל טוב יותר בתהליכים כאלה ולהפחית תקורה מיותרת?",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. החלפת הקשר היא תהליך שבו מערכת ההפעלה שומרת את מצבו של תהליך אחד (התהליך היוצא מהמעבד) וטוענת את מצבו של תהליך אחר (התהליך הנכנס למעבד). המטרה היא לאפשר למספר תהליכים לחלוק מעבד יחיד (או מספר מעבדים), תוך יצירת אשליה של הרצה מקבילה.\nהשלבים העיקריים כוללים:\nא. שמירת מצב התהליך הנוכחי: המעבד שומר את תוכן האוגרים (registers) של המעבד (כולל Program Counter, Stack Pointer, אוגרי מטרה כלליים), מצב ה-MMU (לדוגמה, כתובת טבלת הדפים הנוכחית) ומידע נוסף הקשור למצב התהליך (כגון מידע על קבצים פתוחים וסמפורים) בתוך בלוק בקרת התהליך (PCB - Process Control Block) שלו בזיכרון.\nב. בחירת התהליך הבא: המתזמן (scheduler) של מערכת ההפעלה בוחר את התהליך הבא שייכנס לריצה, על פי אלגוריתם התזמון הנהוג.\nג. טעינת מצב התהליך הבא: המעבד טוען את תוכן האוגרים, מצב ה-MMU ומידע נוסף מתוך ה-PCB של התהליך הנבחר.\nד. מעבר למצב משתמש והמשך ריצה: המעבד עובר למצב משתמש (user mode) והתהליך החדש ממשיך לרוץ מהנקודה שבה הופסק.\nתהליך זה דורש מעבר למצב ליבה (kernel mode) ותקורה (overhead) משמעותית.\n\n2. גודל יחידת הזמן (time quantum) באלגוריתם Round Robin הוא גורם קריטי המשפיע על ביצועי המערכת:\nא. קוונטום קטן מדי:\n    * יתרון: מעניק תגובתיות (responsiveness) גבוהה למשתמש, שכן כל תהליך מקבל הזדמנות לרוץ לעיתים קרובות. נותן אשליה טובה יותר של מקביליות.\n    * חיסרון: מגביר באופן דרמטי את תדירות החלפות הקשר. כל החלפת קשר כרוכה בתקורה (זמן CPU שאינו משרת אף תהליך משתמש, אלא מוקדש לשמירה/טעינה של מצבים). אם הקוונטום קטן מדי, התקורה של החלפות הקשר עלולה להפוך לנתח משמעותי מזמן המעבד הכולל, מה שמפחית את התפוקה (throughput) הכוללת של המערכת. לדוגמה, אם קוונטום הוא 10ms והחלפת קשר לוקחת 1ms, אזי 10% מזמן המעבד מבוזבז על תקורה.\nב. קוונטום גדול מדי:\n    * יתרון: מפחית את תדירות החלפות הקשר, ובכך מקטין את התקורה הכרוכה בהן.\n    * חיסרון: המערכת הופכת פחות תגובתית. תהליכים קצרים יצטרכו להמתין זמן רב יותר אם תהליך ארוך מהם מריץ את כל הקוונטום שלו. במקרה קיצוני, אם הקוונטום גדול מאוד (אפילו יותר מזמן הריצה של רוב התהליכים), אלגוריתם Round Robin מתנהג בדומה ל-FCFS (First Come First Served), מה שעלול לגרום לזמני המתנה ארוכים ולתחושה של איטיות במערכות אינטראקטיביות. לדוגמה, משתמש שמקיש מקש במקלדת יחווה השהיה ניכרת עד שהתהליך האחראי על הטיפול בקלט יקבל זמן מעבד.\n\n3. תהליכי קלט/פלט (I/O-bound processes) הם תהליכים שמבלים חלק ניכר מזמן ריצתם בהמתנה להשלמת פעולות קלט/פלט (כגון קריאה מדיסק, קבלת נתונים מהרשת).\nאופטימיזציות אפשריות:\nא. מתן עדיפות גבוהה יותר לתהליכים שחוזרים מ-I/O: כאשר תהליך I/O-bound מסיים פעולת קלט/פלט ומוכן שוב לריצה, ניתן לתת לו עדיפות גבוהה יותר לתקופה קצרה. זאת מכיוון שתהליכים אלו בדרך כלל מבצעים חישובים קצרים לאחר ה-I/O לפני שהם עוברים שוב למצב המתנה ל-I/O. מתן עדיפות זו משפר את התגובתיות הכוללת של המערכת.\nב. שימוש באלגוריתם תזמון מרובה תורים עם פידבק (MLFQ - Multi-Level Feedback Queue): אלגוריתם זה יכול לזהות באופן דינמי תהליכי I/O-bound על ידי העברתם לתורים בעדיפות גבוהה יותר עם קוונטום קטן יותר. תהליכים שמנצלים את כל הקוונטום שלהם יורדים בתור (מקבלים עדיפות נמוכה יותר), בעוד שתהליכים שמוותרים על המעבד לפני תום הקוונטום (לרוב בגלל I/O) נשארים בתורים גבוהים יותר או עולים בחזרה.\nג. הבחנה בין חוטים (threads) ושימוש ב-User-level threads: אם מדובר בחוטים, ניתן להבחין בין חוטים שמוכנים לרוץ לבין חוטים שממתינים ל-I/O. במערכות עם חוטים ברמת משתמש (user-level threads), החלפת קשר בין חוטים של אותו תהליך היא זולה יותר מכיוון שהיא אינה דורשת מעבר למצב ליבה (kernel mode) ואינה משנה את מפת הזיכרון. זה יכול להפחית את התקורה הכוללת אם התהליך עצמו הוא I/O-bound אך יש לו חוטים רבים.\nד. היוריסטיקות במתזמן: המתזמן יכול ללמוד את התנהגות התהליכים. אם תהליך מסוים נמצא באופן עקבי כ-I/O-bound (כלומר, הוא מסיים את הקוונטום שלו לפני הזמן ויוצא ל-I/O), ניתן להקצות לו קוונטום קצר יותר באופן יזום, או לשמור אותו בתור בעדיפות גבוהה יותר.\nה. החלפות קשר חלקיות/אופטימיזציה של שמירה/טעינה: במקרים מסוימים, ניתן לבצע אופטימיזציות לשמירה/טעינה של מצב התהליך. לדוגמה, אם תהליך עובר למצב ליבה לצורך קריאת קובץ, וצפוי לחזור במהירות, ייתכן שאין צורך לשמור את כל מצב ה-MMU אם הוא לא משתנה. עם זאת, זו אופטימיזציה מורכבת ופחות נפוצה."
    },
    "difficulty_estimation": "Medium"
  }
}