{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 19:56:24",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3383,
      "output_tokens": 2412,
      "total_tokens": 9954
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Deadlocks",
      "Concurrency",
      "Priority Inversion"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת במתזמן דורסני (preemptive) מבוסס עדיפויות. במערכת רצים שני חוטים, P1 ו-P2. לחוט P1 יש עדיפות גבוהה יותר מחוט P2. המערכת כוללת שני משאבים, R1 ו-R2, הממומשים באמצעות מנעולי mutex. קטעי הקוד הבאים מתארים את פעולתם של P1 ו-P2, כאשר ההנחה היא שהמנעולים R1 ו-R2 מאותחלים כראוי:\n",
      "code_snippet": "pthread_mutex_t R1, R2; // משאבים גלובליים\n\n// פונקציית החוט עבור P1 (עדיפות גבוהה)\nvoid* P1_thread_func(void* arg) {\n    pthread_mutex_lock(&R1);\n    // מבצע עבודה כלשהי (למשל, חישובים שאינם דורשים R2)\n    pthread_mutex_lock(&R2);\n    // מבצע עבודה קריטית הדורשת את שני המשאבים\n    pthread_mutex_unlock(&R2);\n    pthread_mutex_unlock(&R1);\n    return NULL;\n}\n\n// פונקציית החוט עבור P2 (עדיפות נמוכה)\nvoid* P2_thread_func(void* arg) {\n    pthread_mutex_lock(&R2);\n    // מבצע עבודה כלשהי (למשל, חישובים שאינם דורשים R1)\n    pthread_mutex_lock(&R1);\n    // מבצע עבודה קריטית הדורשת את שני המשאבים\n    pthread_mutex_unlock(&R1);\n    pthread_mutex_unlock(&R2);\n    return NULL;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "a",
        "text": "האם יכול להתרחש קיפאון (Deadlock) במערכת זו? נמק את תשובתך תוך התחשבות במתזמן הדורסני מבוסס העדיפויות.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "b",
        "text": "בהנחה שקיפאון אכן יכול להתרחש, הצע שינוי מינימלי בקוד או במדיניות התזמון כדי למנוע אותו, תוך שמירה על רצף בקשות המשאבים ככל הניתן.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "c",
        "text": "האם יכולה להתרחש היפוך עדיפויות (Priority Inversion) במערכת זו? אם כן, תאר כיצד, וכיצד היא תשפיע על ביצועי המערכת.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. כן, קיפאון יכול להתרחש במערכת זו. ננתח את התרחיש לפי ארבעת התנאים ההכרחיים לקיפאון:\n1.  **מניעה הדדית (Mutual Exclusion):** מתקיימת. המשאבים R1 ו-R2 מוגנים על ידי מנעולי mutex, המבטיחים שרק חוט אחד יכול להחזיק במשאב בכל רגע נתון.\n2.  **החזקה והמתנה (Hold and Wait):** מתקיימת. כל חוט מחזיק במשאב אחד (R1 עבור P1, R2 עבור P2) וממתין למשאב השני.\n3.  **אין דריסה (No Preemption):** מתקיימת. לא ניתן לדרוס מנעול mutex מחוט שמחזיק בו; הוא ישוחרר רק מרצונו על ידי החוט המחזיק.\n4.  **המתנה מעגלית (Circular Wait):** מתקיימת. P1 ממתין ל-R2 שמוחזק על ידי P2, ו-P2 ממתין ל-R1 שמוחזק על ידי P1. זהו מעגל המתנה.\n\nהשפעת המתזמן הדורסני מבוסס העדיפויות:\nנניח ש-P2 (עדיפות נמוכה) מתחיל לרוץ ראשון. הוא תופס את המנעול R2. לאחר מכן, P1 (עדיפות גבוהה) הופך לזמין ודורס את P2. P1 מתחיל לרוץ, תופס את המנעול R1, ומנסה לתפוס את R2. מכיוון ש-R2 מוחזק על ידי P2, חוט P1 נחסם. כעת, כיוון ש-P1 חסום, P2 הופך להיות החוט בעל העדיפות הגבוהה ביותר שניתן להרצה, ולכן המתזמן יאפשר לו להמשיך לרוץ. P2 ינסה לתפוס את המנעול R1. מכיוון ש-R1 מוחזק על ידי P1, גם P2 נחסם. בשלב זה, גם P1 וגם P2 חסומים, וכל אחד מהם מחזיק במשאב שהשני ממתין לו, ולכן מתרחש קיפאון.\n\nב. כדי למנוע קיפאון, יש לשבור אחד מארבעת התנאים ההכרחיים. הדרך הנפוצה והמיטבית למנוע המתנה מעגלית במערכות מסוג זה היא באמצעות **הקצאת משאבים בסדר קבוע (Resource Ordering)**. נשנה את קוד אחד החוטים כך ששניהם יבקשו את המשאבים באותו סדר, למשל, תמיד R1 ואז R2.\n\nשינוי מינימלי בקוד של P2 (כדי שיתאים לסדר של P1):\n```c\n// פונקציית החוט עבור P2 (עדיפות נמוכה) - לאחר שינוי\nvoid* P2_thread_func(void* arg) {\n    pthread_mutex_lock(&R1); // שינוי: קודם R1\n    // מבצע עבודה כלשהי\n    pthread_mutex_lock(&R2); // ואז R2\n    // מבצע עבודה קריטית\n    pthread_mutex_unlock(&R2);\n    pthread_mutex_unlock(&R1);\n    return NULL;\n}\n```\nבצורה זו, אם P1 תופס את R1, P2 לא יוכל לתפוס את R1 וימתין. הוא לא יתפוס את R2 לפני ש-P1 ישחרר את R1 (ואת R2), ולכן לא תיווצר המתנה מעגלית.\n\nג. כן, יכולה להתרחש היפוך עדיפויות (Priority Inversion) במערכת זו, אך כדי שתתרחש במובן המלא שלה, נצטרך להניח קיום של חוט שלישי. היפוך עדיפויות מתאר מצב שבו חוט בעל עדיפות גבוהה נחסם מלהתקדם על ידי חוט בעל עדיפות נמוכה, אשר בתורו נמנע מלהשתחרר על ידי חוט בעל עדיפות בינונית.\n\n**תרחיש להיפוך עדיפויות:**\n1.  P2 (עדיפות נמוכה) מתחיל לרוץ ותופס את המנעול R2.\n2.  P1 (עדיפות גבוהה) הופך לזמין ודורס את P2. P1 מתחיל לרוץ, תופס את המנעול R1, ומנסה לתפוס את R2.\n3.  P1 נחסם מכיוון ש-R2 מוחזק על ידי P2.\n4.  כעת P2 הוא החוט הרץ בעל העדיפות הגבוהה ביותר (מבין החוטים הניתנים להרצה). אם בשלב זה יגיע חוט P_medium (בעל עדיפות בינונית, כלומר נמוכה מ-P1 אך גבוהה מ-P2) ויהפוך לזמין, הוא ידרוס את P2.\n5.  P_medium ירוץ ויבצע את עבודתו. כל עוד P_medium רץ, P2 אינו יכול להמשיך, ולכן אינו יכול לשחרר את R2. כתוצאה מכך, P1 (החוט בעל העדיפות הגבוהה ביותר) נשאר חסום וממתין ל-R2, שמוחזק על ידי P2 (החוט בעל העדיפות הנמוכה ביותר) שבתורו נחסם על ידי P_medium (החוט בעל העדיפות הבינונית). זהו היפוך עדיפויות קלאסי.\n\n**השפעה על ביצועי המערכת:**\nהיפוך עדיפויות פוגע קשות בביצועי המערכת, במיוחד במערכות זמן אמת. חוטים בעלי עדיפות גבוהה, שאמורים להגיב במהירות ובזמן, נאלצים להמתין לחוטים בעלי עדיפות נמוכה יותר שישחררו משאבים. זה יכול לגרום לעיכובים בלתי צפויים, החמצת מועדים (deadlines), ובמקרים קיצוניים אף לכשל מערכתי. מנגנונים כמו Priority Inheritance Protocol או Priority Ceiling Protocol נועדו למנוע מצבים כאלה על ידי העלאת עדיפותו הזמנית של חוט בעל עדיפות נמוכה המחזיק במשאב שחוט בעל עדיפות גבוהה ממתין לו."
    },
    "difficulty_estimation": "Hard"
  }
}