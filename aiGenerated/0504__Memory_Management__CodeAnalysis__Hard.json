{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:15:08",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2789,
      "output_tokens": 3041,
      "total_tokens": 9685
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Page Tables",
      "Address Translation"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה פשוטה המממשת זיכרון וירטואלי עבור תהליכים, כאשר לכל תהליך יש טבלת דפים (page table) משלו. טבלת הדפים מיוצגת כרגע באופן גלובלי לצורך פשטות, והיא מערך של מבנים מסוג `PageTableEntry`. כל כניסה בטבלה מכילה את מספר מסגרת הדף הפיזי (PFN) וביטים נוספים כגון `valid` (האם הדף חוקי) ו-`read_only` (האם הדף מוגן מכתיבה).\n\nהמערכת תומכת בגודל דף קבוע של 4KB. נניח ש-`PAGE_SIZE` מוגדר כ-4096 ו-`PAGE_SHIFT` מוגדר כ-12. הקוד המצורף כולל את הגדרות אלו ואת מבנה ה-`PageTableEntry`.\n\nיש להשלים את הפונקציה `translate_and_access(uint32_t virtual_address, bool is_write)` כך שתבצע את תרגום הכתובת הווירטואלית לכתובת פיזית, תוך כדי טיפול נכון בכשלי דף (page faults) והגנות זיכרון. הפונקציה צריכה לבצע את השלבים הבאים:\n1. חלץ את מספר הדף הווירטואלי (VPN) ואת היסט הדף (offset) מהכתובת הווירטואלית הנתונה. יש לוודא שה-VPN נמצא בטווח חוקי של טבלת הדפים (`PTE_COUNT`). אם לא, יש להדפיס הודעת שגיאה מתאימה ולסיים.\n2. בדוק את כניסת טבלת הדפים המתאימה ל-VPN שהתקבל. אם ביט ה-`valid` של הכניסה כבוי, הדפס הודעת שגיאה המציינת כשל דף מסוג 'Page fault: Invalid page'.\n3. אם הדף חוקי, בדוק את ביט ההגנה `read_only`. אם הפעולה המבוקשת היא כתיבה (`is_write` הוא `true`) וביט `read_only` דלוק, הדפס הודעת שגיאה המציינת כשל דף מסוג 'Page fault: Write to read-only page'.\n4. אם כל הבדיקות עברו בהצלחה, חשב את הכתובת הפיזית המתאימה. הדפס את הכתובת הווירטואלית והפיזית המתורגמת. בנוסף, אם הפעולה הייתה כתיבה, הדפס 'Data written successfully', ואם קריאה, הדפס 'Data read successfully'.\n\nיש להשלים את החלק המסומן ב-`// TODO: Implement this function` בקוד המצורף.",
      "code_snippet": "#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define PAGE_SIZE 4096 // 4KB\n#define PAGE_SHIFT 12\n#define PTE_COUNT (1 << (32 - PAGE_SHIFT)) // For 32-bit virtual addresses\n\n// Page Table Entry structure\ntypedef struct {\n    uint32_t pfn : 20;       // Physical Frame Number (assuming 32-bit physical address, 20 bits for PFN)\n    uint32_t valid : 1;      // Is this page table entry valid?\n    uint32_t read_only : 1;  // Is this page read-only?\n    uint32_t reserved : 10;  // Reserved bits\n} PageTableEntry;\n\n// Simplified Page Table (global for simplicity, in real OS it's per-process)\nPageTableEntry current_page_table[PTE_COUNT];\n\n// Function to simulate initializing a page table entry\nvoid init_pte(uint32_t vpn, uint32_t pfn, bool valid, bool read_only) {\n    if (vpn < PTE_COUNT) {\n        current_page_table[vpn].pfn = pfn;\n        current_page_table[vpn].valid = valid;\n        current_page_table[vpn].read_only = read_only;\n    }\n}\n\n// Function to translate and access a virtual address\nvoid translate_and_access(uint32_t virtual_address, bool is_write) {\n    // TODO: Implement this function\n    // 1. Extract VPN and offset\n    // 2. Check PTE validity\n    // 3. Check write protection\n    // 4. Calculate physical address and print status\n}\n\nint main() {\n    // Initialize some page table entries\n    // VPN 0 -> PFN 100, valid, read/write\n    init_pte(0, 100, true, false);\n    // VPN 1 -> PFN 200, valid, read-only\n    init_pte(1, 200, true, true);\n    // VPN 2 -> PFN 300, valid, read/write (but we won't access it here)\n    init_pte(2, 300, true, false);\n    // VPN 3 -> invalid\n    init_pte(3, 0, false, false);\n\n    printf(\"Testing virtual address translations:\\n\");\n\n    // Test case 1: Valid read access\n    printf(\"\\nTest 1: Read from VA 0x00001234 (VPN 0, Offset 0x234)\\n\");\n    translate_and_access(0x00001234, false);\n\n    // Test case 2: Valid write access\n    printf(\"\\nTest 2: Write to VA 0x00001234 (VPN 0, Offset 0x234)\\n\");\n    translate_and_access(0x00001234, true);\n\n    // Test case 3: Read from read-only page\n    printf(\"\\nTest 3: Read from VA 0x00005678 (VPN 1, Offset 0x1678)\\n\");\n    translate_and_access(0x00005678, false);\n\n    // Test case 4: Write to read-only page (should fail)\n    printf(\"\\nTest 4: Write to VA 0x00005678 (VPN 1, Offset 0x1678)\\n\");\n    translate_and_access(0x00005678, true);\n\n    // Test case 5: Access invalid page (should fail)\n    printf(\"\\nTest 5: Read from VA 0x0000DABC (VPN 3, Offset 0xABC)\\n\");\n    translate_and_access(0x0000DABC, false);\n\n    // Test case 6: Access invalid page (should fail)\n    printf(\"\\nTest 6: Write to VA 0x0000DABC (VPN 3, Offset 0xABC)\\n\n\");\n    translate_and_access(0x0000DABC, true);\n\n    // Test case 7: Access non-existent VPN (should implicitly be invalid)\n    printf(\"\\nTest 7: Read from VA 0x00011000 (VPN 4, Offset 0x0)\\n\");\n    translate_and_access(0x00011000, false);\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפונקציה `translate_and_access` מבצעת את הפעולות הנדרשות לתרגום כתובת וירטואלית לכתובת פיזית, תוך כדי בדיקת הרשאות וטיפול בכשלי דף (page faults).\n\nראשית, היא מחלצת את מספר הדף הווירטואלי (VPN) ואת היסט הדף (offset) מהכתובת הווירטואלית. ה-VPN מתקבל על ידי הזזת הכתובת הווירטואלית ימינה ב-`PAGE_SHIFT` (12 ביטים, שכן גודל דף הוא 4KB). ההיסט מתקבל על ידי ביצוע פעולת AND בין הכתובת הווירטואלית לבין `PAGE_SIZE - 1` (מסכה של 12 הביטים הפחות משמעותיים).\n\nלאחר מכן, הפונקציה בודקת את תקינות ה-VPN (האם הוא בטווח טבלת הדפים). אם הוא מחוץ לטווח, מודפסת הודעת שגיאה מתאימה ומסתיימת הפעולה.\n\nהשלב הבא הוא גישה לכניסה המתאימה בטבלת הדפים (`current_page_table[vpn]`). נבדק ה-`valid` ביט של הכניסה. אם הוא כבוי, הדף אינו קיים בזיכרון הפיזי (או לא הוקצה), ומופק כשל דף מסוג 'Invalid page'.\n\nאם הדף חוקי, נבדקת הרשאת הכתיבה. אם הפעולה המבוקשת היא כתיבה (`is_write` הוא `true`) וביט ה-`read_only` בכניסת טבלת הדפים דלוק, אזי מדובר בניסיון כתיבה לדף מוגן, ומופק כשל דף מסוג 'Write to read-only page'.\n\nאם כל הבדיקות עברו בהצלחה, מחושבת הכתובת הפיזית על ידי שילוב מספר מסגרת הדף הפיזי (PFN) מה-PTE עם היסט הדף. ה-PFN מוזז שמאלה ב-`PAGE_SHIFT` כדי ליצור את החלק העליון של הכתובת הפיזית, ואז מוסיפים אליו את ההיסט.\n\nלבסוף, מודפסת הכתובת הפיזית המתורגמת והודעת סטטוס המציינת אם בוצעה פעולת קריאה או כתיבה מוצלחת.\n\nהקוד המלא של הפונקציה `translate_and_access`:\n```c\nvoid translate_and_access(uint32_t virtual_address, bool is_write) {\n    // 1. Extract VPN and offset\n    uint32_t vpn = virtual_address >> PAGE_SHIFT;\n    uint32_t offset = virtual_address & (PAGE_SIZE - 1);\n\n    // Check if VPN is within bounds of our simplified page table\n    if (vpn >= PTE_COUNT) {\n        printf(\"Page fault: Virtual address 0x%X has an out-of-bounds VPN %u.\\n\", virtual_address, vpn);\n        return;\n    }\n\n    PageTableEntry pte = current_page_table[vpn];\n\n    // 2. Check PTE validity\n    if (!pte.valid) {\n        printf(\"Page fault: Invalid page for virtual address 0x%X (VPN %u).\\n\", virtual_address, vpn);\n        return;\n    }\n\n    // 3. Check write protection\n    if (is_write && pte.read_only) {\n        printf(\"Page fault: Write to read-only page for virtual address 0x%X (VPN %u).\\n\", virtual_address, vpn);\n        return;\n    }\n\n    // 4. If all checks pass, calculate physical address and print status\n    uint32_t physical_address = (pte.pfn << PAGE_SHIFT) | offset;\n    printf(\"Virtual address 0x%X translates to Physical address 0x%X.\\n\", virtual_address, physical_address);\n    if (is_write) {\n        printf(\"Data written successfully.\\n\");\n    } else {\n        printf(\"Data read successfully.\\n\");\n    }\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}