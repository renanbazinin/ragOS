{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:33:58",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4148,
      "output_tokens": 7834,
      "total_tokens": 22428
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Shared Memory",
      "Semaphores",
      "Producer-Consumer"
    ],
    "content": {
      "text": "מערכת מבוזרת מורכבת ממספר תהליכי יישום (producers) ותהליך שירות לוגים מרכזי יחיד (consumer). תהליכי היישום צריכים לרשום הודעות לוג למערכת הלוגים, אשר בתורה כותבת אותן לקובץ. התקשורת בין תהליכי היישום לתהליך שירות הלוגים מתבצעת באמצעות חוצץ מעגלי (circular buffer) בזיכרון משותף (shared memory). כל הודעת לוג היא בעלת גודל קבוע של 256 בתים, והחוצץ יכול להכיל 100 הודעות לוג. יש להשתמש בסמפורים לצורך סנכרון.\n\nיש לפרט ולנמק את החישובים וההחלטות בכל סעיף.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מבנה הזיכרון המשותף:\nתאר/י בפירוט את מבנה הנתונים שיש לאחסן בזיכרון המשותף, כולל החוצץ עצמו, כל המשתנים הנחוצים לסנכרון (סמפורים), וכל אינדקסים או מצביעים. נמק/י את בחירתך לכל רכיב.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "אתחול וסנכרון:\nכתוב/כתבי קטע קוד ב-C/C++ המדגים כיצד ליצור ולאתחל את הזיכרון המשותף ואת הסמפורים הנדרשים (עם ערכים התחלתיים מתאימים) בתהליך שירות הלוגים (ה-consumer) לפני יצירת תהליכי היישום (ה-producers).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "קוד Producer ו-Consumer:\nכתוב/כתבי קטעי קוד ב-C/C++ עבור פונקציות `produce_log_message(const char* message)` בתהליך יישום (producer) ו-`consume_log_message(char* message_buffer)` בתהליך שירות הלוגים (consumer). קטעי הקוד צריכים להדגים את השימוש הנכון בסמפורים ובזיכרון המשותף לצורך הוספה והוצאה של הודעות לוג מהחוצץ המעגלי.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.4",
        "text": "סיום והתמודדות עם כשלים:\nהסבר/י כיצד ניתן לסיים את כל התהליכים (producers ו-consumer) בצורה נקייה (graceful shutdown) כאשר אין יותר הודעות לוג לייצר. בנוסף, דון/י בהשלכות של קריסת אחד מתהליכי היישום (producer) או תהליך שירות הלוגים (consumer) על המערכת, וכיצד ניתן להתמודד עם תרחישים אלו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### 1.1 מבנה הזיכרון המשותף:\nמבנה הנתונים בזיכרון המשותף צריך לכלול את החוצץ המעגלי עצמו, אינדקסים לראש ולזנב החוצץ, וכן סמפורים לסנכרון. נגדיר את המבנה הבא:\n\n```c\n#define MAX_LOG_MESSAGES 100\n#define LOG_MESSAGE_SIZE 256\n#define SHM_NAME \"/log_shm\"\n#define SEM_MUTEX_NAME \"/log_mutex\"\n#define SEM_EMPTY_NAME \"/log_empty\"\n#define SEM_FULL_NAME \"/log_full\"\n\ntypedef struct {\n    char buffer[MAX_LOG_MESSAGES][LOG_MESSAGE_SIZE]; // החוצץ המעגלי עצמו\n    int head; // אינדקס הכתיבה הבא (producer)\n    int tail; // אינדקס הקריאה הבא (consumer)\n    // סמפורים לא יאוחסנו ישירות בזיכרון משותף ב-POSIX semaphores, אלא ינוהלו כשמותיים.\n    // עם זאת, אם היינו משתמשים ב-System V semaphores או ב-POSIX unnamed semaphores בתוך ה-shm, היינו צריכים להוסיף אותם כאן.\n    // לצורך שאלה זו, נתייחס לכך שהשמות של הסמפורים מאוחסנים ונגישים לכל התהליכים.\n} shm_data_t;\n```\n\n**הסבר הרכיבים:**\n*   `buffer[MAX_LOG_MESSAGES][LOG_MESSAGE_SIZE]`: זהו החוצץ המעגלי עצמו. הוא מכיל `MAX_LOG_MESSAGES` (100) הודעות, כאשר כל הודעה בגודל `LOG_MESSAGE_SIZE` (256 בתים). גודלו הכולל יהיה `100 * 256 = 25600` בתים.\n*   `head`: אינדקס המצביע על המיקום הבא בחוצץ שבו יוכנס לוג על ידי producer. הוא מתקדם מ-0 עד `MAX_LOG_MESSAGES - 1` וחוזר ל-0 (פעולה מודולו).\n*   `tail`: אינדקס המצביע על המיקום הבא בחוצץ שממנו יילקח לוג על ידי consumer. הוא מתקדם מ-0 עד `MAX_LOG_MESSAGES - 1` וחוזר ל-0 (פעולה מודולו).\n\n**לגבי סמפורים:**\nסמפורי POSIX בעלי שמות (named semaphores) אינם מאוחסנים ישירות בתוך הזיכרון המשותף, אלא נפתחים ונסגרים באמצעות שמות גלובליים. לכן, אין צורך לכלול אותם במבנה ה-`shm_data_t`. שלושת הסמפורים הנדרשים הם:\n*   `mutex`: סמפור בינארי (ערך התחלתי 1) המשמש להגנה על הקטע הקריטי בעת גישה לחוצץ (עדכון `head`, `tail`, וכתיבה/קריאה בפועל). הוא מבטיח שרק תהליך אחד יגש לחוצץ בו-זמנית.\n*   `empty`: סמפור סופר (ערך התחלתי `MAX_LOG_MESSAGES`) המציין את מספר המקומות הריקים בחוצץ. producer מבצע `sem_wait` עליו לפני כתיבה, ו-consumer מבצע `sem_post` עליו לאחר קריאה.\n*   `full`: סמפור סופר (ערך התחלתי 0) המציין את מספר המקומות המלאים בחוצץ. consumer מבצע `sem_wait` עליו לפני קריאה, ו-producer מבצע `sem_post` עליו לאחר כתיבה.\n\n### 1.2 אתחול וסנכרון:\nתהליך ה-consumer (שירות הלוגים) יהיה אחראי ליצור ולאתחל את הזיכרון המשותף ואת הסמפורים. תהליכי ה-producer יפתחו אותם בהמשך.\n\n```c\n#include <fcntl.h>      // For O_CREAT, O_EXCL, etc.\n#include <sys/stat.h>   // For mode constants\n#include <sys/mman.h>   // For shm_open, mmap, munmap, shm_unlink\n#include <semaphore.h>  // For sem_open, sem_close, sem_unlink\n#include <unistd.h>     // For ftruncate\n#include <stdio.h>      // For perror\n#include <stdlib.h>     // For exit\n#include <string.h>     // For memset\n\n// (הגדרות MAX_LOG_MESSAGES, LOG_MESSAGE_SIZE, SHM_NAME, SEM_MUTEX_NAME, SEM_EMPTY_NAME, SEM_FULL_NAME מ-1.1)\n\ntypedef struct {\n    char buffer[MAX_LOG_MESSAGES][LOG_MESSAGE_SIZE];\n    int head;\n    int tail;\n} shm_data_t;\n\nvoid initialize_ipc_resources() {\n    int shm_fd;\n    shm_data_t *shm_ptr;\n    sem_t *mutex_sem, *empty_sem, *full_sem;\n    size_t shm_size = sizeof(shm_data_t);\n\n    // 1. יצירה ואתחול של זיכרון משותף\n    shm_fd = shm_open(SHM_NAME, O_CREAT | O_EXCL | O_RDWR, 0666);\n    if (shm_fd == -1) {\n        perror(\"shm_open failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (ftruncate(shm_fd, shm_size) == -1) {\n        perror(\"ftruncate failed\");\n        shm_unlink(SHM_NAME); // Clean up on failure\n        exit(EXIT_FAILURE);\n    }\n\n    shm_ptr = (shm_data_t *)mmap(NULL, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (shm_ptr == MAP_FAILED) {\n        perror(\"mmap failed\");\n        shm_unlink(SHM_NAME); // Clean up on failure\n        exit(EXIT_FAILURE);\n    }\n\n    // אתחול נתוני הזיכרון המשותף\n    memset(shm_ptr, 0, shm_size);\n    shm_ptr->head = 0;\n    shm_ptr->tail = 0;\n    printf(\"Shared memory initialized. Size: %lu bytes\\n\", shm_size);\n\n    // 2. יצירה ואתחול של סמפורים\n    // Semaphores are created with O_CREAT and O_EXCL to ensure only one process initializes them.\n    // Permissions 0666 for read/write by owner, group, others.\n\n    mutex_sem = sem_open(SEM_MUTEX_NAME, O_CREAT | O_EXCL, 0666, 1);\n    if (mutex_sem == SEM_FAILED) {\n        perror(\"sem_open mutex failed\");\n        // Clean up shm as well\n        munmap(shm_ptr, shm_size);\n        shm_unlink(SHM_NAME);\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Mutex semaphore initialized with value 1.\\n\");\n\n    empty_sem = sem_open(SEM_EMPTY_NAME, O_CREAT | O_EXCL, 0666, MAX_LOG_MESSAGES);\n    if (empty_sem == SEM_FAILED) {\n        perror(\"sem_open empty failed\");\n        // Clean up shm and mutex\n        sem_close(mutex_sem); sem_unlink(SEM_MUTEX_NAME);\n        munmap(shm_ptr, shm_size);\n        shm_unlink(SHM_NAME);\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Empty semaphore initialized with value %d.\\n\", MAX_LOG_MESSAGES);\n\n    full_sem = sem_open(SEM_FULL_NAME, O_CREAT | O_EXCL, 0666, 0);\n    if (full_sem == SEM_FAILED) {\n        perror(\"sem_open full failed\");\n        // Clean up shm, mutex, empty\n        sem_close(mutex_sem); sem_unlink(SEM_MUTEX_NAME);\n        sem_close(empty_sem); sem_unlink(SEM_EMPTY_NAME);\n        munmap(shm_ptr, shm_size);\n        shm_unlink(SHM_NAME);\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Full semaphore initialized with value 0.\\n\");\n\n    // אין צורך לסגור או לבטל את הקישור לסמפורים כאן, מכיוון שהם יישארו פתוחים לשימוש התהליכים.\n    // הם ייסגרו ויבוטלו בקישור בסיום התוכנית או אם מתרחשת שגיאה קריטית.\n    // אבל חשוב לסגור את ה-shm_fd כי ה-mmap כבר מיפה אותו לזיכרון התהליך.\n    close(shm_fd);\n\n    printf(\"IPC resources successfully initialized.\\n\");\n}\n```\n\n**הסבר:**\n1.  **זיכרון משותף:**\n    *   `shm_open`: יוצר אובייקט זיכרון משותף בשם `SHM_NAME`. `O_CREAT` יוצר אם לא קיים, `O_EXCL` מבטיח שהתהליך הוא היוצר היחיד (אם קיים, `shm_open` ייכשל), `O_RDWR` מאפשר קריאה וכתיבה, ו-`0666` נותן הרשאות קריאה וכתיבה לכולם.\n    *   `ftruncate`: מגדיר את גודל אובייקט הזיכרון המשותף לגודל המבנה `shm_data_t`.\n    *   `mmap`: ממפה את אובייקט הזיכרון המשותף למרחב הכתובות של התהליך. `MAP_SHARED` מבטיח שהשינויים יהיו גלויים לתהליכים אחרים הממפים את אותו אובייקט.\n    *   `memset`: מאתחל את כל הזיכרון המשותף לאפס. `head` ו-`tail` מאותחלים ל-0, מה שמצביע על חוצץ ריק.\n2.  **סמפורים:**\n    *   `sem_open`: יוצר סמפור בעל שם. `O_CREAT | O_EXCL` מבטיח גם כאן יצירה חד-פעמית. ההרשאות `0666` מאפשרות גישה לכל התהליכים.\n    *   **mutex_sem**: מאותחל ל-1, מכיוון שהוא סמפור בינארי המגן על קטע קריטי יחיד.\n    *   **empty_sem**: מאותחל ל-`MAX_LOG_MESSAGES` (100), מכיוון שבתחילה החuצץ ריק לחלוטין ויש 100 מקומות פנויים.\n    *   **full_sem**: מאותחל ל-0, מכיוון שבתחילה החוצץ ריק לחלוטין ואין בו הודעות לוג.\n\n### 1.3 קוד Producer ו-Consumer:\n\n**פונקציית Producer:**\n```c\n// (הגדרות ו-typedef מ-1.1)\n\nvoid produce_log_message(const char* message) {\n    int shm_fd;\n    shm_data_t *shm_ptr;\n    sem_t *mutex_sem, *empty_sem, *full_sem;\n    size_t shm_size = sizeof(shm_data_t);\n\n    // פתיחת זיכרון משותף (רק פתיחה, לא יצירה)\n    shm_fd = shm_open(SHM_NAME, O_RDWR, 0666);\n    if (shm_fd == -1) {\n        perror(\"Producer: shm_open failed\");\n        return;\n    }\n    shm_ptr = (shm_data_t *)mmap(NULL, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (shm_ptr == MAP_FAILED) {\n        perror(\"Producer: mmap failed\");\n        close(shm_fd);\n        return;\n    }\n    close(shm_fd); // סגירת ה-fd לאחר המיפוי\n\n    // פתיחת סמפורים קיימים\n    mutex_sem = sem_open(SEM_MUTEX_NAME, 0); // 0 means don't create\n    if (mutex_sem == SEM_FAILED) { perror(\"Producer: sem_open mutex failed\"); munmap(shm_ptr, shm_size); return; }\n    empty_sem = sem_open(SEM_EMPTY_NAME, 0);\n    if (empty_sem == SEM_FAILED) { perror(\"Producer: sem_open empty failed\"); sem_close(mutex_sem); munmap(shm_ptr, shm_size); return; }\n    full_sem = sem_open(SEM_FULL_NAME, 0);\n    if (full_sem == SEM_FAILED) { perror(\"Producer: sem_open full failed\"); sem_close(mutex_sem); sem_close(empty_sem); munmap(shm_ptr, shm_size); return; }\n\n    // 1. המתן למקום פנוי (empty)\n    sem_wait(empty_sem);\n\n    // 2. המתן לנעילת הקטע הקריטי (mutex)\n    sem_wait(mutex_sem);\n\n    // קטע קריטי: כתיבה לחוצץ המשותף\n    strncpy(shm_ptr->buffer[shm_ptr->head], message, LOG_MESSAGE_SIZE - 1);\n    shm_ptr->buffer[shm_ptr->head][LOG_MESSAGE_SIZE - 1] = '\\0'; // ודא סיום null\n    shm_ptr->head = (shm_ptr->head + 1) % MAX_LOG_MESSAGES;\n    printf(\"Producer produced: %s\\n\", message);\n\n    // 3. שחרור נעילת הקטע הקריטי (mutex)\n    sem_post(mutex_sem);\n\n    // 4. אותת שיש מקום מלא (full)\n    sem_post(full_sem);\n\n    // סגירת סמפורים וזיכרון משותף בסיום השימוש (או בסיום התהליך)\n    sem_close(mutex_sem);\n    sem_close(empty_sem);\n    sem_close(full_sem);\n    munmap(shm_ptr, shm_size);\n}\n```\n\n**הסבר Producer:**\n*   **`sem_wait(empty_sem)`**: Producer ממתין כאן אם אין מקום פנוי בחוצץ (כלומר, `empty_sem` הוא 0). כאשר יש מקום, הוא מפחית את `empty_sem` באחד.\n*   **`sem_wait(mutex_sem)`**: Producer ממתין כאן כדי לקבל גישה בלעדית לקטע הקריטי (החוצץ). הוא מפחית את `mutex_sem` באחד (ל-0), ובכך מונע מ-producer או consumer אחרים לגשת לחוצץ.\n*   **כתיבה לחוצץ**: ההודעה מועתקת למיקום `head` בחוצץ. `head` מתקדם באופן מעגלי.\n*   **`sem_post(mutex_sem)`**: Producer משחרר את הנעילה על הקטע הקריטי, ומגדיל את `mutex_sem` בחזרה ל-1.\n*   **`sem_post(full_sem)`**: Producer מאותת ל-consumer שיש כעת הודעה נוספת בחוצץ, ומגדיל את `full_sem` באחד.\n\n**פונקציית Consumer:**\n```c\n// (הגדרות ו-typedef מ-1.1)\n\nvoid consume_log_message(char* message_buffer) {\n    int shm_fd;\n    shm_data_t *shm_ptr;\n    sem_t *mutex_sem, *empty_sem, *full_sem;\n    size_t shm_size = sizeof(shm_data_t);\n\n    // פתיחת זיכרון משותף (רק פתיחה)\n    shm_fd = shm_open(SHM_NAME, O_RDWR, 0666);\n    if (shm_fd == -1) {\n        perror(\"Consumer: shm_open failed\");\n        return;\n    }\n    shm_ptr = (shm_data_t *)mmap(NULL, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (shm_ptr == MAP_FAILED) {\n        perror(\"Consumer: mmap failed\");\n        close(shm_fd);\n        return;\n    }\n    close(shm_fd); // סגירת ה-fd לאחר המיפוי\n\n    // פתיחת סמפורים קיימים\n    mutex_sem = sem_open(SEM_MUTEX_NAME, 0);\n    if (mutex_sem == SEM_FAILED) { perror(\"Consumer: sem_open mutex failed\"); munmap(shm_ptr, shm_size); return; }\n    empty_sem = sem_open(SEM_EMPTY_NAME, 0);\n    if (empty_sem == SEM_FAILED) { perror(\"Consumer: sem_open empty failed\"); sem_close(mutex_sem); munmap(shm_ptr, shm_size); return; }\n    full_sem = sem_open(SEM_FULL_NAME, 0);\n    if (full_sem == SEM_FAILED) { perror(\"Consumer: sem_open full failed\"); sem_close(mutex_sem); sem_close(empty_sem); munmap(shm_ptr, shm_size); return; }\n\n    // 1. המתן למקום מלא (full)\n    sem_wait(full_sem);\n\n    // 2. המתן לנעילת הקטע הקריטי (mutex)\n    sem_wait(mutex_sem);\n\n    // קטע קריטי: קריאה מהחוצץ המשותף\n    strncpy(message_buffer, shm_ptr->buffer[shm_ptr->tail], LOG_MESSAGE_SIZE - 1);\n    message_buffer[LOG_MESSAGE_SIZE - 1] = '\\0'; // ודא סיום null\n    shm_ptr->tail = (shm_ptr->tail + 1) % MAX_LOG_MESSAGES;\n    printf(\"Consumer consumed: %s\\n\", message_buffer);\n\n    // 3. שחרור נעילת הקטע הקריטי (mutex)\n    sem_post(mutex_sem);\n\n    // 4. אותת שיש מקום פנוי (empty)\n    sem_post(empty_sem);\n\n    // סגירת סמפורים וזיכרון משותף בסיום השימוש (או בסיום התהליך)\n    sem_close(mutex_sem);\n    sem_close(empty_sem);\n    sem_close(full_sem);\n    munmap(shm_ptr, shm_size);\n}\n```\n\n**הסבר Consumer:**\n*   **`sem_wait(full_sem)`**: Consumer ממתין כאן אם אין הודעות לוג בחוצץ (כלומר, `full_sem` הוא 0). כאשר יש הודעה, הוא מפחית את `full_sem` באחד.\n*   **`sem_wait(mutex_sem)`**: Consumer ממתין כאן כדי לקבל גישה בלעדית לקטע הקריטי (החוצץ). הוא מפחית את `mutex_sem` באחד (ל-0).\n*   **קריאה מהחוצץ**: ההודעה מועתקת ממיקום `tail` בחוצץ. `tail` מתקדם באופן מעגלי.\n*   **`sem_post(mutex_sem)`**: Consumer משחרר את הנעילה על הקטע הקריטי, ומגדיל את `mutex_sem` בחזרה ל-1.\n*   **`sem_post(empty_sem)`**: Consumer מאותת ל-producer שיש כעת מקום פנוי נוסף בחוצץ, ומגדיל את `empty_sem` באחד.\n\n### 1.4 סיום והתמודדות עם כשלים:\n\n**סיום נקי (Graceful Shutdown):**\nכדי לסיים את המערכת בצורה נקייה, ישנן מספר גישות:\n1.  **\"גלולת רעל\" (Poison Pill Message):** ה-producers, כאשר אין להם יותר לוגים לייצר, יכולים לשלוח הודעה מיוחדת (למשל, מחרוזת מוגדרת כמו \"SHUTDOWN\") לחוצץ. ה-consumer, כאשר הוא קורא הודעה זו, מבין שהוא צריך לסיים את פעולתו. אם יש מספר producers, כל אחד יכול לשלוח גלולת רעל, או producer יחיד ייעודי יכול לשלוח מספר גלולות רעל כמספר ה-consumers (במקרה זה, consumer יחיד, אז גלולה אחת).\n2.  **סמפור נוסף / דגל בזיכרון משותף:** ניתן להוסיף סמפור בינארי נוסף או דגל בזיכרון המשותף (`int shutdown_flag;`) שה-consumer בודק מעת לעת. כאשר ה-producers מסיימים, הם מציבים את הדגל. ה-consumer ימשיך לעבד הודעות קיימות בחוצץ, ולאחר מכן, כשהוא מזהה את הדגל ו-`full_sem` מגיע ל-0, הוא יסיים. גישה זו דורשת שה-consumer לא ייתקע ב-`sem_wait(full_sem)` לנצח, ולכן ייתכן שיהיה צורך ב-`sem_trywait` או בשימוש ב-`sem_timedwait` עם בדיקת הדגל לאחר מכן.\n3.  **אותות (Signals):** תהליך חיצוני או אחד ה-producers יכול לשלוח אות (למשל `SIGTERM`) ל-consumer. ה-consumer יתפוס את האות, יסיים לעבד את שאר ההודעות בחוצץ, ויבצע ניקוי לפני יציאה.\n\nלאחר שה-consumer מסיים את פעולתו, עליו לבצע ניקוי של משאבי ה-IPC:\n*   `munmap()`: ניתוק הזיכרון המשותף ממרחב הכתובות של התהליך.\n*   `shm_unlink()`: מחיקת אובייקט הזיכרון המשותף מהמערכת (הוא נמחק רק כאשר כל התהליכים ניתקו אותו).\n*   `sem_close()`: סגירת כל הסמפורים הפתוחים.\n*   `sem_unlink()`: מחיקת הסמפורים בעלי השמות מהמערכת.\n\n**התמודדות עם כשלים (Process Crashes):**\nקריסת תהליך יכולה להוביל למספר בעיות:\n\n*   **קריסת Producer:**\n    *   **השלכות:** אם producer קורס בזמן שהוא מחזיק את `mutex_sem` (כלומר, בתוך הקטע הקריטי), ה-`mutex_sem` יישאר נעול (ערכו יהיה 0). זה יגרום ל-deadlock, שכן אף producer או consumer אחר לא יוכל להיכנס לקטע הקריטי, והמערכת כולה תיתקע. הודעות לוג שכבר נכתבו לחוצץ על ידי producers אחרים לא יצרכו. אם producer קורס לפני שהוא מבצע `sem_post(full_sem)` לאחר כתיבה, ה-consumer לא ידע שיש הודעה חדשה, והודעה זו תישאר \"בלתי נראית\" ל-consumer.\n    *   **התמודדות:**\n        *   **Robust Mutexes:** סמפורים ב-Linux (PTHREAD_PROCESS_SHARED mutexes) יכולים להיות \"robust\", כלומר המערכת מזהה שתהליך המחזיק את המנעול קרס ומשחררת אותו, ומחזירה שגיאה לתהליך הבא שמנסה לנעול. POSIX named semaphores אינם תומכים בתכונה זו ישירות. לכן, יש לשקול שימוש ב-`pthread_mutex_t` עם `PTHREAD_PROCESS_SHARED` ו-`PTHREAD_MUTEX_ROBUST` אם הם מאוחסנים בזיכרון משותף.\n        *   **Timeout:** ניתן להשתמש ב-`sem_timedwait` במקום `sem_wait` עם timeout קצר יחסית. אם ה-timeout פג, התהליך מניח שהסמפור נשאר נעול בגלל קריסה ומנסה להתאושש (למשל, על ידי ניסיון לאתחל מחדש את הסמפור, אם כי זה מסובך ויכול להוביל לבעיות עקביות).\n        *   **תהליך ניטור (Monitor Process):** תהליך נפרד יכול לנטר את תהליכי ה-producer. אם producer קורס, תהליך הניטור יכול לנקות את הסמפורים (לדוגמה, על ידי קריאה ל-`sem_post` אם יודעים שהוא נשאר נעול, אבל זה מסוכן אם לא בטוחים). גישה זו מורכבת ליישום נכון.\n\n*   **קריסת Consumer:**\n    *   **השלכות:** אם ה-consumer קורס, אף אחד לא יצרוך יותר הודעות מהחוצץ. ה-producers ימשיכו לכתוב הודעות עד שהחוצץ יתמלא (`empty_sem` יגיע ל-0), ואז הם ייתקעו ב-`sem_wait(empty_sem)` וימתינו לנצח. הודעות הלוג שכבר נכתבו לחוצץ יאבדו אם ה-shared memory לא תנוטר ותיקרא על ידי consumer חדש.\n    *   **התמודדות:**\n        *   **תהליך ניטור:** תהליך חיצוני יכול לנטר את ה-consumer. אם ה-consumer קורס, תהליך הניטור יכול להפעיל מחדש את ה-consumer, אשר יפתח מחדש את ה-IPC resources וימשיך מנקודת הקריסה (ה-head וה-tail בזיכרון המשותף ישמרו את מצבם). יש לוודא שה-consumer החדש יתחיל לצרוך מהמקום הנכון בחוצץ. יש לנקות את הסמפורים שנותרו פתוחים על ידי ה-consumer הקודם (אם הם לא נסגרו כראוי).\n        *   **Persistent Shared Memory:** מכיוון שאובייקטים של זיכרון משותף וסמפורים נשארים במערכת עד לביטול הקישור שלהם (`shm_unlink`, `sem_unlink`), קריסת תהליך לא תמחק אותם אוטומטית. זה מאפשר לתהליך חדש לפתוח אותם ולהמשיך לעבוד, אך דורש טיפול נכון בנעילות שנותרו.\n\nבכל מקרה של קריסה, יש צורך במנגנוני ניטור ובדיקות עקביות כדי למנוע deadlock ולאפשר התאוששות מהירה ככל הניתן. ניקוי משאבים בסיום התהליך (גם בסיום נקי וגם במקרה של שגיאה) הוא קריטי למניעת זליגות משאבים ובעיות עקביות."
    },
    "difficulty_estimation": "Hard"
  }
}