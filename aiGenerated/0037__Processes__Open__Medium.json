{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 18:17:57",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3602,
      "output_tokens": 1198,
      "total_tokens": 6182
    },
    "subject": "Virtualization"
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "Processes",
      "System Calls",
      "fork"
    ],
    "content": {
      "text": "לפניכם קוד בשפת C המשתמש בקריאות המערכת fork ו-wait. הניחו שכל קריאות המערכת מצליחות.",
      "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    for (int i = 0; i < 3; i++) {\n        pid_t pid = fork();\n        if (pid == 0) {\n            printf(\"Child %d\\n\", i);\n            if (i % 2 == 0) {\n                fork();\n            }\n            _exit(0);\n        }\n    }\n    while(wait(NULL) > 0);\n    printf(\"Parent done\\n\");\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "7.1",
        "text": "כמה תהליכים בסך הכל ייווצרו במהלך ריצת התוכנית (כולל התהליך הראשי)? הסבירו את החישוב.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.2",
        "text": "מה יקרה אם נחליף את הקריאה ל-`_exit(0)` בפקודת `break`? כיצד זה ישפיע על מספר התהליכים הנוצרים?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.3",
        "text": "הסבירו בקצרה את ההבדל בין `exit()` לבין `_exit()`. מדוע בקוד זה נעשה שימוש ב-`_exit()` בתוך תהליך הבן?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.4",
        "text": "אם נסיר את שורת הקוד `while(wait(NULL) > 0);`, מה עלול לקרות לתהליכי הבן בסיום ריצתם כל עוד התהליך האב עדיין רץ? הגדירו את המושג המתאים.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "7.1: סך הכל ייווצרו 6 תהליכים. פירוט: התהליך הראשי (1) מריץ לולאה 3 פעמים. באיטרציה i=0 הוא יוצר בן (C1), והבן יוצר נכד (C1_1) כי 0 זוגי. באיטרציה i=1 הוא יוצר בן (C2), והוא לא יוצר נכד כי 1 אינו זוגי. באיטרציה i=2 הוא יוצר בן (C3), והוא יוצר נכד (C3_1) כי 2 זוגי. סה\"כ: 1 (אב) + 3 (בנים) + 2 (נכדים) = 6.\n\n7.2: אם נחליף ב-break, תהליכי הבנים והנכדים לא יסיימו את ריצתם מיד אלא יצאו מהלולאה וימשיכו לשורת ה-wait. במקרה זה, מספר התהליכים שייווצרו לא ישתנה (עדיין 6), מכיוון שכל תהליך שנוצר יוצא מהלולאה ולא ממשיך לאיטרציות הבאות של האב.\n\n7.3: הפונקציה exit() היא פונקציית ספרייה המבצעת ניקוי (cleanup) הכולל ריקון חוצצים (buffers) של stdio לפני סיום התהליך, בעוד _exit() היא קריאת מערכת שמסיימת את התהליך מיד ללא ניקוי חוצצים. בבנים משתמשים לעיתים ב-_exit כדי למנוע מצב שבו חוצצים שהועתקו מהאב ירוקנו פעמיים (גם ע\"י הבן וגם ע\"י האב), מה שעלול להוביל לכפילות בפלט.\n\n7.4: ללא ה-wait, תהליכי הבן יהפכו לתהליכי 'זומבי' (Zombie Processes). זהו מצב שבו התהליך סיים את ביצועו אך עדיין קיימת רשומה עבורו בטבלת התהליכים של מערכת ההפעלה, כדי לאפשר לאב לקרוא את קוד היציאה שלו."
    },
    "difficulty_estimation": "Medium"
  }
}