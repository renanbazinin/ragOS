{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 09:12:42",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1598,
      "output_tokens": 1492,
      "total_tokens": 5654
    }
  },
  "question": {
    "id": 100,
    "type": "Open",
    "topic": [
      "Scheduling",
      "CPU Scheduling",
      "Round Robin"
    ],
    "content": {
      "text": "שקלו מערכת המריצה אלגוריתם תזמון Round-Robin (RR) עם קוואנטום זמן קבוע. המערכת מעבדת תערובת של משימות עתירות CPU (חישובים ארוכים) ומשימות עתירות I/O (פעולות קלט/פלט תכופות, פרצי CPU קצרים).\n\n1. הסבירו כיצד קוואנטום זמן קצר מאוד עלול להשפיע לרעה על הביצועים הכוללים של המערכת ועל זמן התגובה של משימות עתירות CPU.\n2. הסבירו כיצד קוואנטום זמן ארוך מאוד עלול להשפיע לרעה על זמן התגובה של משימות עתירות I/O ועל הוגנות המערכת הכוללת.\n3. הציעו שינוי או גישת תזמון חלופית שיכולה לאזן טוב יותר את הצרכים של משימות עתירות CPU ומשימות עתירות I/O במערכת כזו, והסבירו את יתרונותיה.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. **קוואנטום זמן קצר מאוד:**\n   *   **השפעה על ביצועים כוללים:** קוואנטום זמן קצר מדי מוביל למספר רב של מיתוגי הקשר (context switches). כל מיתוג הקשר כרוך בתקורה (overhead) – שמירה ושחזור מצב המעבד, עדכון טבלאות, וכו'. תקורה זו גוזלת זמן CPU יקר, מפחיתה את התפוקה (throughput) האפקטיבית של המערכת, ומגדילה את זמן הריצה הכולל של המשימות.\n   *   **השפעה על זמן תגובה של משימות עתירות CPU:** משימות עתירות CPU דורשות זמן עיבוד רב. עם קוואנטום זמן קצר, הן יופרעו שוב ושוב לפני שיסיימו חלק משמעותי מפרץ ה-CPU שלהן. זה אומר שהן יחוו זמן תגובה (turnaround time) ארוך יותר, מכיוון שהן יבזבזו זמן רב בהמתנה ובתקורת מיתוגי הקשר, וייקח להן זמן רב יותר להשלים את עבודתן.\n\n2. **קוואנטום זמן ארוך מאוד:**\n   *   **השפעה על זמן תגובה של משימות עתירות I/O:** משימות עתירות I/O מאופיינות בפרצי CPU קצרים יחסית, ולאחר מכן הן עוברות למצב המתנה ל-I/O. אם הקוואנטום ארוך מאוד, משימת I/O-bound יכולה לסיים את פרץ ה-CPU הקצר שלה הרבה לפני תום הקוואנטום. היא תפנה את המעבד מרצונה. עם זאת, אם משימה עתירת CPU מקבלת את המעבד ומתחילה לרוץ, היא תמשיך לרוץ במשך כל הקוואנטום הארוך, גם אם משימת I/O-bound אחרת הגיעה למצב Ready. זה יגרום למשימות ה-I/O-bound להמתין זמן רב יותר לתורן, מה שיפגע קשות בזמן התגובה שלהן ובתגובתיות המערכת.\n   *   **השפעה על הוגנות המערכת:** קוואנטום ארוך מדי הופך את RR לדמוי FCFS (First Come First Served) במידה רבה. משימה שקיבלה את המעבד תשלוט בו למשך זמן רב, וכל שאר המשימות יאלצו להמתין. זה פוגע בהוגנות, שכן כל המשימות אמורות לקבל חלק שווה יחסית מזמן המעבד לאורך זמן.\n\n3. **הצעה לשינוי/גישת תזמון חלופית:**\n   *   **מערכת תורים מרובת רמות עם משוב (Multi-Level Feedback Queue - MLFQ):** זוהי גישה נפוצה שיכולה לאזן היטב בין משימות מסוגים שונים.\n   *   **יתרונות:**\n       *   **העדפה למשימות I/O-bound:** משימות חדשות נכנסות לתור בעדיפות גבוהה עם קוואנטום זמן קצר. משימות I/O-bound יסיימו את פרץ ה-CPU הקצר שלהן ויעזבו את המעבד (או יופרעו לאחר זמן קצר) מהר, ובכך יקבלו זמן תגובה טוב.\n       *   **הורדת עדיפות למשימות CPU-bound:** משימות שמנצלות את כל הקוואנטום שלהן (כלומר, משימות CPU-bound) מורדות לתורים בעדיפות נמוכה יותר, שם הן מקבלות קוואנטום זמן ארוך יותר (או מתוזמנות ב-FCFS). זה מפחית את מספר מיתוגי ההקשר עבורן ומאפשר להן להתקדם ביעילות רבה יותר, תוך כדי הקטנת התקורה.\n       *   **מניעת הרעבה (starvation):** מנגנון ה-\"priority boost\" מעלה מעת לעת את כל המשימות לתור העליון, מה שמבטיח שגם משימות בעדיפות נמוכה יקבלו הזדמנות לרוץ ולא יורעבו.\n       *   **אדפטיביות:** האלגוריתם מסתגל להתנהגות המשימות באופן דינמי מבלי לדרוש ידע מוקדם על סוגן."
    },
    "difficulty_estimation": "Medium"
  }
}