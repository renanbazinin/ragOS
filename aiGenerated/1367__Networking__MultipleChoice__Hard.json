{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "Networking",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:41:35",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 968,
      "output_tokens": 1145,
      "total_tokens": 8024
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "Networking",
      "Socket Programming",
      "I/O Multiplexing",
      "TCP"
    ],
    "content": {
      "text": "נתבונן בשרת TCP המשתמש במנגנון `select` לטיפול במספר חיבורי לקוחות במקביל. השרת מוסיף את ה-file descriptor של כל לקוח למערך ה-`fd_set` עבור קריאות `select`.\nלאחר ש-`select` חוזר ומציין ש-file descriptor מסוים של לקוח מוכן לקריאה, השרת מנסה לקרוא ממנו באמצעות `read()`.\n\nאיזו מהטענות הבאות מתארת את התרחיש *הנפוץ והמצופה ביותר* בו `select` מציין ש-socket של לקוח מוכן לקריאה, אך קריאה עוקבת של `read()` תחזיר 0 (אפס) בתים, ומהי המשמעות של תוצאה זו?",
      "code_snippet": null,
      "options": [
        "א. הלקוח שלח חלקיק קטן של נתונים, והשרת קרא את כולם. `read()` מחזירה 0 כדי לציין שאין יותר נתונים זמינים כרגע. המשמעות היא שהנתונים נקראו בהצלחה.",
        "ב. הלקוח סגר את החיבור מצידו באופן יזום ורגיל (graceful shutdown). `read()` מחזירה 0 כדי לסמן סוף קובץ (EOF) בחיבור. המשמעות היא שהלקוח התנתק, ועל השרת לסגור את ה-socket מצידו.",
        "ג. הלקוח ניתק באופן פתאומי (לדוגמה, קריסת תוכנה או ניתוק כבל רשת), מה שגורם ל-TCP לשלוח חבילת RST. `read()` מחזירה 0 כדי לציין שהחיבור נותק. המשמעות היא שיש לטפל בשגיאה זו כניתוק לא צפוי.",
        "ד. השרת מנסה לקרוא מ-socket שאינו חסום (non-blocking) כאשר אין נתונים זמינים. `read()` מחזירה 0 במקרה זה. המשמעות היא שהשרת צריך לנסות לקרוא שוב מאוחר יותר.",
        "ה. אף אחת מהטענות האחרות אינה נכונה."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "התשובה הנכונה היא ב'.\nכאשר `select` מציין ש-socket מוכן לקריאה, זה לא אומר בהכרח שיש נתונים ממתינים ב-buffer. זה יכול גם לסמן שקצה החיבור השני (הלקוח) סגר את החיבור מצידו. במקרה של סגירת חיבור יזומה ורגילה (graceful shutdown) על ידי הלקוח, קריאה ל-`read()` בשרת תחזיר 0 בתים. ערך החזרה זה מציין 'סוף קובץ' (EOF) במונחי חיבורי רשת, ומעיד שהלקוח התנתק. השרת צריך לזהות מצב זה כניתוק תקין ולסגור את ה-socket מצידו.\n\nניתוח שאר האפשרויות:\nא. אם הלקוח שלח נתונים והשרת קרא אותם, `read()` תחזיר את מספר הבתים שנקראו (ערך חיובי), ולא 0.\nג. ניתוק פתאומי של לקוח (לדוגמה, קריסה או ניתוק כבל) עשוי לגרום ל-TCP לשלוח חבילת RST. במקרה כזה, קריאה ל-`read()` עשויה להחזיר -1 ולעדכן את `errno` ל-`ECONNRESET` (או שגיאה אחרת), ולא 0. למרות שקיימים תרחישים מסוימים בהם `read()` יכולה להחזיר 0 גם במקרה של ניתוק פתאומי (אם ה-OS מזהה זאת כ-EOF), התרחיש של סגירה יזומה הוא ה'נפוץ והמצופה ביותר' להחזרת 0.\nד. כאשר קוראים מ-socket שאינו חסום (non-blocking) ואין נתונים זמינים, `read()` תחזיר -1 ו-`errno` יוגדר ל-`EAGAIN` או `EWOULDBLOCK`, ולא 0."
    },
    "difficulty_estimation": "Hard"
  }
}