{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:17:16",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 969,
      "output_tokens": 995,
      "total_tokens": 4267
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "System Calls",
      "Kernel",
      "Memory Management",
      "Security"
    ],
    "content": {
      "text": "תהליך משתמש קורא למערכת ההפעלה באמצעות קריאת מערכת `write(fd, buf, count)`. נניח ש-`count` גדול מאוד, והתהליך מנסה לכתוב נתונים לתוך קובץ. מיד לאחר הקריאה ל-`write`, אך לפני שהקרנל סיים להעתיק את כל הנתונים מ-`buf` או לכתוב אותם להתקן, התהליך מבצע קריאת מערכת נוספת, `munmap`, על חלק מזיכרון המשתמש ש-`buf` מצביע אליו. איזו מהטענות הבאות מתארת את ההתנהגות הצפויה והנכונה של מערכת הפעלה מודרנית ובטוחה (למשל Linux) במצב כזה?",
      "code_snippet": null,
      "options": [
        "א. הקרנל יקרוס (kernel panic) עקב ניסיון גישה לכתובת זיכרון לא חוקית במצב קרנל.",
        "ב. הקרנל יכתוב רק את החלק מהנתונים שהספיק להעתיק לפני ה-`munmap`, ויחזיר ערך הצלחה (מספר הבתים שנכתבו) המעיד על כתיבה חלקית, מבלי להחזיר שגיאה.",
        "ג. הקרנל יזהה את ניסיון הגישה הלא חוקית לזיכרון המשתמש במהלך העתקת הנתונים, יפסיק את פעולת ה-`write`, ויחזיר קוד שגיאה מתאים (לדוגמה, `EFAULT`).",
        "ד. הקרנל יבצע העתקה אטומית של כל הנתונים מ-`buf` למאגר פנימי בזיכרון הקרנל מיד בתחילת קריאת ה-`write` (לפני כל גישה אחרת ל-`buf`), ולכן ה-`munmap` המאוחר יותר לא ישפיע על פעולת ה-`write`, שתסתיים בהצלחה מלאה."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ג",
      "explanation": "הסבר: התשובה הנכונה היא ג'. מערכות הפעלה מודרניות, כמו לינוקס, נוקטות בגישה זהירה בעת גישה לזיכרון משתמש. למרות שהן מבצעות בדיקות ראשוניות על כתובות (למשל, שהן נמצאות בטווח החוקי של מרחב הכתובות של התהליך), הן גם מטפלות בפסיקות דף (page faults) ובגישה לזיכרון לא חוקי במהלך פעולת קריאת המערכת. במקרה שבו תהליך המשתמש מבטל מיפוי של דפי זיכרון (באמצעות `munmap`) בזמן שהקרנל עדיין מנסה לגשת אליהם עבור קריאת מערכת כמו `write`, הקרנל יזהה את פסיקת הדף או את הגישה הלא חוקית. במקום לקרוס (א'), או להמשיך בפעולה חלקית ללא דיווח שגיאה (ב'), הוא יפסיק את פעולת קריאת המערכת ויחזיר קוד שגיאה מתאים, לרוב `EFAULT`, המציין 'כתובת רעה' (bad address). העתקה אטומית של כל הנתונים למאגר קרנל (ד') אינה תמיד מעשית או יעילה עבור כמויות גדולות של נתונים, ולכן הקרנל לרוב ניגש לדפי המשתמש ישירות (לאחר אימות) או מעתיק אותם בחלקים, תוך טיפול שוטף בפסיקות זיכרון ואימות הרשאות בכל גישה."
    },
    "difficulty_estimation": "Hard"
  }
}