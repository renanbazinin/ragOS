{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 06:51:11",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3971,
      "output_tokens": 2921,
      "total_tokens": 17402
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Paging",
      "Virtual Memory",
      "TLB",
      "Page Faults"
    ],
    "content": {
      "text": "נתונה מערכת זיכרון וירטואלי בעלת המאפיינים הבאים:\n*   גודל עמוד (page size): 4KB (4096 בתים).\n*   כתובות וירטואליות בגודל 32 ביט.\n*   מערכת ההפעלה משתמשת בטבלת עמודים יחידה (single-level page table).\n*   למערכת קיים TLB (Translation Lookaside Buffer) בעל 4 כניסות (fully associative) המשתמש במדיניות החלפה LRU (Least Recently Used).\n*   ה-TLB ריק בתחילת ריצת התוכנית.\n*   כל העמודים של המערך `matrix` נמצאים בתחילה בדיסק ונטענים לזיכרון פיזי לפי דרישה (demand paging).\n*   גודל הזיכרון הפיזי מספיק גדול כדי להכיל את כל העמודים של המערך `matrix` בו זמנית.\n*   יש להתעלם מגישות לזיכרון עבור קוד התוכנית, מחסנית, או משתנים גלובליים אחרים. התמקדו רק בגישות למערך `matrix`.\n*   הקצאת הזיכרון באמצעות `malloc` מחזירה כתובת וירטואלית מיושרת לגבול עמוד (page-aligned).\n\nנתונה התוכנית הבאה:",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n\n#define NUM_ROWS 1024\n#define NUM_COLS 1024\n#define PAGE_SIZE 4096 // 4KB\n\nint main() {\n    // Allocate a 2D array of integers\n    // Assuming sizeof(int) is 4 bytes\n    int (*matrix)[NUM_COLS] = (int (*)[NUM_COLS])malloc(NUM_ROWS * NUM_COLS * sizeof(int));\n\n    if (matrix == NULL) {\n        perror(\"malloc failed\");\n        return 1;\n    }\n\n    // First access pattern\n    for (int i = 0; i < NUM_ROWS; ++i) {\n        for (int j = 0; j < NUM_COLS; j += 128) {\n            matrix[i][j] = i + j;\n        }\n    }\n\n    // Second access pattern\n    for (int j = 0; j < NUM_COLS; ++j) {\n        for (int i = 0; i < NUM_ROWS; i += 64) {\n            matrix[i][j] += 1;\n        }\n    }\n\n    free(matrix);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "כמה **TLB Misses** יתרחשו בסך הכל במהלך ביצוע הפונקציה `main`? פרטו את חישובכם.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "כמה **Page Faults** יתרחשו בסך הכל במהלך ביצוע הפונקציה `main`? פרטו את חישובכם.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**חישובים מקדימים:**\n*   גודל `int`: 4 בתים (בהנחה של מערכת 32 ביט או ספציפיקציה של הקומפיילר).\n*   גודל המערך `matrix`: `NUM_ROWS * NUM_COLS * sizeof(int) = 1024 * 1024 * 4 = 4,194,304` בתים = `4MB`.\n*   גודל עמוד: `4096` בתים.\n*   מספר העמודים הכולל הנדרש למערך: `4,194,304 / 4096 = 1024` עמודים.\n*   כל שורה במערך: `NUM_COLS * sizeof(int) = 1024 * 4 = 4096` בתים. כלומר, כל שורה תופסת בדיוק עמוד אחד.\n*   בהנחה ש-`malloc` מחזיר כתובת מיושרת לעמוד, העמודים של המערך ממוספרים מ-0 עד 1023 (כלומר, שורה `i` נמצאת בעמוד `i` יחסית לתחילת המערך).\n*   גודל TLB: 4 כניסות, מדיניות החלפה LRU.\n\n**ניתוח לולאה ראשונה:**\n```c\n    for (int i = 0; i < NUM_ROWS; ++i) {\n        for (int j = 0; j < NUM_COLS; j += 128) {\n            matrix[i][j] = i + j;\n        }\n    }\n```\n*   בלולאה החיצונית, `i` עובר על כל השורות, כאשר כל שורה תופסת עמוד זיכרון בודד. כלומר, בכל איטרציה של `i`, אנו ניגשים לעמוד חדש (עמוד `i`).\n*   בלולאה הפנימית, אנו ניגשים לאלמנטים בתוך אותה השורה (אותו העמוד). לדוגמה, עבור `i=0`, נגשים ל-`matrix[0][0]`, `matrix[0][128]`, וכו'. כל הגישות הללו הן לאותו עמוד.\n\n*   **TLB Misses בלולאה הראשונה:**\n    *   ה-TLB ריק בתחילה.\n    *   עבור `i=0`, הגישה הראשונה ל-`matrix[0][0]` תגרום ל-TLB miss. כניסה עבור עמוד 0 נכנסת ל-TLB. כל הגישות הבאות עבור `i=0` (לאותו עמוד) יהיו TLB hits.\n    *   עבור `i=1, 2, 3`, יתרחשו TLB misses עבור הגישה הראשונה לכל עמוד (עמוד 1, 2, 3 בהתאמה). ה-TLB יתמלא ב-4 כניסות (עמודים 0, 1, 2, 3).\n    *   החל מ-`i=4`, כל גישה ראשונה לעמוד חדש (עמוד `i`) תגרום ל-TLB miss. מכיוון שה-TLB מכיל רק 4 כניסות, הכניסה שהכי פחות בשימוש (LRU) תוצא כדי לפנות מקום לעמוד החדש. מכיוון שאנו תמיד ניגשים לעמוד חדש שטרם נגיש בלולאה הפנימית, כל גישה ראשונה לעמוד תהיה TLB miss.\n    *   ישנם `NUM_ROWS = 1024` עמודים שונים (שורות) שאליהם ניגשים בלולאה זו.\n    *   לכן, מספר ה-TLB misses בלולאה הראשונה הוא **1024**.\n\n*   **Page Faults בלולאה הראשונה:**\n    *   כל אחד מ-1024 העמודים (מ-0 עד 1023) נגיש בפעם הראשונה בלולאה זו.\n    *   מכיוון שכל העמודים נמצאים בתחילה בדיסק ונטענים לפי דרישה, וכל עמוד נגיש לראשונה, תתרחש תקלת עמוד (page fault) עבור כל אחד מ-1024 העמודים.\n    *   סה\"כ page faults בלולאה הראשונה הוא **1024**.\n\n**ניתוח לולאה שנייה:**\n```c\n    for (int j = 0; j < NUM_COLS; ++j) {\n        for (int i = 0; i < NUM_ROWS; i += 64) {\n            matrix[i][j] += 1;\n        }\n    }\n```\n*   בלולאה החיצונית, `j` עובר על כל העמודות.\n*   בלולאה הפנימית, עבור כל `j` קבוע, אנו ניגשים לאלמנטים `matrix[0][j]`, `matrix[64][j]`, `matrix[128][j]`, וכו'.\n*   העמודים שאליהם ניגשים עבור כל `j` הם: עמוד 0, עמוד 64, עמוד 128, ..., עד עמוד `1024-64 = 960`.\n*   מספר העמודים הדיסקרטיים שנגישים עבור כל `j` הוא `NUM_ROWS / 64 = 1024 / 64 = 16` עמודים.\n\n*   **TLB Misses בלולאה השנייה:**\n    *   בסיום הלולאה הראשונה, ה-TLB מכיל את הכניסות עבור 4 העמודים האחרונים שנגישו (למשל, 1020, 1021, 1022, 1023, אם הם היו ה-LRU). כל העמודים הללו אינם נכללים בקבוצת העבודה של 16 העמודים הנגישים בלולאה השנייה (0, 64, ..., 960).\n    *   עבור `j=0`, אנו ניגשים לעמודים 0, 64, 128, 192, 256, ..., 960 (סה\"כ 16 עמודים שונים).\n    *   כל אחד מ-16 העמודים הללו יגרום ל-TLB miss, מכיוון שגודל קבוצת העבודה (16 עמודים) גדול משמעותית מגודל ה-TLB (4 כניסות). ה-TLB יתמלא ויתחיל להחליף כניסות במדיניות LRU. כיוון שהגישות הן לעמודים שונים בכל פעם, כל גישה לעמוד חדש תגרום ל-TLB miss.\n    *   לכן, עבור `j=0`, יהיו 16 TLB misses.\n    *   מצב זה חוזר על עצמו עבור כל `j` מ-0 עד `NUM_COLS-1` (1024 עמודות).\n    *   סה\"כ TLB misses בלולאה השנייה: `NUM_COLS * (NUM_ROWS / 64) = 1024 * 16 = 16384`.\n\n*   **Page Faults בלולאה השנייה:**\n    *   כל העמודים (0 עד 1023) הובאו כבר לזיכרון הפיזי בלולאה הראשונה.\n    *   מכיוון שגודל הזיכרון הפיזי מספיק גדול להכיל את כל העמודים של המערך בו זמנית, לא תתרחשנה תקלוות עמוד נוספות בלולאה השנייה.\n    *   סה\"כ page faults בלולאה השנייה הוא **0**.\n\n**סיכום כולל:**\n1.  **סה\"כ TLB Misses:** `1024 (מלולאה 1) + 16384 (מלולאה 2) = 17408`.\n2.  **סה\"כ Page Faults:** `1024 (מלולאה 1) + 0 (מלולאה 2) = 1024`."
    },
    "difficulty_estimation": "Hard"
  }
}