{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling and Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 11:48:51",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2319,
      "output_tokens": 1551,
      "total_tokens": 8065
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "CPU Scheduling",
      "Context Switching",
      "Round Robin",
      "Performance Overhead"
    ],
    "content": {
      "text": "נתונה מערכת המריצה אלגוריתם תזמון Round-Robin עם קוונטום זמן (time slice) קצר מאוד. ענו על השאלות הבאות:",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "7.1",
        "text": "תארו את השלבים המעורבים במעבר הקשר (Context Switch) בין שני תהליכים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.2",
        "text": "הסבירו כיצד קוונטום זמן קצר מאוד משפיע על ביצועי המערכת, במיוחד בהקשר של מעברי הקשר.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.3",
        "text": "הציעו שינוי לאלגוריתם Round-Robin או מנגנון משלים שיכול למתן את ההשפעות השליליות של מעברי הקשר תכופים, תוך שמירה על היענות (responsiveness). נמקו את הצעתכם.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "7.1. מעבר הקשר כולל את השלבים הבאים:\n1. שמירת מצב ה-CPU (אוגרים, מונה תוכנית, מצביע מחסנית וכו') של התהליך הנוכחי (P1) בבלוק בקרת התהליך (PCB) שלו.\n2. עדכון מצבו של P1 (לדוגמה, מ'רץ' ל'מוכן' או 'ממתין').\n3. בחירת התהליך הבא (P2) להרצה מתור התהליכים המוכנים.\n4. עדכון מצבו של P2 (לדוגמה, מ'מוכן' ל'רץ').\n5. שחזור מצב ה-CPU של P2 מבלוק בקרת התהליך שלו לאוגרי ה-CPU.\n6. עדכון רישומים ביחידת ניהול הזיכרון (MMU), כמו רישום בסיס טבלת הדפים, אם P1 ו-P2 שייכים למרחבי כתובות שונים.\n7. חידוש ביצוע של P2.\n\n7.2. קוונטום זמן קצר מאוד מוביל למספר השפעות שליליות:\n1. **עלויות תקורה גבוהות**: כל מעבר הקשר דורש זמן CPU (לשמירה ושחזור מצב, ביטול קאש, ניקוי TLB). כאשר הקוונטום קצר מאוד, המעבד מבלה חלק גדול מזמנו בביצוע מעברי הקשר במקום בביצוע עבודה שימושית. זה מפחית את התפוקה הכוללת של המערכת.\n2. **ירידה בתפוקה**: כתוצאה מעלויות התקורה הגבוהות, פחות עבודה 'אמיתית' מבוצעת ליחידת זמן.\n3. **פגיעה בביצועי מטמון (Cache Performance)**: מעבר בין תהליכים שונים מוביל לרוב ל-cache misses תכופים יותר, מכיוון שנתונים ופקודות של התהליך הקודם מפונים מהמטמון וצריך לטעון את אלו של התהליך החדש.\n4. **היענות (Responsiveness) משופרת (עד גבול מסוים)**: באופן עקרוני, קוונטום קצר יותר מגביר את ההיענות בכך שכל תהליך מקבל הזדמנות לרוץ לעתים קרובות יותר. אולם, כאשר הקוונטום קצר מדי, עלויות התקורה של מעברי הקשר יכולות לנגוס ביתרון זה ולפגוע בהיענות בפועל.\n\n7.3. ניתן להציע שינוי לאלגוריתם Round-Robin המשלב אלמנטים של Multi-level Feedback Queue (MLFQ):\n**מנגנון**: במקום קוונטום קבוע לכל התהליכים, נגדיר מספר תורים בעלי עדיפויות שונות וקוונטומים שונים. תהליכים יתחילו בתור בעל העדיפות הגבוהה ביותר עם קוונטום זמן קצר (לדוגמה, 10ms). אם תהליך משלים את משימתו או נחסם בגלל I/O לפני תום הקוונטום, הוא נשאר בתור זה (או חוזר אליו אם נחסם). אם תהליך משתמש בכל הקוונטום שלו (כלומר, הוא CPU-bound), הוא מורד לתור בעל עדיפות נמוכה יותר עם קוונטום זמן ארוך יותר (לדוגמה, 100ms).\n**נימוק**: \n*   **הפחתת מעברי הקשר לתהליכים תלויי CPU**: תהליכים שצורכים הרבה CPU יורדו לתורים עם קוונטומים ארוכים יותר, ובכך יבצעו פחות מעברי הקשר. זה מפחית את התקורה הכוללת של המערכת.\n*   **שמירה על היענות לתהליכים תלויי I/O**: תהליכים תלויי I/O, שנוטים להתחסם במהירות, יישארו בתורים בעלי עדיפות גבוהה ועם קוונטומים קצרים. זה מבטיח שהם יקבלו את ה-CPU במהירות כשהם מוכנים, מה שמשפר את ההיענות למשתמש.\n*   **מניעת רעב (Starvation)**: ניתן להוסיף מנגנון 'העלאת עדיפות' (priority boost) תקופתי, שיחזיר את כל התהליכים לתור בעל העדיפות הגבוהה ביותר, כדי לוודא שגם תהליכים שירדו לתורים נמוכים יקבלו הזדמנות בסופו של דבר."
    },
    "difficulty_estimation": "Medium"
  }
}