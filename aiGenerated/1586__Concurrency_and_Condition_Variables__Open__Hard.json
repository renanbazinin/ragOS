{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Concurrency and Condition Variables",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 11:44:04",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3819,
      "output_tokens": 3505,
      "total_tokens": 15243
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Concurrency",
      "Condition Variables",
      "Synchronization",
      "Reusable Barrier"
    ],
    "content": {
      "text": "קבוצה של N תהליכונים (threads) צריכה להסתנכרן כך שכל N התהליכונים יגיעו לנקודה מסוימת (מחסום) לפני שאף אחד מהם יוכל להמשיך. המחסום צריך להיות ניתן לשימוש חוזר (reusable), כלומר, לאחר שקבוצה אחת של N תהליכונים עברה את המחסום, הוא מוכן לקבוצה הבאה של N תהליכונים.\n\nא. עצב ויישם מנגנון מחסום כזה ב-C++ תוך שימוש ב-`std::mutex` וב-`std::condition_variable`. כלול את הקוד המלא של מחלקה `ReusableBarrier` עם מתודה `wait()`.\nב. הסבר בפירוט את פתרונך.\nג. דון בבעיות פוטנציאליות העלולות להתעורר אם המחסום אינו מיושם בזהירות, במיוחד בהקשר של שימוש חוזר (reusability). התייחס למצבי מרוץ (race conditions), קיפאון (deadlock), והתנהגות שגויה.",
      "code_snippet": "class ReusableBarrier {\npublic:\n    explicit ReusableBarrier(int count) :\n        threshold(count),\n        arrived_count(0),\n        waiting_for_reset_count(0),\n        current_phase(0) {}\n\n    void wait() {\n        std::unique_lock<std::mutex> lock(m);\n        int my_phase = current_phase; // לכידת הפאזה הנוכחית של התהליכון\n\n        arrived_count++;\n\n        if (arrived_count < threshold) {\n            // זהו אינו התהליכון האחרון שהגיע, המתן לאחרים להגיע לפאזה זו\n            cv_arrival.wait(lock, [this, my_phase]{\n                // התעורר אם הפאזה השתנתה (כלומר, המחסום עבר)\n                // או אם התעוררות שווא והפאזה עדיין זהה (חזור להמתין)\n                return my_phase != current_phase;\n            });\n        } else {\n            // זהו התהליכון האחרון שהגיע עבור פאזה זו.\n            // אפס את מונה ההגעה עבור הפאזה הבאה.\n            arrived_count = 0;\n            // קדם את מספר הפאזה כדי לסמן שהקבוצה הנוכחית עברה.\n            current_phase++;\n            // הער את כל התהליכונים שהמתינו להגעה.\n            cv_arrival.notify_all();\n\n            // כעת, התהליכון האחרון צריך להמתין שכל התהליכונים\n            // מהפאזה הקודמת יאשרו שהם עברו את המחסום\n            // לפני שקבוצה חדשה תוכל להתחיל.\n            waiting_for_reset_count = threshold; // כל התהליכונים מקבוצה זו חייבים לאותת שסיימו\n            cv_reset.wait(lock, [this]{\n                // המתן עד שכל התהליכונים אישרו את האיפוס\n                return waiting_for_reset_count == 0;\n            });\n        }\n\n        // כל התהליכונים עברו את נקודת ההגעה.\n        // כעת, כל תהליכון (למעט האחרון שהפעיל את notify_all ב-cv_reset)\n        // צריך לאותת שהוא ראה את שינוי הפאזה ומוכן להמשיך,\n        // כך שהתהליכון האחרון יוכל להמשיך.\n        // יש לוודא שהתהליכון אכן היה חלק מהפאזה שהסתיימה זה עתה\n        if (my_phase == current_phase - 1) {\n            waiting_for_reset_count--;\n            if (waiting_for_reset_count == 0) {\n                // רק התהליכון האחרון שמאשר את האיפוס צריך להעיר את התהליכון האחרון שהמתין ב-cv_reset\n                cv_reset.notify_one();\n            }\n        }\n    }\n\nprivate:\n    std::mutex m;\n    std::condition_variable cv_arrival; // עבור תהליכונים הממתינים שאחרים יגיעו\n    std::condition_variable cv_reset;   // עבור התהליכון האחרון הממתין שאחרים יאשרו את האיפוס\n\n    int threshold;              // מספר התהליכונים הנדרשים כדי לעבור את המחסום\n    int arrived_count;          // מונה התהליכונים שהגיעו למחסום בפאזה הנוכחית\n    int waiting_for_reset_count; // מונה התהליכונים שטרם אישרו את האיפוס לאחר מעבר המחסום\n    int current_phase;          // מספר הפאזה הנוכחית, כדי להבחין בין מחזורי מחסום שונים\n};",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\nא. יישום מחלקה `ReusableBarrier`:\nהקוד המלא של המחלקה `ReusableBarrier` מופיע בסעיף `code_snippet` שבשאלה.\n\nב. הסבר הפתרון:\nהפתרון מבוסס על מנגנון \"מחסום דו-פאזי\" (two-phase barrier) המשתמש בשני משתני תנאי (condition variables) ובמונה פאזות (`current_phase`) כדי לטפל בצורה נכונה בשימוש חוזר.\n\n*   **`threshold`**: מספר התהליכונים שחייבים להגיע כדי שהמחסום ייפתח.\n*   **`arrived_count`**: מונה כמה תהליכונים הגיעו לנקודת המחסום בפאזה הנוכחית.\n*   **`current_phase`**: משמש להבחנה בין מחזורי מחסום שונים. כל מחזור (קבוצה של `threshold` תהליכונים) מקבל מספר פאזה ייחודי. חוט לוכד את מספר הפאזה שלו (`my_phase`) כשהוא נכנס למחסום.\n*   **`cv_arrival`**: משתנה תנאי שעליו ממתינים התהליכונים עד שכל `threshold` התהליכונים של הפאזה הנוכחית יגיעו.\n*   **`cv_reset`**: משתנה תנאי שעליו ממתין התהליכון האחרון (שפותח את המחסום) עד שכל שאר התהליכונים יאשרו שהם עברו את המחסום והם מוכנים למחזור הבא.\n*   **`waiting_for_reset_count`**: מונה כמה תהליכונים (מתוך הקבוצה שעברה זה עתה את המחסום) טרם אישרו שהם עברו את המחסום ומוכנים לאיפוס.\n\n**תהליך הפעולה:**\n\n1.  **כניסה למתודה `wait()`**: כל תהליכון שרוצה לעבור את המחסום קורא למתודה `wait()`. הוא נועל את המוטקס (`m`) ולוכד את `current_phase` לתוך המשתנה המקומי `my_phase`.\n2.  **ספירת הגעה**: `arrived_count` גדל באחד.\n3.  **החוטים הראשונים (1 עד `threshold-1`)**:\n    *   אם `arrived_count` קטן מ-`threshold`, התהליכון אינו האחרון שהגיע. הוא ממתין על `cv_arrival`.\n    *   תנאי ההמתנה (`my_phase != current_phase`) מבטיח שהתהליכון יתעורר רק כאשר `current_phase` יקודם על ידי התהליכון האחרון. זה מונע התעוררויות שווא או התקדמות שגויה אם `notify_all` נקרא עבור פאזה אחרת.\n4.  **החוט האחרון (`threshold`-י)**:\n    *   כאשר `arrived_count` מגיע ל-`threshold`, התהליכון הנוכחי הוא האחרון שהגיע.\n    *   הוא מאפס את `arrived_count` (כדי להכין את המחסום למחזור הבא).\n    *   הוא מקדם את `current_phase` (כדי לסמן שקבוצה זו עברה את המחסום ולשחרר את התהליכונים הממתינים).\n    *   הוא קורא ל-`cv_arrival.notify_all()` כדי להעיר את כל התהליכונים האחרים הממתינים על `cv_arrival`.\n    *   **פאזת האיפוס (Reset Phase)**: כדי לוודא שכל התהליכונים מהקבוצה הנוכחית אכן עברו והתחילו להתקדם *לפני* שקבוצה חדשה תוכל להתחיל, התהליכון האחרון מאתחל את `waiting_for_reset_count` ל-`threshold` וממתין על `cv_reset` עד שמונה זה יגיע לאפס.\n5.  **אחרי ההתעוררות (לכל החוטים)**:\n    *   לאחר שהתהליכונים התעוררו מ-`cv_arrival` (או שהיו האחרונים שהגיעו), הם בודקים אם הם היו חלק מהפאזה שהסתיימה זה עתה (`my_phase == current_phase - 1`).\n    *   אם כן, הם מקטינים את `waiting_for_reset_count`.\n    *   התהליכון האחרון שמקטין את `waiting_for_reset_count` לאפס (כלומר, כל התהליכונים אישרו שהם עברו) קורא ל-`cv_reset.notify_one()` כדי להעיר את התהליכון האחרון שהמתין על `cv_reset`.\n    *   רק אז כל התהליכונים, כולל האחרון, יכולים לשחרר את המוטקס ולהמשיך.\n\nג. בעיות פוטנציאליות ביישום לא זהיר:\n\n1.  **מצבי מרוץ (Race Conditions) והתנהגות שגויה בשימוש חוזר:**\n    *   **הבעיה המרכזית במחסומים ניתנים לשימוש חוזר** היא כאשר קבוצת תהליכונים עוברת את המחסום, והתהליכונים הראשונים של הקבוצה *הבאה* מגיעים למחסום לפני שכל התהליכונים של הקבוצה *הקודמת* הספיקו לעבור לגמרי.\n    *   **ללא `current_phase`**: אם היינו משתמשים רק ב-`arrived_count` וב-`cv_arrival` ללא מונה פאזות, חוטים מהקבוצה הראשונה שהתעוררו עלולים לראות את `arrived_count` מאופס (על ידי החוט האחרון של קבוצתם) ולהתחיל להגדיל אותו עבור הקבוצה הבאה, בעוד שהם עדיין חלק מהמחזור הקודם. זה יכול לגרום לכך שחוטים יתקדמו לפני שהקבוצה שלהם הושלמה, או שחוטים ייתקעו.\n    *   **פתרון ביישום הנוכחי**: השימוש ב-`my_phase` וב-`current_phase` מבטיח שכל תהליכון משויך באופן חד-משמעי למחזור מסוים של המחסום. תהליכון יתקדם רק אם ה-`current_phase` השתנה (כלומר, הקבוצה שלו עברה) או אם הוא עצמו היה החוט האחרון בקבוצה.\n    *   **הבעיה של \"החוט האחרון בורח\"**: אם החוט האחרון (שקורא ל-`notify_all`) לא ימתין שכל שאר החוטים יאשרו שהם עברו, הוא עלול לאפס את המחסום ולהתחיל את המחזור הבא, בעוד שחוטים מהמחזור הקודם עדיין נמצאים בתהליך היציאה. זה יכול לגרום לבלבול ולחוסר סנכרון. ה-`cv_reset` ו-`waiting_for_reset_count` פותרים זאת בכך שהם מאלצים את החוט האחרון להמתין לאישור מכל החוטים האחרים לפני שהוא משחרר את המוטקס סופית.\n\n2.  **קיפאון (Deadlock)**:\n    *   **שימוש ב-`notify_one` במקום `notify_all`**: אם החוט האחרון היה קורא ל-`notify_one` במקום `notify_all`, רק תהליכון אחד שהמתין היה מתעורר. השאר היו נשארים רדומים לנצח, מה שהיה מוביל לקיפאון.\n    *   **ללא טיפול נכון ב-`my_phase`**: אם תנאי ההמתנה ב-`cv.wait` לא היה בודק את `my_phase`, תהליכון שהתעורר מהמתנה שווא (spurious wakeup) או מ-`notify_all` של פאזה קודמת/עתידית, עלול היה לראות ש-`arrived_count` עדיין לא הגיע ל-`threshold` ולהיכנס שוב למצב המתנה, אך ללא שינוי ב-`current_phase` (אם אף חוט לא הגיע אחריו) הוא היה נתקע.\n\n3.  **התעוררויות שווא (Spurious Wakeups)**:\n    *   `std::condition_variable::wait` יכול להתעורר באופן ספונטני גם ללא קריאה ל-`notify_one` או `notify_all`. לכן, חיוני להשתמש בלולאת `while` עם התנאי הרצוי (כמו `while(my_phase == current_phase && arrived_count < threshold)`) במקום `if` בלבד. ביישום הנוכחי, התנאי ב-`wait` כבר מטפל בכך: `return my_phase != current_phase;`."
    },
    "difficulty_estimation": "Hard"
  }
}