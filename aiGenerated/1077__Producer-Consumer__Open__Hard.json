{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:48:56",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3433,
      "output_tokens": 3794,
      "total_tokens": 13140
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Producer-Consumer",
      "Synchronization",
      "Semaphores",
      "Deadlock Prevention",
      "Concurrency"
    ],
    "content": {
      "text": "במפעל לייצור צעצועים קיימים שני סוגי עובדים: `Workers` ו-`Assemblers`. ה-`Workers` מייצרים שני סוגי חלקים: `PartA` ו-`PartB`. ה-`Assemblers` לוקחים חלק אחד מכל סוג (כלומר, `PartA` אחד ו-`PartB` אחד) ומרכיבים מהם `Product` יחיד.\n\nלצורך ניהול המלאי, קיימים שני בּאפרים נפרדים בגודל קבוע (`BUFFER_SIZE`): אחד עבור `PartA` ואחד עבור `PartB`. ה-`Workers` מוסיפים חלקים לבאפר המתאים, וה-`Assemblers` מוציאים חלקים מהבאפרים המתאימים.\n\nיש לממש את לוגיקת ה-`Worker` ואת לוגיקת ה-`Assembler` באמצעות ת'רדים. הפתרון צריך למנוע מצבי קיפאון (deadlock) ורעב (starvation) ולהבטיח שהייצור וההרכבה יתבצעו באופן תקין. ניתן להניח כי הסמפורים הוגנים (fair).\n\n**הגבלות:**\n1.  השתמשו בסמפורים בלבד לצורך סנכרון (אין להשתמש ב-mutexes, condition variables או פעולות אטומיות אחרות מעבר לפעולות סמפור).\n2.  הבאפרים הם באפרים מעגליים (circular buffers).\n3.  יש ליישם את הפונקציות `put_part_A`, `get_part_A`, `put_part_B`, `get_part_B` כפונקציות עזר פנימיות לניהול הבאפרים.\n\nיש לתאר בקצרה ובבירור את הפתרון ולכתוב קוד ברור.\n\n**משתנים גלובליים (יש לכתוב ערכי אתחול בהערה):**\n",
      "code_snippet": "#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // for sleep\n\n#define BUFFER_SIZE 5\n\n// Buffers and indices\nint buffer_A[BUFFER_SIZE];\nint buffer_B[BUFFER_SIZE];\nint in_A = 0, out_A = 0;\nint in_B = 0, out_B = 0;\n\n// Semaphores\n// (Student needs to declare and initialize these)\n\n// Helper functions for buffer management\nvoid put_part_A(int part) {\n    buffer_A[in_A] = part;\n    in_A = (in_A + 1) % BUFFER_SIZE;\n}\n\nint get_part_A() {\n    int part = buffer_A[out_A];\n    out_A = (out_A + 1) % BUFFER_SIZE;\n    return part;\n}\n\nvoid put_part_B(int part) {\n    buffer_B[in_B] = part;\n    in_B = (in_B + 1) % BUFFER_SIZE;\n}\n\nint get_part_B() {\n    int part = buffer_B[out_B];\n    out_B = (out_B + 1) % BUFFER_SIZE;\n    return part;\n}\n\n// Worker thread function\nvoid* worker(void* arg) {\n    // ... implement worker logic ...\n}\n\n// Assembler thread function\nvoid* assembler(void* arg) {\n    // ... implement assembler logic ...\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**תיאור הפתרון:**\nהפתרון משתמש בשני באפרים מעגליים נפרדים, אחד עבור `PartA` ואחד עבור `PartB`. כל באפר מוגן על ידי סמפורים משלו: סמפור `mutex` להגנה על גישה הדדית לבאפר עצמו, סמפור `items` לספירת פריטים זמינים בבאפר, וסמפור `slots` לספירת מקומות פנויים בבאפר.\n\n**אתחול סמפורים:**\n- `mutex_A`, `mutex_B`: סמפורי בינארי (mutex), מאותחלים ל-1. מגינים על הגישה לבאפר `A` ובאפר `B` בהתאמה.\n- `items_A`, `items_B`: סמפורי ספירה, מאותחלים ל-0. מציינים את מספר חלקי `PartA` ו-`PartB` הזמינים בבאפרים.\n- `slots_A`, `slots_B`: סמפורי ספירה, מאותחלים ל-`BUFFER_SIZE`. מציינים את מספר המקומות הפנויים בבאפרים `A` ו-`B` בהתאמה.\n\n**לוגיקת ה-`Worker`:**\nכל `Worker` מייצר באופן אקראי `PartA` או `PartB`. לפני הוספת חלק לבאפר, ה-`Worker` מבצע `sem_wait` על סמפור `slots` המתאים (כדי לוודא שיש מקום פנוי) ולאחר מכן `sem_wait` על סמפור `mutex` המתאים (כדי להבטיח גישה בלעדית לבאפר). לאחר הוספת החלק, הוא מבצע `sem_post` על ה-`mutex` ועל ה-`items` המתאים (כדי לסמן שפריט נוסף זמין).\n\n**לוגיקת ה-`Assembler`:**\nה-`Assembler` הוא הצרכן המורכב יותר, מכיוון שהוא זקוק לשני סוגי חלקים כדי לייצר `Product`. כדי למנוע מצבי קיפאון (deadlock) ורעב (starvation) כאשר `Assemblers` מרובים מנסים לצרוך משני הבאפרים, יש להקפיד על סדר קבוע ברכישת המשאבים:\n1.  **רכישת סמפורי ספירה (`items`):** ה-`Assembler` מבצע `sem_wait(&items_A)` ולאחר מכן `sem_wait(&items_B)`. סדר קבוע זה מבטיח שכל ה-`Assemblers` ינסו לרכוש את המשאבים באותו סדר, ובכך נמנע קיפאון שנובע מסדר רכישה שונה של `items_A` ו-`items_B` בין ת'רדים שונים. בשלב זה, אנו יודעים שיש לפחות `PartA` אחד ו-`PartB` אחד זמינים.\n2.  **רכישת סמפורי הגנה (`mutex`):** לאחר מכן, ה-`Assembler` מבצע `sem_wait(&mutex_A)` ולאחר מכן `sem_wait(&mutex_B)`. שוב, סדר קבוע זה מונע קיפאון שנובע מניסיונות גישה בו-זמנית לבאפרים בסדר שונה.\n3.  **הוצאת חלקים והרכבה:** בתוך הקטע הקריטי המוגן על ידי שני ה-`mutex`ים, ה-`Assembler` מוציא את ה-`PartA` ואת ה-`PartB` מהבאפרים המתאימים.\n4.  **שחרור סמפורים:** ה-`Assembler` משחרר את ה-`mutex`ים בסדר הפוך (קודם `mutex_B` ואז `mutex_A`) ולאחר מכן מבצע `sem_post` על סמפורי `slots` המתאימים (כדי לסמן שמקום פנוי נוסף בבאפרים).\n\nפונקציות העזר `put_part_A/B` ו-`get_part_A/B` מטפלות בלוגיקה של באפר מעגלי פשוט, והן אינן כוללות סנכרון בעצמן אלא מופעלות מתוך הקטעים הקריטיים המוגנים בסמפורים.",
      "code_snippet": "#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // for sleep\n\n#define BUFFER_SIZE 5\n\n// Buffers and indices\nint buffer_A[BUFFER_SIZE];\nint buffer_B[BUFFER_SIZE];\nint in_A = 0, out_A = 0;\nint in_B = 0, out_B = 0;\n\n// Semaphores\nsem_t mutex_A;    // init to 1\nsem_t mutex_B;    // init to 1\nsem_t items_A;    // init to 0\nsem_t items_B;    // init to 0\nsem_t slots_A;    // init to BUFFER_SIZE\nsem_t slots_B;    // init to BUFFER_SIZE\n\n// Helper functions for buffer management (provided in question)\nvoid put_part_A(int part) {\n    buffer_A[in_A] = part;\n    in_A = (in_A + 1) % BUFFER_SIZE;\n}\n\nint get_part_A() {\n    int part = buffer_A[out_A];\n    out_A = (out_A + 1) % BUFFER_SIZE;\n    return part;\n}\n\nvoid put_part_B(int part) {\n    buffer_B[in_B] = part;\n    in_B = (in_B + 1) % BUFFER_SIZE;\n}\n\nint get_part_B() {\n    int part = buffer_B[out_B];\n    out_B = (out_B + 1) % BUFFER_SIZE;\n    return part;\n}\n\n// Worker thread function\nvoid* worker(void* arg) {\n    int worker_id = *(int*)arg;\n    int part_counter = 0;\n    while (1) {\n        sleep(rand() % 2); // Simulate work\n        int part_type = rand() % 2; // 0 for PartA, 1 for PartB\n        part_counter++;\n\n        if (part_type == 0) { // Produce PartA\n            sem_wait(&slots_A);\n            sem_wait(&mutex_A);\n            // Critical section for buffer_A\n            put_part_A(part_counter);\n            printf(\"Worker %d produced PartA #%d. Buffer A size: %d\\n\", worker_id, part_counter, (in_A - out_A + BUFFER_SIZE) % BUFFER_SIZE);\n            sem_post(&mutex_A);\n            sem_post(&items_A);\n        } else { // Produce PartB\n            sem_wait(&slots_B);\n            sem_wait(&mutex_B);\n            // Critical section for buffer_B\n            put_part_B(part_counter);\n            printf(\"Worker %d produced PartB #%d. Buffer B size: %d\\n\", worker_id, part_counter, (in_B - out_B + BUFFER_SIZE) % BUFFER_SIZE);\n            sem_post(&mutex_B);\n            sem_post(&items_B);\n        }\n    }\n    return NULL;\n}\n\n// Assembler thread function\nvoid* assembler(void* arg) {\n    int assembler_id = *(int*)arg;\n    int product_counter = 0;\n    while (1) {\n        // Strict order for acquiring counting semaphores to prevent deadlock\n        // All assemblers must wait for items_A then items_B.\n        sem_wait(&items_A); // Wait for a PartA to be available\n        sem_wait(&items_B); // Wait for a PartB to be available\n        \n        // Now we know both are available. Acquire mutexes in strict order.\n        // All assemblers must wait for mutex_A then mutex_B.\n        sem_wait(&mutex_A);\n        sem_wait(&mutex_B); \n        \n        // Critical section for both buffers\n        int part_a = get_part_A();\n        int part_b = get_part_B();\n        \n        sem_post(&mutex_B); // Release mutexes in reverse order\n        sem_post(&mutex_A);\n        \n        sem_post(&slots_A); // Signal a slot is now free in buffer_A\n        sem_post(&slots_B); // Signal a slot is now free in buffer_B\n        \n        product_counter++;\n        printf(\"Assembler %d assembled Product #%d using PartA #%d and PartB #%d. Buffer A size: %d, Buffer B size: %d\\n\", \n               assembler_id, product_counter, part_a, part_b, (in_A - out_A + BUFFER_SIZE) % BUFFER_SIZE, (in_B - out_B + BUFFER_SIZE) % BUFFER_SIZE);\n        \n        sleep(rand() % 3); // Simulate assembly time\n    }\n    return NULL;\n}\n\n/*\n// Example main function to test (not part of the required solution output)\n#define NUM_WORKERS 3\n#define NUM_ASSEMBLERS 2\n\nint main() {\n    // Initialize semaphores\n    sem_init(&mutex_A, 0, 1);\n    sem_init(&mutex_B, 0, 1);\n    sem_init(&items_A, 0, 0);\n    sem_init(&items_B, 0, 0);\n    sem_init(&slots_A, 0, BUFFER_SIZE);\n    sem_init(&slots_B, 0, BUFFER_SIZE);\n\n    pthread_t worker_threads[NUM_WORKERS];\n    pthread_t assembler_threads[NUM_ASSEMBLERS];\n    int worker_ids[NUM_WORKERS];\n    int assembler_ids[NUM_ASSEMBLERS];\n\n    for (int i = 0; i < NUM_WORKERS; i++) {\n        worker_ids[i] = i + 1;\n        pthread_create(&worker_threads[i], NULL, worker, &worker_ids[i]);\n    }\n\n    for (int i = 0; i < NUM_ASSEMBLERS; i++) {\n        assembler_ids[i] = i + 1;\n        pthread_create(&assembler_threads[i], NULL, assembler, &assembler_ids[i]);\n    }\n\n    for (int i = 0; i < NUM_WORKERS; i++) {\n        pthread_join(worker_threads[i], NULL);\n    }\n\n    for (int i = 0; i < NUM_ASSEMBLERS; i++) {\n        pthread_join(assembler_threads[i], NULL);\n    }\n\n    // Destroy semaphores\n    sem_destroy(&mutex_A);\n    sem_destroy(&mutex_B);\n    sem_destroy(&items_A);\n    sem_destroy(&items_B);\n    sem_destroy(&slots_A);\n    sem_destroy(&slots_B);\n\n    return 0;\n}\n*/"
    },
    "difficulty_estimation": "Hard"
  }
}