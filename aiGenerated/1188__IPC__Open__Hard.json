{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:36:16",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4148,
      "output_tokens": 5210,
      "total_tokens": 22102
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Shared Memory",
      "Semaphores",
      "Synchronization"
    ],
    "content": {
      "text": "נתונה מערכת המורכבת מ-N תהליכי יצרן (Producers) ו-M תהליכי צרכן (Consumers), המשתפים ביניהם חוצץ מעגלי בגודל K פריטים (לדוגמה, מספרים שלמים). התקשורת מתבצעת באמצעות זיכרון משותף (Shared Memory) וסנכרון באמצעות סמפורי POSIX.\nתהליכי היצרן מייצרים פריטי נתונים ומכניסים אותם לחוצץ. תהליכי הצרכן קוראים את פריטי הנתונים מהחוצץ ומעבדים אותם.\n\nנדרש לתכנן מנגנון כיבוי חכם (Graceful Shutdown) למערכת, אשר יופעל על ידי אחד מתהליכי היצרן (להלן: \"היצרן המאתחל\"). לאחר שהיצרן המאתחל מסיים את ייצור הפריטים הרגילים שלו, הוא יוזם את תהליך הכיבוי.\n\nדרישות ממנגנון הכיבוי:\n1.  **עצירת יצרנים:** מרגע שהכיבוי יזום, אף יצרן אחר (שאינו היצרן המאתחל) לא יכניס יותר פריטי נתונים רגילים לחוצץ. יצרנים אלו יסיימו את עבודתם ויצאו מהמערכת.\n2.  **עיבוד נתונים קיימים:** כל פריטי הנתונים הרגילים שהיו בחוצץ או הוכנסו אליו לפני שהכיבוי יזום (על ידי היצרן המאתחל או יצרנים אחרים), חייבים להיקרא ולעבור עיבוד על ידי הצרכנים *לפני* שהצרכנים יקבלו אות כיבוי.\n3.  **הפצת אות כיבוי לצרכנים:** היצרן המאתחל חייב להבטיח שכל M תהליכי הצרכן יקבלו לבסוף \"אות כיבוי\" (לדוגמה, המספר השלם -1). אותות אלו יוזרקו לחוצץ על ידי היצרן המאתחל, ויש להבטיח שהם יוזרקו רק לאחר שכל פריטי הנתונים הרגילים שהיו בחוצץ טופלו.\n4.  **יציאת צרכנים וניקוי משאבים:** כל צרכן, לאחר שקיבל ועיבד אות כיבוי, יצא מהמערכת. הצרכן האחרון שיוצא (כלומר, כאשר כל M הצרכנים עיבדו את אות הכיבוי שלהם) אחראי על ניקוי כל משאבי ה-IPC המשותפים (זיכרון משותף, סמפורים).\n\n**יש לפרט ולנמק את התשובה באופן מלא, כולל:**\nא.  מבנה הזיכרון המשותף הנדרש (כולל משתנים גלובליים, דגלים וכו').\nב.  הגדרת הסמפורים הנדרשים ותפקידם.\nג.  פסאודו-קוד (או קוד C/C++ חלקי) המדגים את הלוגיקה המרכזית עבור:\n    1.  תהליך יצרן רגיל (שאינו היצרן המאתחל) בלולאת הייצור שלו.\n    2.  היצרן המאתחל בלולאת הייצור שלו ובתהליך הכיבוי.\n    3.  תהליך צרכן בלולאת הצריכה שלו ובתהליך הכיבוי.\nד.  הסבר מפורט כיצד כל דרישות הכיבוי מתקיימות, תוך התייחסות לפתרון בעיות סנכרון פוטנציאליות.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון מנגנון כיבוי חכם (Graceful Shutdown) במערכת יצרן-צרכן:\n\n**א. מבנה הזיכרון המשותף הנדרש (Shared Memory):**\nנשתמש במבנה נתונים משותף (לדוגמה, struct) שימופה לזיכרון משותף. הוא יכלול:\n-   `int buffer[K]`: החוצץ המעגלי לאחסון פריטים.\n-   `int in`: אינדקס הכתיבה הבא בחוצץ.\n-   `int out`: אינדקס הקריאה הבא מהחוצץ.\n-   `int num_producers_active`: מונה את מספר היצרנים הפעילים (מתחיל ב-N). משמש את היצרן המאתחל כדי לדעת מתי כל שאר היצרנים סיימו את עבודתם הרגילה.\n-   `int num_consumers_active`: מונה את מספר הצרכנים הפעילים (מתחיל ב-M). משמש לזיהוי הצרכן האחרון שאחראי על ניקוי המשאבים.\n-   `int shutdown_phase_1_initiated`: דגל בוליאני (0 או 1). כאשר 1, מאותת ליצרנים (שאינם המאתחל) להפסיק לייצר פריטים רגילים.\n-   `int shutdown_phase_2_initiated`: דגל בוליאני (0 או 1). כאשר 1, מאותת לצרכנים שהיצרן המאתחל התחיל להזרים אותות כיבוי (-1) לחוצץ.\n-   `int num_items_in_buffer`: מונה את מספר הפריטים הנוכחי בחוצץ (כולל פריטים רגילים ואותות כיבוי).\n\n**ב. הגדרת הסמפורים הנדרשים ותפקידם:**\nנשתמש בסמפורי POSIX בעלי שם (named semaphores) כדי שניתן יהיה לגשת אליהם מתהליכים שונים:\n-   `sem_t *mutex`: סמפור בינארי (מוטקס) עם ערך התחלתי 1. מגן על הגישה לזיכרון המשותף (החוצץ וכל המשתנים המשותפים) מפני תנאי מירוץ (race conditions).\n-   `sem_t *empty`: סמפור מונה (counting semaphore) עם ערך התחלתי K. מונה את מספר המקומות הריקים בחוצץ. יצרנים מבצעים עליו `sem_wait` לפני כתיבה, וצרכנים מבצעים עליו `sem_post` לאחר קריאה.\n-   `sem_t *full`: סמפור מונה עם ערך התחלתי 0. מונה את מספר המקומות המלאים בחוצץ. צרכנים מבצעים עליו `sem_wait` לפני קריאה, ויצרנים מבצעים עליו `sem_post` לאחר כתיבה.\n-   `sem_t *producer_done_sem`: סמפור מונה עם ערך התחלתי 0. כל יצרן (שאינו המאתחל) מבצע עליו `sem_post` כשהוא מסיים את לולאת הייצור הרגילה שלו. היצרן המאתחל מבצע עליו `sem_wait` בסך הכל N-1 פעמים כדי לוודא שכל שאר היצרנים סיימו את עבודתם הרגילה לפני שהוא ממשיך לשלב הבא בכיבוי.\n\n**ג. פסאודו-קוד (או קוד C/C++ חלקי):**\n\n**1. תהליך יצרן רגיל (Standard Producer):**\n```c\nvoid standard_producer_func(SharedData* shm_data) {\n    // ... הגדרת סמפורים וחיבור לזיכרון משותף ...\n\n    while (true) {\n        // בדיקה לדגל כיבוי לפני ניסיון לייצר פריט חדש\n        sem_wait(shm_data->mutex);\n        if (shm_data->shutdown_phase_1_initiated) {\n            sem_post(shm_data->mutex);\n            break; // יציאה מלולאת הייצור הרגילה\n        }\n        sem_post(shm_data->mutex);\n\n        // ייצור פריט\n        int item = generate_item(); \n\n        sem_wait(shm_data->empty); // המתן למקום פנוי בחוצץ\n        sem_wait(shm_data->mutex); // נעילת הגישה לזיכרון המשותף\n        shm_data->buffer[shm_data->in] = item;\n        shm_data->in = (shm_data->in + 1) % K;\n        shm_data->num_items_in_buffer++; // עדכון מונה פריטים בחוצץ\n        sem_post(shm_data->mutex); // שחרור נעילה\n        sem_post(shm_data->full);  // איתות על מקום מלא\n\n        // ... עיכוב קצר או עבודה אחרת ...\n    }\n\n    // לאחר סיום לולאת הייצור, עדכון מונה היצרנים הפעילים ואיתות ליצרן המאתחל\n    sem_wait(shm_data->mutex);\n    shm_data->num_producers_active--;\n    sem_post(shm_data->mutex);\n    sem_post(shm_data->producer_done_sem); // איתות ליצרן המאתחל שסיימתי\n\n    // ... ניקוי משאבים ספציפיים לתהליך ...\n}\n```\n\n**2. היצרן המאתחל (Initiator Producer):**\n```c\nvoid initiator_producer_func(SharedData* shm_data) {\n    // ... הגדרת סמפורים וחיבור לזיכרון משותף ...\n\n    // שלב 1: ייצור פריטים רגילים משלו\n    while (my_items_to_produce > 0) {\n        // ... (אותה לוגיקת ייצור כמו יצרן רגיל) ...\n        int item = generate_item();\n        sem_wait(shm_data->empty);\n        sem_wait(shm_data->mutex);\n        shm_data->buffer[shm_data->in] = item;\n        shm_data->in = (shm_data->in + 1) % K;\n        shm_data->num_items_in_buffer++;\n        sem_post(shm_data->mutex);\n        sem_post(shm_data->full);\n        my_items_to_produce--;\n    }\n\n    // שלב 2: יזום כיבוי - עצירת יצרנים אחרים\n    sem_wait(shm_data->mutex);\n    shm_data->shutdown_phase_1_initiated = 1; // הגדרת דגל לעצירת יצרנים אחרים\n    sem_post(shm_data->mutex);\n\n    // המתן לכל N-1 היצרנים האחרים שיסיימו את עבודתם הרגילה\n    for (int i = 0; i < N - 1; ++i) {\n        sem_wait(shm_data->producer_done_sem);\n    }\n\n    // בשלב זה, כל היצרנים סיימו לייצר פריטים רגילים.\n    // כעת המתן עד שהחוצץ יתרוקן מכל הפריטים הרגילים שנותרו בו.\n    while (true) {\n        sem_wait(shm_data->mutex);\n        if (shm_data->num_items_in_buffer == 0) { // בדיקה שהחוצץ ריק\n            sem_post(shm_data->mutex);\n            break;\n        }\n        sem_post(shm_data->mutex);\n        usleep(10000); // המתן קצר כדי לא לבצע busy-waiting\n    }\n\n    // שלב 3: הזרקת אותות כיבוי (-1) לחוצץ עבור הצרכנים\n    sem_wait(shm_data->mutex);\n    shm_data->shutdown_phase_2_initiated = 1; // איתות לצרכנים לצפות לאותות כיבוי\n    sem_post(shm_data->mutex);\n\n    for (int i = 0; i < M; ++i) {\n        sem_wait(shm_data->empty); // המתן למקום פנוי, ייתכן שייחסם אם הצרכנים איטיים\n        sem_wait(shm_data->mutex);\n        shm_data->buffer[shm_data->in] = -1; // הזרקת אות כיבוי\n        shm_data->in = (shm_data->in + 1) % K;\n        shm_data->num_items_in_buffer++; // עדכון מונה פריטים (כולל אותות כיבוי)\n        sem_post(shm_data->mutex);\n        sem_post(shm_data->full);\n    }\n\n    // שלב 4: היצרן המאתחל גם מסיים את עבודתו\n    sem_wait(shm_data->mutex);\n    shm_data->num_producers_active--;\n    sem_post(shm_data->mutex);\n\n    // ... ניקוי משאבים ספציפיים לתהליך ...\n}\n```\n\n**3. תהליך צרכן (Consumer):**\n```c\nvoid consumer_func(SharedData* shm_data) {\n    // ... הגדרת סמפורים וחיבור לזיכרון משותף ...\n\n    while (true) {\n        sem_wait(shm_data->full);  // המתן לפריט זמין בחוצץ\n        sem_wait(shm_data->mutex); // נעילת הגישה לזיכרון המשותף\n        int item = shm_data->buffer[shm_data->out];\n        shm_data->out = (shm_data->out + 1) % K;\n        shm_data->num_items_in_buffer--; // עדכון מונה פריטים\n        sem_post(shm_data->mutex); // שחרור נעילה\n        sem_post(shm_data->empty); // איתות על מקום פנוי\n\n        if (item == -1) {\n            // פריט זה הוא אות כיבוי. \n            // בגלל הלוגיקה של היצרן המאתחל, אנו יודעים ש- (-1) יוזרק רק לאחר שכל הפריטים הרגילים עובדו.\n            sem_wait(shm_data->mutex);\n            shm_data->num_consumers_active--;\n            int remaining_consumers = shm_data->num_consumers_active;\n            sem_post(shm_data->mutex);\n\n            if (remaining_consumers == 0) {\n                // זהו הצרכן האחרון. עליו לנקות את משאבי ה-IPC המשותפים.\n                // ... סגירת וניתוק זיכרון משותף, סגירת ומחיקת סמפורים ...\n            }\n            break; // יציאה מלולאת הצריכה\n        }\n\n        // עיבוד פריט רגיל\n        process_item(item);\n\n        // ... עיכוב קצר או עבודה אחרת ...\n    }\n\n    // ... ניקוי משאבים ספציפיים לתהליך ...\n}\n```\n\n**ד. הסבר מפורט כיצד כל דרישות הכיבוי מתקיימות, תוך התייחסות לפתרון בעיות סנכרון פוטנציאליות:**\n\n1.  **עצירת יצרנים (דרישה 1):**\n    -   הדגל `shutdown_phase_1_initiated` בזיכרון המשותף משמש לאותת ליצרנים האחרים להפסיק לייצר. כל יצרן בודק דגל זה בתוך אזור קריטי המוגן על ידי ה-`mutex` (לפני ניסיון `sem_wait(empty)`). אם הדגל מוגדר, היצרן יוצא מלולאת הייצור שלו.\n    -   היצרן המאתחל ממתין לכל N-1 היצרנים האחרים באמצעות `sem_wait` על הסמפור `producer_done_sem`. כל יצרן, לאחר שסיים את לולאת הייצור שלו (אפילו אם הפסיק עקב דגל הכיבוי), מבצע `sem_post` על `producer_done_sem` לפני יציאתו. זה מבטיח שהיצרן המאתחל לא ימשיך לשלב הבא לפני שכל היצרנים האחרים סיימו את החלק הראשון של הכיבוי.\n    -   **פתרון בעיות סנכרון:** הבדיקה של `shutdown_phase_1_initiated` לפני `sem_wait(empty)` ובתוך אזור קריטי מונעת מצב שבו יצרן ייחסם על `empty` בעוד שהכיבוי כבר יזום, ובכך מונע מצב של תקיעות.\n\n2.  **עיבוד נתונים קיימים (דרישה 2):**\n    -   לאחר שהיצרן המאתחל מוודא שכל שאר היצרנים סיימו לייצר פריטים רגילים (באמצעות `producer_done_sem`), הוא ממתין באופן פעיל (אך עם השהייה קצרה באמצעות `usleep`) עד שמונה הפריטים בחוצץ `num_items_in_buffer` יגיע ל-0. זה מבטיח שכל הפריטים הרגילים שהוכנסו לחוצץ עד כה (כולל אלו שהוכנסו על ידי היצרן המאתחל עצמו ואחרים) נצרכו על ידי הצרכנים.\n    -   רק לאחר שהחוצץ ריק מפריטים רגילים, היצרן המאתחל ממשיך לשלב הבא.\n    -   **פתרון בעיות סנכרון:** ההמתנה לריקון מוחלט של החuצץ לפני הזרקת אותות הכיבוי מבטיחה שדרישה זו מתקיימת. אין חשש שאות כיבוי יגיע לצרכן לפני שכל הנתונים הרגילים לפניו עובדו, מכיוון שאותות הכיבוי מוזרקים רק לחוצץ ריק מנתונים רגילים.\n\n3.  **הפצת אות כיבוי לצרכנים (דרישה 3):**\n    -   לאחר שהחוצץ התרוקן מפריטים רגילים, היצרן המאתחל מגדיר את הדגל `shutdown_phase_2_initiated` (כדי לסמן לצרכנים שאותות -1 הם אכן אותות כיבוי ולא נתונים רגילים). לאחר מכן, הוא מזריק M פעמים את הערך -1 (אות הכיבוי) לחוצץ.\n    -   הזרקה זו מתבצעת תוך שימוש בלוגיקת הייצור הרגילה (`sem_wait(empty)`, `sem_wait(mutex)`, כתיבה, `sem_post(mutex)`, `sem_post(full)`). אם הצרכנים איטיים, היצרן המאתחל יחסם על `empty` עד שיתפנה מקום, אך בסופו של דבר כל אותות הכיבוי יגיעו לחוצץ.\n    -   **פתרון בעיות סנכרון:** הזרקת M אותות כיבוי מבטיחה שכל M הצרכנים יקבלו אות כיבוי משלהם. העובדה שהזרקה זו מתבצעת רק לאחר שהחוצץ ריק מנתונים רגילים פותרת את בעיית הסדר.\n\n4.  **יציאת צרכנים וניקוי משאבים (דרישה 4):**\n    -   כל צרכן, כאשר הוא קורא פריט -1 מהחוצץ (ומוודא ש-`shutdown_phase_2_initiated` מוגדר), מבין שזהו אות כיבוי. הוא מעדכן את המונה המשותף `num_consumers_active` (בתוך אזור קריטי) ומפסיק את לולאת הצריכה שלו.\n    -   הצרכן האחרון שמוריד את `num_consumers_active` ל-0 מזהה את עצמו כאחראי על ניקוי כל משאבי ה-IPC המשותפים (זיכרון משותף, סמפורים).\n    -   **פתרון בעיות סנכרון:** השימוש במונה `num_consumers_active` המוגן על ידי מוטקס מבטיח זיהוי מדויק של הצרכן האחרון. ניקוי המשאבים על ידי הצרכן האחרון מונע מצב של דליפת משאבים (resource leak) או ניסיון גישה למשאבים שכבר נוקו, מכיוון שכל התהליכים האחרים כבר יצאו או עומדים לצאת."
    },
    "difficulty_estimation": "Hard"
  }
}