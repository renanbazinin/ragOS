{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 19:57:10",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3383,
      "output_tokens": 3606,
      "total_tokens": 14990
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Deadlocks",
      "Resource Management",
      "Banker's Algorithm",
      "Priority Scheduling"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המנהלת משאבים באמצעות אלגוריתם הבנקאי (Banker's Algorithm) למניעת קיפאון, ומשתמשת במתזמן קדימויות (Preemptive Priority Scheduler) עבור תהליכים. במערכת קיימים 3 תהליכים (P0, P1, P2) ו-2 סוגי משאבים (R0, R1). מצב המערכת הנוכחי נתון בטבלאות הבאות:\n\n**Available (משאבים זמינים):**\n[2, 1]\n\n**Allocation (משאבים שהוקצו):**\n| תהליך | R0 | R1 |\n|---|----|----|\n| P0  | 0  | 0  |\n| P1  | 1  | 0  |\n| P2  | 0  | 1  |\n\n**Max (דרישה מקסימלית למשאבים):**\n| תהליך | R0 | R1 |\n|---|----|----|\n| P0  | 2  | 1  |\n| P1  | 1  | 1  |\n| P2  | 1  | 1  |\n\n**הערה**: תהליך P0 בעל קדימות גבוהה יותר מ-P1, ו-P1 בעל קדימות גבוהה יותר מ-P2 (כלומר: P0 > P1 > P2).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "a",
        "text": "האם המצב ההתחלתי של המערכת בטוח? אם כן, ספק רצף בטוח אפשרי אחד.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "b",
        "text": "תהליך P1 מבקש כעת את המשאבים [0, 1]. האם ניתן לאשר את הבקשה באופן מיידי? נמק והצג את החישובים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "c",
        "text": "דון באתגרים ובבעיות פוטנציאליות העולות משילוב אלגוריתם הבנקאי עם מתזמן קדימויות פרסמפטיבי, במיוחד כאשר תהליך בעל קדימות גבוהה ממתין למשאב המוחזק על ידי תהליך בעל קדימות נמוכה יותר. כיצד מערכת הפעלה יכולה להתמודד עם אתגרים אלו?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 25,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "ראשית, נחשב את מטריצת ה-Need (דרישה נוספת) עבור המצב ההתחלתי:\nNeed = Max - Allocation\n\n**Need:**\n| תהליך | R0 | R1 |\n|---|----|----|\n| P0  | 2  | 1  |\n| P1  | 0  | 1  |\n| P2  | 1  | 0  |\n\n**סעיף א': האם המצב ההתחלתי בטוח?**\nנבצע את אלגוריתם בטיחות:\nWork = Available = [2, 1]\nFinish = [False, False, False]\n\n1.  **בדיקה עבור P0:** Need[0] = [2, 1]. Work = [2, 1]. Need[0] <= Work. כן.\n    נניח P0 יסיים. Work = Work + Allocation[0] = [2, 1] + [0, 0] = [2, 1]. Finish[0] = True.\n    (רצף ביניים: <P0>)\n2.  **בדיקה עבור P1:** Need[1] = [0, 1]. Work = [2, 1]. Need[1] <= Work. כן.\n    נניח P1 יסיים. Work = Work + Allocation[1] = [2, 1] + [1, 0] = [3, 1]. Finish[1] = True.\n    (רצף ביניים: <P0, P1>)\n3.  **בדיקה עבור P2:** Need[2] = [1, 0]. Work = [3, 1]. Need[2] <= Work. כן.\n    נניח P2 יסיים. Work = Work + Allocation[2] = [3, 1] + [0, 1] = [3, 2]. Finish[2] = True.\n    (רצף סופי: <P0, P1, P2>)\n\nמכיוון שמצאנו רצף בטוח (לדוגמה: <P0, P1, P2>), המצב ההתחלתי **בטוח**.\n\n**סעיף ב': תהליך P1 מבקש כעת את המשאבים [0, 1]. האם ניתן לאשר את הבקשה באופן מיידי?**\nבקשת P1 היא Request = [0, 1].\n\n1.  **בדיקת תקינות הבקשה:**\n    *   האם Request <= Need[1]? [0, 1] <= [0, 1]. כן, הבקשה קטנה או שווה לדרישה הנוספת של P1.\n    *   האם Request <= Available? [0, 1] <= [2, 1]. כן, הבקשה קטנה או שווה למשאבים הזמינים.\n\n2.  **בדיקת בטיחות המצב לאחר הקצאה זמנית:**\n    נניח שהבקשה מאושרת באופן זמני:\n    *   Available' = Available - Request = [2, 1] - [0, 1] = [2, 0]\n    *   Allocation'[1] = Allocation[1] + Request = [1, 0] + [0, 1] = [1, 1]\n    *   Need'[1] = Need[1] - Request = [0, 1] - [0, 1] = [0, 0]\n\n    המצב החדש:\n    **Available':** [2, 0]\n    **Allocation':**\n    | תהליך | R0 | R1 |\n    |---|----|----|\n    | P0  | 0  | 0  |\n    | P1  | 1  | 1  |\n    | P2  | 0  | 1  |\n    **Need':**\n    | תהליך | R0 | R1 |\n    |---|----|----|\n    | P0  | 2  | 1  |\n    | P1  | 0  | 0  |\n    | P2  | 1  | 0  |\n\n    נבצע שוב את אלגוריתם הבטיחות עבור המצב החדש:\n    Work = Available' = [2, 0]\n    Finish = [False, False, False]\n\n    1.  **בדיקה עבור P0:** Need'[0] = [2, 1]. Work = [2, 0]. Need'[0] <= Work. לא.\n    2.  **בדיקה עבור P1:** Need'[1] = [0, 0]. Work = [2, 0]. Need'[1] <= Work. כן.\n        נניח P1 יסיים. Work = Work + Allocation'[1] = [2, 0] + [1, 1] = [3, 1]. Finish[1] = True.\n        (רצף ביניים: <P1>)\n    3.  **בדיקה עבור P2:** Need'[2] = [1, 0]. Work = [3, 1]. Need'[2] <= Work. כן.\n        נניח P2 יסיים. Work = Work + Allocation'[2] = [3, 1] + [0, 1] = [3, 2]. Finish[2] = True.\n        (רצף ביניים: <P1, P2>)\n    4.  **בדיקה עבור P0 (שוב):** Need'[0] = [2, 1]. Work = [3, 2]. Need'[0] <= Work. כן.\n        נניח P0 יסיים. Work = Work + Allocation'[0] = [3, 2] + [0, 0] = [3, 2]. Finish[0] = True.\n        (רצף סופי: <P1, P2, P0>)\n\n    מכיוון שהמצב החדש בטוח, **ניתן לאשר את הבקשה** של P1 באופן מיידי.\n\n**סעיף ג': אתגרים בשילוב אלגוריתם הבנקאי עם מתזמן קדימויות פרסמפטיבי**\nשילוב אלגוריתם הבנקאי, המיועד למנוע קיפאון על ידי הבטחת מצב בטוח, עם מתזמן קדימויות פרסמפטיבי, המיועד להבטיח שתהליכים בעלי קדימות גבוהה יקבלו זמן מעבד, יכול להוביל למספר אתגרים ובעיות פוטנציאליות:\n\n1.  **היפוך קדימויות (Priority Inversion):** זוהי הבעיה המרכזית. אם תהליך בעל קדימות גבוהה (לדוגמה P0) מנסה לגשת למשאב (לדוגמה R0) שמוחזק על ידי תהליך בעל קדימות נמוכה יותר (לדוגמה P1 או P2), התהליך בעל הקדימות הגבוהה ייחסם. המתזמן הפרסמפטיבי ימנע מתהליכים בעלי קדימות נמוכה יותר (כמו P1 או P2) לרוץ, כל עוד P0 מוכן לריצה. עם זאת, P0 חסום על המשאב המוחזק על ידי P1/P2. התוצאה היא ש-P1/P2 לא ירוץ כדי לשחרר את המשאב, ו-P0 לא יוכל להתקדם, למרות קדימותו הגבוהה. זה יכול לגרום לשיהוי בלתי צפוי וארוך לתהליכים קריטיים.\n\n2.  **הרעבת תהליכים (Starvation):** אלגוריתם הבנקאי מבטיח קיום של רצף בטוח, אך אינו מבטיח שכל תהליך יסיים בזמן סביר או יקבל את המשאבים הנדרשים לו. ייתכן שתהליך בעל קדימות נמוכה יבקש משאבים, והבנקאי יקבע שהקצאתם תוביל למצב לא בטוח (או שהיא תמנע מתהליכים אחרים לסיים, גם אם המצב טכנית בטוח). אם בקשותיו נדחות שוב ושוב לטובת תהליכים בעלי קדימות גבוהה יותר, הוא עלול להיכנס למצב של הרעבה, כלומר לעולם לא יקבל מספיק משאבים כדי לסיים.\n\n3.  **התנגשות בין מדיניות אופטימלית:** הבנקאי שואף למקסם את ניצול המשאבים תוך שמירה על בטיחות, בעוד שמתזמן הקדימויות שואף למקסם את התגובה עבור תהליכים חשובים. במקרים מסוימים, החלטה שמונעת קיפאון יכולה להאט תהליך בעל קדימות גבוהה, ולהפך – קידום תהליך בעל קדימות גבוהה יכול להוביל למצב שבו הבנקאי אינו יכול למצוא רצף בטוח.\n\n**כיצד מערכת הפעלה יכולה להתמודד עם אתגרים אלו?**\n\n1.  **פרוטוקולי ירושת קדימויות (Priority Inheritance Protocol):** כאשר תהליך בעל קדימות גבוהה נחסם על משאב המוחזק על ידי תהליך בעל קדימות נמוכה, התהליך בעל הקדימות הנמוכה מקבל באופן זמני את הקדימות של התהליך החוסם. זה מאפשר לתהליך בעל הקדימות הנמוכה לרוץ, לשחרר את המשאב, ובכך לאפשר לתהליך בעל הקדימות הגבוהה להמשיך. לאחר שחרור המשאב, קדימותו של התהליך הנמוך חוזרת למצבה המקורי. זה פותר את בעיית היפוך הקדימויות.\n\n2.  **פרוטוקולי תקרת קדימויות (Priority Ceiling Protocol):** פרוטוקול זה מונע היפוך קדימויות מלכתחילה. כאשר תהליך מבקש משאב, קדימותו מוגבהת לקדימות הגבוהה ביותר של כל תהליך אחר שעלול לבקש את אותו משאב. זה מבטיח שאם תהליך בעל קדימות נמוכה מחזיק משאב, אף תהליך בעל קדימות גבוהה יותר שזקוק לאותו משאב לא יוכל להיחסם על ידו. למעשה, זה מבטיח שתהליך יוכל להיכנס לקטע קריטי רק אם אף תהליך בעל קדימות גבוהה ממנו לא יכול להיחסם על ידיו.\n\n3.  **שילוב מודע של מדיניות:** מערכת ההפעלה צריכה לשלב את אלגוריתם הבנקאי עם מדיניות המתזמן באופן מודע. לדוגמה, בעת קבלת החלטת הקצאת משאבים, הבנקאי יכול לקחת בחשבון לא רק את הבטיחות אלא גם את הקדימויות. ייתכן שבקשה ממשאב בעל קדימות נמוכה תידחה, גם אם המצב נשאר בטוח, אם הקצאתה תפגע באופן משמעותי ביכולת של תהליך בעל קדימות גבוהה להתקדם.\n\n4.  **הזדקנות (Aging):** כדי למנוע הרעבה, ניתן ליישם מנגנון הזדקנות שמעלה בהדרגה את הקדימות של תהליכים שממתינים זמן רב למשאבים או לזמן מעבד. זה יבטיח שבסופו של דבר, גם תהליכים בעלי קדימות נמוכה יקבלו הזדמנות לרוץ ולסיים."
    },
    "difficulty_estimation": "Hard"
  }
}