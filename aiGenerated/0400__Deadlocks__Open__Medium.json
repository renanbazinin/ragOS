{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 21:17:45",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3559,
      "output_tokens": 1664,
      "total_tokens": 9340
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Deadlocks",
      "Resource Allocation",
      "Deadlock Prevention"
    ],
    "content": {
      "text": "מערכת הפעלה מנהלת שלושה סוגי משאבים: A, B ו-C. לכל סוג משאב יש מספר מופעים קבוע (לדוגמה: 2 מופעי A, 2 מופעי B, 2 מופעי C). במערכת רצים מספר תהליכים. כל תהליך דורש שני סוגי משאבים שונים כדי להשלים את משימתו. לדוגמה, תהליך P1 זקוק למופע אחד מ-A ומופע אחד מ-B, תהליך P2 זקוק למופע אחד מ-B ומופע אחד מ-C, וכך הלאה.\n\nא. תארו מצב שבו יכול להתרחש קיפאון (deadlock) במערכת כזו. ציינו אילו מהתנאים ההכרחיים לקיפאון (mutual exclusion, hold and wait, no preemption, circular wait) מתקיימים במצב שתיארתם.\nב. הציעו אסטרטגיה למניעת קיפאון במערכת זו. הסבירו כיצד האסטרטגיה שהצעתם שוברת לפחות אחד מהתנאים ההכרחיים לקיפאון.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "חלק א': תיאור מצב קיפאון ותנאים\nנניח שיש לנו 2 מופעים מכל סוג משאב (A, B, C) ושלושה תהליכים: P1, P2, P3.\n*   P1 זקוק למופע אחד מ-A ומופע אחד מ-B.\n*   P2 זקוק למופע אחד מ-B ומופע אחד מ-C.\n*   P3 זקוק למופע אחד מ-C ומופע אחד מ-A.\n\nמצב קיפאון אפשרי:\n1.  P1 רוכש מופע אחד של A.\n2.  P2 רוכש מופע אחד של B.\n3.  P3 רוכש מופע אחד של C.\n\nבשלב זה:\n*   P1 מחזיק ב-A וממתין ל-B.\n*   P2 מחזיק ב-B וממתין ל-C.\n*   P3 מחזיק ב-C וממתין ל-A.\n\nכל תהליך מחזיק במשאב אחד וממתין למשאב אחר שמוחזק על ידי תהליך אחר, ונוצר מעגל המתנה. אף תהליך לא יכול להמשיך, וזהו מצב קיפאון.\n\nהתנאים ההכרחיים לקיפאון המתקיימים במצב זה:\n*   **Mutual Exclusion (מניעה הדדית):** מתקיים. משאבים ניתנים לשימוש בלעדי (מופע של משאב יכול להיות מוחזק רק על ידי תהליך אחד). \n*   **Hold and Wait (החזק והמתן):** מתקיים. כל תהליך מחזיק במשאב אחד (לדוגמה, P1 מחזיק ב-A) וממתין למשאב נוסף (P1 ממתין ל-B) שמוחזק על ידי תהליך אחר.\n*   **No Preemption (אי-הפקעה):** מתקיים. לא ניתן להפקיע משאבים מתהליך שמחזיק בהם בכוח; התהליך חייב לשחרר אותם מרצונו.\n*   **Circular Wait (המתנה מעגלית):** מתקיים. P1 ממתין למשאב שמוחזק על ידי P2, P2 ממתין למשאב שמוחזק על ידי P3, ו-P3 ממתין למשאב שמוחזק על ידי P1. נוצר מעגל סגור של המתנה.\n\nחלק ב': אסטרטגיה למניעת קיפאון\nאחת האסטרטגיות למניעת קיפאון היא לשבור את תנאי **המתנה מעגלית (Circular Wait)** באמצעות **היררכיה של משאבים (Resource Ordering)**.\n\n**תיאור האסטרטגיה:**\nנקצה סדר מספרי גלובלי לכל סוג משאב. לדוגמה: A=1, B=2, C=3. כל תהליך במערכת חייב לבקש משאבים בסדר עולה בלבד. כלומר, אם תהליך זקוק למשאבים מסוג R_i ו-R_j, והמספר הסידורי של R_i קטן מהמספר הסידורי של R_j, אזי התהליך חייב לבקש את R_i לפני R_j.\n\n**הסבר כיצד האסטרטגיה שוברת את תנאי Circular Wait:**\nעם היררכיה של משאבים, לא ייתכן שיתקיים מעגל המתנה. נניח שקיימת שרשרת המתנה מעגלית: P1 ממתין למשאב שמוחזק על ידי P2, P2 ממתין למשאב שמוחזק על ידי P3, ..., Pn ממתין למשאב שמוחזק על ידי P1. אם כל תהליך חייב לבקש משאבים בסדר עולה, אז:\n*   המשאב ש-P1 ממתין לו (שמוחזק על ידי P2) חייב להיות בעל מספר סידורי גבוה יותר מהמשאב ש-P1 מחזיק בו.\n*   המשאב ש-P2 ממתין לו (שמוחזק על ידי P3) חייב להיות בעל מספר סידורי גבוה יותר מהמשאב ש-P2 מחזיק בו.\n*   וכך הלאה, עד Pn.\n\nאם Pn ממתין למשאב שמוחזק על ידי P1, אז המשאב ש-Pn ממתין לו חייב להיות בעל מספר סידורי גבוה יותר מהמשאב ש-Pn מחזיק בו. אך זה אומר שהמשאב ש-P1 מחזיק בו יהיה בעל מספר סידורי גבוה יותר מהמשאב ש-Pn מחזיק בו. בסופו של דבר, אם נלך לאורך המעגל, המשאב הראשון בשרשרת יהיה בעל מספר סידורי גבוה יותר מעצמו, וזו סתירה. לכן, לא ניתן ליצור מעגל המתנה כאשר משאבים נרכשים בסדר היררכי עולה, ובכך נשבר תנאי ה-Circular Wait."
    },
    "difficulty_estimation": "Medium"
  }
}