{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Concurrency and Condition Variables",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 11:41:33",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3819,
      "output_tokens": 3462,
      "total_tokens": 27519
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Concurrency",
      "Condition Variables",
      "Synchronization",
      "Producer-Consumer",
      "Priority"
    ],
    "content": {
      "text": "נתון קטע קוד המממש חיץ חסום (bounded buffer) עבור משימות. לכל משימה יש מזהה מספרי (int id). קיימים מספר מפיקים וצרכנים. הדרישה המיוחדת היא כדלקמן: צרכן חייב תמיד לצרוך משימה בעלת מזהה זוגי, *אם קיימת כזו בחיץ*. רק אם אין בחיץ אף משימה בעלת מזהה זוגי, רשאי הצרכן לצרוך משימה בעלת מזהה אי-זוגי.\n\nנתחו את קטע הקוד הנתון, מצאו את כל הבעיות הקשורות לתיאום (Synchronization) – כולל תנאי מירוץ (race conditions), קיפאון (deadlock), או הרעבה (starvation) – והסבירו אותן. לאחר מכן, תקנו את הקוד כך שיעמוד בדרישות המערכת באופן נכון ויעיל.",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define BUFFER_CAPACITY 5\n\ntypedef struct {\n    int id;\n    // Other task data...\n} Task;\n\nTask buffer[BUFFER_CAPACITY];\nint count = 0;\nint head = 0; // Index for consumption\nint tail = 0; // Index for production\nint even_tasks_count = 0; // Number of tasks with even IDs in the buffer\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond_not_full = PTHREAD_COND_INITIALIZER;\npthread_cond_t cond_not_empty = PTHREAD_COND_INITIALIZER; // Single condition variable for consumers\n\nvoid produce(Task t) {\n    pthread_mutex_lock(&mutex);\n    while (count == BUFFER_CAPACITY) {\n        pthread_cond_wait(&cond_not_full, &mutex);\n    }\n\n    buffer[tail] = t;\n    tail = (tail + 1) % BUFFER_CAPACITY;\n    count++;\n    if (t.id % 2 == 0) {\n        even_tasks_count++;\n    }\n    pthread_cond_signal(&cond_not_empty); // Flaw: Using signal instead of broadcast\n    pthread_mutex_unlock(&mutex);\n}\n\nTask consume() {\n    pthread_mutex_lock(&mutex);\n    while (count == 0) { // Flaw: Incomplete predicate, doesn't consider priority\n        pthread_cond_wait(&cond_not_empty, &mutex);\n    }\n\n    Task consumed_task;\n    int task_idx_to_remove = -1;\n\n    if (even_tasks_count > 0) {\n        // Find an even task (inefficient linear scan)\n        for (int i = 0; i < count; i++) {\n            int current_idx = (head + i) % BUFFER_CAPACITY;\n            if (buffer[current_idx].id % 2 == 0) {\n                task_idx_to_remove = current_idx;\n                break;\n            }\n        }\n        // This case should ideally not happen if even_tasks_count is accurate,\n        // but indicates a potential logic error or race if it does.\n        if (task_idx_to_remove == -1) {\n            // Fallback to consuming odd if even_tasks_count was wrong or race occurred.\n            // This violates priority rule if a true even task exists elsewhere.\n            task_idx_to_remove = head; // Take from head as a fallback\n        }\n    } else { // No even tasks, take any (from head)\n        task_idx_to_remove = head;\n    }\n\n    consumed_task = buffer[task_idx_to_remove];\n\n    // Flaw: Inefficient and potentially incorrect element shifting for circular buffer\n    if (task_idx_to_remove != head) {\n        // Shift elements to fill the gap. Highly inefficient (O(N)).\n        // This also complicates head/tail management.\n        for (int i = task_idx_to_remove; i != head; i = (i - 1 + BUFFER_CAPACITY) % BUFFER_CAPACITY) {\n            buffer[i] = buffer[(i - 1 + BUFFER_CAPACITY) % BUFFER_CAPACITY];\n        }\n        head = (head + 1) % BUFFER_CAPACITY; // This head adjustment is likely wrong after shift\n    } else {\n        head = (head + 1) % BUFFER_CAPACITY;\n    }\n\n    count--;\n    if (consumed_task.id % 2 == 0) {\n        even_tasks_count--;\n    }\n\n    pthread_cond_signal(&cond_not_full); // Flaw: Using signal instead of broadcast\n    pthread_mutex_unlock(&mutex);\n    return consumed_task;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "ניתוח הבעיות בקוד המקורי:\n1.  **תנאי המתנה שגוי ב-`consume` והרעבה**: הצרכן ממתין רק כאשר החיץ ריק לחלוטין (`count == 0`). הוא אינו לוקח בחשבון את דרישת העדיפות למשימות זוגיות. אם יש משימות בחיץ אך כולן אי-זוגיות (`count > 0` ו-`even_tasks_count == 0`), וקיימים צרכנים שממתינים למשימה זוגית (או כאלו שחייבים לקחת זוגית אם קיימת), הם יתעוררו, יגלו שאין משימה זוגית זמינה (עבורם), ויצטרכו לצרוך משימה אי-זוגית (בניגוד לדרישה אם קיימת משימה זוגית שצרכן אחר יכול לקחת), או להמתין שוב. זה עלול לגרום להרעבה של משימות זוגיות אם צרכנים יבחרו באופן שגוי משימות אי-זוגיות, או להרעבה של צרכנים הממתינים לזוגיות אם ימשיכו להמתין ללא תנאי נכון. הקוד גם לא מטפל במקרה שבו `even_tasks_count > 0` אך הצרכן לא מוצא משימה זוגית (בגלל שגיאת לוגיקה או תנאי מירוץ), ובמקום להמתין הוא נופל ללקיחת משימה אי-זוגית.\n2.  **שימוש ב-`pthread_cond_signal` במקום `pthread_cond_broadcast`**: \n    *   בפונקציה `produce`: כאשר משימה מיוצרת, `signal` מעירה רק חוט אחד מבין אלו הממתינים על `cond_not_empty`. אם מספר צרכנים ממתינים למשימות (כולל צרכנים המעדיפים משימות זוגיות), והגיעה משימה זוגית, ייתכן שהחוט שהתעורר לא יהיה זה שצריך לצרוך אותה (למשל, אם הוא צרכן שמעדיף משימות אי-זוגיות), או אם יש לו זמן תגובה איטית. שימוש ב-`broadcast` מבטיח שכל החוטים הממתינים יתעוררו ויבדקו מחדש את התנאי שלהם, ובכך מגדיל את הסיכוי שהחוט הנכון יפעל ומונע הרעבה.\n    *   בפונקציה `consume`: כנ\"ל לגבי מפיקים הממתינים על `cond_not_full`. אם מספר מפיקים חסומים, וחיץ התפנה, `signal` מעירה רק אחד. `broadcast` בטוח יותר.\n3.  **ניהול חיץ לא יעיל ושגוי למשימות בעדיפות**: \n    *   החיפוש הלינארי אחר משימה זוגית (`for (int i = 0; i < count; i++)`) הוא לא יעיל (סיבוכיות O(N)).\n    *   ההזזה של איברים בחיץ (`for (int i = task_idx_to_remove; i != head; i = (i - 1 + BUFFER_CAPACITY) % BUFFER_CAPACITY)`) לאחר מציאת משימה זוגית שאינה בראש החיץ, היא פעולה יקרה מאוד ולא מתאימה לחיץ מעגלי (סיבוכיות O(N) לכל צריכה). היא פוגעת קשות בביצועים ואף עלולה להכניס שגיאות לוגיות בניהול ה-`head` וה-`tail` אם לא מטופלת בקפידה רבה. חיץ מעגלי מיועד להכנסה והוצאה ב-O(1) מהקצוות. כדי לתמוך בעדיפות כזו, יש צורך במבנה נתונים מורכב יותר, כמו שני חיצים נפרדים (אחד לזוגיים ואחד לאי-זוגיים), או תור עדיפויות אמיתי.\n\nתיקון הקוד:\nהתיקון המוצע משתמש בשני חיצים מעגליים לוגיים נפרדים (אחד למשימות זוגיות ואחד לאי-זוגיות). פתרון זה מאפשר גישה ב-O(1) לכל סוג משימה, ומטפל נכון בדרישות העדיפות והתיאום. פתרון זה משנה את מבנה הנתונים הבסיסי כדי להשיג יעילות ונכונות.\n\n```c\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define BUFFER_CAPACITY 5 // Capacity for EACH buffer type\n\ntypedef struct {\n    int id;\n    // Other task data...\n} Task;\n\n// Two separate logical buffers for even and odd tasks\nTask even_buffer[BUFFER_CAPACITY];\nint even_count = 0;\nint even_head = 0;\nint even_tail = 0;\n\nTask odd_buffer[BUFFER_CAPACITY];\nint odd_count = 0;\nint odd_head = 0;\nint odd_tail = 0;\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond_even_not_full = PTHREAD_COND_INITIALIZER;\npthread_cond_t cond_even_not_empty = PTHREAD_COND_INITIALIZER;\npthread_cond_t cond_odd_not_full = PTHREAD_COND_INITIALIZER;\npthread_cond_t cond_odd_not_empty = PTHREAD_COND_INITIALIZER;\n\nvoid produce(Task t) {\n    pthread_mutex_lock(&mutex);\n    if (t.id % 2 == 0) { // Even task\n        while (even_count == BUFFER_CAPACITY) {\n            pthread_cond_wait(&cond_even_not_full, &mutex);\n        }\n        even_buffer[even_tail] = t;\n        even_tail = (even_tail + 1) % BUFFER_CAPACITY;\n        even_count++;\n        pthread_cond_broadcast(&cond_even_not_empty); // Wake consumers waiting for even tasks\n        pthread_cond_broadcast(&cond_odd_not_empty);  // ALSO wake general consumers waiting for 'any' task\n    } else { // Odd task\n        while (odd_count == BUFFER_CAPACITY) {\n            pthread_cond_wait(&cond_odd_not_full, &mutex);\n        }\n        odd_buffer[odd_tail] = t;\n        odd_tail = (odd_tail + 1) % BUFFER_CAPACITY;\n        odd_count++;\n        pthread_cond_broadcast(&cond_odd_not_empty); // Wake consumers for odd tasks (and general consumers)\n    }\n    pthread_mutex_unlock(&mutex);\n}\n\nTask consume() {\n    pthread_mutex_lock(&mutex);\n    Task consumed_task;\n\n    // Consumer logic: Prioritize even tasks. If no even, take odd. If both empty, wait.\n    while (true) {\n        if (even_count > 0) { // Even tasks available, take one.\n            break; // Exit waiting loop, proceed to consume even.\n        } else if (odd_count > 0) { // No even tasks, but odd tasks available, take one.\n            break; // Exit waiting loop, proceed to consume odd.\n        } else { // Both buffers are empty. Wait for *any* task to arrive.\n            // We wait on `cond_odd_not_empty` as a general signal for 'something arrived'.\n            // Producers for even tasks will also signal `cond_odd_not_empty` in addition to `cond_even_not_empty`\n            // to ensure consumers waiting for 'any' task are woken.\n            pthread_cond_wait(&cond_odd_not_empty, &mutex);\n            // After waking, the loop re-evaluates the conditions.\n        }\n    }\n\n    if (even_count > 0) { // Prioritize even tasks\n        consumed_task = even_buffer[even_head];\n        even_head = (even_head + 1) % BUFFER_CAPACITY;\n        even_count--;\n        pthread_cond_broadcast(&cond_even_not_full); // Wake up producers for even tasks\n    } else { // No even tasks, consume odd (odd_count must be > 0 at this point due to `while` loop logic)\n        consumed_task = odd_buffer[odd_head];\n        odd_head = (odd_head + 1) % BUFFER_CAPACITY;\n        odd_count--;\n        pthread_cond_broadcast(&cond_odd_not_full); // Wake up producers for odd tasks\n    }\n\n    pthread_mutex_unlock(&mutex);\n    return consumed_task;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}