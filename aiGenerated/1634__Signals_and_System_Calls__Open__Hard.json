{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 12:01:12",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 4985,
      "total_tokens": 18722
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "IPC",
      "Process Management",
      "Synchronization"
    ],
    "content": {
      "text": "כתבו תוכנית C המממשת את התרחיש הבא:\nתהליך אב (Parent) יוצר N תהליכי בן (Children). כל תהליך בן מבצע את הפעולות הבאות:\n1.  ממתין לאות `SIGUSR1` מהאב.\n2.  עם קבלת האות, הוא מבצע 'עבודה' המדומה על ידי השהייה של `i+1` שניות (כאשר `i` הוא מספר סידורי של הבן, החל מ-0).\n3.  לאחר סיום העבודה, הוא כותב את ה-PID שלו ואת מספר הבן הסידורי שלו (i) לצינור (pipe) משותף.\n4.  שולח אות `SIGUSR2` לאב כדי להודיע על סיום עבודתו.\n5.  מסיים את פעולתו.\n\nתהליך האב צריך לבצע את הפעולות הבאות:\n1.  להגדיר מטפל אותות עבור `SIGUSR2` שיספור כמה בנים סיימו את עבודתם.\n2.  ליצור `N` תהליכי בן.\n3.  ליצור צינור תקשורת שישמש את הבנים לשליחת תוצאות לאב.\n4.  לאחר יצירת כל הבנים, האב שולח אות `SIGUSR1` לכל אחד מהם כדי להתחיל את עבודתם.\n5.  האב ממתין שכל הבנים יסיימו את עבודתם (באמצעות ספירת אותות `SIGUSR2`).\n6.  כאשר כל הבנים סיימו, האב קורא את כל התוצאות מהצינור ומדפיס אותן למסך בפורמט: `Child PID: [PID], Child Index: [Index]`.\n\nיש לוודא שהתוכנית מטפלת כראוי במצבי מירוץ (race conditions) ובהפרעות של קריאות מערכת (system calls) על ידי אותות. יש להשתמש ב-`sigaction` לטיפול באותות.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n\n#define N_CHILDREN 3 // ניתן לשנות את מספר הבנים לבדיקה\n\n// משתנים גלובליים לטיפול באותות\nvolatile sig_atomic_t children_done_count = 0;\npid_t children_pids[N_CHILDREN];\nint pipefd[2]; // צינור לתקשורת\n\n// מבנה לתוצאה הנשלחת דרך הצינור\nstruct ChildResult {\n    pid_t pid;\n    int index;\n};\n\n// מטפל אותות עבור SIGUSR2 בתהליך האב\nvoid sigusr2_handler(int signum) {\n    // בודק אם האות הוא אכן SIGUSR2\n    if (signum == SIGUSR2) {\n        children_done_count++;\n    }\n}\n\n// מטפל אותות עבור SIGUSR1 בתהליך הבן\nvolatile sig_atomic_t child_received_sigusr1 = 0;\nvoid child_sigusr1_handler(int signum) {\n    if (signum == SIGUSR1) {\n        child_received_sigusr1 = 1;\n    }\n}\n\n// פונקציה לכתיבה בטוחה לצינור (מטפלת ב-EINTR)\nssize_t safe_write(int fd, const void *buf, size_t count) {\n    ssize_t bytes_written = 0;\n    ssize_t total_written = 0;\n    while (total_written < count) {\n        bytes_written = write(fd, buf + total_written, count - total_written);\n        if (bytes_written == -1) {\n            if (errno == EINTR) {\n                continue; // הופרע, מנסים שוב\n            } else {\n                perror(\"write failed\");\n                return -1;\n            }\n        }\n        total_written += bytes_written;\n    }\n    return total_written;\n}\n\n// פונקציה לקריאה בטוחה מהצינור (מטפלת ב-EINTR)\nssize_t safe_read(int fd, void *buf, size_t count) {\n    ssize_t bytes_read = 0;\n    ssize_t total_read = 0;\n    while (total_read < count) {\n        bytes_read = read(fd, buf + total_read, count - total_read);\n        if (bytes_read == -1) {\n            if (errno == EINTR) {\n                continue; // הופרע, מנסים שוב\n            } else {\n                perror(\"read failed\");\n                return -1;\n            }\n        }\n        if (bytes_read == 0) { // EOF - כל הכותבים סגרו את הצינור\n            break;\n        }\n        total_read += bytes_read;\n    }\n    return total_read;\n}\n\n// לוגיקה של תהליך הבן\nvoid child_proc(int child_idx) {\n    // 1. הגדרת מטפל SIGUSR1\n    struct sigaction sa_usr1;\n    sa_usr1.sa_handler = child_sigusr1_handler;\n    sigemptyset(&sa_usr1.sa_mask);\n    sa_usr1.sa_flags = 0; // אין צורך ב-SA_RESTART עבור הגדרת דגל\n    if (sigaction(SIGUSR1, &sa_usr1, NULL) == -1) {\n        perror(\"Child sigaction SIGUSR1 failed\");\n        exit(1);\n    }\n\n    // חסימת SIGUSR1 זמנית כדי להבטיח שהמתנה תתבצע כראוי\n    sigset_t blockmask, oldmask;\n    sigemptyset(&blockmask);\n    sigaddset(&blockmask, SIGUSR1);\n    sigprocmask(SIG_BLOCK, &blockmask, &oldmask); // חוסם את SIGUSR1\n\n    printf(\"Child %d (PID %d) waiting for SIGUSR1...\\n\", child_idx, getpid());\n\n    // המתנה לאות SIGUSR1\n    while (!child_received_sigusr1) {\n        sigsuspend(&oldmask); // מבטל חסימה אטומית של SIGUSR1 וממתין לכל אות\n    }\n    printf(\"Child %d (PID %d) received SIGUSR1. Starting work...\\n\", child_idx, getpid());\n    sigprocmask(SIG_SETMASK, &oldmask, NULL); // שחזור מסכת אותות מקורית\n\n    // 2. דימוי עבודה\n    sleep(child_idx + 1);\n\n    // 3. כתיבת PID ואינדקס לצינור\n    close(pipefd[0]); // בן סוגר את קצה הקריאה של הצינור\n    struct ChildResult result = {getpid(), child_idx};\n    if (safe_write(pipefd[1], &result, sizeof(result)) == -1) {\n        fprintf(stderr, \"Child %d (PID %d) failed to write to pipe.\\n\", child_idx, getpid());\n        exit(1);\n    }\n    close(pipefd[1]); // בן סוגר את קצה הכתיבה של הצינור\n\n    // 4. שליחת SIGUSR2 לאב\n    if (kill(getppid(), SIGUSR2) == -1) {\n        perror(\"Child failed to send SIGUSR2 to parent\");\n    }\n\n    // 5. יציאה\n    printf(\"Child %d (PID %d) finished work and exiting.\\n\", child_idx, getpid());\n    exit(0);\n}\n\n// לוגיקה של תהליך האב\nvoid parent_proc() {\n    // 1. הגדרת מטפל SIGUSR2\n    struct sigaction sa_usr2;\n    sa_usr2.sa_handler = sigusr2_handler;\n    sigemptyset(&sa_usr2.sa_mask);\n    sa_usr2.sa_flags = SA_RESTART; // SA_RESTART כדי להפעיל מחדש קריאות מערכת שהופרעו\n    if (sigaction(SIGUSR2, &sa_usr2, NULL) == -1) {\n        perror(\"sigaction SIGUSR2 failed\");\n        exit(1);\n    }\n\n    // חסימת SIGCHLD זמנית כדי למנוע מצבי מירוץ עם בנים היוצאים מוקדם\n    sigset_t block_chld, old_mask;\n    sigemptyset(&block_chld);\n    sigaddset(&block_chld, SIGCHLD);\n    sigprocmask(SIG_BLOCK, &block_chld, &old_mask);\n\n    // 2. יצירת N תהליכי בן\n    for (int i = 0; i < N_CHILDREN; i++) {\n        children_pids[i] = fork();\n        if (children_pids[i] == -1) {\n            perror(\"fork failed\");\n            // ניקוי בנים שכבר נוצרו\n            for (int j = 0; j < i; ++j) {\n                kill(children_pids[j], SIGTERM); // שולח אות סיום\n                waitpid(children_pids[j], NULL, 0); // ממתין לסיום\n            }\n            exit(1);\n        } else if (children_pids[i] == 0) {\n            // תהליך הבן\n            close(pipefd[1]); // בן סוגר את קצה הכתיבה של האב (הוא ישתמש בקצה שלו)\n            // שחזור מסכת אותות מקורית לבן\n            sigprocmask(SIG_SETMASK, &old_mask, NULL);\n            child_proc(i);\n            // לא אמור להגיע לכאן\n            exit(1);\n        }\n    }\n\n    // תהליך האב ממשיך\n    close(pipefd[1]); // אב סוגר את קצה הכתיבה של הצינור\n\n    printf(\"Parent (PID %d) forked %d children. Sending SIGUSR1...\\n\", getpid(), N_CHILDREN);\n\n    // 4. שליחת SIGUSR1 לכל הבנים\n    for (int i = 0; i < N_CHILDREN; i++) {\n        if (kill(children_pids[i], SIGUSR1) == -1) {\n            perror(\"Parent failed to send SIGUSR1 to child\");\n        }\n    }\n\n    // 5. האב ממתין שכל הבנים יסיימו (על ידי ספירת אותות SIGUSR2)\n    printf(\"Parent waiting for all children to finish...\\n\");\n    sigset_t empty_mask;\n    sigemptyset(&empty_mask);\n\n    while (children_done_count < N_CHILDREN) {\n        sigsuspend(&empty_mask); // ממתין לכל אות לא חסום, כולל SIGUSR2\n    }\n    printf(\"Parent received completion signals from all %d children.\\n\", N_CHILDREN);\n\n    // 6. קריאת תוצאות מהצינור\n    printf(\"Parent reading results from pipe:\\n\");\n    struct ChildResult result;\n    for (int i = 0; i < N_CHILDREN; i++) {\n        if (safe_read(pipefd[0], &result, sizeof(result)) == sizeof(result)) {\n            printf(\"Child PID: %d, Child Index: %d\\n\", result.pid, result.index);\n        } else {\n            fprintf(stderr, \"Parent failed to read result %d from pipe.\\n\", i);\n        }\n    }\n    close(pipefd[0]); // אב סוגר את קצה הקריאה של הצינור\n\n    // 7. המתנה לסיום כל הבנים (כדי למנוע זומבים)\n    sigprocmask(SIG_SETMASK, &old_mask, NULL); // שחזור מסכת אותות מקורית כדי לבטל חסימת SIGCHLD\n    for (int i = 0; i < N_CHILDREN; i++) {\n        waitpid(children_pids[i], NULL, 0);\n    }\n    printf(\"Parent finished, all children reaped.\\n\");\n}\n\nint main() {\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe failed\");\n        exit(1);\n    }\n\n    parent_proc();\n\n    return 0;\n}\n",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "התוכנית מורכבת מתהליך אב ו-N תהליכי בן, המשתמשים באותות ובצינור (pipe) לתקשורת וסנכרון.\n\n**תהליך האב:**\n1.  **הגדרת מטפל אותות (`SIGUSR2`):**\n    *   האב מגדיר מטפל לאות `SIGUSR2` באמצעות `sigaction`. המטפל, `sigusr2_handler`, פשוט מגדיל מונה גלובלי (`children_done_count`) מסוג `volatile sig_atomic_t` כדי לספור כמה בנים סיימו את עבודתם. שימוש ב-`volatile sig_atomic_t` מבטיח שהמשתנה יעודכן וייקרא בצורה בטוחה בתוך מטפל האותות ועל ידי התהליך הראשי.\n    *   הדגל `SA_RESTART` מוגדר כדי להבטיח שקריאות מערכת כמו `read` לא יופרעו ויתחילו מחדש אוטומטית אם יתקבל `SIGUSR2` במהלך הקריאה.\n2.  **יצירת צינור:**\n    *   האב יוצר צינור באמצעות `pipe()` לפני יצירת הבנים. קצה הכתיבה של הצינור (`pipefd[1]`) נשאר פתוח בבנים, וקצה הקריאה (`pipefd[0]`) נשאר פתוח באב.\n3.  **יצירת בנים:**\n    *   האב יוצר `N` תהליכי בן באמצעות לולאת `fork()`. כל PID של בן נשמר במערך `children_pids`.\n    *   בכל תהליך בן, קצה הקריאה של הצינור (`pipefd[0]`) נסגר, ובאב קצה הכתיבה (`pipefd[1]`) נסגר מיד לאחר יצירת כל הבנים.\n4.  **שליחת `SIGUSR1` לבנים:**\n    *   לאחר שכל הבנים נוצרו, האב עובר על מערך ה-PIDs ושולח `SIGUSR1` לכל בן באמצעות `kill()`, ובכך מאותת לבנים להתחיל את עבודתם.\n5.  **המתנה לסיום עבודת הבנים:**\n    *   האב נכנס ללולאה שבה הוא ממתין שמונה ה-`children_done_count` יגיע ל-`N_CHILDREN`. בתוך הלולאה, האב קורא ל-`sigsuspend()` עם מסכת אותות ריקה. זה גורם לאב להשהות את ביצועו באופן אטומי עד לקבלת אות כלשהו (כולל `SIGUSR2`), ואז הוא בודק שוב את המונה. שיטה זו מונעת 'busy-waiting' ומבטיחה שהאב יתעורר רק כאשר יש צורך.\n6.  **קריאת תוצאות מהצינור:**\n    *   לאחר שכל הבנים אותתו על סיום עבודתם (מונה `children_done_count` הגיע ל-`N_CHILDREN`), האב קורא את כל הנתונים מהצינור. הפונקציות `safe_read` ו-`safe_write` ממומשות כדי לטפל במקרה שקריאת מערכת מופרעת על ידי אות (`EINTR`), ולנסות שוב.\n7.  **איסוף בנים (`waitpid`):**\n    *   לבסוף, האב קורא ל-`waitpid()` עבור כל בן כדי לאסוף את ה-exit status שלהם ולמנוע יצירת תהליכי זומבי.\n\n**תהליך הבן:**\n1.  **הגדרת מטפל אותות (`SIGUSR1`):**\n    *   כל בן מגדיר מטפל לאות `SIGUSR1` (`child_sigusr1_handler`) המגדיר דגל גלובלי (`child_received_sigusr1`) מסוג `volatile sig_atomic_t`.\n2.  **המתנה ל-`SIGUSR1`:**\n    *   הבן חוסם זמנית את `SIGUSR1` באמצעות `sigprocmask()`, ואז נכנס ללולאה שבה הוא ממתין לדגל `child_received_sigusr1` להיות מוגדר. בתוך הלולאה, הוא קורא ל-`sigsuspend()` עם המסכה המקורית (לפני חסימת `SIGUSR1`). זה מאפשר ל-`SIGUSR1` להתקבל ולעורר את הבן.\n    *   לאחר קבלת האות, הבן משחזר את מסכת האותות המקורית.\n3.  **ביצוע עבודה:**\n    *   הבן מדמה עבודה על ידי קריאה ל-`sleep(child_idx + 1)`.\n4.  **כתיבת תוצאות לצינור:**\n    *   הבן סוגר את קצה הקריאה של הצינור (`pipefd[0]`) וכותב את ה-PID שלו ואת מספרו הסידורי לצינור באמצעות `safe_write`. לאחר הכתיבה, הוא סוגר גם את קצה הכתיבה של הצינור (`pipefd[1]`).\n5.  **שליחת `SIGUSR2` לאב:**\n    *   הבן שולח אות `SIGUSR2` לאב באמצעות `kill(getppid(), SIGUSR2)` כדי להודיע על סיום עבודתו.\n6.  **יציאה:**\n    *   הבן מסיים את פעולתו באמצעות `exit(0)`.\n\n**טיפול במצבי מירוץ והפרעות:**\n*   **`volatile sig_atomic_t`:** השימוש במשתנים אלו מבטיח גישה בטוחה מתוך מטפלי אותות ומחוצה להם.\n*   **`sigaction` עם `SA_RESTART`:** מבטיח שקריאות מערכת כמו `read` ו-`write` יופעלו מחדש אוטומטית אם יופרעו על ידי אותות (במקום להיכשל עם `EINTR`).\n*   **`safe_read`/`safe_write`:** פונקציות עטיפה שבודקות את `errno == EINTR` ומנסות שוב את הקריאה/כתיבה, ובכך מטפלות במקרים של הפרעות אותות.\n*   **`sigsuspend`:** משמש הן באב והן בבן להמתנה יעילה לאותות ספציפיים, מונע 'busy-waiting' ומבטיח סנכרון נכון (למשל, המתנת הבן ל-`SIGUSR1` והמתנת האב לסיום הבנים).\n*   **סגירת קצוות צינור:** סגירה נכונה של קצוות הצינור בתהליכים השונים מונעת מצבי קיפאון (deadlock) ומוודאת ש-`read` יקבל EOF כשכל הכותבים סגרו את הצינור."
    },
    "difficulty_estimation": "Hard"
  }
}