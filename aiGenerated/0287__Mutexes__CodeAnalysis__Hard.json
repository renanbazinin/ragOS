{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:34:39",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4847,
      "output_tokens": 3774,
      "total_tokens": 17826
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Mutexes",
      "Deadlock",
      "Concurrency",
      "Lazy Initialization",
      "Singleton"
    ],
    "content": {
      "text": "במערכת מרובת חוטים, נדרש לממש אובייקט יחיד (singleton) שמאותחל באופן עצלני (lazy initialization). אובייקט זה, `Logger`, אחראי לרישום הודעות ליומן. בניית אובייקט `Logger` היא פעולה יקרה וארוכה, ודורשת גישה למשאב גלובלי נוסף (לדוגמה, קובץ קונפיגורציה), המוגן על ידי מנעול `config_mutex`.\n\nלהלן המימוש המוצע:\n1. הפונקציה `get_logger()` אחראית להחזיר את מופע ה-`Logger` היחיד, וליצור אותו אם טרם נוצר.\n2. הקונסטרוקטור של `Logger` (הפונקציה `Logger::Logger()`) מבצע את האתחול היקר, ובמהלכו נועל את `config_mutex`.\n\nבנוסף, קיימת פונקציה `update_configuration()` המבצעת עדכון כלשהו בקונפיגורציה, ודורשת גישה לשני המנעולים: תחילה `config_mutex` ולאחר מכן `logger_init_mutex` (מסיבות שאינן רלוונטיות לבעיה, אך נדרשות על ידי לוגיקה פנימית).\n\nנתחו את הקוד הנתון וענו על השאלות הבאות.",
      "code_snippet": "#include <iostream>\n#include <pthread.h>\n#include <unistd.h> // For sleep\n\n// Global mutex for lazy initialization of Logger\npthread_mutex_t logger_init_mutex = PTHREAD_MUTEX_INITIALIZER;\n// Global mutex for configuration access (used by Logger constructor and update_configuration)\npthread_mutex_t config_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nclass Logger {\npublic:\n    Logger() {\n        // Simulate expensive initialization requiring config_mutex\n        pthread_mutex_lock(&config_mutex);\n        std::cout << \"Logger constructor: Acquiring config_mutex for expensive initialization...\" << std::endl;\n        sleep(2); // Simulate long initialization\n        std::cout << \"Logger constructor: Finished expensive initialization and releasing config_mutex.\" << std::endl;\n        pthread_mutex_unlock(&config_mutex);\n    }\n\n    void log(const char* message) {\n        std::cout << \"Log message: \" << message << std::endl;\n    }\n};\n\n// The singleton instance\nLogger* g_logger_instance = NULL;\n\n// Function to get the singleton Logger instance\nLogger* get_logger() {\n    if (g_logger_instance == NULL) { // First check (no lock)\n        pthread_mutex_lock(&logger_init_mutex);\n        if (g_logger_instance == NULL) { // Second check (with lock)\n            std::cout << \"Thread \" << pthread_self() << \": Initializing Logger...\" << std::endl;\n            g_logger_instance = new Logger(); // Calls Logger constructor\n            std::cout << \"Thread \" << pthread_self() << \": Logger initialized.\" << std::endl;\n        }\n        pthread_mutex_unlock(&logger_init_mutex);\n    }\n    return g_logger_instance;\n}\n\n// Another function that needs config_mutex then logger_init_mutex\nvoid update_configuration() {\n    std::cout << \"Thread \" << pthread_self() << \": Entering update_configuration()...\" << std::endl;\n    pthread_mutex_lock(&config_mutex);\n    std::cout << \"Thread \" << pthread_self() << \": Acquired config_mutex in update_configuration().\" << std::endl;\n    sleep(1); // Simulate some work\n    \n    pthread_mutex_lock(&logger_init_mutex); // Potential deadlock here\n    std::cout << \"Thread \" << pthread_self() << \": Acquired logger_init_mutex in update_configuration().\" << std::endl;\n    // Perform configuration update that might involve checking logger state or similar\n    // For simplicity, just simulate work.\n    sleep(1);\n    \n    pthread_mutex_unlock(&logger_init_mutex);\n    std::cout << \"Thread \" << pthread_self() << \": Released logger_init_mutex in update_configuration().\" << std::endl;\n    \n    pthread_mutex_unlock(&config_mutex);\n    std::cout << \"Thread \" << pthread_self() << \": Released config_mutex in update_configuration().\" << std::endl;\n}\n\n// Example thread functions\nvoid* thread_logger_task(void* arg) {\n    Logger* logger = get_logger();\n    logger->log(\"Hello from logger thread!\");\n    return NULL;\n}\n\nvoid* thread_config_task(void* arg) {\n    update_configuration();\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n\n    std::cout << \"Starting threads...\" << std::endl;\n    pthread_create(&t1, NULL, thread_logger_task, NULL);\n    pthread_create(&t2, NULL, thread_config_task, NULL);\n\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n\n    std::cout << \"Threads finished.\" << std::endl;\n\n    // Clean up\n    delete g_logger_instance; // Only if initialized\n    pthread_mutex_destroy(&logger_init_mutex);\n    pthread_mutex_destroy(&config_mutex);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "101.1",
        "text": "זהו את בעיית הסנכרון הקיימת בקוד. תארו כיצד הבעיה יכולה להתרחש באמצעות רצף אירועים ספציפי הכולל את שני החוטים (t1 ו-t2).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.2",
        "text": "תקנו את הקוד על מנת לפתור את בעיית הסנכרון שזיהיתם. הסבירו בקצרה את הפתרון שלכם ואת השינויים שביצעתם.",
        "code_snippet": "/* הכניסו כאן את הקוד המתוקן */",
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### 101.1 זיהוי הבעיה והסבר:\nהבעיה היא **קיפאון (Deadlock)**. קיפאון יכול להתרחש כאשר שני חוטים או יותר ממתינים זה לזה למשאב שהשני מחזיק בו, ויוצרים מעגל המתנה.\n\n**רצף אירועים המוביל לקיפאון:**\n1.  **חוט t1 (מריץ את `thread_logger_task`):** קורא לפונקציה `get_logger()`. הוא מגלה ש-`g_logger_instance` הוא `NULL`.\n2.  **חוט t1:** נועל את `logger_init_mutex`. (כעת t1 מחזיק ב-`logger_init_mutex`).\n3.  **חוט t1:** מתחיל את יצירת אובייקט `Logger` על ידי קריאה ל-`new Logger()`.\n4.  **חוט t1 (בתוך הקונסטרוקטור של `Logger`):** מנסה לנעול את `config_mutex`. כעת הוא ממתין ל-`config_mutex`.\n\n5.  **חוט t2 (מריץ את `thread_config_task`):** קורא לפונקציה `update_configuration()`.\n6.  **חוט t2:** נועל את `config_mutex`. (כעת t2 מחזיק ב-`config_mutex`).\n7.  **חוט t2:** מנסה לנעול את `logger_init_mutex`. כעת הוא ממתין ל-`logger_init_mutex`.\n\n**תוצאה:**\n*   חוט t1 מחזיק ב-`logger_init_mutex` וממתין ל-`config_mutex`.\n*   חוט t2 מחזיק ב-`config_mutex` וממתין ל-`logger_init_mutex`.\n\nשני החוטים חסומים באופן הדדי, ונוצר מצב של קיפאון. אף אחד מהם לא יכול להמשיך, והתוכנית תיתקע.\n\n### 101.2 תיקון הקוד:\nהבעיה נובעת מכך שהחוטים מנסים לנעול את המנעולים בסדר שונה: `get_logger` נועל את `logger_init_mutex` ואז מנסה לנעול את `config_mutex` (דרך הקונסטרוקטור), בעוד ש-`update_configuration` נועל את `config_mutex` ואז מנסה לנעול את `logger_init_mutex`. כדי למנוע קיפאון, יש להקפיד על סדר אחיד של נעילת מנעולים בכל מקום בתוכנית.\n\n**פתרון:** נשנה את סדר נעילת המנעולים בפונקציה `update_configuration()` כך שתמיד ינעל קודם את `logger_init_mutex` ולאחר מכן את `config_mutex`. לחלופין, ניתן לשנות את הקונסטרוקטור של `Logger` כך שינעל את `config_mutex` רק *לאחר* ש-`logger_init_mutex` שוחרר, אך זה מסובך יותר ודורש שינוי לוגיקה של Double-Checked Locking. הסדר העדיף הוא לשנות את `update_configuration` כדי להתאים לסדר של `get_logger` (או להיפך), תוך שמירה על סדר עקבי.\n\n**שינויים שבוצעו:**\nהקוד של `update_configuration()` שונה כך שסדר נעילת המנעולים יהיה זהה לסדר המרומז ב-`get_logger()` (כלומר, קודם `logger_init_mutex` ואז `config_mutex`).\n\n```c\n#include <iostream>\n#include <pthread.h>\n#include <unistd.h> // For sleep\n\n// Global mutex for lazy initialization of Logger\npthread_mutex_t logger_init_mutex = PTHREAD_MUTEX_INITIALIZER;\n// Global mutex for configuration access (used by Logger constructor and update_configuration)\npthread_mutex_t config_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nclass Logger {\npublic:\n    Logger() {\n        // Simulate expensive initialization requiring config_mutex\n        pthread_mutex_lock(&config_mutex); // This is still the internal order for Logger init\n        std::cout << \"Logger constructor: Acquiring config_mutex for expensive initialization...\" << std::endl;\n        sleep(2); // Simulate long initialization\n        std::cout << \"Logger constructor: Finished expensive initialization and releasing config_mutex.\" << std::endl;\n        pthread_mutex_unlock(&config_mutex);\n    }\n\n    void log(const char* message) {\n        std::cout << \"Log message: \" << message << std::endl;\n    }\n};\n\n// The singleton instance\nLogger* g_logger_instance = NULL;\n\n// Function to get the singleton Logger instance\nLogger* get_logger() {\n    if (g_logger_instance == NULL) { // First check (no lock)\n        pthread_mutex_lock(&logger_init_mutex);\n        if (g_logger_instance == NULL) { // Second check (with lock)\n            std::cout << \"Thread \" << pthread_self() << \": Initializing Logger...\" << std::endl;\n            g_logger_instance = new Logger(); // Calls Logger constructor\n            std::cout << \"Thread \" << pthread_self() << \": Logger initialized.\" << std::endl;\n        }\n        pthread_mutex_unlock(&logger_init_mutex);\n    }\n    return g_logger_instance;\n}\n\n// Another function that needs config_mutex then logger_init_mutex\nvoid update_configuration() {\n    std::cout << \"Thread \" << pthread_self() << \": Entering update_configuration()...\" << std::endl;\n    \n    // FIX: Changed lock order to prevent deadlock. \n    // Now it always locks logger_init_mutex first, then config_mutex.\n    pthread_mutex_lock(&logger_init_mutex);\n    std::cout << \"Thread \" << pthread_self() << \": Acquired logger_init_mutex in update_configuration().\" << std::endl;\n    sleep(1); // Simulate some work\n\n    pthread_mutex_lock(&config_mutex);\n    std::cout << \"Thread \" << pthread_self() << \": Acquired config_mutex in update_configuration().\" << std::endl;\n    // Perform configuration update that might involve checking logger state or similar\n    // For simplicity, just simulate work.\n    sleep(1);\n    \n    pthread_mutex_unlock(&config_mutex);\n    std::cout << \"Thread \" << pthread_self() << \": Released config_mutex in update_configuration().\" << std::endl;\n    \n    pthread_mutex_unlock(&logger_init_mutex);\n    std::cout << \"Thread \" << pthread_self() << \": Released logger_init_mutex in update_configuration().\" << std::endl;\n}\n\n// Example thread functions\nvoid* thread_logger_task(void* arg) {\n    Logger* logger = get_logger();\n    logger->log(\"Hello from logger thread!\");\n    return NULL;\n}\n\nvoid* thread_config_task(void* arg) {\n    update_configuration();\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n\n    std::cout << \"Starting threads...\" << std::endl;\n    pthread_create(&t1, NULL, thread_logger_task, NULL);\n    pthread_create(&t2, NULL, thread_config_task, NULL);\n\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n\n    std::cout << \"Threads finished.\" << std::endl;\n\n    // Clean up\n    delete g_logger_instance; // Only if initialized\n    pthread_mutex_destroy(&logger_init_mutex);\n    pthread_mutex_destroy(&config_mutex);\n\n    return 0;\n}\n```\n\n**הערה:** חשוב לציין שהפתרון הזה (שינוי סדר הנעילה ב-`update_configuration`) עובד מכיוון שהוא מייצר סדר נעילה גלובלי אחיד: תמיד `logger_init_mutex` ואז `config_mutex` (או רק אחד מהם). אם היה צורך אמיתי לנעול את `config_mutex` לפני `logger_init_mutex` ב-`update_configuration` מסיבות לוגיות אחרות, היה צריך לשקול פתרונות מורכבים יותר כמו `trylock` או שימוש ב-`std::call_once` ב-C++11 ומעלה כדי להימנע מנעילת `logger_init_mutex` באופן ישיר ב-`get_logger` לאחר האתחול הראשון."
    },
    "difficulty_estimation": "Hard"
  }
}