{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 22:05:14",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2670,
      "output_tokens": 2950,
      "total_tokens": 14560
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Memory Management",
      "Paging",
      "Locality of Reference",
      "Page Faults"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת במטריצה דו-ממדית גדולה. המערכת מריצה את התוכנית על מעבד יחיד. גודל דף זיכרון הוא 4KB. גודל משתנה `int` הוא 4 בתים. המטריצה `matrix` מוגדרת כמשתנה גלובלי. נניח שבהתחלה אף דף של המטריצה אינו נמצא בזיכרון הפיזי (כלומר, כל גישה לדף חדש תגרום ל-Page Fault). כמו כן, נניח שגודל הזיכרון הפיזי הזמין לתהליך הוא 100 דפים בלבד, ושמדיניות החלפת הדפים היא LRU (Least Recently Used).\n\nהקוד הבא מראה שתי פונקציות המגשות לאלמנטים במטריצה בסדרים שונים.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ROWS 1024\n#define COLS 1024\n#define PAGE_SIZE_BYTES 4096 // 4 KB\n#define INT_SIZE 4           // size of int in bytes\n\nint matrix[ROWS][COLS]; // Global static array\n\nvoid access_row_major() {\n    for (int i = 0; i < ROWS; ++i) {\n        for (int j = 0; j < COLS; ++j) {\n            matrix[i][j] = i * COLS + j;\n        }\n    }\n}\n\nvoid access_col_major() {\n    for (int j = 0; j < COLS; ++j) {\n        for (int i = 0; i < ROWS; ++i) {\n            matrix[i][j] = i * COLS + j;\n        }\n    }\n}\n\nint main() {\n    access_row_major();\n    access_col_major();\n    return 0;\n}\n```\n\nנתחו את הקוד הנתון וענו על השאלות הבאות:\n1.  כמה Page Faults סך הכל יתרחשו במהלך קריאה לפונקציה `access_row_major()`? נמקו.\n2.  כמה Page Faults סך הכל יתרחשו במהלך קריאה לפונקציה `access_col_major()`? נמקו.\n3.  הסבירו מדוע יש הבדל (אם יש) במספר ה-Page Faults בין שתי הפונקציות, ואיזה עיקרון של ניהול זיכרון מודגם כאן.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "חישובים מקדימים:\n*   גודל `int`: 4 בתים.\n*   גודל דף: 4096 בתים.\n*   מספר משתני `int` לדף: 4096 / 4 = 1024 משתני `int`.\n*   ממדי המטריצה: `ROWS = 1024`, `COLS = 1024`.\n*   גודל שורה במטריצה: `COLS * INT_SIZE = 1024 * 4 = 4096` בתים. כלומר, שורה אחת תופסת בדיוק דף אחד.\n*   מספר הדפים הכולל של המטריצה: `ROWS` (1024 שורות) * 1 דף לשורה = 1024 דפים.\n*   מספר פריימים פיזיים זמינים: 100.\n*   מדיניות החלפת דפים: LRU.\n\n1.  **Page Faults בפונקציה `access_row_major()`:**\n    בפונקציה זו, הגישה למטריצה מתבצעת בסדר שורה-אחר-שורה (`matrix[i][j]`). מכיוון שכל שורה תופסת בדיוק דף אחד והמטריצה מאוחסנת בזיכרון בסדר שורות (row-major order), גישה ל-`matrix[i][j]` עבור `j` משתנה (כש-`i` קבוע) תמיד תישאר באותו דף. רק כאשר `i` משתנה, אנו עוברים לשורה חדשה, ולכן לדף חדש.\n    *   עבור `i=0`, אנו ניגשים לראשונה לדף 0 (המכיל את `matrix[0][0]` עד `matrix[0][1023]`). זה יגרום ל-Page Fault (PF). הדף נטען לזיכרון הפיזי.\n    *   לאחר מכן, עבור `j=1` עד `COLS-1`, הגישות נשארות באותו דף 0, ולכן לא נגרמים Page Faults נוספים.\n    *   כאשר `i` מתקדם ל-1, אנו ניגשים לראשונה לדף 1 (המכיל את `matrix[1][0]` עד `matrix[1][1023]`). זה יגרום ל-Page Fault.\n    *   דפוס זה חוזר על עצמו עבור כל אחת מ-`ROWS` (1024) השורות. בכל פעם שאנו מתחילים שורה חדשה, אנו ניגשים לדף חדש.\n    *   מכיוון שכל גישה לדף חדש גורמת ל-PF, ופונקציה זו ניגשת ל-1024 דפים שונים באופן סדרתי, יהיו בסך הכל **1024 Page Faults**. מדיניות ה-LRU ומגבלת הזיכרון הפיזי (100 דפים) אינן משפיעות על המספר הכולל במקרה זה, כיוון שהגישה היא סדרתית וכל דף נקרא פעם אחת בלבד. ה-Working Set של הפונקציה הוא דף אחד בלבד.\n\n2.  **Page Faults בפונקציה `access_col_major()`:**\n    בפונקציה זו, הגישה למטריצה מתבצעת בסדר עמודה-אחר-עמודה (`matrix[i][j]`). עבור `j` קבוע, הלולאה הפנימית משנה את `i` מ-0 עד `ROWS-1`. זה אומר שאנו ניגשים ל-`matrix[0][j]`, `matrix[1][j]`, ..., `matrix[1023][j]`.\n    *   כפי שחישבנו, `matrix[i][j]` ו-`matrix[i+1][j]` נמצאים בדפים שונים (דף `i` ודף `i+1` בהתאמה).\n    *   עבור `j=0` (העמודה הראשונה):\n        *   הגישה ל-`matrix[0][0]` גורמת ל-PF (טוען דף 0). \n        *   הגישה ל-`matrix[1][0]` גורמת ל-PF (טוען דף 1). \n        *   ... \n        *   הגישה ל-`matrix[99][0]` גורמת ל-PF (טוען דף 99). בשלב זה, 100 פריימים פיזיים מלאים.\n        *   הגישה ל-`matrix[100][0]` גורמת ל-PF (טוען דף 100, מחליף את דף 0 שהוא ה-LRU).\n        *   דפוס זה ממשיך: כל גישה ל-`matrix[i][0]` (עבור `i` מ-0 עד 1023) תגרום ל-PF. סך הכל 1024 Page Faults עבור העמודה הראשונה.\n        *   בסיום סריקת העמודה הראשונה, הדפים בזיכרון הפיזי הם דפים 924 עד 1023.\n    *   עבור `j=1` (העמודה השנייה):\n        *   הלולאה הפנימית ניגשת שוב לדפים 0, 1, ..., 1023.\n        *   הגישה ל-`matrix[0][1]` פירושה גישה לדף 0. דף 0 יצא מהזיכרון הפיזי במהלך סריקת העמודה הראשונה (הוחלף כאשר `i=100`). לכן, גישה זו תגרום שוב ל-PF. דף 0 ייטען מחדש ויחליף את דף 924 (ה-LRU).\n        *   דפוס זה חוזר על עצמו עבור כל גישה ל-`matrix[i][1]` עבור `i` מ-0 עד 1023. כלומר, 1024 Page Faults נוספים עבור העמודה השנייה.\n    *   מכיוון שהלולאה החיצונית רצה `COLS` (1024) פעמים, ובכל פעם היא גורמת ל-1024 Page Faults, סך הכל יתרחשו `COLS * ROWS` = `1024 * 1024` = **1,048,576 Page Faults**.\n\n3.  **הסבר ההבדל ועיקרון ניהול הזיכרון:**\n    ההבדל הדרמטי במספר ה-Page Faults נובע מעיקרון \"עקרון המקומיות\" (Locality of Reference), ובפרט \"מקומיות מרחבית\" (Spatial Locality).\n    *   **`access_row_major()`** מציגה מקומיות מרחבית מצוינת. היא ניגשת לאלמנטים בזיכרון בסדר רציף (או קרוב לרציף). כאשר דף נטען לזיכרון הפיזי, הוא מכיל את כל הנתונים הנדרשים לגישות הבאות (בתוך אותה שורה). זה ממזער את מספר ה-Page Faults, שכן דף אחד מספיק \"לכסות\" את כל הגישות בשורה אחת. ה-Working Set (קבוצת הדפים הפעילים) של הפונקציה קטן (דף אחד) ומתאים בקלות לזיכרון הפיזי.\n    *   **`access_col_major()`** מציגה מקומיות מרחבית ירודה מאוד. היא ניגשת לאלמנטים בזיכרון בקפיצות גדולות. כל גישה ל-`matrix[i][j]` עבור `i` חדש (כש-`j` קבוע) קופצת לדף חדש לחלוטין. מכיוון שגודל הזיכרון הפיזי (100 דפים) קטן משמעותית ממספר הדפים הכולל של המטריצה (1024 דפים) הנדרשים בכל איטרציה של הלולאה הפנימית, ובכל איטרציה של הלולאה החיצונית אנו סורקים מחדש את כל טווח הדפים של המטריצה, דפים ישנים נזרקים מהזיכרון הפיזי רק כדי להיטען מחדש מיד לאחר מכן. תופעה זו נקראת \"Thrashing\" (סחף דפים), והיא גורמת לירידה חמורה בביצועים עקב מספר עצום של Page Faults ופעולות קריאה/כתיבה לדיסק.\n    העיקרון המודגם הוא חשיבות ה-Spatial Locality (מקומיות מרחבית) ויכולת מערכת ההפעלה לנצל אותה באמצעות טעינת דפים. גישה לא רציפה לזיכרון, במיוחד כאשר ה-Working Set (קבוצת הדפים הפעילים) גדולה מהזיכרון הפיזי הזמין, עלולה להוביל לביצועים גרועים ביותר."
    },
    "difficulty_estimation": "Medium"
  }
}