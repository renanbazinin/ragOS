{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:57:41",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3853,
      "output_tokens": 1034,
      "total_tokens": 7546
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Semaphores",
      "Concurrency",
      "Synchronization",
      "Threads"
    ],
    "content": {
      "text": "נתונה תוכנית C הבאה המשתמשת בסמפורים. עיין בקוד וענה על השאלה הבאה:\n\nמהו/מהם הפלט/ים האפשרי/ים של התוכנית? נמק את תשובתך.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // for sleep\n\nsem_t sem;\nint counter = 0;\n\nvoid *thread_A(void *arg) {\n    // Simulate some work before incrementing\n    sleep(1);\n    counter++;\n    printf(\"Thread A: counter incremented to %d\\n\", counter);\n    sem_post(&sem);\n    return NULL;\n}\n\nvoid *thread_B(void *arg) {\n    printf(\"Thread B: Waiting for semaphore...\\n\");\n    sem_wait(&sem);\n    printf(\"Thread B: Semaphore acquired. Counter value is %d\\n\", counter);\n    return NULL;\n}\n\nint main() {\n    pthread_t tid_a, tid_b;\n\n    // Initialize semaphore to 0\n    sem_init(&sem, 0, 0);\n\n    // Create threads\n    pthread_create(&tid_b, NULL, thread_B, NULL); // Create B first\n    pthread_create(&tid_a, NULL, thread_A, NULL); // Create A second\n\n    // Wait for threads to finish\n    pthread_join(tid_a, NULL);\n    pthread_join(tid_b, NULL);\n\n    sem_destroy(&sem);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסמפור `sem` מאותחל לערך 0. המשמעות היא שכל קריאה ל-`sem_wait` תחסום את התהליך הקורא עד שקריאה ל-`sem_post` תשחרר את הסמפור.\n\nהתהליך הראשי יוצר תחילה את `thread_B` ולאחר מכן את `thread_A`.\n1.  `thread_B` מתחיל לרוץ ומיד קורא ל-`sem_wait(&sem)`. מכיוון שערך הסמפור הוא 0, `thread_B` נחסם וממתין.\n2.  `thread_A` מתחיל לרוץ. הוא מבצע `sleep(1)` (המדמה עבודה כלשהי), מגדיל את `counter` ל-1, ומדפיס את מצב המונה.\n3.  לאחר מכן, `thread_A` קורא ל-`sem_post(&sem)`. פעולה זו מגדילה את ערך הסמפור ל-1 ומשחררת את `thread_B` החסום.\n4.  `thread_B` ממשיך את ריצתו, מדפיס הודעה שהוא שוחרר ואת ערך `counter`. בנקודה זו, `counter` כבר עודכן על ידי `thread_A` ולכן ערכו יהיה 1.\n\nהפלט תמיד יציג את ערך המונה כ-1 כאשר `thread_B` מסיים את המתנתו. הסמפור מבטיח ש-`thread_B` ימתין תמיד ל-`thread_A` שיסיים את עדכון המונה וישחרר את הסמפור.\n\nהפלט האפשרי היחיד (בסדר הדפסה ספציפי) הוא:\nThread B: Waiting for semaphore...\nThread A: counter incremented to 1\nThread B: Semaphore acquired. Counter value is 1\n\nייתכן גם סדר הדפסה אחר בין שתי השורות הראשונות (בהתאם לתיזמון), אך השורה האחרונה תמיד תופיע בסוף ותציג את הערך 1."
    },
    "difficulty_estimation": "Easy"
  }
}