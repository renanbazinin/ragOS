{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:24:11",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4189,
      "output_tokens": 810,
      "total_tokens": 6854
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Mutexes",
      "Synchronization",
      "Concurrency",
      "Threads"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בחוטים (threads) ובמנעול (mutex) כדי לעדכן משתנה גלובלי. קראו את הקוד המצורף וענו על השאלה הבאה:\n\nמה יהיה הערך הסופי המודפס של המשתנה הגלובלי `counter` לאחר שכל החוטים יסיימו את ריצתם, ומהי הסיבה לכך?",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h> // For exit\n\n#define NUM_THREADS 5\n#define INCREMENTS_PER_THREAD 100000\n\nint counter = 0;\npthread_mutex_t mtx;\n\nvoid* thread_function(void* arg) {\n    for (int i = 0; i < INCREMENTS_PER_THREAD; ++i) {\n        pthread_mutex_lock(&mtx); // Acquire mutex\n        counter++;\n        pthread_mutex_unlock(&mtx); // Release mutex\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    pthread_mutex_init(&mtx, NULL); // Initialize mutex\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, thread_function, NULL);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", counter);\n\n    pthread_mutex_destroy(&mtx); // Destroy mutex\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הערך הסופי המודפס של המשתנה `counter` יהיה 500000.\n\nהסיבה לכך היא שהתוכנית משתמשת במנעול (mutex) כדי להגן על פעולת העדכון של המשתנה הגלובלי `counter`. כל חוט מבצע את הפעולה `counter++` בתוך קטע קריטי המוגן על ידי `pthread_mutex_lock` ו-`pthread_mutex_unlock`. מנגנון זה מבטיח שרק חוט אחד יכול לגשת ולשנות את `counter` בכל רגע נתון, ובכך מונע מצב מרוץ (race condition). כתוצאה מכך, כל אחת מ-100,000 ההגדלות שמבצע כל חוט (ישנם 5 חוטים) מבוצעת באופן בטוח ומשתקפת בערך הסופי של `counter`.\n\nחישוב: 5 חוטים * 100,000 הגדלות לכל חוט = 500,000."
    },
    "difficulty_estimation": "Easy"
  }
}