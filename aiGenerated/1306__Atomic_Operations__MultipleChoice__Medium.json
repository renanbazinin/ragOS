{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Atomic Operations",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 09:26:13",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1758,
      "output_tokens": 786,
      "total_tokens": 6005
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "Atomic Operations",
      "Synchronization",
      "Concurrency"
    ],
    "content": {
      "text": "נתון מעבד התומך בפעולה האטומית CAS, הניתנת להפעלה ע\"י קריאה לפונקציה:\n`BOOL compareAndSet (int* ptr, int expected, int new);`\n\nסטודנט כתב את הפונקציה הבאה לדימוי פעולת המעבד האטומית `atomic_exchange` (החלפה אטומית) באמצעות פעולת CAS. פעולת `atomic_exchange` אמורה להחליף את הערך ב-`*ptr` ב-`new_val` ולהחזיר את הערך המקורי שהיה ב-`*ptr` לפני ההחלפה.",
      "code_snippet": "BOOL compareAndSet (int* ptr, int expected, int new);\n\nint atomic_exchange_with_cas(int* ptr, int new_val) {\n    int old_val_read;\n    do {\n        old_val_read = *ptr;\n    } while (!compareAndSet(ptr, old_val_read, new_val));\n    return old_val_read;\n}",
      "options": [
        "א. המימוש תקין, ושקול לשימוש בפעולה אטומית `atomic_exchange` מקורית.",
        "ב. המימוש תקין, אך יפגין ביצועים פחות טובים משימוש בפעולה אטומית `atomic_exchange` מקורית.",
        "ג. המימוש לא תקין, שימוש בו עלול לגרום לקיפאון.",
        "ד. המימוש לא תקין, שימוש בו עלול לגרום להרעבה.",
        "ה. המימוש לא תקין, הערך המוחזר לא תמיד יהיה הערך שהיה ב-`*ptr` לפני ההחלפה."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "ב'. המימוש תקין מבחינה לוגית ופונקציונלית. לולאת ה-`do-while` מבטיחה שפעולת ה-`compareAndSet` תצליח רק כאשר `old_val_read` שווה לערך הנוכחי ב-`*ptr`, ובכך מבטיחה אטומיות והחזרת הערך הנכון שהיה ב-`*ptr` לפני ההחלפה. עם זאת, פעולת `atomic_exchange` מקורית (הקיימת בחומרת המעבד) היא בדרך כלל פקודת מעבד בודדת ואטומית, בעוד שהמימוש באמצעות CAS דורש לולאה של קריאה, ניסיון CAS ובדיקת הצלחה. במקרה של תחרות גבוהה, הלולאה עלולה להתבצע מספר פעמים, מה שמוביל לצריכת משאבים גבוהה יותר (busy-waiting) וביצועים נמוכים יותר בהשוואה לפעולה אטומית חומרתית ישירה."
    },
    "difficulty_estimation": "Medium"
  }
}