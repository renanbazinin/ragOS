{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:53:37",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 6793,
      "total_tokens": 19346
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "Inter-Process Communication",
      "Concurrency"
    ],
    "content": {
      "text": "תכננו וכתבו תוכנית בשפת C המדמה תקשורת בין תהליך אב (Parent) לתהליך בן (Child) באמצעות צינור (pipe) ואותות (signals).\n\n**דרישות התוכנית:**\n1.  **יצירת תהליכים ותקשורת:**\n    *   תהליך האב יצור תהליך בן יחיד.\n    *   התקשורת העיקרית בין האב לבן תתבצע באמצעות צינור, כאשר האב כותב נתונים והבן קורא אותם.\n2.  **לוגיקת תהליך הבן:**\n    *   הבן יקרא נתונים מהצינור בלולאה אינסופית (עד לקבלת אות סיום).\n    *   הבן יספור את סך כל הבתים שקרא מהצינור.\n    *   כאשר הבן יקבל את האות `SIGUSR1` מהאב:\n        *   עליו להפסיק זמנית את פעולת הקריאה.\n        *   להדפיס למסך את מספר הבתים הכולל שקרא עד כה (לדוגמה: \"Child received SIGUSR1. Total bytes read: X\").\n        *   לשלוח את האות `SIGUSR2` לאב כדי לאשר את שליחת הדיווח.\n        *   להמשיך לקרוא נתונים מהצינור.\n    *   הבן צריך לטפל באות `SIGTERM` כדי לסיים את פעולתו בצורה מסודרת ולצאת.\n3.  **לוגיקת תהליך האב:**\n    *   האב יכתוב נתונים לצינור במקטעים (לדוגמה, 10 בתים בכל פעם).\n    *   לאחר כל N כתיבות (לדוגמה, כל 5 כתיבות), האב ישלח את האות `SIGUSR1` לבן.\n    *   לאחר שליחת `SIGUSR1`, האב ימתין לקבלת האות `SIGUSR2` מהבן (אישור שהדיווח נשלח) לפני שימשיך בכתיבה.\n    *   לאחר כמות מסוימת של נתונים שנכתבו (לדוגמה, 20 כתיבות סך הכל), האב ישלח את האות `SIGTERM` לבן וימתין לסיומו (באמצעות `waitpid`).\n    *   לאחר שהבן הסתיים, האב יסיים גם הוא.\n4.  **דרישות ספציפיות לאותות וקריאות מערכת:**\n    *   הבן חייב לטפל בקריאת המערכת `read()` כך שתתמודד במפורש עם הפרעה עקב אות (`EINTR`), ללא שימוש בדגל `SA_RESTART` עבור ה-handler של `SIGUSR1`. כלומר, אם `read()` מופרעת עקב `SIGUSR1`, היא צריכה לחזור עם `EINTR` והבן יטפל בכך.\n    *   האב חייב להשתמש בפונקציה `sigsuspend()` כדי להמתין לאות `SIGUSR2` מהבן, תוך הימנעות מ-busy-waiting.\n    *   יש להשתמש ב-`sigaction` להגדרת מטפלי אותות.\n    *   יש לטפל באות `SIGCHLD` בתהליך האב.\n    *   יש לוודא יציאה נקייה של שני התהליכים וסגירת קבצים.\n\n**קוד התחלתי (ניתן להשתמש בו כבסיס):**",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <string.h>\n\n// Global variables for signal handling\nvolatile sig_atomic_t sigusr1_received = 0;\nvolatile sig_atomic_t sigusr2_received = 0;\nvolatile sig_atomic_t sigterm_received = 0;\nvolatile sig_atomic_t sigchld_received = 0;\n\npid_t child_pid = -1; // To store child's PID in parent\n\n// Signal handlers\nvoid sigusr1_handler(int signum) {\n    sigusr1_received = 1;\n}\n\nvoid sigusr2_handler(int signum) {\n    sigusr2_received = 1;\n}\n\nvoid sigterm_handler(int signum) {\n    sigterm_received = 1;\n}\n\nvoid sigchld_handler(int signum) {\n    sigchld_received = 1;\n    // In a real application, you might call waitpid here to reap the child\n    // For this question, we'll waitpid in the main parent loop\n}\n\n// Function to set up signal handlers\nvoid setup_signal_handlers(void) {\n    struct sigaction sa;\n\n    // SIGUSR1 handler (child)\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigusr1_handler;\n    sa.sa_flags = 0; // Do not use SA_RESTART for SIGUSR1 in child\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGUSR1, &sa, NULL) == -1) {\n        perror(\"sigaction SIGUSR1\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGUSR2 handler (parent)\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigusr2_handler;\n    sa.sa_flags = 0; // Not critical for SIGUSR2, but stick to 0\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGUSR2, &sa, NULL) == -1) {\n        perror(\"sigaction SIGUSR2\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGTERM handler (child)\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigterm_handler;\n    sa.sa_flags = 0;\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGTERM, &sa, NULL) == -1) {\n        perror(\"sigaction SIGTERM\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGCHLD handler (parent)\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigchld_handler;\n    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP; // SA_RESTART is fine for SIGCHLD, SA_NOCLDSTOP avoids extra signals\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// Parent process logic\nvoid parent_logic(int write_fd, int read_fd) {\n    // Implement parent logic here\n    // Remember to close unused pipe ends\n    close(read_fd); // Parent does not read from pipe\n    \n    // ...\n    close(write_fd); // Close after done writing\n}\n\n// Child process logic\nvoid child_logic(int read_fd, int write_fd) {\n    // Implement child logic here\n    // Remember to close unused pipe ends\n    close(write_fd); // Child does not write to pipe (except for SIGUSR2 ack, but that's not pipe)\n    \n    // ...\n    close(read_fd); // Close after done reading\n}\n\nint main() {\n    int pipe_fds[2]; // pipe_fds[0] for read, pipe_fds[1] for write\n\n    if (pipe(pipe_fds) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    setup_signal_handlers();\n\n    child_pid = fork();\n    if (child_pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (child_pid == 0) { // Child process\n        child_logic(pipe_fds[0], pipe_fds[1]);\n    } else { // Parent process\n        parent_logic(pipe_fds[1], pipe_fds[0]);\n    }\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**הסבר כללי לפתרון:**\nהפתרון מתמודד עם האתגרים של תקשורת בין-תהליכית באמצעות צינור ואותות, תוך הקפדה על טיפול נכון בהפרעות קריאות מערכת על ידי אותות ובמניעת busy-waiting. נשתמש ב-`sigaction` להגדרת מטפלי אותות, וב-`volatile sig_atomic_t` למשתנים גלובליים שאליהם ניגשים מטפלי האותות.\n\n**פירוט ומימוש:**\n\n1.  **הגדרת מטפלי אותות (`setup_signal_handlers`):**\n    *   עבור `SIGUSR1` (בתהליך הבן): המטפל יסמן דגל `sigusr1_received`. חשוב להגדיר `sa.sa_flags = 0` (או לא להגדיר `SA_RESTART`) כדי שקריאות מערכת כמו `read()` יופרעו ויחזרו עם `EINTR`, כנדרש בשאלה.\n    *   עבור `SIGUSR2` (בתהליך האב): המטפל יסמן דגל `sigusr2_received`. גם כאן, `sa.sa_flags = 0` מומלץ.\n    *   עבור `SIGTERM` (בתהליך הבן): המטפל יסמן דגל `sigterm_received` כדי לאותת ללולאה הראשית לצאת.\n    *   עבור `SIGCHLD` (בתהליך האב): המטפל יסמן דגל `sigchld_received`. כאן, `SA_RESTART` ו-`SA_NOCLDSTOP` הם דגלים שימושיים, אך לא קריטיים ללוגיקה המרכזית של השאלה.\n\n2.  **לוגיקת תהליך הבן (`child_logic`):**\n    *   **סגירת קצה הצינור שאינו בשימוש:** הבן סוגר את `write_fd`.\n    *   **לולאת קריאה:** הבן נכנס ללולאה אינסופית הקוראת מהצינור.\n    *   **טיפול ב-`read()` ו-`EINTR`:**\n        *   קריאת ה-`read()` ממוקמת בתוך לולאה פנימית (`do-while`) כדי לטפל במקרה של `EINTR`. אם `read()` מופרעת עקב אות וחוזרת עם `errno == EINTR`, הלולאה הפנימית תמשיך לנסות לקרוא. ישנה בדיקה נוספת לדגל `sigterm_received` בתוך לולאת ה-`do-while` כדי לצאת במהירות אם האות הגיע.\n        *   ברגע ש-`read()` חוזרת בהצלחה (או עם שגיאה אחרת), הדגל `sigusr1_received` נבדק.\n    *   **טיפול ב-`SIGUSR1`:**\n        *   אם `sigusr1_received` מסומן, הבן מאפס את הדגל, מדפיס את מספר הבתים שנקראו (`total_bytes_read`), ושולח `SIGUSR2` לאב באמצעות `kill(getppid(), SIGUSR2)`.\n    *   **טיפול ב-`SIGTERM`:**\n        *   הלולאה הראשית תמשיך כל עוד `sigterm_received` אינו מסומן. ברגע שהוא מסומן, הלולאה נשברת, הבן סוגר את קצה הצינור שברשותו ויוצא.\n\n3.  **לוגיקת תהליך האב (`parent_logic`):**\n    *   **סגירת קצה הצינור שאינו בשימוש:** האב סוגר את `read_fd`.\n    *   **כתיבה לצינור ושליחת אותות:**\n        *   האב כותב נתונים לצינור במקטעים.\n        *   לאחר כל `REPORT_INTERVAL` כתיבות:\n            *   האב שולח `SIGUSR1` לבן (`kill(child_pid, SIGUSR1)`).\n            *   **המתנה ל-`SIGUSR2` באמצעות `sigsuspend()`:**\n                *   כדי למנוע תנאי מירוץ (race condition) בו `SIGUSR2` מגיע לפני שהאב נכנס ל-`sigsuspend`, יש לחסום את `SIGUSR2` לפני שליחת `SIGUSR1`.\n                *   מסיכה חדשה (`sigset_t`) מוגדרת ובה חסום `SIGUSR2` בלבד. `sigprocmask(SIG_BLOCK, &block_mask, &old_mask)` חוסם את `SIGUSR2` ושומר את המסיכה הקודמת.\n                *   לאחר שליחת `SIGUSR1`, האב מאפס את `sigusr2_received` (חשוב למקרה שהאות הגיע מוקדם מדי לפני החסימה, או נשאר מסומן מאיטרציה קודמת), ונכנס ללולאה שבה הוא קורא ל-`sigsuspend(&wait_mask)`. `wait_mask` היא מסיכה שבה `SIGUSR2` אינו חסום, מה שמאפשר לו להתקבל. `wait_mask` נוצרת על בסיס `old_mask` (המסיכה הנוכחית של האב) עם הסרה זמנית של `SIGUSR2`.\n                *   `sigsuspend` מחליפה באופן אטומי את מסיכת האותות של התהליך ל-`wait_mask` וממתינה לאות שאינו חסום. לאחר קבלת אות כזה (במקרה שלנו, `SIGUSR2`), היא משחזרת את המסיכה המקורית (`old_mask`) וחוזרת.\n                *   הלולאה נמשכת כל עוד `sigusr2_received` אינו מסומן.\n                *   לאחר שהאות התקבל, `sigusr2_received` מאופס, ומסיכת האותות המקורית משוחזרת באמצעות `sigprocmask(SIG_SETMASK, &old_mask, NULL)`.\n    *   **סיום התהליך הבן:**\n        *   לאחר כמות כוללת של כתיבות (`TOTAL_WRITES`), האב שולח `SIGTERM` לבן (`kill(child_pid, SIGTERM)`).\n        *   האב ממתין לסיום הבן באמצעות `waitpid(child_pid, &status, 0)`.\n        *   לאחר שהבן הסתיים, האב סוגר את קצה הצינור שברשותו ויוצא.\n\n**יתרונות הפתרון:**\n*   **טיפול נכון ב-`EINTR`:** הבן מטפל באופן מפורש בהפרעות לקריאת `read()`, כנדרש.\n*   **מניעת תנאי מירוץ ו-busy-waiting:** האב משתמש ב-`sigsuspend()` בשילוב עם חסימת אותות כדי להמתין ביעילות ובבטחה לאישור מהבן, ללא צריכת משאבי CPU מיותרים.\n*   **יציאה נקייה:** שני התהליכים מטפלים באותות סיום ויוצאים בצורה מסודרת, ומשחררים משאבים (סגירת צינורות).\n*   **שימוש ב-`sigaction`:** מבטיח טיפול מודרני ואמין באותות.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <string.h>\n\n// Global variables for signal handling\nvolatile sig_atomic_t sigusr1_received = 0;\nvolatile sig_atomic_t sigusr2_received = 0;\nvolatile sig_atomic_t sigterm_received = 0;\nvolatile sig_atomic_t sigchld_received = 0;\n\npid_t child_pid = -1; // To store child's PID in parent\n\n#define REPORT_INTERVAL 5 // Parent sends SIGUSR1 every 5 writes\n#define TOTAL_WRITES 20   // Parent performs 20 writes in total\n#define DATA_CHUNK_SIZE 10 // Bytes per write operation\n\n// Signal handlers\nvoid sigusr1_handler(int signum) {\n    sigusr1_received = 1;\n}\n\nvoid sigusr2_handler(int signum) {\n    sigusr2_received = 1;\n}\n\nvoid sigterm_handler(int signum) {\n    sigterm_received = 1;\n}\n\nvoid sigchld_handler(int signum) {\n    sigchld_received = 1;\n    // In a real application, you might call waitpid here to reap the child\n    // For this question, we'll waitpid in the main parent loop\n}\n\n// Function to set up signal handlers\nvoid setup_signal_handlers(void) {\n    struct sigaction sa;\n\n    // SIGUSR1 handler (child)\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigusr1_handler;\n    sa.sa_flags = 0; // Do not use SA_RESTART for SIGUSR1 in child\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGUSR1, &sa, NULL) == -1) {\n        perror(\"sigaction SIGUSR1\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGUSR2 handler (parent)\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigusr2_handler;\n    sa.sa_flags = 0; // Not critical for SIGUSR2, but stick to 0\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGUSR2, &sa, NULL) == -1) {\n        perror(\"sigaction SIGUSR2\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGTERM handler (child)\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigterm_handler;\n    sa.sa_flags = 0;\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGTERM, &sa, NULL) == -1) {\n        perror(\"sigaction SIGTERM\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGCHLD handler (parent)\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigchld_handler;\n    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP; // SA_RESTART is fine for SIGCHLD, SA_NOCLDSTOP avoids extra signals\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// Parent process logic\nvoid parent_logic(int write_fd, int read_fd_unused) {\n    close(read_fd_unused); // Parent does not read from pipe\n\n    char buffer[DATA_CHUNK_SIZE];\n    int bytes_written_total = 0;\n    int write_count = 0;\n\n    printf(\"Parent %d: Starting to write data and send signals.\\n\", getpid());\n\n    sigset_t block_mask, old_mask, wait_mask;\n\n    // Block SIGUSR2 before sending SIGUSR1 to prevent race conditions\n    sigemptyset(&block_mask);\n    sigaddset(&block_mask, SIGUSR2);\n    if (sigprocmask(SIG_BLOCK, &block_mask, &old_mask) == -1) {\n        perror(\"sigprocmask SIG_BLOCK\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Configure wait_mask to unblock SIGUSR2 for sigsuspend\n    // sigsuspend temporarily uses this mask, so it should be old_mask with SIGUSR2 unblocked\n    wait_mask = old_mask; // Start with the parent's current blocked signals\n    sigdelset(&wait_mask, SIGUSR2); // Temporarily unblock SIGUSR2 for sigsuspend\n\n    for (int i = 0; i < TOTAL_WRITES; ++i) {\n        memset(buffer, 'A' + (i % 26), DATA_CHUNK_SIZE); // Fill buffer with some data\n        \n        printf(\"Parent %d: Writing %d bytes (chunk %d/%d).\\n\", getpid(), DATA_CHUNK_SIZE, i + 1, TOTAL_WRITES);\n        if (write(write_fd, buffer, DATA_CHUNK_SIZE) == -1) {\n            perror(\"parent write\");\n            break;\n        }\n        bytes_written_total += DATA_CHUNK_SIZE;\n        write_count++;\n\n        if (write_count % REPORT_INTERVAL == 0) {\n            printf(\"Parent %d: Sending SIGUSR1 to child %d for report.\\n\", getpid(), child_pid);\n            if (kill(child_pid, SIGUSR1) == -1) {\n                perror(\"parent kill SIGUSR1\");\n                break;\n            }\n\n            // Reset flag and wait for SIGUSR2 from child using sigsuspend\n            sigusr2_received = 0;\n            printf(\"Parent %d: Waiting for SIGUSR2 from child %d...\\n\", getpid(), child_pid);\n            while (!sigusr2_received) {\n                // sigsuspend atomically replaces the current signal mask with wait_mask\n                // and waits for a signal. When a signal is caught, the original mask\n                // is restored and sigsuspend returns.\n                if (sigsuspend(&wait_mask) == -1 && errno != EINTR) {\n                    perror(\"sigsuspend\");\n                    // Handle other errors if necessary, but EINTR is expected when a signal wakes it up\n                }\n            }\n            sigusr2_received = 0; // Reset for next iteration\n            printf(\"Parent %d: Received SIGUSR2. Continuing writes.\\n\", getpid());\n        }\n        sleep(1); // Simulate work\n    }\n\n    // Unblock SIGUSR2 before terminating to ensure clean exit\n    if (sigprocmask(SIG_SETMASK, &old_mask, NULL) == -1) {\n        perror(\"sigprocmask SIG_SETMASK\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Parent %d: Finished writing. Total bytes written: %d. Sending SIGTERM to child %d.\\n\", getpid(), bytes_written_total, child_pid);\n    if (kill(child_pid, SIGTERM) == -1) {\n        perror(\"parent kill SIGTERM\");\n    }\n\n    close(write_fd); // Close after done writing\n\n    // Wait for child to terminate\n    int status;\n    while (waitpid(child_pid, &status, 0) == -1) {\n        if (errno == EINTR) {\n            continue; // Interrupted by a signal, try again\n        } else {\n            perror(\"parent waitpid\");\n            break;\n        }\n    }\n\n    if (WIFEXITED(status)) {\n        printf(\"Parent %d: Child %d exited with status %d.\\n\", getpid(), child_pid, WEXITSTATUS(status));\n    } else if (WIFSIGNALED(status)) {\n        printf(\"Parent %d: Child %d terminated by signal %d.\\n\", getpid(), child_pid, WTERMSIG(status));\n    }\n\n    printf(\"Parent %d: Exiting.\\n\", getpid());\n}\n\n// Child process logic\nvoid child_logic(int read_fd, int write_fd_unused) {\n    close(write_fd_unused); // Child does not write to pipe\n\n    char buffer[DATA_CHUNK_SIZE];\n    ssize_t bytes_read;\n    long total_bytes_read = 0;\n\n    printf(\"Child %d: Starting to read data.\\n\", getpid());\n\n    while (!sigterm_received) {\n        bytes_read = 0;\n        do {\n            bytes_read = read(read_fd, buffer, sizeof(buffer));\n        } while (bytes_read == -1 && errno == EINTR && !sigterm_received); // Loop until read succeeds or non-EINTR error or SIGTERM\n\n        if (sigterm_received) {\n            printf(\"Child %d: SIGTERM received, exiting read loop.\\n\", getpid());\n            break; // Exit main loop if SIGTERM was received during read or while waiting for read\n        }\n\n        if (bytes_read == -1) {\n            perror(\"child read\");\n            break; // Exit on other read errors\n        }\n        if (bytes_read == 0) {\n            printf(\"Child %d: End of file (pipe closed by parent).\\n\", getpid());\n            break; // Parent closed the pipe\n        }\n\n        total_bytes_read += bytes_read;\n        printf(\"Child %d: Read %zd bytes. Total: %ld.\\n\", getpid(), bytes_read, total_bytes_read);\n\n        if (sigusr1_received) {\n            sigusr1_received = 0; // Reset flag\n            printf(\"Child %d: Received SIGUSR1. Total bytes read: %ld. Sending SIGUSR2 to parent %d.\\n\", getpid(), total_bytes_read, getppid());\n            if (kill(getppid(), SIGUSR2) == -1) {\n                perror(\"child kill SIGUSR2\");\n            }\n        }\n    }\n\n    close(read_fd); // Close after done reading\n    printf(\"Child %d: Exiting. Total bytes read: %ld.\\n\", getpid(), total_bytes_read);\n    exit(EXIT_SUCCESS);\n}\n\nint main() {\n    int pipe_fds[2]; // pipe_fds[0] for read, pipe_fds[1] for write\n\n    if (pipe(pipe_fds) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    setup_signal_handlers();\n\n    child_pid = fork();\n    if (child_pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (child_pid == 0) { // Child process\n        child_logic(pipe_fds[0], pipe_fds[1]);\n    } else { // Parent process\n        parent_logic(pipe_fds[1], pipe_fds[0]);\n    }\n\n    return 0;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}