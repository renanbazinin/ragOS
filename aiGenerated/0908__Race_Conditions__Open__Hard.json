{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Race Conditions",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 01:14:15",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4708,
      "output_tokens": 3102,
      "total_tokens": 11828
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Race Conditions",
      "Synchronization",
      "Multithreading"
    ],
    "content": {
      "text": "נתון קטע קוד בשפת C++ המדמה ניהול יתרת חשבון בנק משותף על ידי מספר תהליכונים (threads) הפועלים במקביל. תהליכונים אלו מבצעים פעולות הפקדה ומשיכה על היתרה הגלובלית `balance`.",
      "code_snippet": "#include <iostream>\n#include <thread>\n#include <vector>\n\n// משתנה גלובלי משותף המייצג את יתרת החשבון\nint balance = 0;\n\n// פונקציית הפקדה\nvoid deposit(int amount) {\n    balance = balance + amount;\n}\n\n// פונקציית משיכה\nvoid withdraw(int amount) {\n    balance = balance - amount;\n}\n\n// פונקציה שתהליכונים יריצו (לדוגמה)\nvoid account_operations(int num_transactions, int deposit_amount, int withdraw_amount) {\n    for (int i = 0; i < num_transactions; ++i) {\n        deposit(deposit_amount);\n        withdraw(withdraw_amount);\n    }\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "זהו את תנאי המירוץ (Race Condition) בקטע הקוד הנתון. הסבירו בפירוט מדוע הוא מתרחש, כולל דוגמה ספציפית של סדר פעולות (interleaving) בין שני תהליכונים המובילה לתוצאה שגויה. התייחסו לפעולות ברמת המכונה (לדוגמה: Load, Add, Store).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "הציעו פתרון למניעת תנאי המירוץ באמצעות מנגנון סנכרון מתאים (לדוגמה: mutex). הציגו את קטע הקוד המתוקן.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "הסבירו כיצד הפתרון שהצעתם מונע את תנאי המירוץ. דון בחלופות אפשריות (כגון סמפורים או פעולות אטומיות) ויתרונותיהן/חסרונותיהן בהקשר זה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.4",
        "text": "האם הפתרון שהצעתם עלול להכניס מצב של קיפאון (Deadlock) או הרעבה (Starvation)? נמקו את תשובתכם.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "10.1: תנאי המירוץ מתרחש בפעולות העדכון של המשתנה `balance` הן בפונקציה `deposit` והן בפונקציה `withdraw`. כל אחת מהפעולות הללו אינה אטומית, אלא מורכבת ממספר הוראות מכונה:\n1. טעינת הערך הנוכחי של `balance` לרג'יסטר (Load).\n2. ביצוע פעולה אריתמטית (חיבור/חיסור) על הערך שברג'יסטר (Add/Subtract).\n3. שמירת הערך החדש מהרג'יסטר חזרה ל-`balance` (Store).\n\nכאשר שני תהליכונים או יותר מנסים לבצע פעולות אלו במקביל, סדר הפעולות ביניהם אינו מובטח, ועלול להוביל לאיבוד עדכונים.\n\nדוגמה לסדר פעולות המוביל לתוצאה שגויה:\nנניח ש-`balance` = 100. שני תהליכונים, T1 ו-T2, מנסים שניהם לבצע `deposit(10)`.\n* T1: Load balance (100) - T1 קורא את 100.\n* T2: Load balance (100) - T2 קורא גם הוא את 100, כי T1 עדיין לא עדכן.\n* T1: Add 10 (result: 110) - T1 מחשב את הערך החדש.\n* (קדם-הדחה / Preemption) - מערכת ההפעלה מעבירה את השליטה ל-T2.\n* T2: Add 10 (result: 110) - T2 מחשב את הערך החדש.\n* T2: Store 110 to balance. (`balance` = 110) - T2 כותב את 110 חזרה לזיכרון.\n* (קדם-הדחה / Preemption) - מערכת ההפעלה מעבירה את השליטה חזרה ל-T1.\n* T1: Store 110 to balance. (`balance` = 110) - T1 כותב את 110 חזרה לזיכרון, דורס את העדכון של T2 (או כותב את אותו ערך).\n\nהתוצאה הסופית היא 110, למרות שהייתה צריכה להיות 120 (100 + 10 + 10). העדכון של אחד מהתהליכונים אבד. מצב דומה יכול להתרחש עם `withdraw` או שילוב של `deposit` ו-`withdraw`.\n\n10.2: כדי למנוע תנאי מירוץ, יש להבטיח שהגישה למשתנה המשותף `balance` תהיה הדדית-בלעדית (mutually exclusive). ניתן לעשות זאת באמצעות מנעול (mutex).\n\nקוד מתוקן עם mutex:\n```cpp\n#include <iostream>\n#include <thread>\n#include <vector>\n#include <mutex> // Include for std::mutex\n\n// משתנה גלובלי משותף המייצג את יתרת החשבון\nint balance = 0;\n\n// מנעול גלובלי להגנה על המשתנה balance\nstd::mutex balance_mutex;\n\n// פונקציית הפקדה\nvoid deposit(int amount) {\n    balance_mutex.lock(); // נעל את המנעול לפני גישה למשתנה המשותף\n    balance = balance + amount;\n    balance_mutex.unlock(); // שחרר את המנעול לאחר סיום הגישה\n}\n\n// פונקציית משיכה\nvoid withdraw(int amount) {\n    balance_mutex.lock(); // נעל את המנעול\n    balance = balance - amount;\n    balance_mutex.unlock(); // שחרר את המנעול\n}\n\n// פונקציה שתהליכונים יריצו (לדוגמה)\nvoid account_operations(int num_transactions, int deposit_amount, int withdraw_amount) {\n    for (int i = 0; i < num_transactions; ++i) {\n        deposit(deposit_amount);\n        withdraw(withdraw_amount);\n    }\n}\n```\n\n10.3: הפתרון עם mutex מונע את תנאי המירוץ על ידי הבטחת הדדיות-בלעדית לאזור הקריטי (critical section) – הקוד המעדכן את `balance`. כאשר תהליכון אחד נועל את ה-mutex, כל תהליכון אחר שינסה לנעול אותו ייחסם (ימתין) עד שהתהליכון הראשון ישחרר את המנעול. זה מבטיח שרק תהליכון אחד יוכל לבצע את רצף הפעולות Load-Modify-Store על `balance` בכל רגע נתון, ובכך מונע איבוד עדכונים.\n\nחלופות:\n*   **סמפור בינארי (Binary Semaphore)**: סמפור בינארי יכול לשמש כמו mutex. הוא מאפשר לנעול משאב (ערך 1) ולשחרר אותו (ערך 0). השימוש יהיה דומה: `wait()` לפני האזור הקריטי ו-`signal()` אחריו. יתרונות וחסרונות דומים ל-mutex בהקשר זה.\n*   **פעולות אטומיות (Atomic Operations)**: עבור פעולות פשוטות כמו חיבור/חיסור על משתנים מספריים, ניתן להשתמש בפעולות אטומיות (כמו `std::atomic<int>::fetch_add` או `std::atomic<int>::fetch_sub` ב-C++). פעולות אלו מובטחות להתבצע כיחידה בלתי ניתנת לחלוקה ברמת החומרה/תוכנה, ולכן אינן דורשות מנעולים מפורשים.\n    *   **יתרונות פעולות אטומיות**: ביצועים טובים יותר במקרים רבים (במיוחד במערכות מרובות מעבדים) מכיוון שהן נמנעות מהתקורה של נעילה ושחרור mutex (המצריך לעיתים קרובות מעבר למצב קרנל). הן גם מאפשרות רמה גבוהה יותר של קונקרנטיות (concurrency) שכן אינן חוסמות תהליכונים אחרים באופן גורף כמו מנעול.\n    *   **חסרונות פעולות אטומיות**: מתאימות רק לפעולות פשוטות ואטומיות מטבען. אם האזור הקריטי מורכב ממספר רב של פעולות או כולל לוגיקה מורכבת, mutex או סמפור עשויים להיות מתאימים יותר וקלים יותר ליישום נכון. במקרה שלנו, הפעולה של `balance = balance + amount` היא פעולה פשוטה שיכולה להיות מיושמת אטומית.\n*   **Read-Write Locks (מנעולי קריאה-כתיבה)**: אם יש הרבה פעולות קריאה ומעט פעולות כתיבה, ניתן להשתמש במנעולי קריאה-כתיבה. הם מאפשרים למספר תהליכונים לקרוא במקביל, אך רק לתהליכון אחד לכתוב (ובזמן כתיבה, אף אחד לא יכול לקרוא). במקרה זה, `deposit` ו-`withdraw` הן שתיהן פעולות כתיבה-שינוי, ולכן ידרשו מנעול כתיבה, מה שהופך אותן לדומות ל-mutex מבחינת הדדיות-בלעדית.\n\n10.4: הפתרון שהוצע באמצעות `std::mutex` אינו עלול להכניס מצב של קיפאון (Deadlock) או הרעבה (Starvation) במקרה הספציפי הזה, מהסיבות הבאות:\n\n*   **קיפאון (Deadlock)**: קיפאון מתרחש כאשר שני תהליכונים או יותר חוסמים זה את זה באופן הדדי וממתינים למשאבים שבידי השני. במקרה זה, יש רק משאב משותף אחד (ה-`balance_mutex`) וכל תהליכון נועל אותו, מבצע את פעולתו, ומשחרר אותו. אין רצף של נעילות מרובות שעלול להוביל למעגל המתנה. כלומר, לא מתקיימים התנאים ההכרחיים לקיפאון (בפרט, אין \"Hold and Wait\" ואין \"Circular Wait\" על מנעולים שונים).\n*   **הרעבה (Starvation)**: הרעבה מתרחשת כאשר תהליכון אחד או יותר לעולם אינו מקבל גישה למשאב, למרות שהוא זמין. במערכות הפעלה מודרניות, מנגנוני התזמון של ה-mutex (או סמפורים) בדרך כלל הוגנים מספיק כדי למנוע הרעבה מוחלטת. תהליכונים הממתינים למנעול בדרך כלל נכנסים לתור, ומובטח להם בסופו של דבר לקבל את המנעול כשישתחרר. אמנם ייתכן שתהליכון ימתין זמן רב אם יש תחרות גבוהה מאוד, אך הוא לא יורעב באופן תיאורטי (כלומר, לא ימתין לנצח) כל עוד התהליכונים האחרים משחררים את המנעול. לכן, הפתרון עם mutex הוא בטוח יחסית בהקשר זה."
    },
    "difficulty_estimation": "Hard"
  }
}