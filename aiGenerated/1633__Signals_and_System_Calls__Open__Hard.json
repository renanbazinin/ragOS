{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 12:00:15",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 3721,
      "total_tokens": 16103
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "Process Management",
      "Concurrency"
    ],
    "content": {
      "text": "תהליך אב יוצר מספר קבוע של תהליכי בן (לדוגמה, `NUM_CHILDREN = 3`). כל תהליך בן מדמה עבודה על ידי קריאה ל-`sleep()` למשך זמן אקראי (בין 1 ל-5 שניות) ואז יוצא עם קוד יציאה המציין את זמן השינה שלו. תהליך האב נדרש להמתין שכל תהליכי הבן יסיימו את עבודתם, אך עם מגבלת זמן כוללת של `TOTAL_TIMEOUT` שניות (לדוגמה, `TOTAL_TIMEOUT = 7`).\n\nאם כל הבנים מסיימים לפני תום ה-`TOTAL_TIMEOUT`, האב צריך להדפיס את ה-PID וסטטוס היציאה של כל אחד מהם. אם ה-`TOTAL_TIMEOUT` פג לפני שכל הבנים סיימו, האב צריך לסיים את כל תהליכי הבן שעדיין רצים (באמצעות `SIGKILL`), ולאחר מכן להדפיס את ה-PID וסטטוס היציאה של כל הבנים (כולל אלה שסיימו באופן רגיל ואלה שחוסלו על ידו).\n\nכתבו תוכנית ב-C המממשת את הלוגיקה הנדרשת. שימו לב לטפל כראוי בטיפול באותות (`SIGCHLD`, `SIGALRM`) ובמצבי מרוץ אפשריים, במיוחד סביב יצירת תהליכים והמתנה להם. יש להשתמש בפונקציות `sigaction` לטיפול באותות.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון דורש תיאום בין טיפול באותות (`SIGCHLD` ו-`SIGALRM`) לבין ניהול תהליכים (`fork`, `waitpid`, `kill`).\n\n**1. הגדרת משתנים גלובליים:**\n   - `children_remaining`: מונה את מספר הילדים שעדיין לא נאספו על ידי האב.\n   - `timeout_expired`: דגל המציין אם פג הזמן הכולל.\n   - `child_pids`: מערך לאחסון ה-PIDs של כל הילדים שנוצרו.\n   - `child_exit_statuses`: מערך לאחסון סטטוסי היציאה של הילדים לאחר איסופם.\n   - `child_reaped`: מערך דגלים למעקב אילו ילדים כבר נאספו.\n   השימוש ב-`volatile` הכרחי למשתנים שמשותפים בין הקוד הראשי למטפלי אותות, כדי להבטיח שהמהדר לא יבצע אופטימיזציות שגויות.\n\n**2. מטפל האותות `SIGCHLD` (`handle_sigchld`):**\n   - תפקידו לאסוף ילדים מומתים כדי למנוע יצירת תהליכי זומבי.\n   - הוא משתמש בלולאה עם `waitpid(-1, &status, WNOHANG)` כדי לאסוף את כל הילדים שסיימו את דרכם.\n   - עבור כל ילד שנאסף, הוא מעדכן את מערכי ה-`child_exit_statuses` ו-`child_reaped` ומקטין את `children_remaining`.\n   - אם כל הילדים נאספו, הוא מבטל את ה-`alarm` באמצעות `alarm(0)` כדי למנוע קבלת `SIGALRM` מיותר.\n\n**3. מטפל האותות `SIGALRM` (`handle_sigalrm`):**\n   - פשוט מציב את הדגל `timeout_expired` ל-1 ומבטל את ה-`alarm`.\n\n**4. פונקציית `main`:**\n   - **הגדרת מטפלי אותות:** משתמשים ב-`sigaction` (במקום `signal` הישנה והפחות אמינה) להגדרת המטפלים. דגלי `SA_RESTART` ו-`SA_NOCLDSTOP` מוגדרים עבור `SIGCHLD` כדי להבטיח שקריאות מערכת כמו `pause()` יופעלו מחדש לאחר הטיפול באות, ושלא נקבל אות על עצירה של ילד.\n   - **חסימת `SIGCHLD` במהלך `fork`:** לפני יצירת הילדים, `SIGCHLD` נחסם זמנית באמצעות `sigprocmask`. זה מונע מצב מרוץ שבו ילד מסיים את דרכו מיד לאחר ה-`fork` אך לפני שהאב מספיק לאחסן את ה-PID שלו במערך ה-`child_pids`, מה שעלול לגרום לילד להיאסף על ידי המטפל לפני שהאב בכלל יודע עליו.\n   - **יצירת ילדים:** לולאה יוצרת `NUM_CHILDREN` ילדים. כל ילד קורא ל-`sleep()` לזמן אקראי ויוצא עם קוד יציאה מתאים. האב מאחסן את ה-PIDs של הילדים.\n   - **שחרור חסימת `SIGCHLD`:** לאחר יצירת כל הילדים, `SIGCHLD` משוחרר באמצעות `sigprocmask`. כעת, אם אותות `SIGCHLD` היו תלויים, הם יטופלו מיד.\n   - **הפעלת טיימר:** `alarm(TOTAL_TIMEOUT)` מוגדר כדי להפעיל `SIGALRM` לאחר הזמן הכולל שנקבע.\n   - **המתנה לאירועים:** האב נכנס ללולאה `while (children_remaining > 0 && !timeout_expired) { pause(); }`. הפונקציה `pause()` משעה את התהליך עד שיתקבל אות כלשהו (או `SIGCHLD` או `SIGALRM`).\n   - **טיפול בפקיעת זמן:** אם `timeout_expired` הוא 1, האב עובר על כל הילדים. עבור כל ילד שטרם נאסף (`child_reaped[i] == 0`), הוא שולח `SIGKILL` כדי לסיים אותו בכוח.\n   - **המתנה לאיסוף כל הילדים:** לאחר מכן, האב ממשיך להמתין באמצעות `while (children_remaining > 0) { pause(); }` עד שכל הילדים (כולל אלה שחוסלו זה עתה) ייאספו על ידי מטפל ה-`SIGCHLD`.\n   - **הדפסת סיכום:** לבסוף, האב מדפיס את ה-PID וסטטוס היציאה של כל ילד, תוך הבחנה אם יצא באופן רגיל או חוסל על ידי אות.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <time.h>\n#include <string.h> // For memset\n\n#define NUM_CHILDREN 3\n#define TOTAL_TIMEOUT 7 // seconds\n\n// Global variables to be accessed by signal handlers and main\nvolatile int children_remaining = NUM_CHILDREN;\nvolatile int timeout_expired = 0;\npid_t child_pids[NUM_CHILDREN];\nint child_exit_statuses[NUM_CHILDREN];\nvolatile int child_reaped[NUM_CHILDREN] = {0}; // 1 if reaped, 0 otherwise\n\n// SIGCHLD signal handler\nvoid handle_sigchld(int signum) {\n    int status;\n    pid_t pid;\n    // Reap all terminated children to prevent zombies\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        for (int i = 0; i < NUM_CHILDREN; i++) {\n            if (child_pids[i] == pid) {\n                child_exit_statuses[i] = status;\n                if (child_reaped[i] == 0) { // Only decrement if not already reaped\n                    children_remaining--;\n                    child_reaped[i] = 1;\n                }\n                break;\n            }\n        }\n    }\n\n    if (children_remaining == 0) {\n        alarm(0); // Cancel alarm if all children are reaped\n    }\n}\n\n// SIGALRM signal handler\nvoid handle_sigalrm(int signum) {\n    timeout_expired = 1;\n    alarm(0); // Ensure alarm is off\n}\n\nint main() {\n    srand(time(NULL)); // Seed for random sleep times\n\n    // 1. Set up signal handlers for SIGCHLD and SIGALRM\n    struct sigaction sa_chld, sa_alrm;\n\n    // SIGCHLD handler setup\n    memset(&sa_chld, 0, sizeof(sa_chld));\n    sa_chld.sa_handler = handle_sigchld;\n    sigemptyset(&sa_chld.sa_mask); // No additional signals blocked inside handler\n    sa_chld.sa_flags = SA_RESTART | SA_NOCLDSTOP; // Restart interrupted syscalls, don't get signal for stopped children\n    if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGALRM handler setup\n    memset(&sa_alrm, 0, sizeof(sa_alrm));\n    sa_alrm.sa_handler = handle_sigalrm;\n    sigemptyset(&sa_alrm.sa_mask); // No additional signals blocked inside handler\n    sa_alrm.sa_flags = SA_RESTART; // Restart interrupted syscalls\n    if (sigaction(SIGALRM, &sa_alrm, NULL) == -1) {\n        perror(\"sigaction SIGALRM\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 2. Block SIGCHLD temporarily during fork loop to prevent race conditions\n    sigset_t block_chld, old_mask;\n    sigemptyset(&block_chld);\n    sigaddset(&block_chld, SIGCHLD);\n    if (sigprocmask(SIG_BLOCK, &block_chld, &old_mask) == -1) {\n        perror(\"sigprocmask SIG_BLOCK\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 3. Fork children\n    printf(\"Parent (PID %d) is creating %d children.\\n\", getpid(), NUM_CHILDREN);\n    for (int i = 0; i < NUM_CHILDREN; i++) {\n        pid_t pid = fork();\n\n        if (pid == -1) {\n            perror(\"fork\");\n            sigprocmask(SIG_SETMASK, &old_mask, NULL); // Unblock SIGCHLD on error\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) { // Child process\n            sigprocmask(SIG_SETMASK, &old_mask, NULL); // Restore original mask for child\n\n            srand(getpid() ^ time(NULL)); // Re-seed for child\n            int sleep_time = (rand() % 5) + 1; // Sleep 1 to 5 seconds\n            printf(\"Child %d (PID %d) starting, will sleep for %d seconds.\\n\", i + 1, getpid(), sleep_time);\n            sleep(sleep_time);\n            printf(\"Child %d (PID %d) finished.\\n\", i + 1, getpid());\n            exit(sleep_time); // Exit with sleep time as status\n        } else { // Parent process\n            child_pids[i] = pid;\n            // child_reaped[i] initialized to 0 globally\n        }\n    }\n\n    // 4. Unblock SIGCHLD now that all children are spawned and their PIDs recorded\n    if (sigprocmask(SIG_SETMASK, &old_mask, NULL) == -1) {\n        perror(\"sigprocmask SIG_SETMASK\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 5. Start the global alarm\n    printf(\"Parent setting alarm for %d seconds.\\n\", TOTAL_TIMEOUT);\n    alarm(TOTAL_TIMEOUT);\n\n    // 6. Parent waits for children to finish or timeout to expire\n    // Use pause() to efficiently wait for signals\n    while (children_remaining > 0 && !timeout_expired) {\n        pause(); // Will be interrupted by SIGCHLD or SIGALRM\n    }\n\n    // 7. Handle timeout expiration\n    if (timeout_expired) {\n        printf(\"\\nTimeout expired! Parent (PID %d) is terminating remaining children.\\n\", getpid());\n        for (int i = 0; i < NUM_CHILDREN; i++) {\n            if (child_reaped[i] == 0) { // If child hasn't been reaped yet\n                printf(\"Killing child PID %d.\\n\", child_pids[i]);\n                if (kill(child_pids[i], SIGKILL) == -1) {\n                    perror(\"kill\");\n                }\n            }\n        }\n        // After sending SIGKILL, wait for SIGCHLD to be delivered for these children\n        // The SIGCHLD handler will eventually reap them.\n        while (children_remaining > 0) {\n            pause(); // Wait for all children to be reaped\n        }\n    } else {\n        printf(\"\\nAll children finished before timeout.\\n\");\n    }\n\n    // 8. Print summary of child process results\n    printf(\"\\n--- Child Process Summary ---\\n\");\n    for (int i = 0; i < NUM_CHILDREN; i++) {\n        printf(\"Child PID %d: \", child_pids[i]);\n        if (child_reaped[i]) {\n            if (WIFEXITED(child_exit_statuses[i])) {\n                printf(\"Exited normally with status %d.\\n\", WEXITSTATUS(child_exit_statuses[i]));\n            } else if (WIFSIGNALED(child_exit_statuses[i])) {\n                printf(\"Terminated by signal %d (%s).\\n\", WTERMSIG(child_exit_statuses[i]),\n                       (WTERMSIG(child_exit_statuses[i]) == SIGKILL ? \"SIGKILL\" : \"other signal\"));\n            } else {\n                printf(\"Unknown exit status.\\n\");\n            }\n        } else {\n            // This case should ideally not be reached if the final `while (children_remaining > 0)` loop works\n            printf(\"Still running or status not captured (error in logic).\\n\");\n        }\n    }\n\n    return 0;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}