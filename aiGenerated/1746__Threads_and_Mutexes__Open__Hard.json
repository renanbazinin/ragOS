{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:30:56",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4527,
      "output_tokens": 2786,
      "total_tokens": 14407
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Threads",
      "Mutexes",
      "Deadlock",
      "Concurrency"
    ],
    "content": {
      "text": "נתון קטע קוד בשפת C++ המממש העברת כספים בין שני חשבונות בנק בסביבה מרובת תהליכונים. כל חשבון בנק מוגן על ידי מנעול (mutex) משלו כדי להבטיח עקביות בגישה משותפת. הפונקציה `transfer` מקבלת מצביעים לשני חשבונות ומנסה להעביר סכום כסף ביניהם. יש לנתח את הקוד, לזהות בעיה פוטנציאלית חמורה, להסביר אותה בפירוט, ולהציע פתרון מתוקן תוך שימוש במנגנוני סנכרון סטנדרטיים של C++.",
      "code_snippet": "#include <iostream>\n#include <thread>\n#include <mutex>\n#include <vector>\n#include <chrono>\n\nclass BankAccount {\npublic:\n    int balance;\n    std::mutex mtx; // Each account has its own mutex\n    int id;         // For identification\n\n    BankAccount(int initial_balance, int account_id) : balance(initial_balance), id(account_id) {}\n\n    // Methods that assume the caller has already locked the account's mutex\n    void unsafe_deposit(int amount) {\n        balance += amount;\n    }\n\n    bool unsafe_withdraw(int amount) {\n        if (balance >= amount) {\n            balance -= amount;\n            return true;\n        }\n        return false;\n    }\n};\n\n// Function to transfer money between two accounts\nvoid transfer(BankAccount* from, BankAccount* to, int amount) {\n    // Acquire locks for both accounts\n    from->mtx.lock(); // Lock 'from' account\n    // std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Simulate work/context switch\n    to->mtx.lock();   // Lock 'to' account\n\n    if (from->unsafe_withdraw(amount)) {\n        to->unsafe_deposit(amount);\n        std::cout << \"Transfer \" << amount << \" from \" << from->id << \" to \" << to->id << \" successful. \"\n                  << \"Balances: \" << from->id << \"=\" << from->balance << \", \" << to->id << \"=\" << to->balance << std::endl;\n    } else {\n        std::cout << \"Transfer \" << amount << \" from \" << from->id << \" to \" << to->id << \" failed (insufficient funds).\" << std::endl;\n    }\n\n    to->mtx.unlock();   // Unlock 'to' account\n    from->mtx.unlock(); // Unlock 'from' account\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הבעיה המרכזית בקוד הנתון היא פוטנציאל לקיפאון (deadlock). קיפאון יתרחש כאשר שני תהליכונים ינסו לבצע העברות כספים בין אותם שני חשבונות, אך בסדר הפוך. לדוגמה, תהליכון A מנסה להעביר כסף מחשבון 1 לחשבון 2, ותהליכון B מנסה להעביר כסף מחשבון 2 לחשבון 1.\n\n**תרחיש קיפאון (Deadlock Scenario):**\n1.  תהליכון A מתחיל לבצע `transfer(&acc1, &acc2, 100)` ונועל את המנעול של חשבון `acc1` (`acc1.mtx.lock()`).\n2.  מתרחש מיתוג הקשר (context switch), ותהליכון B מתחיל לבצע `transfer(&acc2, &acc1, 50)`.\n3.  תהליכון B נועל את המנעול של חשבון `acc2` (`acc2.mtx.lock()`).\n4.  תהליכון B מגיע לשורה `from->mtx.lock()` (שבמקרה זה היא `acc1.mtx.lock()`), ומנסה לנעול את המנעול של חשבון `acc1`. אך המנעול כבר נעול על ידי תהליכון A, ולכן תהליכון B נחסם וממתין.\n5.  מתרחש מיתוג הקשר בחזרה לתהליכון A. תהליכון A מגיע לשורה `to->mtx.lock()` (שבמקרה זה היא `acc2.mtx.lock()`), ומנסה לנעול את המנעול של חשבון `acc2`. אך המנעול כבר נעול על ידי תהליכון B, ולכן תהליכון A נחסם וממתין.\nכתוצאה מכך, שני התהליכונים חסומים זה לזה (כל אחד ממתין למנעול שהשני מחזיק) ואינם יכולים להמשיך, מה שמוביל לקיפאון.\n\n**פתרון מתוקן:**\nכדי למנוע קיפאון, יש להבטיח שכל המנעולים הנדרשים נרכשים בסדר קבוע ועקבי (global ordering), או באמצעות מנגנון שמאפשר רכישה אטומית של מספר מנעולים. ב-C++, הפונקציה `std::lock` נועדה בדיוק למטרה זו. היא מקבלת מספר מנעולים ורוכשת אותם באופן שמונע קיפאון על ידי אלגוריתם חכם (לרוב על ידי ניסיון לרכוש את כולם, וביצוע נסיגה וניסיון חוזר אם לא ניתן לרכוש את כולם בבת אחת).\n\nפתרון מתוקן באמצעות `std::lock` ו-`std::lock_guard` עם `std::adopt_lock`:\n`std::lock` רוכש את המנעולים `from->mtx` ו-`to->mtx` באופן בטוח מפני קיפאון. לאחר מכן, `std::lock_guard` משמשים לניהול שחרור המנעולים באופן אוטומטי (RAII - Resource Acquisition Is Initialization) כאשר הם יוצאים מהסקופ של הפונקציה. `std::adopt_lock` מציין ל-`lock_guard` שהמנעול כבר נרכש על ידי `std::lock` ורק צריך לאמץ אותו ולנהל את שחרורו.\n\nיש גם צורך לטפל במקרה קצה שבו מנסים להעביר כסף לחשבון עצמו (כלומר `from == to`), כדי למנוע נעילה כפולה של אותו מנעול או התנהגות בלתי צפויה מ-`std::lock`.\n\n```cpp\nvoid transfer(BankAccount* from, BankAccount* to, int amount) {\n    // Handle self-transfer explicitly to avoid locking the same mutex twice\n    if (from == to) {\n        std::lock_guard<std::mutex> lock(from->mtx);\n        if (from->unsafe_withdraw(amount)) {\n            to->unsafe_deposit(amount); // 'to' is the same as 'from'\n            std::cout << \"Transfer \" << amount << \" from \" << from->id << \" to itself successful. \"\n                      << \"Balance: \" << from->id << \"=\" << from->balance << std::endl;\n        } else {\n            std::cout << \"Transfer \" << amount << \" from \" << from->id << \" to itself failed (insufficient funds).\" << std::endl;\n        }\n        return;\n    }\n\n    // Use std::lock to acquire both mutexes without deadlock\n    // std::lock ensures that if it fails to acquire all locks, it releases already acquired ones\n    std::lock(from->mtx, to->mtx);\n\n    // Use std::lock_guard with std::adopt_lock to manage mutexes automatically\n    std::lock_guard<std::mutex> lock1(from->mtx, std::adopt_lock);\n    std::lock_guard<std::mutex> lock2(to->mtx, std::adopt_lock);\n\n    if (from->unsafe_withdraw(amount)) {\n        to->unsafe_deposit(amount);\n        std::cout << \"Transfer \" << amount << \" from \" << from->id << \" to \" << to->id << \" successful. \"\n                  << \"Balances: \" << from->id << \"=\" << from->balance << \", \" << to->id << \"=\" << to->balance << std::endl;\n    } else {\n        std::cout << \"Transfer \" << amount << \" from \" << from->id << \" to \" << to->id << \" failed (insufficient funds).\" << std::endl;\n    }\n    // Mutexes are automatically unlocked when lock1 and lock2 go out of scope\n}\n```\n\n**פתרון חלופי (Global Ordering):**\nפתרון נוסף למניעת קיפאון הוא להטיל סדר גלובלי (global ordering) על המשאבים (במקרה זה, חשבונות הבנק). לדוגמה, תמיד לנעול את החשבון בעל ה-ID הקטן יותר תחילה, ולאחר מכן את החשבון בעל ה-ID הגדול יותר. זה מבטיח שכל התהליכונים ינסו לרכוש את המנעולים באותו סדר, ובכך ימנע קיפאון.\n\n```cpp\nvoid transfer_ordered(BankAccount* from, BankAccount* to, int amount) {\n    if (from == to) {\n        std::lock_guard<std::mutex> lock(from->mtx);\n        // ... (same logic as above for self-transfer)\n        return;\n    }\n\n    // Determine which mutex to lock first based on ID\n    // To avoid issues if from->id == to->id (which is handled above), use memory addresses if IDs can be same for different accounts\n    // For simplicity, assuming unique IDs for distinct accounts or handling from == to already\n    BankAccount* first_account = (from->id < to->id) ? from : to;\n    BankAccount* second_account = (from->id < to->id) ? to : from;\n\n    // Lock mutexes in a consistent order\n    std::lock_guard<std::mutex> lock1(first_account->mtx);\n    std::lock_guard<std::mutex> lock2(second_account->mtx);\n\n    // Now that both are locked, perform the transfer operation on original 'from' and 'to'\n    if (from->unsafe_withdraw(amount)) {\n        to->unsafe_deposit(amount);\n        std::cout << \"Transfer \" << amount << \" from \" << from->id << \" to \" << to->id << \" successful. \"\n                  << \"Balances: \" << from->id << \"=\" << from->balance << \", \" << to->id << \"=\" << to->balance << std::endl;\n    } else {\n        std::cout << \"Transfer \" << amount << \" from \" << from->id << \" to \" << to->id << \" failed (insufficient funds).\" << std::endl;\n    }\n}\n```\n\nפתרון `std::lock` הוא עדיף בדרך כלל מכיוון שהוא מופשט יותר ופחות נוטה לטעויות מאשר ניהול סדר ידני, במיוחד במערכות מורכבות יותר עם מספר רב של משאבים או יחסי תלות דינמיים."
    },
    "difficulty_estimation": "Hard"
  }
}