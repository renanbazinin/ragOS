{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Deadlocks and Synchronization",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 11:50:18",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1163,
      "output_tokens": 1051,
      "total_tokens": 3753
    }
  },
  "question": {
    "id": 101,
    "type": "MultipleChoice",
    "topic": [
      "Deadlocks",
      "Synchronization",
      "Deadlock Prevention"
    ],
    "content": {
      "text": "שני תהליכים (P1 ו-P2) צריכים גישה לשני משאבים שונים (R1 ו-R2) המוגנים על ידי מנעולים (mutexes) m1 ו-m2 בהתאמה.\nP1 מנסה לרכוש את m1, ולאחר מכן את m2.\nP2 מנסה לרכוש את m2, ולאחר מכן את m1.\n\nאיזו אסטרטגיה תמנע קיפאון (deadlock) במערכת זו?",
      "code_snippet": null,
      "options": [
        "א. לאפשר ל-P1 לרכוש את m1 ו-m2 בו-זמנית (באופן אטומי).",
        "ב. לאפשר ל-P2 לרכוש את m2 ו-m1 בו-זמנית (באופן אטומי).",
        "ג. לאכוף סדר אחיד ברכישת המנעולים עבור שני התהליכים (לדוגמה, תמיד m1 ואז m2).",
        "ד. להשתמש בטיימר עבור כל רכישת מנעול, ולשחרר את המנעול אם הטיימר פג לפני רכישת השני.",
        "ה. להשתמש במנעולי קריאה/כתיבה (read/write locks) במקום mutexes."
      ]
    },
    "sub_questions": null,
    "points": 5,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ג",
      "explanation": "התשובה הנכונה היא ג'. המצב המתואר הוא דוגמה קלאסית לקיפאון (deadlock) שיכול להתרחש עקב רכישת משאבים בסדר שונה על ידי תהליכים שונים. במקרה זה:\n- תהליך P1 רוכש את m1.\n- תהליך P2 רוכש את m2.\n- כעת P1 מנסה לרכוש את m2 (שמוחזק על ידי P2) ונחסם.\n- P2 מנסה לרכוש את m1 (שמוחזק על ידי P1) ונחסם.\nנוצר מעגל המתנה (circular wait), והמערכת נכנסת לקיפאון.\n\nאסטרטגיית מניעת קיפאון נפוצה ויעילה היא לאכוף סדר היררכי אחיד לרכישת משאבים. אם שני התהליכים ינסו לרכוש תמיד את m1 ואז את m2 (או תמיד m2 ואז m1), לא ייווצר מעגל המתנה. לדוגמה, אם P1 מחזיק ב-m1 ו-P2 מנסה לרכוש אותו (כחלק מסדר הרכישה m1 ואז m2), P2 ימתין. כאשר P1 ישחרר את m1 (לאחר שרכש ושחרר את m2), P2 יוכל להמשיך.\n\nאפשרויות א' ו-ב' (רכישה סימולטנית) יכולות למנוע קיפאון במקרים ספציפיים אך אינן אסטרטגיה כללית למניעת קיפאון ואינן תמיד ניתנות ליישום. הן למעשה מונעות את תנאי 'החזק והמתן' (Hold and Wait) על ידי הפיכת הרכישה לאטומית.\nאפשרות ד' (טיימר) היא שיטה לזיהוי או התאוששות מקיפאון, או למניעת 'החזק והמתן' בצורה אגרסיבית, אך לא מניעת התנאים מראש. היא גם עלולה לגרום ל-livelock (תהליכים משחררים ורוכשים מחדש מנעולים שוב ושוב מבלי להתקדם).\nאפשרות ה' (מנעולי קריאה/כתיבה) רלוונטית למצבים שבהם יש סוגים שונים של גישה לאותו משאב (קריאה או כתיבה), אך לא למקרה של שני משאבים נפרדים R1 ו-R2 וצורך במנעולי הדדיות."
    },
    "difficulty_estimation": "Medium"
  }
}