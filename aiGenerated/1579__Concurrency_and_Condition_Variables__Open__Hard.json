{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Concurrency and Condition Variables",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:52:21",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3819,
      "output_tokens": 2911,
      "total_tokens": 12899
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Concurrency",
      "Condition Variables",
      "Synchronization",
      "Priority Scheduling"
    ],
    "content": {
      "text": "מערכת שטיפת מכוניות: נתבונן במערכת שטיפת מכוניות עם מספר מוגבל של עמדות שטיפה. ישנן `NUM_BAYS` עמדות זמינות. מכוניות מגיעות ומבקשות שטיפה. חלק מהמכוניות הן 'VIP' ויש לתת להן עדיפות על פני מכוניות רגילות בהקצאת עמדת שטיפה, אם שתיהן ממתינות. כל מכונית מבלה זמן מסוים בשטיפה. עליך לממש את הפונקציות `car_arrive_and_wash` ו-`car_finish_washing` תוך שימוש במנגנוני סנכרון (mutex ו-condition variables) כדי להבטיח נכונות ועמידה בדרישות העדיפות. יש להשתמש ב-C/C++ וב-pthreads. נתונים המשתנים הגלובליים הבאים:\n\n",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For usleep\n#include <stdlib.h> // For rand\n\n#define NUM_BAYS 3 // Example number of washing bays\n\npthread_mutex_t car_wash_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond_vip_bay = PTHREAD_COND_INITIALIZER;\npthread_cond_t cond_regular_bay = PTHREAD_COND_INITIALIZER;\n\nint free_bays = NUM_BAYS;\nint waiting_vips = 0; \nint waiting_regulars = 0;\n\n// Implement these functions:\nvoid car_arrive_and_wash(int is_vip) {\n    // Your implementation here\n}\n\nvoid car_finish_washing() {\n    // Your implementation here\n}\n\n/*\n// Optional: Example main function for testing\nvoid* car_thread(void* arg) {\n    int is_vip = *(int*)arg;\n    printf(\"Car (VIP: %d) arrived.\\n\", is_vip);\n    car_arrive_and_wash(is_vip);\n    printf(\"Car (VIP: %d) finished washing.\\n\", is_vip);\n    return NULL; // car_finish_washing is called inside arrive_and_wash for simplicity of thread logic\n}\n\nint main() {\n    srand(time(NULL)); // Seed random number generator\n    pthread_t threads[10];\n    int vip_flags[] = {0, 1, 0, 1, 0, 0, 1, 0, 1, 0}; // Example: Regular, VIP, Regular, VIP, Regular, Regular, VIP, Regular, VIP, Regular\n\n    // Simulate cars arriving\n    for (int i = 0; i < 10; ++i) {\n        usleep(rand() % 200000 + 50000); // Small random delay for arrival\n        pthread_create(&threads[i], NULL, car_thread, &vip_flags[i]);\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"All cars processed. Free bays: %d\\n\", free_bays);\n\n    // Destroy mutex and condition variables\n    pthread_mutex_destroy(&car_wash_mutex);\n    pthread_cond_destroy(&cond_vip_bay);\n    pthread_cond_destroy(&cond_regular_bay);\n\n    return 0;\n}\n*/"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\n```c\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For usleep\n#include <stdlib.h> // For rand\n#include <time.h>   // For time (to seed rand)\n\n#define NUM_BAYS 3 // Example number of washing bays\n\npthread_mutex_t car_wash_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond_vip_bay = PTHREAD_COND_INITIALIZER;\npthread_cond_t cond_regular_bay = PTHREAD_COND_INITIALIZER;\n\nint free_bays = NUM_BAYS;\nint waiting_vips = 0; \nint waiting_regulars = 0;\n\nvoid car_arrive_and_wash(int is_vip) {\n    pthread_mutex_lock(&car_wash_mutex);\n\n    if (is_vip) {\n        waiting_vips++;\n        while (free_bays == 0) {\n            // VIPs wait only if no bay is free\n            pthread_cond_wait(&cond_vip_bay, &car_wash_mutex);\n        }\n        waiting_vips--;\n    } else { // Regular car\n        waiting_regulars++;\n        while (free_bays == 0 || waiting_vips > 0) { \n            // Regulars wait if no bay OR if VIPs are currently waiting\n            pthread_cond_wait(&cond_regular_bay, &car_wash_mutex);\n        }\n        waiting_regulars--;\n    }\n    \n    free_bays--;\n    // printf(\"Car (VIP: %d) started washing. Free bays: %d, Waiting VIPs: %d, Waiting Regulars: %d\\n\", is_vip, free_bays, waiting_vips, waiting_regulars);\n    pthread_mutex_unlock(&car_wash_mutex);\n\n    // Simulate washing time outside the critical section\n    usleep(500000 + (rand() % 500000)); // Simulate variable washing time\n    \n    // After washing, the car finishes\n    car_finish_washing();\n}\n\nvoid car_finish_washing() {\n    pthread_mutex_lock(&car_wash_mutex);\n    free_bays++;\n    // printf(\"Car finished. Free bays: %d, Waiting VIPs: %d, Waiting Regulars: %d\\n\", free_bays, waiting_vips, waiting_regulars);\n\n    if (waiting_vips > 0) {\n        // Prioritize VIPs: signal one waiting VIP\n        pthread_cond_signal(&cond_vip_bay);\n    } else if (waiting_regulars > 0) {\n        // No VIPs waiting, signal one regular car\n        pthread_cond_signal(&cond_regular_bay);\n    }\n    \n    pthread_mutex_unlock(&car_wash_mutex);\n}\n```\n\n**הסבר מפורט:**\n\n**פונקציה `car_arrive_and_wash(int is_vip)`:**\n1.  **כניסה למקטע קריטי:** הפונקציה מתחילה בנעילת המוטקס (`pthread_mutex_lock(&car_wash_mutex)`) כדי להבטיח גישה בלעדית למשתנים המשותפים (`free_bays`, `waiting_vips`, `waiting_regulars`).\n2.  **עדכון מונים:** המכונית מגדילה את מונה המכוניות הממתינות מסוגה (`waiting_vips` אם היא VIP, או `waiting_regulars` אם היא רגילה).\n3.  **לולאת המתנה (Waiting Loop):**\n    *   **עבור מכוניות VIP:** מכונית VIP נכנסת ללולאת המתנה (`while (free_bays == 0)`) אך ורק אם אין עמדות שטיפה פנויות. היא ממתינה על `cond_vip_bay`. **חשוב:** מכונית VIP אינה צריכה לחכות אם יש מכוניות רגילות ממתינות, מכיוון שהיא מקבלת עדיפות על פניהן, ולכן התנאי ב-`while` עבורה פשוט יותר וממוקד בזמינות עמדה בלבד.\n    *   **עבור מכוניות רגילות:** מכונית רגילה נכנסת ללולאת המתנה (`while (free_bays == 0 || waiting_vips > 0)`) אם אין עמדות שטיפה פנויות **או** אם יש מכוניות VIP שממתינות. תנאי זה מבטיח שמכוניות רגילות לא יתפסו עמדה אם יש מכוניות VIP שממתינות (או שאין בכלל עמדות פנויות). היא ממתינה על `cond_regular_bay`.\n    *   `pthread_cond_wait` משחרר את המוטקס באופן אטומי ונכנס למצב המתנה. כאשר החוט מתעורר, הוא תופס מחדש את המוטקס לפני שהוא ממשיך בביצוע הקוד.\n4.  **יציאה מהמתנה וקבלת עמדה:** לאחר שהתנאים מתקיימים והמכונית יכולה להיכנס (כלומר, יצאה מלולאת ה-`while`), מונה הממתינים מסוגה מופחת (`waiting_vips--` או `waiting_regulars--`), ומונה העמדות הפנויות מופחת (`free_bays--`).\n5.  **שחרור המוטקס:** המוטקס משוחרר (`pthread_mutex_unlock(&car_wash_mutex)`).\n6.  **ביצוע הפעולה:** המכונית מדמה שטיפה (באמצעות `usleep`) מחוץ למקטע הקריטי. זה חיוני כדי לא לחסום חוטים אחרים בזמן שהמכונית מבצעת את פעולתה הארוכה, מה שמאפשר מקסום ניצול המעבד.\n7.  **סיום שטיפה:** לאחר סיום השטיפה, המכונית קוראת לפונקציה `car_finish_washing()`.\n\n**פונקציה `car_finish_washing()`:**\n1.  **כניסה למקטע קריטי:** הפונקציה מתחילה בנעילת המוטקס.\n2.  **שחרור עמדה:** מונה העמדות הפנויות מוגדל (`free_bays++`).\n3.  **איתות (Signaling):** לאחר שחרור עמדה, יש להודיע לחוטים הממתינים. סדר העדיפויות חשוב כאן:\n    *   **עדיפות ל-VIPs:** אם יש מכוניות VIP ממתינות (`waiting_vips > 0`), נשלח איתות ל-`cond_vip_bay` באמצעות `pthread_cond_signal`. זה מעיר מכונית VIP אחת, שתבדוק את התנאי שלה ותתפוס עמדה אם היא פנויה.\n    *   **מכוניות רגילות:** אם אין VIPs ממתינים (`waiting_vips == 0`), ויש מכוניות רגילות ממתינות (`waiting_regulars > 0`), נשלח איתות ל-`cond_regular_bay` באמצעות `pthread_cond_signal`. זה מעיר מכונית רגילה אחת.\n    *   שימוש ב-`pthread_cond_signal` במקום `pthread_cond_broadcast` מספיק במקרה זה, שכן בכל פעם משתחררת עמדה אחת בלבד, ורק מכונית אחת יכולה לתפוס אותה. אם `NUM_BAYS` היה גדול מ-1 והיה צורך להעיר מספר חוטים בו זמנית (למשל, אם משתחררות מספר עמדות ואין עדיפות), `broadcast` היה יכול להיות יעיל יותר, אך `signal` נכון לוגית במקרה זה.\n4.  **שחרור המוטקס:** המוטקס משוחרר (`pthread_mutex_unlock(&car_wash_mutex)`)."
    },
    "difficulty_estimation": "Hard"
  }
}