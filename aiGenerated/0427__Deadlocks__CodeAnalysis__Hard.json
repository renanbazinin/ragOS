{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Deadlocks",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 21:29:10",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3900,
      "output_tokens": 2760,
      "total_tokens": 13917
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Deadlocks",
      "Synchronization",
      "Atomic Operations",
      "Resource Allocation"
    ],
    "content": {
      "text": "במערכת נתונה, ישנם שני משאבים מסוגים שונים, `משאב A` ו-`משאב B`. כל משאב קיים במופע יחיד. תהליכים (או חוטים) במערכת נדרשים לרכוש את שני המשאבים, `משאב A` ו-`משאב B`, על מנת לבצע משימה כלשהי. לרשותנו עומדות שתי פעולות אטומיות בלבד: `TestAndSet` ו-`atomic_release`.\n\nהפעולה `TestAndSet(int *lock_ptr)` מבצעת באופן אטומי את הפעולות הבאות: היא קובעת את הערך של `*lock_ptr` ל-1, ומחזירה את ערכו הקודם (לפני השינוי). אם `*lock_ptr` היה 0, המשאב היה פנוי וכעת נתפס. אם `*lock_ptr` היה 1, המשאב כבר היה תפוס.\n\nהפעולה `atomic_release(int *lock_ptr)` מבצעת באופן אטומי את הפעולה הבאה: היא קובעת את הערך של `*lock_ptr` ל-0, ובכך משחררת את המשאב.\n\nנתון קטע הקוד הבא המנסה לרכוש את שני המשאבים:\n",
      "code_snippet": "extern int TestAndSet(int *lock_ptr);\nextern void atomic_release(int *lock_ptr);\n\n// משתנים גלובליים המייצגים את מצב המשאבים (0 = פנוי, 1 = תפוס)\nint resource_A = 0; \nint resource_B = 0; \n\nvoid acquire_two_resources_naive() {\n    while (TestAndSet(&resource_A) == 1); // נסה לרכוש את משאב A\n    while (TestAndSet(&resource_B) == 1); // נסה לרכוש את משאב B\n}\n\nvoid release_two_resources() {\n    atomic_release(&resource_B);\n    atomic_release(&resource_A);\n}\n",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "א. נתח את קטע הקוד `acquire_two_resources_naive()` והסבר מדוע הוא עלול לגרום למצב של קיפאון (Deadlock) במערכת. ציין אילו תנאים לקיפאון מתקיימים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "ב. כתוב מחדש את הפונקציות `acquire_two_resources()` ו-`release_two_resources()` כך שימנעו קיפאון, תוך שימוש אך ורק בפעולות האטומיות `TestAndSet` ו-`atomic_release`. המימוש חייב להבטיח שאם חוט לא מצליח לרכוש את שני המשאבים יחד, הוא לא יחזיק באף אחד מהם (כלומר, לא תתקיים החזקה והמתנה חלקית). קוד המימוש צריך להיות יעיל ככל האפשר.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\nא. ניתוח `acquire_two_resources_naive()` וגורמי קיפאון:\nהפונקציה `acquire_two_resources_naive()` אכן עלולה לגרום למצב של קיפאון (Deadlock) במערכת. קיפאון מתרחש כאשר ארבעה תנאים הכרחיים מתקיימים בו-זמנית:\n\n1.  **מניעה הדדית (Mutual Exclusion)**: תנאי זה מתקיים. פעולות `TestAndSet` מבטיחות שרק חוט אחד יכול להחזיק במשאב A ורק חוט אחד יכול להחזיק במשאב B בכל רגע נתון. אם חוט מנסה לרכוש משאב שכבר תפוס, `TestAndSet` יחזיר 1 והחוט ימשיך בלולאת המתנה פעילה (busy-waiting) עד שהמשאב ישתחרר.\n\n2.  **החזקה והמתנה (Hold and Wait)**: תנאי זה מתקיים. חוט יכול לרכוש את `משאב A` (כלומר, להחזיק בו), ולאחר מכן לנסות לרכוש את `משאב B`. אם `משאב B` תפוס על ידי חוט אחר, החוט הראשון ימתין ל-`משאב B` תוך כדי שהוא ממשיך להחזיק ב-`משאב A`.\n\n3.  **אי-נשללות (No Preemption)**: תנאי זה מתקיים. משאבים אינם נשללים מחוט בכוח. חוט חייב לשחרר את המשאבים מרצונו החופשי באמצעות `atomic_release` לאחר שסיים את השימוש בהם.\n\n4.  **המתנה מעגלית (Circular Wait)**: תנאי זה עלול להיווצר. נניח שני חוטים, T1 ו-T2:\n    *   T1 מבצע בהצלחה `TestAndSet(&resource_A)` (תופס את A).\n    *   T2 מבצע בהצלחה `TestAndSet(&resource_B)` (תופס את B).\n    *   כעת, T1 מנסה לבצע `TestAndSet(&resource_B)`, אך מגלה ש-B תפוס על ידי T2. T1 נכנס למצב המתנה על B.\n    *   בו-זמנית, T2 מנסה לבצע `TestAndSet(&resource_A)`, אך מגלה ש-A תפוס על ידי T1. T2 נכנס למצב המתנה על A.\n    *   במצב זה, T1 ממתין ל-T2 שישחרר את B, ו-T2 ממתין ל-T1 שישחרר את A. נוצרת שרשרת המתנה מעגלית, ושני החוטים נמצאים בקיפאון.\n\nב. מימוש פונקציות `acquire_two_resources()` ו-`release_two_resources()` למניעת קיפאון:\nכדי למנוע קיפאון, נשבור את תנאי ה\"החזקה והמתנה\" על ידי הבטחה שחוט לא יחזיק באף משאב אם הוא לא מצליח לרכוש את כל המשאבים הנדרשים לו באופן מיידי. אסטרטגיה נפוצה לכך היא \"ניסיון וביטול\" (try-and-rollback) או רכישה בסדר קבוע ומוסכם. נבחר באסטרטגיה של רכישה בסדר קבוע (תמיד A ואז B) בשילוב עם מנגנון ביטול:\n\n```c\nvoid acquire_two_resources() {\n    while (1) {\n        // נסה לרכוש את משאב A\n        while (TestAndSet(&resource_A) == 1); // המתן באופן פעיל עד ש-A יהיה פנוי ותפוס אותו\n\n        // משאב A נתפס. כעת נסה לרכוש את משאב B.\n        if (TestAndSet(&resource_B) == 0) {\n            // אם B היה פנוי ונתפס בהצלחה, רכשנו את שני המשאבים.\n            return; // יציאה מהלולאה, שני המשאבים בידינו.\n        } else {\n            // משאב B היה תפוס. שחרר את משאב A וחזור לנסות לרכוש את שניהם מההתחלה.\n            atomic_release(&resource_A);\n            // ניתן להוסיף כאן השהיה קצרה (למשל, thread_yield) כדי למנוע בזבוז משאבי מעבד ב-busy-waiting אגרסיבי,\n            // אך מכיוון שלא ניתנו פרימיטיבים נוספים, נסתפק בלולאה.\n        }\n    }\n}\n\nvoid release_two_resources() {\n    atomic_release(&resource_B); // שחרר את משאב B\n    atomic_release(&resource_A); // שחרר את משאב A\n}\n```\n\n**הסבר לפתרון:**\n\n1.  **מניעת החזקה והמתנה חלקית:** המימוש מבטיח שחוט שרוכש את `משאב A` אך מגלה ש-`משאב B` תפוס, ישחרר מיד את `משאב A` לפני שהוא מנסה שוב. בכך, חוט אף פעם לא יחזיק במשאב אחד (A) וימתין למשאב אחר (B) לזמן בלתי מוגבל. זה שובר את תנאי ה\"החזקה והמתנה\" באופן שמבטיח שחוט לא ייכנס למצב המתנה מעגלית.\n\n2.  **סדר רכישה קבוע:** כל החוטים מנסים לרכוש את המשאבים באותו סדר: תמיד `משאב A` תחילה, ורק לאחר מכן `משאב B`. זהו תנאי מונע קיפאון קלאסי בפני עצמו, אך במקרה שלנו הוא משולב עם מנגנון ה\"ניסיון וביטול\" כדי להתמודד עם מצב שבו המשאב השני אינו זמין מיד. אם כל החוטים ינסו לרכוש A ואז B, לעולם לא תיווצר המתנה מעגלית שבה חוט אחד מחזיק ב-A ומחכה ל-B, וחוט אחר מחזיק ב-B ומחכה ל-A, מכיוון שחוט שיתפוס את B ראשון לעולם לא ינסה לתפוס את A (הוא תמיד ינסה A ואז B).\n\n3.  **חופש מקיפאון:** המימוש מבטיח חופש מקיפאון. גם אם חוטים רבים מתחרים על המשאבים, בסופו של דבר אחד מהם יצליח לתפוס את שניהם, משום שהם משחררים משאבים שהוחזקו חלקית, ובכך מאפשרים לחוטים אחרים להתקדם. אין מצב שבו קבוצת חוטים ממתינה זה לזה באופן בלתי הפיך.\n\n4.  **יעילות (בהינתן המגבלות):** בהיעדר פרימיטיבים כמו `sleep` או `yield`, השימוש ב-`while (TestAndSet(...) == 1);` הוא צורת busy-waiting. למרות שזה לא יעיל מבחינת ניצול מעבד, זהו המימוש היעיל ביותר האפשרי עם הפרימיטיבים האטומיים הנתונים בלבד, מכיוון שאין דרך אחרת להמתין לשחרור משאב מבלי לצרוך זמן מעבד בלולאה."
    },
    "difficulty_estimation": "Hard"
  }
}