{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:30:52",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4148,
      "output_tokens": 6563,
      "total_tokens": 19182
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Shared Memory",
      "Semaphores",
      "Producer-Consumer Problem",
      "Synchronization"
    ],
    "content": {
      "text": "מערכת הפעלה נדרשת לטפל בתקשורת בין מספר תהליכי \"יצרן\" (Producers) המייצרים נתונים, לבין מספר תהליכי \"צרכן\" (Consumers) הצורכים אותם. התקשורת מתבצעת באמצעות חוצץ מעגלי (Circular Buffer) הנמצא בזיכרון משותף. גודל החוצץ קבוע. הנתונים המיוצרים והנצרכים הם מספרים שלמים (int).\n\nעליך לתכנן ולממש חלקית מערכת זו ולנתח את היבטי הסינכרון שלה.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "תכנון המבנה: תאר/י את המבנים הנדרשים בזיכרון המשותף עבור החוצץ המעגלי והנתונים הקשורים אליו (לדוגמה, אינדקסים, ספירות). מהם מנגנוני ה-IPC (תקשורת בין תהליכים) הנדרשים לפתרון בעיה זו, וכיצד תשתמש/י בהם? נמק/י את בחירותיך.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "קוד C/C++: כתוב/כתבי קטע קוד ב-C/C++ עבור תהליך יצרן ותהליך צרכן. קטעי הקוד צריכים להדגים את הלוגיקה המרכזית של הוספת נתון לחוצץ וקריאת נתון ממנו, תוך שימוש במנגנוני ה-IPC שבחרת. יש לכלול את קוד ה-setup וה-cleanup של הזיכרון המשותף והסמפורים. אין צורך לכתוב את הלוגיקה המלאה של יצירת תהליכים (fork/exec) או לולאות אינסופיות של ייצור/צריכה, אלא רק את הפעולה הבודדת והמוגנת של הכנסה/הוצאה מהחוצץ.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "ניתוח סינכרון: הסבר/הסבירי בפירוט מדוע כל אחד מהסמפורים שבחרתם הכרחי. תאר/י מה עלול להשתבש (Race Conditions, Deadlocks, Starvation) אם אחד מהם יושמט או ייושם באופן שגוי (לדוגמה, סדר פעולות שגוי של `sem_wait`/`sem_post`).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.4",
        "text": "טיפול בשגיאות וניקוי משאבים: מהן הפעולות הנדרשות כדי לטפל בשגיאות פוטנציאליות (לדוגמה, כשל ב-`shm_open` או `sem_open`) וכיצד יש לנקות את המשאבים (זיכרון משותף וסמפורים) בסיום פעולת המערכת, גם במקרה של סיום לא רגיל של אחד התהליכים?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### פתרון מפורט:\n\n#### 1.1 תכנון המבנה ומנגנוני IPC:\n\n**מבנה הזיכרון המשותף (Shared Memory Structure):**\nנזדקק למבנה שיכיל את החוצץ המעגלי עצמו, יחד עם משתנים שינהלו אותו:\n```c\ntypedef struct {\n    int buffer[BUFFER_SIZE]; // החוצץ המעגלי לאחסון מספרים שלמים\n    int head;                // אינדקס התא הבא לקריאה (על ידי צרכן)\n    int tail;                // אינדקס התא הבא לכתיבה (על ידי יצרן)\n    // int count;            // ניתן לגזור מסמפורים, או להשתמש לצרכי דיבוג\n} SharedBuffer;\n```\n-   `buffer`: מערך של מספרים שלמים בגודל `BUFFER_SIZE` שישמש כחוצץ המעגלי.\n-   `head`: מצביע לאינדקס התא הראשון המכיל נתון שטרם נצרך. תהליכי צרכן קוראים מ-`head` ומקדמים אותו.\n-   `tail`: מצביע לאינדקס התא הפנוי הבא לכתיבה. תהליכי יצרן כותבים ל-`tail` ומקדמים אותו.\n\n**מנגנוני IPC:**\nלפתרון בעיית יצרן-צרכן מרובה תהליכים באמצעות זיכרון משותף, נדרשים שלושה סמפורים (Named Semaphores הם הבחירה המתאימה לתקשורת בין תהליכים שאינם קשורים בהכרח בקשר הורה-ילד): \n\n1.  **`sem_t *mutex` (סמפור הדדיות - Mutual Exclusion):** \n    -   **מטרה:** להבטיח שרק תהליך אחד (יצרן או צרכן) יוכל לגשת ולשנות את המשתנים המשותפים (`head`, `tail`) ואת תוכן החוצץ המעגלי בו זמנית. זה מונע Race Conditions בגישה למבנה ה-`SharedBuffer`.\n    -   **ערך התחלתי:** 1 (סמפור בינארי).\n\n2.  **`sem_t *empty` (סמפור \"ריק\" - Empty Slots):**\n    -   **מטרה:** לספור את מספר התאים הריקים הזמינים בחוצץ. יצרנים ממתינים לסמפור זה לפני שהם כותבים, כדי לוודא שיש מקום פנוי. כל פעולת כתיבה מקטינה את ערכו. \n    -   **ערך התחלתי:** `BUFFER_SIZE` (מספר התאים הכולל בחוצץ).\n\n3.  **`sem_t *full` (סמפור \"מלא\" - Full Slots):**\n    -   **מטרה:** לספור את מספר התאים המלאים בחוצץ המכילים נתונים. צרכנים ממתינים לסמפור זה לפני שהם קוראים, כדי לוודא שיש נתונים זמינים. כל פעולת קריאה מקטינה את ערכו. \n    -   **ערך התחלתי:** 0 (בתחילה החוצץ ריק).\n\n**נימוק לבחירה:**\n-   **זיכרון משותף (Shared Memory):** נבחר בזכות היותו מנגנון ה-IPC המהיר ביותר, שכן הוא מאפשר גישה ישירה לנתונים ללא צורך בהעתקה דרך הקרנל. מתאים למקרים בהם יש צורך בהעברת כמויות גדולות של נתונים או ביצועים גבוהים.\n-   **סמפורים בעלי שם (Named Semaphores):** מתאימים לתקשורת בין תהליכים שאינם קשורים (לדוגמה, תהליכים שהופעלו בנפרד או שנוצרו על ידי `fork` אך צריכים לשתף משאבים). הם ניתנים לגישה לפי שם במערכת הקבצים הוירטואלית, מה שמקל על איתורם ושימושם על ידי תהליכים שונים.\n\n#### 1.2 קוד C/C++:\n\n**הגדרות וקוד Setup (ניתן לכלול בקובץ נפרד או כפונקציית אתחול):**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <semaphore.h>\n#include <errno.h>\n\n#define BUFFER_SIZE 10\n#define SHM_NAME \"/my_shared_buffer\"\n#define SEM_MUTEX_NAME \"/sem_mutex\"\n#define SEM_EMPTY_NAME \"/sem_empty\"\n#define SEM_FULL_NAME \"/sem_full\"\n\ntypedef struct {\n    int buffer[BUFFER_SIZE];\n    int head; // Index for consumers to read from\n    int tail; // Index for producers to write to\n} SharedBuffer;\n\nSharedBuffer *shm_buffer = NULL;\nsem_t *mutex = NULL;\nsem_t *empty = NULL;\nsem_t *full = NULL;\n\n// פונקציה לאתחול זיכרון משותף וסמפורים\nvoid init_shared_resources() {\n    int shm_fd;\n\n    // יצירה/פתיחה של מקטע זיכרון משותף\n    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);\n    if (shm_fd == -1) {\n        perror(\"shm_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // הגדרת גודל הזיכרון המשותף\n    if (ftruncate(shm_fd, sizeof(SharedBuffer)) == -1) {\n        perror(\"ftruncate\");\n        exit(EXIT_FAILURE);\n    }\n\n    // מיפוי הזיכרון המשותף למרחב הכתובות של התהליך\n    shm_buffer = (SharedBuffer *)mmap(NULL, sizeof(SharedBuffer), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (shm_buffer == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    // אתחול החוצץ המשותף. חשוב שזה יקרה רק פעם אחת!\n    // במערכת אמיתית, נהוג שיהיה תהליך אתחול ייעודי. \n    // לצורך הדגמה, נניח שזה נקרא ע\"י התהליך הראשון שמתחיל.\n    shm_buffer->head = 0;\n    shm_buffer->tail = 0;\n\n    // יצירה/פתיחה של סמפורים\n    mutex = sem_open(SEM_MUTEX_NAME, O_CREAT, 0666, 1);\n    if (mutex == SEM_FAILED) {\n        perror(\"sem_open mutex\");\n        exit(EXIT_FAILURE);\n    }\n\n    empty = sem_open(SEM_EMPTY_NAME, O_CREAT, 0666, BUFFER_SIZE);\n    if (empty == SEM_FAILED) {\n        perror(\"sem_open empty\");\n        exit(EXIT_FAILURE);\n    }\n\n    full = sem_open(SEM_FULL_NAME, O_CREAT, 0666, 0);\n    if (full == SEM_FAILED) {\n        perror(\"sem_open full\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// פונקציה לניקוי משאבים משותפים. יש לקרוא אותה מתהליך ייעודי בלבד.\nvoid cleanup_shared_resources() {\n    // סגירת מיפוי הזיכרון\n    if (shm_buffer != NULL) {\n        if (munmap(shm_buffer, sizeof(SharedBuffer)) == -1) {\n            perror(\"munmap\");\n        }\n    }\n    // סגירת סמפורים\n    if (mutex != NULL) sem_close(mutex);\n    if (empty != NULL) sem_close(empty);\n    if (full != NULL) sem_close(full);\n\n    // מחיקת אובייקטי סמפור וזיכרון משותף מהמערכת\n    // פעולות אלה צריכות להתבצע רק כאשר אף תהליך לא משתמש בהם יותר\n    sem_unlink(SEM_MUTEX_NAME);\n    sem_unlink(SEM_EMPTY_NAME);\n    sem_unlink(SEM_FULL_NAME);\n    shm_unlink(SHM_NAME);\n}\n```\n\n**קוד תהליך יצרן (Producer Process Logic):**\n```c\n// פונקציה זו מייצגת שלב ייצור בודד\nvoid produce_item(int item) {\n    // המתן לתא ריק (מקטין את סמפור empty)\n    // מבטיח שהיצרן ממתין אם החוצץ מלא\n    if (sem_wait(empty) == -1) { perror(\"sem_wait empty (producer)\"); exit(EXIT_FAILURE); }\n\n    // קבלת מנעול הדדיות (mutex) (מבטיח גישה בלעדית לחוצץ המשותף)\n    if (sem_wait(mutex) == -1) { perror(\"sem_wait mutex (producer)\"); exit(EXIT_FAILURE); }\n\n    // קטע קריטי: הוסף פריט לחוצץ\n    shm_buffer->buffer[shm_buffer->tail] = item;\n    shm_buffer->tail = (shm_buffer->tail + 1) % BUFFER_SIZE;\n    printf(\"Producer added %d to buffer. Current tail: %d\\n\", item, shm_buffer->tail);\n\n    // שחרור מנעול הדדיות (mutex)\n    if (sem_post(mutex) == -1) { perror(\"sem_post mutex (producer)\"); exit(EXIT_FAILURE); }\n\n    // איתות שתא התמלא (מגדיל את סמפור full)\n    if (sem_post(full) == -1) { perror(\"sem_post full (producer)\"); exit(EXIT_FAILURE); }\n}\n\n// דוגמה לפונקציית main עבור יצרן (מפושטת)\nint main() {\n    init_shared_resources(); // נניח שתהליך זה הוא לא המאתחל הייעודי\n\n    int data_to_produce = getpid(); // דוגמה: נתוני ייצור הם ה-PID של התהליך\n    produce_item(data_to_produce);\n\n    // cleanup_shared_resources(); // יש לקרוא רק מתהליך ניקוי ייעודי\n    return 0;\n}\n```\n\n**קוד תהליך צרכן (Consumer Process Logic):**\n```c\n// פונקציה זו מייצגת שלב צריכה בודד\nint consume_item() {\n    int item;\n\n    // המתן לתא מלא (מקטין את סמפור full)\n    // מבטיח שהצרכן ממתין אם החוצץ ריק\n    if (sem_wait(full) == -1) { perror(\"sem_wait full (consumer)\"); exit(EXIT_FAILURE); }\n\n    // קבלת מנעול הדדיות (mutex) (מבטיח גישה בלעדית לחוצץ המשותף)\n    if (sem_wait(mutex) == -1) { perror(\"sem_wait mutex (consumer)\"); exit(EXIT_FAILURE); }\n\n    // קטע קריטי: הסר פריט מהחוצץ\n    item = shm_buffer->buffer[shm_buffer->head];\n    shm_buffer->head = (shm_buffer->head + 1) % BUFFER_SIZE;\n    printf(\"Consumer read %d from buffer. Current head: %d\\n\", item, shm_buffer->head);\n\n    // שחרור מנעול הדדיות (mutex)\n    if (sem_post(mutex) == -1) { perror(\"sem_post mutex (consumer)\"); exit(EXIT_FAILURE); }\n\n    // איתות שתא התפנה (מגדיל את סמפור empty)\n    if (sem_post(empty) == -1) { perror(\"sem_post empty (consumer)\"); exit(EXIT_FAILURE); }\n\n    return item;\n}\n\n// דוגמה לפונקציית main עבור צרכן (מפושטת)\nint main() {\n    init_shared_resources(); // נניח שתהליך זה הוא לא המאתחל הייעודי\n\n    int consumed_data = consume_item();\n    printf(\"Consumer consumed item: %d\\n\", consumed_data);\n\n    // cleanup_shared_resources(); // יש לקרוא רק מתהליך ניקוי ייעודי\n    return 0;\n}\n```\n\n#### 1.3 ניתוח סינכרון:\n\n**הכרחיות הסמפורים:**\n1.  **`mutex`:**\n    -   **הכרחיות:** מונע Race Conditions בגישה למשתנים המשותפים `head`, `tail`, ותוכן ה-`buffer` עצמו. לדוגמה, אם שני יצרנים ינסו לכתוב בו-זמנית לאותו תא (או תאים סמוכים כאשר `tail` מתעדכן באופן לא אטומי), או אם יצרן וצרכן ינסו לגשת לאותם אינדקסים או לעדכן את `head`/`tail` בו-זמנית, הנתונים בחוצץ עלולים להיהרס או שהאינדקסים יהפכו לבלתי עקביים.\n    -   **השלכות של השמטה/יישום שגוי (לדוגמה, השמטה):**\n        -   **Race Conditions:** מספר תהליכים יגשו וישנו את `head`, `tail` או את תוכן המערך בו-זמנית, מה שיוביל לנתונים שגויים, דריסת נתונים, או מצב לא עקבי של החוצץ.\n        -   **דוגמה:** יצרן קורא את `tail`, מחושב האינדקס לכתיבה. לפני שהוא כותב, יצרן אחר קורא גם הוא את `tail` (שלא עודכן עדיין), כותב לאותו אינדקס, מעדכן את `tail`. היצרן הראשון כותב שוב לאותו אינדקס (דורך על הנתון של היצרן השני) ומעדכן את `tail` שוב, מה שמוביל לאיבוד נתונים ולמצב לא עקבי.\n\n2.  **`empty`:**\n    -   **הכרחיות:** מבטיח שיצרן ימתין אם החוצץ מלא ואין מקום פנוי לכתיבה. הוא סופר את מספר התאים הריקים. `sem_wait(empty)` מקטין את הספירה; אם היא מגיעה ל-0, היצרן נחסם עד שצרכן משחרר תא.\n    -   **השלכות של השמטה/יישום שגוי (לדוגמה, השמטה):**\n        -   **דריסת נתונים (Buffer Overflow):** יצרנים ינסו לכתוב לחוצץ גם כשהוא מלא, ידחפו נתונים לתאים שכבר מכילים נתונים שטרם נצרכו, וידרסו אותם. זה יוביל לאיבוד נתונים ולמצב לא עקבי.\n        -   **Deadlock (סדר פעולות שגוי):** אם יצרן מבצע `sem_wait(mutex)` לפני `sem_wait(empty)`, והחוצץ מלא, היצרן יחזיק את ה-`mutex` וייחסם ב-`sem_wait(empty)`. צרכנים יצטרכו את ה-`mutex` כדי לקרוא ולשחרר מקום, אך הם לא יוכלו להשיג אותו. זהו מצב של Deadlock. סדר הפעולות הנכון הוא קודם `sem_wait(empty)` ורק אז `sem_wait(mutex)`.\n\n3.  **`full`:**\n    -   **הכרחיות:** מבטיח שצרכן ימתין אם החoצץ ריק ואין נתונים לצריכה. הוא סופר את מספר התאים המלאים. `sem_wait(full)` מקטין את הספירה; אם היא מגיעה ל-0, הצרכן נחסם עד שיצרן כותב נתון.\n    -   **השלכות של השמטה/יישום שגוי (לדוגמה, השמטה):**\n        -   **קריאת נתונים שגויים/לא קיימים (Buffer Underflow):** צרכנים ינסו לקרוא מהחוצץ גם כשהוא ריק, מה שיוביל לקריאת נתונים זבל או נתונים שכבר נצרכו, ולשגיאות לוגיות.\n        -   **Deadlock (סדר פעולות שגוי):** אם צרכן מבצע `sem_wait(mutex)` לפני `sem_wait(full)`, והחוצץ ריק, הצרכן יחזיק את ה-`mutex` וייחסם ב-`sem_wait(full)`. יצרנים יצטרכו את ה-`mutex` כדי לכתוב נתונים ולשחרר את הצרכן, אך הם לא יוכלו להשיג אותו. זהו מצב של Deadlock. סדר הפעולות הנכון הוא קודם `sem_wait(full)` ורק אז `sem_wait(mutex)`.\n\n**סדר פעולות נכון (Producer):** `sem_wait(empty)` -> `sem_wait(mutex)` -> [Critical Section] -> `sem_post(mutex)` -> `sem_post(full)`.\n**סדר פעולות נכון (Consumer):** `sem_wait(full)` -> `sem_wait(mutex)` -> [Critical Section] -> `sem_post(mutex)` -> `sem_post(empty)`.\n\n#### 1.4 טיפול בשגיאות וניקוי משאבים:\n\n**טיפול בשגיאות:**\n-   **בדיקת ערכי החזרה:** כל קריאת מערכת (system call) כגון `shm_open`, `ftruncate`, `mmap`, `sem_open`, `sem_wait`, `sem_post`, `munmap`, `sem_close`, `sem_unlink`, `shm_unlink` מחזירה ערך המציין הצלחה או כישלון. יש לבדוק ערכים אלו (לרוב -1 במקרה של כישלון) ולהשתמש ב-`perror()` כדי להדפיף הודעת שגיאה מפורטת, וב-`exit(EXIT_FAILURE)` כדי לסיים את התהליך באופן נקי אם השגיאה קריטית.\n-   **טיפול ב-`MAP_FAILED`:** עבור `mmap`, יש לבדוק אם הערך המוחזר הוא `MAP_FAILED` במקום -1.\n-   **טיפול ב-`SEM_FAILED`:** עבור `sem_open`, יש לבדוק אם הערך המוחזר הוא `SEM_FAILED` במקום -1.\n-   **סדר סגירה/שחרור משאבים במקרה שגיאה:** אם שגיאה מתרחשת באמצע אתחול, יש לוודא שמשאבים שכבר נפתחו (לדוגמה, קובץ זיכרון משותף או סמפורים) ייסגרו או ישוחררו לפני היציאה.\n\n**ניקוי משאבים (Resource Cleanup):**\nניקוי משאבים חיוני כדי למנוע דליפות זיכרון וסמפורים מיותרים במערכת.\n-   **`munmap(shm_buffer, sizeof(SharedBuffer))`:** משחרר את מיפוי הזיכרון המשותף ממרחב הכתובות של התהליך. כל תהליך שמיפה את הזיכרון המשותף צריך לבצע `munmap` לפני סיום.\n-   **`sem_close(sem_t *sem)`:** סוגר את הסמפור עבור התהליך הקורא. כל תהליך שפתח סמפור באמצעות `sem_open` צריך לסגור אותו באמצעות `sem_close` לפני סיום.\n-   **`shm_unlink(SHM_NAME)`:** מוחק את אובייקט הזיכרון המשותף מהמערכת. פעולה זו צריכה להתבצע רק כאשר אין יותר תהליכים המשתמשים בזיכרון המשותף. בדרך כלל, תהליך ייעודי (לדוגמה, ה-\"מנהל\" של המערכת או תהליך Cleanup נפרד) הוא שיבצע פעולה זו בסיום העבודה של כלל היצרנים והצרכנים.\n-   **`sem_unlink(SEM_MUTEX_NAME)`, `sem_unlink(SEM_EMPTY_NAME)`, `sem_unlink(SEM_FULL_NAME)`:** מוחקים את אובייקטי הסמפורים מהמערכת. בדומה ל-`shm_unlink`, פעולות אלו צריכות להתבצע רק כאשר אין יותר תהליכים המשתמשים בסמפורים. תהליך ייעודי או תהליך ה-Cleanup יבצע אותן.\n\n**במקרה של סיום לא רגיל (לדוגמה, קריסה של תהליך):**\n-   זיכרון משותף וסמפורים בעלי שם נשארים במערכת הקבצים הוירטואלית גם לאחר סיום תהליך שפתח אותם, עד שהם משוחררים במפורש על ידי `shm_unlink` ו-`sem_unlink` או עד אתחול המערכת. זוהי יתרון וחיסרון כאחד: יתרון כי מאפשר לתהליכים אחרים להמשיך להשתמש בהם גם אם תהליך אחד קורס. חיסרון כי דורש טיפול מפורש בניקוי.\n-   כדי להתמודד עם סיום לא רגיל, נהוג להשתמש במנגנונים כגון `atexit()` לרשום פונקציות ניקוי שיקראו אוטומטית ביציאה רגילה. עבור סיום לא רגיל (לדוגמה, קריסה כתוצאה מ-Segmentation Fault), פונקציות אלו לא יקראו. במקרים אלו, נהוג לכתוב סקריפט או תהליך \"שומר\" (watcher process) שיזהה קריסות ויבצע את הניקוי הנדרש, או להסתמך על תהליך אתחול שידאג לנקות משאבים \"יתומים\" (orphaned resources) בפתיחת המערכת."
    },
    "difficulty_estimation": "Hard"
  }
}