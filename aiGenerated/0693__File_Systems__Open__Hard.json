{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 23:39:24",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4084,
      "output_tokens": 4336,
      "total_tokens": 15940
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "File Systems",
      "I/O",
      "Disk Management",
      "Journaling"
    ],
    "content": {
      "text": "נתונה מערכת קבצים VSFS עם מבנה ייחודי: אין טבלת Inode ייעודית. במקום זאת, Inodes מאוחסנים בתוך בלוקי DATA רגילים. כל רשומת תיקייה מכילה את שם הקובץ ואת מיקום ה-Inode שלו, המיוצג כזוג `(מספר_בלוק, היסט_בתוך_הבלוק)`.\nInode הוא בגודל קבוע של 256 בתים. בלוק DATA הוא בגודל 4KB. גודל מצביע הוא 8 בתים.\nכל Inode מכיל:\n- מונה קישורים (reference count) בגודל 4 בתים.\n- סוג קובץ (file type) בגודל 4 בתים.\n- גודל קובץ (file size) בגודל 8 בתים.\n- 10 מצביעים ישירים.\n- 2 מצביעים עקיפים יחידים.\n- מצביע עקיף כפול אחד.\n- שאר המקום ב-Inode שמור לשימוש עתידי (padding).\n\nפרמטרי דיסק:\n- מהירות סיבוב (RPM): 7500.\n- זמן Seek ממוצע: 10ms.\n- קצב העברה מקסימלי: 2 MB/s.\n- תיקיית השורש (root directory) ממוקמת בבלוק DATA מספר 1, וה-Inode שלה ממוקם בבלוק DATA מספר 1 בהיסט 0.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מהו הגודל המקסימלי של קובץ הנתמך במערכת קבצים זו, וכמה בלוקי DATA הוא יתפוס (כולל בלוקים של מצביעים אך לא בלוק Inode)? פרטו את החישובים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "משתמש ביצע פעולת קריאה של 20KB מתחילתו של הקובץ `/home/user/documents/report.txt`. נתיב זה מכיל 3 תיקיות (home, user, documents) והקובץ report.txt. ידוע שכל רשומת תיקייה (Directory Entry) תופסת 32 בתים (שם הקובץ + מיקום Inode). כמו כן, ידוע שכל התיקיות בנתיב, וגם הקובץ `report.txt`, קטנים מספיק כך שכל הנתונים שלהם (למעט ה-Inode עצמו) נשמרים בבלוק DATA יחיד. בנוסף, ידוע שכל ה-Inodes בנתיב (כולל Inode הקובץ) נמצאים בבלוקי DATA שונים זה מזה, אך כל Inode ממוקם בתחילת הבלוק (היסט 0).\nנתון שאף cache אינו מכיל מידע רלוונטי לביצוע הפעולה. מהו הזמן המינימלי שתיקח פעולה זו? יש לפרט ולנמק את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "סטודנט טוען כי עיצוב מערכת קבצים זה (Inodes המוקצים בתוך בלוקי DATA, ורשומות תיקייה המצביעות ל-`(מספר_בלוק, היסט_בתוך_הבלוק)`) מציג אתגרים משמעותיים לניהול יעיל של שטח פנוי ולעקביות מטה-דאטה בעת מחיקת קבצים, גם עם מערכת Journaling חזקה. האם אתם מסכימים? הסבירו את האתגרים הספציפיים וכיצד ניתן למתן אותם, תוך התייחסות הן לקבצים בעלי קישור יחיד והן לקבצים בעלי קישורים קשיחים (hard links). תארו כיצד קריסה בנקודה קריטית במהלך מחיקה עלולה להוביל לאי-עקביות או אובדן נתונים.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון שאלה 1:\n\n1.1. חישוב גודל Inode:\nגודל Inode = 256 בתים.\nמקום למצביעים: 256 - 4 (מונה קישורים) - 4 (סוג קובץ) - 8 (גודל קובץ) = 240 בתים.\nמספר מצביעים שניתן לאחסן ב-Inode: 240 / 8 (גודל מצביע) = 30 מצביעים.\n\nהמצביעים הקיימים:\n- 10 מצביעים ישירים.\n- 2 מצביעים עקיפים יחידים.\n- 1 מצביע עקיף כפול.\nסה\"כ 10 + 2 + 1 = 13 מצביעים מסוגים שונים.\nמכיוון ש-13 < 30, כל המצביעים הללו יכולים להיכנס ב-Inode.\n\nמספר מצביעים בבלוק עקיף:\nבלוק DATA = 4KB = 4096 בתים.\nמספר מצביעים בבלוק עקיף = 4096 / 8 = 512 מצביעים.\n\nחישוב בלוקי נתונים מקסימליים:\n- 10 מצביעים ישירים: 10 בלוקים.\n- 2 מצביעים עקיפים יחידים: 2 * 512 בלוקים = 1024 בלוקים.\n- 1 מצביע עקיף כפול: 1 * 512 * 512 בלוקים = 262144 בלוקים.\nסה\"כ בלוקי DATA = 10 + 1024 + 262144 = 263178 בלוקים.\n\nגודל קובץ מקסימלי:\nגודל קובץ מקסימלי = 263178 בלוקים * 4KB/בלוק = 1,052,712KB = 1,028.039MB ≈ 1GB.\n\n1.2. נפרק את פעולת הקריאה לשלבים:\nחישוב זמן גישה לבלוק בודד (seek + rotational latency + transfer time):\nזמן סיבוב מלא = 60000ms / 7500 RPM = 8ms.\nזמן rotational latency ממוצע = 0.5 * 8ms = 4ms.\nזמן העברת בלוק (4KB) = 4KB / (2MB/s) = 4KB / 2048KB/s = 1/512 s ≈ 1.95ms ≈ 2ms.\nזמן גישה לבלוק בודד = 10ms (seek) + 4ms (rotational) + 2ms (transfer) = 16ms.\n\n1.  **קריאת Inode של תיקיית השורש:** ה-Inode נמצא בבלוק DATA 1. קריאה אחת של בלוק DATA. זמן = 16ms.\n2.  **קריאת בלוק ה-DATA של תיקיית השורש:** נניח שנתוני התיקייה נמצאים בבלוק DATA נוסף. קריאה אחת של בלוק DATA. זמן = 16ms.\n3.  **קריאת Inode של תיקיית `/home`:** מצאנו את `(block_num, offset)` עבור `/home`. נניח שזה בבלוק DATA חדש. קריאה אחת של בלוק DATA. זמן = 16ms.\n4.  **קריאת בלוק ה-DATA של תיקיית `/home`:** נניח שנתוני התיקייה נמצאים בבלוק DATA נוסף. קריאה אחת של בלוק DATA. זמן = 16ms.\n5.  **קריאת Inode של תיקיית `/user`:** מצאנו את `(block_num, offset)` עבור `/user`. נניח שזה בבלוק DATA חדש. קריאה אחת של בלוק DATA. זמן = 16ms.\n6.  **קריאת בלוק ה-DATA של תיקיית `/user`:** נניח שנתוני התיקייה נמצאים בבלוק DATA נוסף. קריאה אחת של בלוק DATA. זמן = 16ms.\n7.  **קריאת Inode של תיקיית `/documents`:** מצאנו את `(block_num, offset)` עבור `/documents`. נניח שזה בבלוק DATA חדש. קריאה אחת של בלוק DATA. זמן = 16ms.\n8.  **קריאת בלוק ה-DATA של תיקיית `/documents`:** נניח שנתוני התיקייה נמצאים בבלוק DATA נוסף. קריאה אחת של בלוק DATA. זמן = 16ms.\n9.  **קריאת Inode של הקובץ `report.txt`:** מצאנו את `(block_num, offset)` עבור `report.txt`. נניח שזה בבלוק DATA חדש. קריאה אחת של בלוק DATA. זמן = 16ms.\n\nסה\"כ פעולות גישה למטה-דאטה (Inodes ותיקיות) = 9 פעולות. זמן כולל למטה-דאטה = 9 * 16ms = 144ms.\n\n10. **קריאת נתוני הקובץ `report.txt`:** יש לקרוא 20KB. גודל בלוק הוא 4KB, לכן יש לקרוא 20KB / 4KB = 5 בלוקים.\n    נניח תרחיש מינימלי שבו 5 הבלוקים הללו רציפים על הדיסק, ומיד לאחר בלוק ה-Inode של הקובץ. במקרה זה, תהיה פעולת Seek אחת לבלוק הראשון של הנתונים, ולאחר מכן קריאה רציפה.\n    זמן קריאת 5 בלוקים רציפים = 10ms (seek) + 4ms (rotational) + (5 * 2ms (transfer)) = 10ms + 4ms + 10ms = 24ms.\n\nסה\"כ זמן מינימלי = 144ms (מטה-דאטה) + 24ms (נתונים) = 168ms.\n\n1.3. **הסכמה עם טענת הסטודנט:** כן, טענת הסטודנט נכונה. עיצוב זה אכן מציג אתגרים משמעותיים.\n\n**אתגרים ספציפיים וכיצד ניתן למתן אותם:**\n\n1.  **ניהול שטח פנוי בתוך בלוקים (Internal Fragmentation):**\n    *   **האתגר:** Inodes מוקצים בתוך בלוקי DATA. כאשר קובץ נמחק (מונה הקישורים שלו מגיע ל-0), רק ה-Inode הספציפי בתוך בלוק ה-DATA מסומן כפנוי. בלוק ה-DATA המכיל אותו לא יכול להיות משוחרר בחזרה לבריכת הבלוקים הפנויים כל עוד יש בו Inodes פעילים אחרים, או אם הבלוק משמש גם לאחסון נתוני קבצים אחרים. זה מוביל לפרגמנטציה פנימית משמעותית בתוך בלוקים, כאשר בלוקי DATA מכילים שילוב של Inodes פעילים, Inode slots פנויים שאינם ניתנים לשימוש עבור נתוני קובץ רגילים, ואולי גם נתוני קבצים רגילים.\n    *   **מיגון:** יש צורך ב-bitmap ייעודי ל-Inode slots בתוך בלוקי DATA, בדומה ל-bitmap של בלוקי DATA. כל ביט ב-bitmap כזה ייצג אם Inode slot מסוים בתוך בלוק DATA פנוי או תפוס. בלוק DATA ישוחרר רק כאשר כל ה-Inode slots בתוכו פנויים, וגם אין בו נתוני קבצים פעילים אחרים (אם הבלוק שימש גם לאחסון נתונים). מנגנון כזה מגדיל את מורכבות ניהול השטח הפנוי.\n    *   **עבור קבצים בעלי קישור יחיד:** כשמונה הקישורים מגיע ל-0, יש לסמן את ה-Inode slot כפנוי ולשחרר את בלוקי הנתונים שלו. אם בלוק ה-DATA שהכיל את ה-Inode כעת ריק מכל Inodes ונתונים, ניתן לשחרר אותו.\n    *   **עבור קבצים בעלי קישורים קשיחים:** מחיקת רשומת תיקייה רק מפחיתה את מונה הקישורים ב-Inode. רק כאשר מונה הקישורים מגיע ל-0, ה-Inode slot מסומן כפנוי ובלוקי הנתונים משוחררים. האתגר זהה לקבצים בעלי קישור יחיד – ניהול שטח פנוי בתוך בלוקים המכילים Inodes, אך במקרה זה, בלוק ה-DATA שמכיל את ה-Inode יישאר תפוס כל עוד מונה הקישורים גדול מ-0.\n\n2.  **מורכבות Journaling ועקביות מטה-דאטה:**\n    *   **האתגר:** במערכת Journaling רגילה, פעולת מחיקת קובץ כוללת: (1) הסרת רשומת התיקייה, (2) הפחתת מונה הקישורים ב-Inode, (3) אם מונה הקישורים מגיע ל-0: שחרור בלוקי הנתונים של הקובץ ושחרור ה-Inode slot בבלוק ה-DATA המכיל אותו. בעיצוב זה, פעולות (2) ו-(3) הן פעולות על בלוק DATA שיכול להכיל Inodes אחרים ו/או נתוני קבצים, מה שמסבך את הטיפול.\n    *   **תרחיש קריסה בעייתי (אי-עקביות/אובדן נתונים):**\n        *   **קריסה לאחר (1) ולפני (2):** רשומת התיקייה נמחקה, אך מונה הקישורים ב-Inode לא עודכן. ה-Inode ובלוקי הנתונים שלו עדיין מסומנים כתפוסים אך אינם נגישים דרך מערכת הקבצים (lost data). ה-Journaling צריך לכלול את עדכון מונה הקישורים כחלק מהטרנזקציה יחד עם מחיקת רשומת התיקייה. אם ה-Journaling לא מטפל בכך במפורש, הנתונים אבודים (לא ניתנים לגישה) אך לא משוחררים, מה שמוביל לדליפת שטח דיסק.\n        *   **קריסה לאחר (2) ולפני (3):** מונה הקישורים ירד ל-0, אך בלוקי הנתונים וה-Inode slot לא שוחררו. זה יוביל לדליפת שטח דיסק (space leak) – הנתונים אינם נגישים ואינם משוחררים. ה-Journaling חייב להבטיח ששחרור המשאבים יתבצע כחלק אינטגרלי מהטרנזקציה.\n        *   **אתגר ייחודי למערכת זו (קריסה בבלוק Inode):** אם בלוק DATA מכיל מספר Inodes, ובלוק זה משוחרר בטעות (למשל, עקב באג או קריסה מורכבת) לפני שכל ה-Inodes הפעילים בו פונו, אזי Inodes חיים עלולים להיפגע או להימחק. כל הקבצים המצביעים אליהם יהפכו לבלתי נגישים, וישנה סכנה לאובדן נתונים חמור. Journaling חייב לוודא ששחרור בלוק DATA המכיל Inodes מבוצע רק לאחר אימות שכל ה-Inode slots בתוכו פנויים, וכי הבלוק אינו מכיל נתוני קבצים פעילים אחרים.\n    *   **מיגון:** Journaling חייב לכלול את כל הפעולות הכרוכות במחיקה כטרנזקציה אטומית אחת: הסרת רשומת התיקייה, עדכון מונה הקישורים, ושחרור ה-Inode slot ובלוקי הנתונים (אם רלוונטי). במקרה של קריסה, ה-Journaling יבטיח שהמערכת תחזור למצב עקבי (לפני המחיקה או אחרי המחיקה המלאה). בנוסף, יש צורך בסריקות רקע תקופתיות (כמו fsck) לאיתור Inodes עם מונה קישורים 0 שבלוקיהם לא שוחררו (space leaks), או Inodes נגישים בבלוקים שסומנו בטעות כפנויים, כדי לתקן אי-עקביויות.\n\nלסיכום, בעוד שהעיצוב חוסך טבלת Inode ייעודית, הוא מעביר את מורכבות ניהול ה-Inodes לתוך בלוקי ה-DATA, מה שמסבך את ניהול שטח פנוי, פרגמנטציה פנימית, ודורש Journaling קפדני ומורכב יותר כדי להבטיח עקביות ושלמות המערכת."
    },
    "difficulty_estimation": "Hard"
  }
}