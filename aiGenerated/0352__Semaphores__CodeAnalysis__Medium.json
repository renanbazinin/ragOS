{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 21:01:03",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2864,
      "output_tokens": 1290,
      "total_tokens": 8578
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Semaphores",
      "Concurrency",
      "Threads"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה המשתמשת בסמפורים לצורך סנכרון בין שני תהליכונים (threads). ניתן להניח שכל קריאות המערכת מצליחות.",
      "code_snippet": "#include <pthread.h>\n#include <semaphore.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> \n\nsem_t semA, semB;\n\nvoid *thread_A_func(void *arg) {\n    for (int i = 0; i < 3; ++i) {\n        sem_wait(&semA);\n        printf(\"A\");\n        fflush(stdout); \n        sem_post(&semB);\n    }\n    return NULL;\n}\n\nvoid *thread_B_func(void *arg) {\n    for (int i = 0; i < 3; ++i) {\n        sem_wait(&semB);\n        printf(\"B\");\n        fflush(stdout); \n        sem_post(&semA);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tidA, tidB;\n\n    // Initialize semaphores\n    // semA allows thread A to start (value 1)\n    // semB blocks thread B initially (value 0)\n    sem_init(&semA, 0, 1); // Line 30\n    sem_init(&semB, 0, 0); // Line 31\n\n    pthread_create(&tidA, NULL, thread_A_func, NULL);\n    pthread_create(&tidB, NULL, thread_B_func, NULL);\n\n    pthread_join(tidA, NULL);\n    pthread_join(tidB, NULL);\n\n    sem_destroy(&semA);\n    sem_destroy(&semB);\n\n    printf(\"\\n\"); \n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "מהו הפלט המדויק של התוכנית? נמקו את תשובתכם.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "נניח שהקריאות לאתחול הסמפורים בשורות 30 ו-31 (sem_init) היו משתנות ל- `sem_init(&semA, 0, 0);` ו- `sem_init(&semB, 0, 0);` בהתאמה. מה תהיה השפעת השינוי על ריצת התוכנית? נמקו את תשובתכם.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. התוכנית יוצרת שני תהליכונים, Thread A ו-Thread B, המשתמשים בשני סמפורים (semA, semB) כדי להבטיח סדר הדפסה מתחלף. סמפור semA מאותחל ל-1, מה שמאפשר ל-Thread A להתחיל מיד. סמפור semB מאותחל ל-0, מה שחוסם את Thread B בתחילה.\nThread A מבצע `sem_wait(&semA)`, מדפיס 'A', ואז מבצע `sem_post(&semB)`. פעולה זו מאפשרת ל-Thread B להמשיך.\nThread B מבצע `sem_wait(&semB)`, מדפיס 'B', ואז מבצע `sem_post(&semA)`. פעולה זו מאפשרת ל-Thread A להמשיך.\nהלולאה מתבצעת 3 פעמים בכל תהליכון, וכך נוצרת סדרה של הדפסות מתחלפות. הפלט המדויק יהיה: ABABAB.\n\n2. אם שני הסמפורים יאותחלו ל-0, כלומר `sem_init(&semA, 0, 0);` ו- `sem_init(&semB, 0, 0);`:\nכאשר Thread A יתחיל, הוא יבצע `sem_wait(&semA)`. מכיוון ש-semA מאותחל ל-0, Thread A יחסם מיד וימתין ש-semA יהפוך לחיובי. הוא לעולם לא יגיע לשלב של `sem_post(&semB)`.\nבאופן דומה, כאשר Thread B יתחיל, הוא יבצע `sem_wait(&semB)`. מכיוון ש-semB מאותחל ל-0, Thread B יחסם מיד וימתין ש-semB יהפוך לחיובי. הוא לעולם לא יגיע לשלב של `sem_post(&semA)`.\nכתוצאה מכך, שני התהליכונים יחסמו באופן הדדי לנצח, והתוכנית תיכנס למצב של קיפאון (deadlock) ולא תדפיס דבר."
    },
    "difficulty_estimation": "Medium"
  }
}