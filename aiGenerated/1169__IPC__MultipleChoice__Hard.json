{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:24:58",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 968,
      "output_tokens": 1584,
      "total_tokens": 5831
    }
  },
  "question": {
    "id": 6,
    "type": "MultipleChoice",
    "topic": [
      "IPC",
      "Synchronization",
      "Semaphores",
      "Deadlock",
      "Producer-Consumer"
    ],
    "content": {
      "text": "נתון קטע קוד המממש בעיית יצרן-צרכן (Producer-Consumer) באמצעות זיכרון משותף (Shared Memory) וסמפורים של POSIX. גודל הבאפר המשותף הוא N. הסמפורים `mutex`, `empty` ו-`full` מאותחלים כראוי (mutex=1, empty=N, full=0). הנה קטע הקוד עבור תהליך היצרן והצרכן:\n\nאיזו טענה מתארת בצורה הטובה ביותר את הבעיה העלולה להתרחש במערכת זו?",
      "code_snippet": "// הגדרות והאתחול של זיכרון משותף וסמפורים בוצעו כראוי\n// sem_t *mutex, *empty, *full;\n// N הוא גודל הבאפר המשותף\n\n// קוד היצרן (Producer)\nvoid producer_task() {\n    // ... קוד הכנסת נתונים לבאפר משותף ...\n    sem_wait(mutex); // (1) תפיסת מנעול הדדי\n    sem_wait(empty); // (2) המתנה למקום פנוי\n    // הוספת פריט לבאפר\n    // ...\n    sem_post(full);  // (3) סימון מקום מלא\n    sem_post(mutex); // (4) שחרור מנעול הדדי\n}\n\n// קוד הצרכן (Consumer)\nvoid consumer_task() {\n    // ... קוד הוצאת נתונים מהבאפר המשותף ...\n    sem_wait(mutex); // (A) תפיסת מנעול הדדי\n    sem_wait(full);  // (B) המתנה לפריט קיים\n    // הוצאת פריט מהבאפר\n    // ...\n    sem_post(empty); // (C) סימון מקום פנוי\n    sem_post(mutex); // (D) שחרור מנעול הדדי\n}",
      "options": [
        "א. המערכת עלולה להיכנס למצב של רעב (Starvation) כאשר אחד התהליכים (יצרן או צרכן) לא יצליח לבצע פעולות, אך ללא קיפאון (Deadlock).",
        "ב. המערכת עלולה להיכנס למצב של קיפאון (Deadlock) כאשר הבאפר מלא והיצרן מנסה להוסיף פריט, אך לא במצב שהבאפר ריק והצרכן מנסה לצרוך פריט.",
        "ג. המערכת עלולה להיכנס למצב של קיפאון (Deadlock) כאשר הבאפר ריק והצרכן מנסה לצרוך פריט, אך לא במצב שהבאפר מלא והיצרן מנסה להוסיף פריט.",
        "ד. המערכת עלולה להיכנס למצב של קיפאון (Deadlock) כאשר הבאפר מלא או ריק, והתהליך המנסה לבצע פעולה חוסם את הגישה למשאבים שנדרשים לתהליך השני כדי להתקדם.",
        "ה. אין כל בעיה בקוד המוצג, והוא יפעל בצורה נכונה ויבטיח סנכרון תקין."
      ]
    },
    "sub_questions": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ד",
      "explanation": "התשובה הנכונה היא ד'. הקוד המוצג מכיל טעות קלאסית בסדר פעולות הסמפורים העלולה להוביל לקיפאון (Deadlock). נבחן שני מקרים:\n\n1.  **כאשר הבאפר מלא:**\n    *   תהליך היצרן מבצע `sem_wait(mutex)` ותופס את המנעול. (פעולה 1)\n    *   לאחר מכן, היצרן מבצע `sem_wait(empty)`. (פעולה 2) מכיוון שהבאפר מלא, ערך הסמפור `empty` הוא 0, והיצרן נכנס למצב המתנה. חשוב לציין שהיצרן עדיין מחזיק במנעול ה-`mutex`.\n    *   כעת, אם תהליך הצרכן מנסה לצרוך פריט, הוא יבצע `sem_wait(mutex)`. (פעולה A) אך המנעול כבר תפוס על ידי היצרן הממתין. לכן, הצרכן נכנס למצב המתנה על המנעול.\n    *   תוצאה: היצרן ממתין ל-`empty` (שישוחרר רק על ידי הצרכן לאחר צריכה), והצרכן ממתין ל-`mutex` (שמוחזק על ידי היצרן). זהו מצב של קיפאון.\n\n2.  **כאשר הבאפר ריק:**\n    *   תהליך הצרכן מבצע `sem_wait(mutex)` ותופס את המנעול. (פעולה A)\n    *   לאחר מכן, הצרכן מבצע `sem_wait(full)`. (פעולה B) מכיוון שהבאפר ריק, ערך הסמפור `full` הוא 0, והצרכן נכנס למצב המתנה. הצרכן עדיין מחזיק במנעול ה-`mutex`.\n    *   כעת, אם תהליך היצרן מנסה לייצר פריט, הוא יבצע `sem_wait(mutex)`. (פעולה 1) אך המנעול כבר תפוס על ידי הצרכן הממתין. לכן, היצרן נכנס למצב המתנה על המנעול.\n    *   תוצאה: הצרכן ממתין ל-`full` (שישוחרר רק על ידי היצרן לאחר ייצור), והיצרן ממתין ל-`mutex` (שמוחזק על ידי הצרכן). זהו גם מצב של קיפאון.\n\nהסדר הנכון של פעולות הסמפורים בפתרון בעיית יצרן-צרכן הוא קודם כל לבצע `sem_wait` על סמפור המשאב (empty/full) ורק לאחר מכן על סמפור ה-`mutex`. שחרור הסמפורים הוא בסדר הפוך (קודם `mutex` ואז `empty`/`full`)."
    },
    "difficulty_estimation": "Hard"
  }
}