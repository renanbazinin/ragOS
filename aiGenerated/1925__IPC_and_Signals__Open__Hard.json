{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:53:38",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 5051,
      "total_tokens": 17563
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Process Management"
    ],
    "content": {
      "text": "נתונה מערכת בה תהליך הורה (Parent) צריך להפיץ משימות למספר תהליכי ילד (Child) ולאסוף מהם תוצאות.\nיש לכתוב תוכנית בשפת C המממשת את התרחיש הבא:\n1.  תהליך ההורה יוצר שלושה תהליכי ילד (N_CHILDREN = 3).\n2.  ההורה שולח מזהה ייחודי (מספר שלם: 0, 1, 2) לכל אחד מהילדים.\n3.  כל תהליך ילד מקבל את המזהה שלו, מגדיל אותו ב-1, ושולח את הערך החדש בחזרה להורה.\n4.  לאחר שילד שולח את התוצאה להורה, הוא שולח אות SIGUSR1 להורה כדי לסמן שסיים את משימתו.\n5.  ההורה חייב להמתין שכל הילדים ישלימו את משימותיהם, לאסוף את כל התוצאות, ולהדפיס אותן.\n6.  ההורה חייב לטפל באות SIGINT (Ctrl+C) בצורה חלקה: עם קבלת האות, ההורה ידפיס הודעה מתאימה, ינסה לסיים את הילדים שעדיין פועלים (אם יש כאלה), ויסיים את פעולתו תוך ניקוי משאבים.\n\nדרישות:\n*   יש לכתוב את קוד המקור המלא בשפת C עבור תהליכי ההורה והילד.\n*   יש לכלול הסבר מפורט בכתב על מנגנוני ה-IPC (Inter-Process Communication) וה-Signals בהם נעשה שימוש.\n*   ההסבר צריך להתייחס במיוחד לאופן שבו נמנעים תנאי מירוץ (Race Conditions) בין קבלת אותות לבין קריאת נתונים מצינורות, וכיצד מובטחת סיום נאות של כל התהליכים וניקוי המשאבים (כולל מניעת Zombie Processes).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון מציג תוכנית C המממשת את התרחיש הנדרש באמצעות שילוב של `fork()`, `pipe()` וטיפול באותות (`signals`).\n\n**קוד מקור:**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <errno.h>\n\n#define N_CHILDREN 3\n\n// Global variables for signal handlers\nvolatile sig_atomic_t children_completed_count = 0;\nvolatile sig_atomic_t sigint_received = 0;\npid_t child_pids[N_CHILDREN]; // To map PIDs to indices\n\n// Signal handler for SIGUSR1\nvoid handle_sigusr1(int sig, siginfo_t *info, void *ucontext) {\n    (void)sig; // Unused parameter\n    (void)ucontext; // Unused parameter\n\n    pid_t sender_pid = info->si_pid;\n    for (int i = 0; i < N_CHILDREN; ++i) {\n        if (child_pids[i] == sender_pid) {\n            children_completed_count++;\n            break;\n        }\n    }\n}\n\n// Signal handler for SIGCHLD\nvoid handle_sigchld(int sig) {\n    (void)sig; // Unused parameter\n    int status;\n    pid_t pid;\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        // Child reaped\n    }\n}\n\n// Signal handler for SIGINT\nvoid handle_sigint(int sig) {\n    (void)sig; // Unused parameter\n    sigint_received = 1;\n    fprintf(stderr, \"\\nהורה: התקבלה בקשת סיום (SIGINT). מסיים פעולה.\\n\");\n}\n\nint main() {\n    // pipes[i][0] for read, pipes[i][1] for write\n    int p2c_pipes[N_CHILDREN][2]; // Parent to Child\n    int c2p_pipes[N_CHILDREN][2]; // Child to Parent\n\n    // Set up signal handlers\n    struct sigaction sa_usr1, sa_chld, sa_int;\n\n    // SIGUSR1 handler\n    sa_usr1.sa_sigaction = handle_sigusr1;\n    sigemptyset(&sa_usr1.sa_mask);\n    sa_usr1.sa_flags = SA_RESTART | SA_SIGINFO; // SA_SIGINFO to get sender PID\n    if (sigaction(SIGUSR1, &sa_usr1, NULL) == -1) {\n        perror(\"sigaction SIGUSR1\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGCHLD handler\n    sa_chld.sa_handler = handle_sigchld;\n    sigemptyset(&sa_chld.sa_mask);\n    sa_chld.sa_flags = SA_RESTART | SA_NOCLDSTOP; // SA_NOCLDSTOP to not get signals for stopped children\n    if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(EXIT_FAILURE);\n    }\n\n    // SIGINT handler\n    sa_int.sa_handler = handle_sigint;\n    sigemptyset(&sa_int.sa_mask);\n    sa_int.sa_flags = SA_RESTART;\n    if (sigaction(SIGINT, &sa_int, NULL) == -1) {\n        perror(\"sigaction SIGINT\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Create pipes and fork children\n    for (int i = 0; i < N_CHILDREN; ++i) {\n        if (pipe(p2c_pipes[i]) == -1) {\n            perror(\"pipe p2c\");\n            exit(EXIT_FAILURE);\n        }\n        if (pipe(c2p_pipes[i]) == -1) {\n            perror(\"pipe c2p\");\n            exit(EXIT_FAILURE);\n        }\n\n        pid_t pid = fork();\n        if (pid == -1) {\n            perror(\"fork\");\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) { // Child process\n            // Close unused pipe ends\n            for (int j = 0; j < N_CHILDREN; ++j) {\n                if (j == i) {\n                    close(p2c_pipes[j][1]); // Child doesn't write to its p2c pipe\n                    close(c2p_pipes[j][0]); // Child doesn't read from its c2p pipe\n                } else {\n                    close(p2c_pipes[j][0]);\n                    close(p2c_pipes[j][1]);\n                    close(c2p_pipes[j][0]);\n                    close(c2p_pipes[j][1]);\n                }\n            }\n\n            // Child logic\n            int received_id;\n            if (read(p2c_pipes[i][0], &received_id, sizeof(received_id)) == -1) {\n                perror(\"child read from p2c pipe\");\n                exit(EXIT_FAILURE);\n            }\n            close(p2c_pipes[i][0]); // Close read end after reading\n\n            printf(\"ילד %d (PID %d): קיבל את המזהה %d. מעבד...\\n\", i, getpid(), received_id);\n            int result = received_id + 1;\n\n            if (write(c2p_pipes[i][1], &result, sizeof(result)) == -1) {\n                perror(\"child write to c2p pipe\");\n                exit(EXIT_FAILURE);\n            }\n            close(c2p_pipes[i][1]); // Close write end after writing\n\n            // Send SIGUSR1 to parent\n            if (kill(getppid(), SIGUSR1) == -1) {\n                perror(\"child kill SIGUSR1\");\n                exit(EXIT_FAILURE);\n            }\n\n            printf(\"ילד %d (PID %d): סיים ושלח תוצאה %d ואות SIGUSR1 להורה.\\n\", i, getpid(), result);\n            exit(EXIT_SUCCESS);\n        } else { // Parent process\n            child_pids[i] = pid; // Store child PID for SIGUSR1 handler\n            // Close unused pipe ends\n            close(p2c_pipes[i][0]); // Parent doesn't read from its p2c pipe\n            close(c2p_pipes[i][1]); // Parent doesn't write to its c2p pipe\n        }\n    }\n\n    // Parent writes initial IDs to children\n    for (int i = 0; i < N_CHILDREN; ++i) {\n        if (sigint_received) break;\n        if (write(p2c_pipes[i][1], &i, sizeof(i)) == -1) {\n            perror(\"parent write to p2c pipe\");\n            exit(EXIT_FAILURE);\n        }\n        close(p2c_pipes[i][1]); // Close write end after writing\n    }\n\n    // Parent waits for all children to complete and reads results\n    int results[N_CHILDREN];\n    printf(\"הורה (PID %d): ממתין לתוצאות מ-%d ילדים...\\n\", getpid(), N_CHILDREN);\n\n    // Block SIGINT temporarily to prevent premature exit during critical section\n    sigset_t block_mask, old_mask;\n    sigemptyset(&block_mask);\n    sigaddset(&block_mask, SIGINT);\n    if (sigprocmask(SIG_BLOCK, &block_mask, &old_mask) == -1) {\n        perror(\"sigprocmask block\");\n        exit(EXIT_FAILURE);\n    }\n\n    for (int i = 0; i < N_CHILDREN; ++i) {\n        if (sigint_received) break;\n        if (read(c2p_pipes[i][0], &results[i], sizeof(results[i])) == -1) {\n            if (errno == EINTR && sigint_received) { // Check if interrupted by SIGINT\n                fprintf(stderr, \"הורה: קריאה מצינור הופרעה על ידי SIGINT.\\n\");\n                break;\n            }\n            perror(\"parent read from c2p pipe\");\n            exit(EXIT_FAILURE);\n        }\n        close(c2p_pipes[i][0]); // Close read end after reading\n        printf(\"הורה: קיבל תוצאה %d מילד %d.\\n\", results[i], i);\n    }\n\n    // Restore original signal mask\n    if (sigprocmask(SIG_SETMASK, &old_mask, NULL) == -1) {\n        perror(\"sigprocmask unblock\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Wait for all children to send SIGUSR1 (if not already received)\n    while (children_completed_count < N_CHILDREN && !sigint_received) {\n        pause(); // Wait for any signal\n    }\n\n    if (!sigint_received) {\n        printf(\"הורה: כל הילדים סימנו סיום ושלחו תוצאות. סיכום:\\n\");\n        for (int i = 0; i < N_CHILDREN; ++i) {\n            printf(\"  תוצאה מילד %d: %d\\n\", i, results[i]);\n        }\n    } else {\n        fprintf(stderr, \"הורה: סיום עקב SIGINT לפני השלמת כל המשימות.\\n\");\n        // Clean up remaining children if any\n        for (int i = 0; i < N_CHILDREN; ++i) {\n            // Send SIGTERM to any child that might still be running\n            if (child_pids[i] > 0 && kill(child_pids[i], SIGTERM) == -1 && errno != ESRCH) {\n                perror(\"kill SIGTERM\");\n            }\n        }\n    }\n\n    // Ensure all children are reaped\n    int status;\n    pid_t reaped_pid;\n    while ((reaped_pid = wait(&status)) > 0) {\n        // Child reaped\n    }\n    if (reaped_pid == -1 && errno != ECHILD) {\n        perror(\"wait\");\n    }\n\n    return sigint_received ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n```\n\n**הסבר מפורט:**\nהפתרון מציג תוכנית C המממשת את התרחיש הנדרש באמצעות שילוב של `fork()`, `pipe()` וטיפול באותות (`signals`).\n\n**יצירת תהליכים ותקשורת (IPC)**:\n1.  **`fork()`**: ההורה יוצר שלושה תהליכי ילד באמצעות קריאות חוזרות ל-`fork()`. כל ילד מקבל מזהה ייחודי (0, 1, 2) בהתאם לסדר היצירה. ה-PID של כל ילד נשמר במערך `child_pids` בהורה לצורך זיהוי מאוחר יותר על ידי מטפל האותות.\n2.  **`pipe()`**: לכל תהליך ילד מוקצים שני צינורות ייעודיים:\n    *   `p2c_pipes[i][2]`: צינור תקשורת מההורה לילד `i`. ההורה כותב לצינור זה (`p2c_pipes[i][1]`) והילד `i` קורא ממנו (`p2c_pipes[i][0]`).\n    *   `c2p_pipes[i][2]`: צינור תקשורת מהילד `i` להורה. הילד `i` כותב לצינור זה (`c2p_pipes[i][1]`) וההורה קורא ממנו (`c2p_pipes[i][0]`).\n    *   **ניהול יעיל של קצוות הצינורות**: כל תהליך (הורה או ילד) סוגר את הקצוות הלא נחוצים של הצינורות מיד לאחר ה-`fork()` כדי למנוע דליפות משאבים או חסימות מיותרות. לדוגמה, ההורה סוגר את קצוות הקריאה של צינורות `p2c` ואת קצוות הכתיבה של צינורות `c2p`. הילד סוגר את קצוות הכתיבה של צינורות `p2c` ואת קצוות הקריאה של צינורות `c2p`, וכן את כל קצוות הצינורות של ילדים אחרים.\n\n**טיפול באותות (Signals)**:\nנעשה שימוש בפונקציה `sigaction()` לטיפול באותות, המאפשרת טיפול מודרני ואמין יותר מאשר `signal()`.\n1.  **`SIGUSR1`**:\n    *   **מטרה**: ילד שסיים את משימתו שולח אות `SIGUSR1` להורה כדי ליידע אותו.\n    *   **טיפול בהורה**: פונקציית הטיפול `handle_sigusr1` מוגדרת עם הדגל `SA_SIGINFO`, המאפשר לקבל מידע נוסף על האות, כולל ה-PID של התהליך השולח (`info->si_pid`). ההורה משתמש במידע זה כדי לזהות איזה ילד שלח את האות (על ידי השוואה ל-`child_pids`) ולעדכן מונה גלובלי `children_completed_count`. זה מאפשר להורה לעקוב כמה ילדים סיימו.\n    *   **טיפול בילד**: הילד שולח `SIGUSR1` להורה באמצעות `kill(getppid(), SIGUSR1)`.\n2.  **`SIGCHLD`**:\n    *   **מטרה**: אות זה נשלח להורה כאשר תהליך ילד משנה את מצבו (לדוגמה, מסיים פעולה).\n    *   **טיפול בהורה**: פונקציית הטיפול `handle_sigchld` קוראת ל-`waitpid(-1, NULL, WNOHANG)` בלולאה. שימוש ב-`WNOHANG` מבטיח שהקריאה אינה חוסמת את ההורה אם אין ילדים שסיימו, והלולאה מבטיחה שכל הילדים ששינו מצב ייאספו (reaped) כדי למנוע תהליכי Zombie.\n3.  **`SIGINT`**:\n    *   **מטרה**: סיום התוכנית על ידי המשתמש (לרוב באמצעות Ctrl+C).\n    *   **טיפול בהורה**: פונקציית הטיפול `handle_sigint` מגדירה דגל גלובלי `sigint_received` ל-1. ההורה בודק דגל זה בלולאה הראשית שלו. אם הדגל פעיל, ההורה מדפיס הודעת סיום, שולח אות `SIGTERM` לכל הילדים שעדיין פועלים (כדי לנסות לסיים אותם באופן יזום), ורק אז מסיים את פעולתו תוך ניקוי משאבים.\n\n**מניעת תנאי מירוץ וסיום נאות**:\n*   **נתונים מצינורות מול אותות**: ההורה מתוכנן לקרוא את התוצאות מכל צינור `c2p_pipes[i][0]` באופן חוסם. כלומר, ההורה ימתין לנתונים מכל ילד בנפרד. מכיוון שהילד כותב את התוצאה לצינור *לפני* שליחת ה-`SIGUSR1`, מובטח שהנתונים יהיו זמינים להורה כאשר הוא יקרא. ה-`SIGUSR1` משמש כאן יותר כאישור נוסף לסיום המשימה, והמונה `children_completed_count` מאפשר להורה לדעת כמה ילדים *הבטיחו* שסיימו.\n*   **חסימת `SIGINT` בקטעים קריטיים**: ההורה חוסם זמנית את אות `SIGINT` באמצעות `sigprocmask()` לפני תחילת קריאת התוצאות מהילדים. זאת כדי למנוע מצב שבו `read()` מופרע על ידי `SIGINT` לפני השלמת קריאת הנתונים, מה שעלול להשאיר את המערכת במצב לא עקבי. לאחר הקריאה מכל הצינורות, המסכה המקורית של האותות משוחזרת. אם ה-`read()` בכל זאת מופרע על ידי `SIGINT` (למרות הדגל `SA_RESTART`), הקוד בודק את `errno == EINTR` יחד עם `sigint_received` ומטפל בכך בהתאם.\n*   **ניקוי ילדים (Reaping Children)**: פונקציית הטיפול ב-`SIGCHLD` מבטיחה שכל ילד שמסיים פעולה ייקלט על ידי ההורה, ובכך נמנעים תהליכי Zombie. בנוסף, בסיום התוכנית, ההורה מבצע לולאת `wait()` אחרונה (לאחר הקריאות החוסמות מהצינורות) כדי לוודא שכל הילדים נאספו, גם אם ה-`SIGCHLD` handler לא הספיק לטפל בכולם, או במקרה של סיום עקב `SIGINT`.\n*   **סיום חלקי עקב `SIGINT`**: אם `SIGINT` מתקבל, ההורה מזהה זאת, מדפיס הודעה, מנסה לשלוח `SIGTERM` לכל הילדים שעדיין רשומים כפעילים (באמצעות ה-PIDs שנשמרו), ורק אז מסיים את עצמו. זהו ניסיון לסגור את התוכנית בצורה נקייה ככל האפשר גם במקרה של הפרעה."
    },
    "difficulty_estimation": "Hard"
  }
}