{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 07:21:16",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3372,
      "output_tokens": 1558,
      "total_tokens": 7751
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "System Calls",
      "Process Management",
      "Kernel"
    ],
    "content": {
      "text": "מערכות הפעלה מספקות ממשק יישומים (API) שמאפשר לתוכניות משתמש לבקש שירותים מהקרנל. ממשק זה ממומש באמצעות קריאות מערכת (System Calls).\n\nא. הסבר/י בפירוט את המנגנון הכללי של קריאת מערכת, כולל המעבר ממצב משתמש (User Mode) למצב קרנל (Kernel Mode) והחזרה ממנו. ציין/י אילו רכיבים מעורבים בתהליך זה.\n\nב. התייחס/י לשתי קריאות המערכת `fork()` ו-`execve()`. הסבר/י את תפקידה של כל אחת מהן והצג/י את ההבדלים העיקריים ביניהן מבחינת השפעתן על התהליך הקורא.\n\nג. הסבר/י בקצרה מהו ההבדל המהותי בין קריאת מערכת (System Call) לבין קריאה לפונקציית ספרייה רגילה (Standard Library Function) מבחינת אופן הביצוע והרשאות.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. מנגנון קריאת מערכת: כאשר תוכנית משתמש מבצעת קריאת מערכת, היא למעשה מבקשת שירות מהקרנל. תהליך זה כרוך במספר שלבים:\n1.  הכנת פרמטרים: התוכנית מכינה את הפרמטרים הנדרשים לקריאת המערכת (למשל, מזהה קובץ, נתונים לכתיבה) ושמה אותם באוגרים או בזיכרון.\n2.  הפעלת פסיקת תוכנה (Software Interrupt / Trap): התוכנית מבצעת פקודת מעבד מיוחדת (לרוב `int N` או `syscall` ב-x86/x64) הגורמת לפסיקת תוכנה.\n3.  מעבר למצב קרנל: הפסיקה גורמת למעבד לעבור ממצב משתמש למצב קרנל, לשמור את מצב המעבד הנוכחי (Context Switching) ולנתב את הביצוע לכתובת בטבלת וקטורי הפסיקות (Interrupt Vector Table) המצביעה על שגרת הטיפול בקריאות מערכת בקרנל.\n4.  זיהוי קריאת המערכת: הקרנל בודק את מספר קריאת המערכת (שנמסר לרוב באוגר ספציפי) ומפנה לשגרת הטיפול המתאימה.\n5.  ביצוע השירות: הקרנל מבצע את הפעולה המבוקשת (לדוגמה, קריאה/כתיבה לדיסק, יצירת תהליך חדש) תוך שימוש בהרשאותיו המלאות.\n6.  החזרת תוצאה: לאחר סיום הפעולה, הקרנל מחזיר את התוצאה (לרוב באוגר ספציפי, למשל `eax` ב-x86) ואת קוד השגיאה (אם יש, למשל דרך `errno`).\n7.  חזרה למצב משתמש: הקרנל משחזר את מצב המעבד של התהליך הקורא וגורם למעבד לחזור למצב משתמש ולהמשיך את ביצוע התוכנית מהנקודה שבה הופסקה.\n\nב. `fork()` ו-`execve()`:\n*   `fork()`: קריאת מערכת זו יוצרת תהליך חדש (תהליך בן) שהוא עותק כמעט זהה של התהליך הקורא (תהליך אב). תהליך הבן מקבל עותק של מרחב הכתובות של האב, כולל קוד, נתונים, מחסנית, אוגרים ומתארי קבצים פתוחים. ההבדל העיקרי הוא ש-`fork()` מחזירה 0 לבן ומזהה תהליך (PID) של הבן לאב.\n*   `execve()` (או משפחת `exec`): קריאת מערכת זו מחליפה את מרחב הכתובות הנוכחי של התהליך הקורא בתוכנית חדשה לגמרי. היא טוענת קוד ונתונים של תוכנית חדשה מהדיסק לזיכרון, מאתחלת את המחסנית והאוגרים, ומעבירה את השליטה לנקודת הכניסה של התוכנית החדשה. ה-PID של התהליך נשאר זהה.\n*   הבדלים עיקריים:\n    *   `fork()` יוצר תהליך חדש, בעוד `execve()` מחליף את התוכנית בתהליך קיים.\n    *   לאחר `fork()`, שני תהליכים (אב ובן) ממשיכים לרוץ. לאחר `execve()`, רק התהליך המקורי ממשיך לרוץ, אך כעת הוא מבצע תוכנית אחרת.\n    *   `fork()` משכפל את מרחב הכתובות; `execve()` מוחק אותו ויוצר חדש.\n\nג. קריאת מערכת מול פונקציית ספרייה:\n*   קריאת מערכת (System Call): מתבצעת במצב קרנל (Kernel Mode) ודורשת מעבר הקשר. היא מספקת גישה למשאבי חומרה (כמו דיסק, זיכרון) ולשירותי ליבה של מערכת ההפעלה, ולכן דורשת הרשאות גבוהות.\n*   פונקציית ספרייה (Standard Library Function): מתבצעת במצב משתמש (User Mode). היא לרוב עוטפת (wraps) קריאת מערכת אחת או יותר, או מבצעת פעולה ללא צורך בגישה ישירה לקרנל (לדוגמה, חישוב מתמטי, מניפולציה של מחרוזות). היא אינה דורשת מעבר הקשר למצב קרנל אלא אם כן היא עצמה קוראת לקריאת מערכת."
    },
    "difficulty_estimation": "Medium"
  }
}