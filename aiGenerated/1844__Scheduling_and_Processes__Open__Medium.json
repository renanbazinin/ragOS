{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 21:10:38",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2768,
      "output_tokens": 2865,
      "total_tokens": 13380
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Processes",
      "CPU Scheduling",
      "Process Types"
    ],
    "content": {
      "text": "מערכת הפעלה מריצה מספר תהליכים בעלי אופי שונה. תהליכים מסוימים הם 'CPU-bound' (דורשים זמן מעבד רב), ותהליכים אחרים הם 'I/O-bound' (מבצעים בעיקר פעולות קלט/פלט וממתינים להן). הבנת האופי של תהליכים אלו חיונית לתזמון יעיל.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "הסבירו מה ההבדל המהותי בין תהליך CPU-bound לתהליך I/O-bound בהקשר של תזמון מעבד, וציינו מדוע חשוב למתזמן להבחין ביניהם.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "כיצד אלגוריתם תזמון Round-Robin (RR) יתמודד עם תערובת של תהליכים משני הסוגים? אילו יתרונות וחסרונות יהיו לגישה זו מבחינת ביצועי המערכת הכוללים (לדוגמה: תפוקה, זמן תגובה, ניצול מעבד)?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "כיצד אלגוריתם תזמון Multi-Level Feedback Queue (MLFQ) יתמודד עם תערובת של תהליכים משני הסוגים? הסבירו כיצד הגישה של MLFQ מנסה לייעל את הטיפול בכל אחד מהסוגים, וציינו שיפורים אפשריים על פני RR בהקשר זה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.4",
        "text": "בהתחשב בקטע הקוד הבא, המייצג חלק מפעילות של תהליך, הסבירו האם הוא נוטה להיות CPU-bound או I/O-bound כאשר `is_cpu_bound` הוא `1`. כיצד שינוי בערך `iterations` (מספר האיטרציות) ישפיע על אופיו זה? הסבירו את השפעת שינוי זה על תזמון התהליך במערכת המשתמשת באלגוריתם MLFQ.",
        "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For usleep\n\nvoid my_process_function(int iterations, int is_cpu_bound) {\n    if (is_cpu_bound) {\n        // Simulate CPU-intensive work\n        for (long long i = 0; i < iterations * 100000; ++i) {\n            // Perform some calculation\n            volatile long long temp = i * i; // Use volatile to prevent optimization\n        }\n    } else {\n        // Simulate I/O-intensive work\n        for (int i = 0; i < iterations; ++i) {\n            usleep(10000); // Simulate blocking I/O for 10ms\n        }\n    }\n}",
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1:\nתהליך CPU-bound הוא תהליך שמבלה את רוב זמנו בביצוע חישובים על המעבד, ורק לעיתים רחוקות מבצע פעולות קלט/פלט. הוא דורש זמן מעבד רב כדי להשלים את משימתו.\nתהליך I/O-bound הוא תהליך שמבלה את רוב זמנו בהמתנה לפעולות קלט/פלט (כגון קריאה/כתיבה לדיסק, תקשורת רשת). הוא מבצע מעט חישובים על המעבד ומשחרר אותו לעיתים קרובות.\nחשוב למתזמן להבחין ביניהם מכיוון שתזמון יעיל צריך למקסם את ניצול המעבד תוך שמירה על זמני תגובה טובים. תהליכי I/O-bound זקוקים למעבד לפרקי זמן קצרים כדי ליזום פעולת קלט/פלט, ולאחר מכן הם משחררים אותו. אם המתזמן יתעדף אותם, הם יתחילו את פעולת ה-I/O שלהם מהר יותר וישחררו את המעבד, מה שמאפשר לתהליכי CPU-bound לרוץ. זה גם משפר את זמן התגובה למשתמש (שפעמים רבות קשור לתהליכי I/O-bound).\n\n1.2:\nאלגוריתם Round-Robin מחלק את זמן המעבד ל\"פרוסות\" זמן קבועות (time slices או quanta) ומקצה לכל תהליך תורו לרוץ עבור פרוסת זמן אחת.\n*   יתרונות:\n    *   הוגנות (Fairness): כל תהליך מקבל הזדמנות לרוץ, מה שמבטיח שגם תהליכים ארוכים יתקדמו ולא יורעבו.\n    *   זמן תגובה (Response Time): עבור תהליכי I/O-bound, RR יכול להיות יעיל למדי. תהליך I/O-bound יקבל את המעבד, יבצע את פעולת ה-I/O שלו (שבדרך כלל מסתיימת לפני תום הקוונטה), וישחרר את המעבד מרצון. זה מאפשר לו להתחיל את פעולת ה-I/O הבאה במהירות יחסית.\n*   חסרונות:\n    *   overhead של החלפת הקשר (Context Switch Overhead): אם ה-quantum קטן מדי, המערכת תבזבז זמן רב על החלפות קשר בין תהליכים, מה שמפחית את ניצול המעבד האפקטיבי, במיוחד עבור תהליכי CPU-bound.\n    *   ביצועים לתהליכי CPU-bound: תהליכי CPU-bound יופסקו שוב ושוב בסוף כל quantum, גם אם יכלו להמשיך לרוץ. זה אולי לא פוגע בתפוקה הכללית (אם המעבד תמיד עסוק), אבל יכול להאריך את זמן ההשלמה (turnaround time) שלהם.\n    *   חוסר התאמה לאופי התהליכים: RR אינו מבחין בין סוגי התהליכים ולכן לא מנצל את העובדה שתהליכי I/O-bound משחררים את המעבד מוקדם. הוא מתייחס לכולם באופן שווה, מה שלא תמיד אופטימלי לניצול המשאבים הכולל.\n\n1.3:\nMLFQ משתמש במספר תורים בעלי רמות עדיפות שונות. תהליכים חדשים נכנסים לתור בעדיפות הגבוהה ביותר.\n*   טיפול בתהליכי I/O-bound: תהליכים אלו נכנסים לתור העליון. מכיוון שהם מבצעים פעולת I/O ומשחררים את המעבד (או נחסמים) במהירות, הם לא מנצלים את כל הקוונטה שלהם. המתזמן רואה שהם לא ניצלו את הקוונטה במלואה, ולכן משאיר אותם בתור בעדיפות גבוהה (או מעלה את עדיפותם). זה מבטיח שתהליכי I/O-bound יקבלו את המעבד במהירות בכל פעם שהם מוכנים לרוץ, מה שמשפר מאוד את זמן התגובה.\n*   טיפול בתהליכי CPU-bound: תהליכים אלו מנצלים את כל הקוונטה שלהם. המתזמן מזהה זאת ומוריד אותם לתור בעדיפות נמוכה יותר, שם ה-quantum ארוך יותר. זה מפחית את מספר החלפות הקשר עבורם ומאפשר להם לרוץ לפרקי זמן ארוכים יותר, מה שמשפר את התפוקה עבורם (פחות overhead).\n*   שיפורים על פני RR:\n    *   הפחתת החלפות קשר מיותרות: MLFQ מזהה תהליכי CPU-bound ומקצה להם קוונטה ארוכה יותר בתורים הנמוכים, מה שמפחית את ה-overhead של החלפות הקשר בהשוואה ל-RR עם quantum קבוע וקצר.\n    *   זמן תגובה טוב יותר לתהליכי I/O-bound: על ידי שמירה על תהליכי I/O-bound בתורים בעדיפות גבוהה, MLFQ מבטיח שהם יקבלו את המעבד כמעט מיד עם הפיכתם למוכנים, מה שמשפר דרמטית את זמן התגובה למשתמש בהשוואה ל-RR שבו הם עשויים לחכות לתורם.\n    *   מניעת הרעבה (Starvation): באמצעות מנגנונים כמו \"priority boost\" (העלאת עדיפות תקופתית של כל התהליכים לתור העליון) MLFQ מונע הרעבה של תהליכים בתורים הנמוכים.\n\n1.4:\nכאשר `is_cpu_bound` הוא `1`, קטע הקוד מייצג תהליך **CPU-bound**. הלולאה `for (long long i = 0; i < iterations * 100000; ++i)` מבצעת חישובים אינטנסיביים על המעבד מבלי לבצע פעולות קלט/פלט או לחסום.\n*   השפעת שינוי ב-`iterations`:\n    *   `iterations` קטן: כאשר `iterations` קטן, כמות החישובים קטנה יותר, והתהליך יסיים את עבודתו על המעבד במהירות יחסית. הוא עדיין CPU-bound, אך לזמן קצר.\n    *   `iterations` גדול: כאשר `iterations` גדול, כמות החישובים גדולה מאוד, והתהליך ידרוש זמן מעבד ארוך מאוד כדי להשלים את משימתו. הוא יהיה CPU-bound מובהק.\n*   השפעה על תזמון MLFQ:\n    *   `iterations` קטן (CPU-bound קצר): התהליך יתחיל בתור בעדיפות גבוהה. למרות שהוא CPU-bound, אם הוא יסיים את ריצתו לפני תום הקוונטה הראשונה (או יבצע מספר מועט של קוונטות), הוא לא יירד רחוק בתורי ה-MLFQ. זמני ההשלמה שלו יהיו טובים יחסית.\n    *   `iterations` גדול (CPU-bound ארוך): התהליך יתחיל בתור בעדיפות גבוהה וינצל את מלוא הקוונטה. המתזמן יזהה זאת ויוריד אותו בהדרגה לתורים בעדיפות נמוכה יותר, שם ה-quantum ארוך יותר. זה אומר שהוא יקבל פחות החלפות קשר אך יצטרך לחכות זמן רב יותר בין ריצותיו, וזמן ההשלמה הכולל שלו יהיה ארוך יותר. MLFQ מזהה את אופיו ה-CPU-bound הארוך ומעביר אותו לתורים שמתאימים יותר לתהליכים כאלה, ובכך משחרר את התורים העליונים לתהליכי I/O-bound או CPU-bound קצרים יותר."
    },
    "difficulty_estimation": "Medium"
  }
}