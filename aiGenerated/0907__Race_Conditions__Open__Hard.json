{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Race Conditions",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 01:13:43",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4708,
      "output_tokens": 4964,
      "total_tokens": 17638
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Race Conditions"
    ],
    "content": {
      "text": "יישום שרת מרובה-תהליכים (multi-threaded) מנהל מאגר של חיבורי רשת. כאשר לקוח מתחבר, אובייקט חיבור נלקח מהמאגר. כאשר לקוח מתנתק, אובייקט החיבור מוחזר למאגר. המאגר ממומש כרשימה מקושרת פשוטה.\nלהלן מימוש חלקי (ולא תקין) של מאגר החיבורים בשפת C++ באמצעות pthreads:\n\n```c++\n#include <iostream>\n#include <vector>\n#include <pthread.h>\n#include <unistd.h> // For sleep\n\n// מייצג חיבור רשת\nstruct Connection {\n    int id;\n    bool in_use;\n    Connection* next;\n};\n\n// ראש המאגר הגלובלי (רשימה מקושרת)\nConnection* connection_pool_head = nullptr;\nint pool_size = 0; // עוקב אחר מספר החיבורים הזמינים\n\n// פונקציה לאתחול המאגר\nvoid initialize_pool(int num_connections) {\n    connection_pool_head = nullptr;\n    for (int i = 0; i < num_connections; ++i) {\n        Connection* new_conn = new Connection();\n        new_conn->id = i;\n        new_conn->in_use = false;\n        new_conn->next = connection_pool_head;\n        connection_pool_head = new_conn;\n        pool_size++;\n    }\n}\n\n// פונקציה לקבלת חיבור מהמאגר\nConnection* get_connection() {\n    if (connection_pool_head == nullptr) {\n        // המאגר ריק, מחכים או מחזירים null\n        return nullptr;\n    }\n    Connection* conn = connection_pool_head;\n    connection_pool_head = connection_pool_head->next;\n    conn->in_use = true;\n    pool_size--;\n    return conn;\n}\n\n// פונקציה להחזרת חיבור למאגר\nvoid return_connection(Connection* conn) {\n    if (conn == nullptr) return;\n    conn->in_use = false;\n    conn->next = connection_pool_head;\n    connection_pool_head = conn;\n    pool_size++;\n}\n\n// פונקציית דוגמה לתהליך לקוח (לא תקינה)\nvoid* client_thread(void* arg) {\n    long thread_id = (long)arg;\n    for (int i = 0; i < 3; ++i) {\n        Connection* conn = get_connection();\n        if (conn) {\n            std::cout << \"Thread \" << thread_id << \" got connection \" << conn->id << std::endl;\n            sleep(1); // מדמה עבודה\n            return_connection(conn);\n            std::cout << \"Thread \" << thread_id << \" returned connection \" << conn->id << std::endl;\n        } else {\n            std::cout << \"Thread \" << thread_id << \" failed to get connection (pool empty)\" << std::endl;\n        }\n        sleep(0); // ויתור על זמן מעבד\n    }\n    return nullptr;\n}\n\nint main() {\n    const int NUM_CONNECTIONS = 5;\n    const int NUM_THREADS = 10;\n\n    initialize_pool(NUM_CONNECTIONS);\n    std::cout << \"Pool initialized with \" << NUM_CONNECTIONS << \" connections.\" << std::endl;\n\n    pthread_t threads[NUM_THREADS];\n    for (long i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], nullptr, client_thread, (void*)i);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], nullptr);\n    }\n\n    std::cout << \"All threads finished.\" << std::endl;\n    // יש לשחרר משאבים בסיום - לא כלול בבדיקה זו\n    return 0;\n}\n```\n\n1.  זהו את כל תנאי המרוץ (Race Conditions) הקיימים בקוד הנתון בפונקציות `get_connection` ו-`return_connection`. פרטו את שורות הקוד הספציפיות שבהן הם מתרחשים.\n2.  הסבירו את ההשלכות הפוטנציאליות של כל תנאי מרוץ שזיהיתם (לדוגמה: אובדן נתונים, קריסות, מצב לא עקבי).\n3.  הציעו מימוש מתוקן, בטוח לתהליכים (thread-safe), עבור הפונקציות `get_connection` ו-`return_connection` תוך שימוש במנגנוני סנכרון של pthreads (לדוגמה: mutexes, condition variables). נמקו את בחירתכם במנגנונים אלו והסבירו כיצד הם פותרים את תנאי המרוץ.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### 1. זיהוי תנאי המרוץ:\n\n*   **בפונקציה `get_connection()`:**\n    *   **שורה `if (connection_pool_head == nullptr)`:** שני תהליכים או יותר יכולים לבדוק בו-זמנית שהמאגר אינו ריק (כלומר, `connection_pool_head` אינו `nullptr`). לאחר מכן, תהליך אחד לוקח את החיבור, והתהליכים האחרים עדיין ינסו לגשת לחיבור שכבר נלקח או ל-`connection_pool_head` שכבר עודכן, מה שעלול להוביל לגישה לא חוקית לזיכרון (dereferencing `nullptr`) או לקבלת אותו חיבור על ידי מספר תהליכים.\n    *   **שורות `Connection* conn = connection_pool_head; connection_pool_head = connection_pool_head->next;`:** זהו תנאי מרוץ קלאסי ברשימה מקושרת. אם תהליך A קורא את `connection_pool_head`, ולאחר מכן תהליך B קורא את `connection_pool_head` (מקבל את אותו ערך), ואז תהליך A מעדכן את `connection_pool_head` ל-`connection_pool_head->next`, ואז תהליך B מעדכן את `connection_pool_head` גם כן (אבל מהערך הישן שקרא), העדכון של תהליך A אובד. בנוסף, שני התהליכים יקבלו את אותו אובייקט `Connection`.\n    *   **שורה `pool_size--;`:** זוהי פעולה של קריאה-שינוי-כתיבה (read-modify-write) על משתנה גלובלי משותף (`pool_size`). אם שני תהליכים מנסים להקטין את `pool_size` בו-זמנית, ייתכן ששניהם יקראו את אותו ערך, יקטינו אותו ב-1, ויכתבו את התוצאה, וכך אחד מהעדכונים יאבד (לדוגמה, אם `pool_size` הוא 5, שני תהליכים יקראו 5, שניהם יחשבו 4, ושניהם יכתבו 4, במקום שהערך יהיה 3).\n    *   **שורה `conn->in_use = true;`:** למרות שזהו עדכון שדה בתוך אובייקט `Connection`, אם שני תהליכים קיבלו את אותו אובייקט `Connection` עקב תנאי מרוץ קודם, שניהם ינסו להגדיר את השדה `in_use` ל-`true`, מה שמעיד על שימוש כפול באותו חיבור.\n\n*   **בפונקציה `return_connection()`:**\n    *   **שורות `conn->next = connection_pool_head; connection_pool_head = conn;`:** גם כאן קיים תנאי מרוץ קלאסי של הוספה לראש רשימה מקושרת. אם תהליך A קורא את `connection_pool_head`, ולאחר מכן תהליך B קורא את `connection_pool_head` (מקבל את אותו ערך), ואז תהליך A מעדכן את `connection_pool_head` (ל-`conn` של A), ואז תהליך B מעדכן את `connection_pool_head` (ל-`conn` של B, באמצעות הערך הישן שקרא), החיבור שהוחזר על ידי תהליך A יאבד מהרשימה.\n    *   **שורה `pool_size++;`:** בדומה ל-`pool_size--`, זוהי פעולת קריאה-שינוי-כתיבה על משתנה גלובלי משותף ללא הגנה, שעלולה לגרום לאובדן עדכונים ולהצגה שגויה של גודל המאגר.\n\n### 2. השלכות פוטנציאליות:\n\n*   **קבלת אותו חיבור על ידי מספר תהליכים:** תוצאה קריטית ביותר. שני לקוחות שונים עלולים להשתמש באותו חיבור רשת בו-זמנית, מה שיוביל לשחיתות נתונים, שליחת נתונים ללקוח הלא נכון, קריסות של השרת או הלקוח, וחוסר יציבות כללי של המערכת.\n*   **אובדן חיבורים מהמאגר:** חיבורים שהוחזרו למאגר עלולים \"להיעלם\" מהרשימה המקושרת אם העדכונים ל-`connection_pool_head` נדרסים. זה יוביל לדליפת זיכרון (אם האובייקטים לא נמחקים) ולמחסור בחיבורים זמינים, גם אם בפועל הם קיימים אך אינם נגישים.\n*   **מצב לא עקבי של `pool_size`:** ערך שגוי של `pool_size` עלול לגרום למערכת לחשוב שיש פחות חיבורים ממה שבאמת זמין (אם `++` אבד) או יותר חיבורים (אם `--` אבד), מה שיוביל להחלטות שגויות לגבי הקצאת משאבים או לחכות לחיבורים שאינם קיימים.\n*   **Dereferencing `nullptr`:** אם תהליכים מנסים לגשת ל-`connection_pool_head->next` כאשר `connection_pool_head` כבר `nullptr` (עקב תנאי מרוץ), זה יוביל לקריסת היישום.\n*   **רעב (Starvation) או המתנה אין-סופית:** במצב שבו `get_connection` מחזיר `nullptr` כאשר המאגר ריק, תהליכים עשויים לחזור על בדיקה זו שוב ושוב, מבזבזים זמן מעבד. במקרה של שימוש במנגנוני המתנה, תנאי מרוץ עלול למנוע מתהליך שצריך חיבור \"להתעורר\" גם כשיש חיבור זמין.\n\n### 3. מימוש מתוקן (Thread-Safe) באמצעות pthreads:\n\nכדי לפתור את תנאי המרוץ, נשתמש ב-`pthread_mutex_t` להגנה על הגישה למבנה הנתונים המשותף (הרשימה המקושרת `connection_pool_head` והמשתנה `pool_size`). בנוסף, נשתמש ב-`pthread_cond_t` (משתנה תנאי) כדי לאפשר לתהליכים לחכות כאשר המאגר ריק, ולהתעורר כאשר חיבור מושב למאגר.\n\n```c++\n#include <iostream>\n#include <vector>\n#include <pthread.h>\n#include <unistd.h> // For sleep\n\n// מייצג חיבור רשת\nstruct Connection {\n    int id;\n    bool in_use;\n    Connection* next;\n};\n\n// ראש המאגר הגלובלי (רשימה מקושרת)\nConnection* connection_pool_head = nullptr;\nint pool_size = 0; // עוקב אחר מספר החיבורים הזמינים\nint max_pool_size = 0; // גודל המאגר המקסימלי\n\n// מנגנוני סנכרון\npthread_mutex_t pool_mutex;\npthread_cond_t pool_not_empty; // מסומן כאשר חיבור זמין במאגר\n\n// פונקציה לאתחול המאגר\nvoid initialize_pool(int num_connections) {\n    pthread_mutex_init(&pool_mutex, nullptr);\n    pthread_cond_init(&pool_not_empty, nullptr);\n    \n    connection_pool_head = nullptr;\n    max_pool_size = num_connections;\n    for (int i = 0; i < num_connections; ++i) {\n        Connection* new_conn = new Connection();\n        new_conn->id = i;\n        new_conn->in_use = false;\n        new_conn->next = connection_pool_head;\n        connection_pool_head = new_conn;\n        pool_size++;\n    }\n}\n\n// פונקציה לקבלת חיבור מהמאגר\nConnection* get_connection() {\n    pthread_mutex_lock(&pool_mutex); // נכנס לאזור קריטי\n    \n    // כל עוד המאגר ריק, נחכה שחיבור יוחזר\n    while (connection_pool_head == nullptr) {\n        // משחרר את המוטקס ומרדים את התהליך. כאשר מתעורר, נועל שוב את המוטקס.\n        pthread_cond_wait(&pool_not_empty, &pool_mutex);\n    }\n    \n    // כעת המאגר אינו ריק, ורק תהליך אחד מחזיק את המוטקס\n    Connection* conn = connection_pool_head;\n    connection_pool_head = connection_pool_head->next;\n    conn->in_use = true;\n    pool_size--;\n    \n    pthread_mutex_unlock(&pool_mutex); // יוצא מהאזור הקריטי\n    return conn;\n}\n\n// פונקציה להחזרת חיבור למאגר\nvoid return_connection(Connection* conn) {\n    if (conn == nullptr) return;\n    \n    pthread_mutex_lock(&pool_mutex); // נכנס לאזור קריטי\n    \n    conn->in_use = false;\n    conn->next = connection_pool_head;\n    connection_pool_head = conn;\n    pool_size++;\n    \n    // מסמן לתהליכים הממתינים שחיבור זמין\n    pthread_cond_signal(&pool_not_empty); // או pthread_cond_broadcast אם יש מספר ממתינים\n    \n    pthread_mutex_unlock(&pool_mutex); // יוצא מהאזור הקריטי\n}\n\n// פונקציה לניקוי משאבים (לצורך השלמת הקוד)\nvoid destroy_pool() {\n    pthread_mutex_destroy(&pool_mutex);\n    pthread_cond_destroy(&pool_not_empty);\n    Connection* current = connection_pool_head;\n    while (current != nullptr) {\n        Connection* next = current->next;\n        delete current;\n        current = next;\n    }\n    connection_pool_head = nullptr;\n    pool_size = 0;\n}\n\n// פונקציית דוגמה לתהליך לקוח (כמו בשאלה)\nvoid* client_thread(void* arg) {\n    long thread_id = (long)arg;\n    for (int i = 0; i < 3; ++i) {\n        Connection* conn = get_connection();\n        if (conn) {\n            std::cout << \"Thread \" << thread_id << \" got connection \" << conn->id << std::endl;\n            sleep(1); // Simulate work\n            return_connection(conn);\n            std::cout << \"Thread \" << thread_id << \" returned connection \" << conn->id << std::endl;\n        } else {\n            // במקרה של המימוש המתוקן, תהליך ימתין ולא יגיע לכאן אלא אם כן יש בעיה חמורה\n            std::cout << \"Thread \" << thread_id << \" (should not happen) failed to get connection (pool empty)\" << std::endl;\n        }\n        sleep(0); // Yield\n    }\n    return nullptr;\n}\n\nint main() {\n    const int NUM_CONNECTIONS = 5;\n    const int NUM_THREADS = 10;\n\n    initialize_pool(NUM_CONNECTIONS);\n    std::cout << \"Pool initialized with \" << NUM_CONNECTIONS << \" connections.\" << std::endl;\n\n    pthread_t threads[NUM_THREADS];\n    for (long i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], nullptr, client_thread, (void*)i);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], nullptr);\n    }\n\n    std::cout << \"All threads finished.\" << std::endl;\n    destroy_pool(); // שחרור משאבים\n    return 0;\n}\n```\n\n**נימוק לבחירת מנגנוני הסנכרון:**\n\n*   **`pthread_mutex_t pool_mutex`:** המוטקס משמש להגנה על האזור הקריטי (critical section) שבו מתבצעת גישה ושינוי של הנתונים המשותפים (`connection_pool_head` ו-`pool_size`). רק תהליך אחד יכול להחזיק במוטקס בכל רגע נתון, מה שמבטיח בלעדיות (mutual exclusion) ומונע את כל תנאי המרוץ שזוהו בסעיף 1. כל פעולות הקריאה והכתיבה על `connection_pool_head` ו-`pool_size` מוגנות כעת.\n*   **`pthread_cond_t pool_not_empty`:** משתנה התנאי מאפשר לתהליכים לחכות ביעילות כאשר המאגר ריק, במקום לבצע סריקה פעילה (busy-waiting).\n    *   ב-`get_connection()`, כאשר `connection_pool_head` הוא `nullptr`, התהליך קורא ל-`pthread_cond_wait()`. פונקציה זו משחררת אוטומטית את המוטקס (`pool_mutex`) ומרדימה את התהליך. כאשר תהליך אחר מחזיר חיבור למאגר, הוא מסמן (signal) למשתנה התנאי.\n    *   כאשר התהליך הממתין \"מתעורר\" (על ידי `signal` או `broadcast`), הוא נועל מחדש את המוטקס באופן אוטומטי וממשיך בביצוע. הלולאה `while (connection_pool_head == nullptr)` חשובה כדי להתמודד עם התעוררות כוזבת (spurious wakeups) או במקרה של `broadcast` כאשר מספר תהליכים מתעוררים אך רק אחד מהם יכול לקבל את החיבור.\n*   **`pthread_cond_signal(&pool_not_empty)`:** ב-`return_connection()`, לאחר שחיבור הוחזר למאגר והנתונים המשותפים עודכנו תחת הגנת המוטקס, הפונקציה קוראת ל-`pthread_cond_signal()`. קריאה זו מעירה תהליך אחד (אם קיים) שממתין על `pool_not_empty`, ובכך מאפשרת לו לנסות שוב לקבל חיבור מהמאגר.\n\nמימוש זה מבטיח שאף שני תהליכים לא יגשו או ישנו את הנתונים המשותפים בו-זמנית, ושזמינות החיבורים תטופל באופן יעיל ללא busy-waiting."
    },
    "difficulty_estimation": "Hard"
  }
}