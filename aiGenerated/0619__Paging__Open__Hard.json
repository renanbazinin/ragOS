{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Paging",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 06:49:13",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4788,
      "output_tokens": 5421,
      "total_tokens": 17297
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Paging",
      "Virtual Memory",
      "Memory Management",
      "Address Translation",
      "Page Faults",
      "TLB"
    ],
    "content": {
      "text": "נתונה מערכת זיכרון וירטואלי המשתמשת בטבלת דפים היררכית דו-רמתית (Two-level Paging).\nגודל דף במערכת הוא 4KB (קילו-בתים).\nגודל כל כניסה בטבלת הדפים (PTE) הוא 8 בתים.\nמרחב הכתובות הוירטואלי של תהליך הוא 64 ביט.\nגודל הזיכרון הפיזי המקסימלי במערכת הוא 2^40 בתים.\nיש להניח שכל טבלת דפים (ברמה P1 וברמה P2) מתאימה בדיוק לדף אחד בזיכרון הפיזי.\n\nיש לפרט ולנמק את כל החישובים וההסברים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון לשאלה 1:\n\n**סעיף 1.1:**\n*   **גודל דף**: נתון 4KB. 4KB = 2^12 בתים. לכן, Page Offset הוא **12 ביטים**.\n*   **גודל PTE**: נתון 8 בתים.\n*   **מספר כניסות בטבלת דפים**: מכיוון שכל טבלת דפים תופסת בדיוק דף אחד (4KB) וכל כניסה היא 8 בתים, מספר הכניסות המקסימלי בכל טבלת דפים הוא: 4KB / 8B = 4096 / 8 = **512 כניסות**.\n*   **ביטים לאינדקס בטבלת דפים**: כדי לאנדקס 512 כניסות, נדרשים log2(512) = **9 ביטים** לכל אינדקס.\n*   לכן, P1 Index הוא **9 ביטים** ו-P2 Index הוא **9 ביטים**.\n\n**סעיף 1.2:**\n*   **גודל זיכרון וירטואלי מקסימלי**: מרחב הכתובות הוירטואלי מוגדר על ידי מספר הביטים המשמשים לאינדוקס בטבלאות הדפים ול-Offset. סך הביטים הפעילים בכתובת הוירטואלית הוא: P1 Index (9 ביטים) + P2 Index (9 ביטים) + Page Offset (12 ביטים) = 30 ביטים.\n    לכן, גודל הזיכרון הוירטואלי המקסימלי שתהליך יכול לגשת אליו הוא 2^30 בתים = **1GB**.\n    (הערה: למרות שמרחב הכתובות הוירטואלי הוא 64 ביט, רק 30 הביטים הנמוכים ממופים בפועל על ידי מבנה טבלת הדפים הנתון. הביטים הנותרים הם לרוב אפסים עבור כתובות קנוניות).\n*   **גודל זיכרון פיזי מקסימלי**: נתון 2^40 בתים = **1TB**.\n    (אימות: גודל PTE הוא 8 בתים, כלומר 64 ביטים. אם נניח שחלק מהביטים משמשים ל-P,V,A,D וכו', ונשארו מספיק ביטים עבור PFN (Physical Frame Number), למשל 28 ביטים ל-PFN, אז ניתן למפות 2^28 מסגרות פיזיות. כל מסגרת בגודל 4KB = 2^12 בתים. 2^28 * 2^12 = 2^40 בתים. לכן, ה-PTE מסוגל להכיל את ה-PFN הנדרש כדי למפות 1TB של זיכרון פיזי).\n\n**סעיף 1.3:**\n*   **כתובת וירטואלית נתונה**: `0x0000_1234_5678_9ABC` (64 ביטים).\n*   מכיוון שרק 30 הביטים הנמוכים משמשים למיפוי בפועל, נתמקד בביטים אלו:\n    `0x5678_9ABC` בבינארי (32 ביטים אחרונים) הוא: `0101 0110 0111 1000 1001 1010 1011 1100`.\n    נחלק ל-3 חלקים: P1 Index (9 ביטים), P2 Index (9 ביטים), Page Offset (12 ביטים), מהסוף להתחלה:\n    *   **Page Offset (12 ביטים)**: `1010 1011 1100` = `0xABC`\n    *   **P2 Index (9 ביטים)**: `001 1010 10` = `0x0D2`\n    *   **P1 Index (9 ביטים)**: `010 1011 00` = `0x15C`\n    (הערה: החלוקה לעיל היא בהתאם לסדר הופעתם בכתובת הוירטואלית, כאשר P1 הוא הביטים הגבוהים יותר ב-VPN ו-P2 נמוכים יותר, לפני ה-Offset. החישובים מתבצעים על 30 הביטים הנמוכים של הכתובת הוירטואלית).\n\n*   **תהליך התרגום צעד אחר צעד (בהנחה שכל ה-PTEs קיימים בזיכרון P=1):**\n    1.  **פירוק הכתובת הוירטואלית**: המעבד מפרק את הכתובת הוירטואלית `0x0000_1234_5678_9ABC` לחלקים הבאים:\n        *   P1 Index: `0x15C`\n        *   P2 Index: `0x0D2`\n        *   Page Offset: `0xABC`\n    2.  **גישה לטבלת P1**: המעבד משתמש בערך המאוחסן ב-CR3 (Page Directory Base Register), שמכיל את הכתובת הפיזית הבסיסית של טבלת הדפים ברמה P1, יחד עם ה-P1 Index (`0x15C`).\n        *   הכתובת הפיזית של ה-PTE המתאים בטבלת P1 מחושבת כך: `CR3_Physical_Address + (P1_Index * PTE_Size)`. (לדוגמה: `CR3 + (0x15C * 8)`).\n        *   המעבד קורא את ה-PTE מכתובת פיזית זו. ה-PTE מכיל את ה-PFN (Physical Frame Number) של טבלת הדפים ברמה P2 (נכנה אותו PFN_P2) ואת ביטי ההגנה וה-Present Bit (שמונח כ-1). \n    3.  **גישה לטבלת P2**: המעבד משתמש ב-PFN_P2 וב-P2 Index (`0x0D2`).\n        *   הכתובת הפיזית של ה-PTE המתאים בטבלת P2 מחושבת כך: `(PFN_P2 * Page_Size) + (P2_Index * PTE_Size)`. (לדוגמה: `(PFN_P2 << 12) + (0x0D2 * 8)`).\n        *   המעבד קורא את ה-PTE מכתובת פיזית זו. ה-PTE מכיל את ה-PFN של דף הנתונים המבוקש (נכנה אותו PFN_Data) ואת ביטי ההגנה וה-Present Bit (שמונח כ-1).\n    4.  **חישוב הכתובת הפיזית הסופית**: המעבד משתמש ב-PFN_Data וב-Page Offset (`0xABC`).\n        *   הכתובת הפיזית הסופית מחושבת כך: `(PFN_Data * Page_Size) + Page_Offset`. (לדוגמה: `(PFN_Data << 12) + 0xABC`).\n        *   זוהי הכתובת הפיזית בזיכרון הראשי שבה נמצא הנתון המבוקש.\n\n**סעיף 1.4:**\n*   **תרחיש**: גישה ל-`VA_X`. ה-PTE המתאים בטבלת P1 (P1[P1_Index]) מסומן כ-`P=0`. הזיכרון הפיזי כמעט מלא, ומדיניות החלפת הדפים היא LRU.\n*   **רצף האירועים**: \n    1.  **ניסיון גישה ותרגום ראשוני**: המעבד מנסה לתרגם את `VA_X` על ידי פירוקו ל-P1 Index, P2 Index ו-Offset. \n    2.  **גישה לטבלת P1 ו-Page Fault**: המעבד מחשב את הכתובת הפיזית של ה-PTE המתאים בטבלת P1 (באמצעות CR3 וה-P1 Index). כאשר הוא קורא את ה-PTE, הוא מגלה שביט ה-P (Present) הוא 0. זהו אינדיקציה לכך שטבלת הדפים ברמה P2, או חלק ממנה, אינה נמצאת בזיכרון הפיזי. המעבד מפעיל **Page Fault Interrupt**.\n    3.  **טיפול ב-Page Fault (מערכת ההפעלה)**:\n        *   מערכת ההפעלה (OS) מקבלת את ההפרעה ומזהה שה-Page Fault נגרם עקב PTE ברמת P1. היא בודקת את ה-PTE הלא נוכח כדי למצוא היכן בדיסק מאוחסנת טבלת P2 המבוקשת (לרוב, ה-PTE יכיל אינדקס לטבלת Swap או כתובת דיסק).\n        *   **בחירת מסגרת פיזית לפינוי (LRU)**: מכיוון שהזיכרון הפיזי כמעט מלא, ה-OS חייבת לפנות מסגרת פיזית קיימת כדי לטעון אליה את טבלת P2. היא משתמשת באלגוריתם LRU: היא סורקת את רשימת המסגרות (או טבלאות הדפים של תהליכים שונים) כדי למצוא את הדף (בין אם דף נתונים או דף טבלת דפים) שהיה בשימוש הכי פחות לאחרונה. נניח שהיא בוחרת לפנות את דף הנתונים של `VA_Y` (הממוקם ב-PF_Y).\n        *   **פינוי הדף (Swap Out)**: אם ביט ה-Dirty (D) של `PF_Y` מסומן כ-1 (כלומר, הדף השתנה מאז שנטען), ה-OS כותבת את תוכן הדף בחזרה לדיסק. לאחר מכן, ה-OS מעדכנת את ה-PTE המתאים עבור `VA_Y` (מסמנת P=0 ואולי מעדכנת את כתובת הדיסק).\n        *   **טעינת טבלת P2 (Swap In)**: ה-OS קוראת את טבלת P2 המבוקשת מהדיסק אל המסגרת הפיזית שפונתה. לאחר מכן, ה-OS מעדכנת את ה-PTE בטבלת P1 שגרם ל-Page Fault: היא מכניסה את ה-PFN החדש (של טבלת P2), מסמנת P=1 (Present), V=1 (Valid), A=1 (Accessed), D=0 (Dirty, כי הדף נטען זה עתה).\n    4.  **חידוש הפקודה והמשך תרגום**: המעבד מחדש את הפקודה שגרמה ל-Page Fault. הפעם, הגישה ל-PTE בטבלת P1 תצליח, והוא יקבל את ה-PFN של טבלת P2.\n    5.  **גישה לטבלת P2 ו-Page Fault נוסף (אפשרי)**: המעבד יחשב את הכתובת הפיזית של ה-PTE המתאים בטבלת P2 (באמצעות PFN_P2 וה-P2 Index). כאשר הוא קורא את ה-PTE מטבלת P2, ייתכן שגם ה-PTE הזה מסומן כ-`P=0` (כלומר, דף הנתונים של `VA_X` אינו בזיכרון הפיזי).\n        *   אם כן, יתרחש **Page Fault נוסף** עבור דף הנתונים עצמו. ה-OS תטפל בו באופן דומה: תמצא דף נוסף לפנות (LRU), תפנה אותו (תכתוב לדיסק אם D=1), ותטען את דף הנתונים של `VA_X` מהדיסק למסגרת שפונתה. היא תעדכן את ה-PTE המתאים בטבלת P2 (PFN, P=1, V=1, A=1, D=0).\n    6.  **גישה סופית לנתונים**: לאחר שדף הנתונים של `VA_X` נטען לזיכרון הפיזי (ובמקרה של Page Fault נוסף, ה-PTE בטבלת P2 עודכן), המעבד יחשב את הכתובת הפיזית הסופית באמצעות ה-PFN מה-PTE ב-P2 וה-Offset, ויגש בהצלחה לנתונים.\n\n**סעיף 1.5:**\n*   **TLB (Translation Lookaside Buffer)**: מטמון חומרה מהיר המאחסן מיפויים אחרונים של כתובות וירטואליות לכתובות פיזיות, כדי לזרז את תהליך התרגום.\n\n*   **מקרה 1: ה-TLB מכיל כניסה תקפה עבור `VA_X` (TLB Hit)**:\n    1.  **בדיקת TLB**: כאשר המעבד מנסה לגשת ל-`VA_X`, הוא בודק תחילה את ה-TLB כדי לראות אם קיים מיפוי עבור כתובת זו.\n    2.  **TLB Hit**: אם נמצאה כניסה תקפה עבור `VA_X` ב-TLB, היא מכילה ישירות את ה-PFN של דף הנתונים ואת ביטי ההגנה וה-Present Bit (שיהיה 1). ה-TLB מאשר שהדף נמצא בזיכרון הפיזי.\n    3.  **אין Page Fault**: מכיוון שהמיפוי נמצא ומוכח כ-Present ב-TLB, המערכת מסיקה שדף הנתונים (ולא רק טבלאות הדפים) נמצא בזיכרון הפיזי. כל רצף האירועים של Page Fault, טיפול מערכת הפעלה, פינוי דפים, וטעינה מהדיסק – **נמנע לחלוטין**.\n    4.  **גישה מיידית**: הכתובת הפיזית מחושבת באופן מיידי באמצעות ה-PFN מה-TLB וה-Offset, והגישה לנתונים מתבצעת במהירות גבוהה מאוד (קרוב למהירות גישה למטמון, הרבה יותר מהיר מגישה לזיכרון הראשי).\n    *   **השפעה על ביצועים**: ה-TLB Hit משפר באופן דרמטי את ביצועי המערכת על ידי קיצור משמעותי של זמן גישת הזיכרון, שכן הוא מבטל את הצורך בגישה למספר טבלאות דפים בזיכרון הראשי ובטיפול ב-Page Faults.\n\n*   **מקרה 2: ה-TLB אינו מכיל כניסה עבור `VA_X` (TLB Miss)**:\n    1.  **בדיקת TLB**: המעבד מנסה לגשת ל-`VA_X` ובודק את ה-TLB.\n    2.  **TLB Miss**: לא נמצאה כניסה תקפה עבור `VA_X` ב-TLB.\n    3.  **התחלת תרגום כתובת רגיל**: המערכת ממשיכה בתהליך תרגום הכתובת הרגיל דרך טבלאות הדפים בזיכרון הראשי, **בדיוק כפי שתואר בסעיף 1.4**.\n    4.  **Page Faults**: כל ה-Page Faults שתוארו בסעיף 1.4 (עבור ה-PTE ב-P1, ואולי גם עבור ה-PTE ב-P2, ואז עבור דף הנתונים עצמו) יתרחשו במלואם, במידה וביט ה-P=0 באחד מה-PTEs.\n    5.  **עדכון TLB**: לאחר שכל ה-Page Faults טופלו (אם היו כאלה), ודף הנתונים של `VA_X` נטען בהצלחה לזיכרון הפיזי וכתובתו הפיזית נקבעה, המערכת **תעדכן את ה-TLB** עם הכניסה החדשה (`VA_X` -> `PA_X`).\n        *   מכיוון שה-TLB הוא Fully Associative עם 128 כניסות, מערכת ההפעלה (או חומרה ייעודית) תבחר כניסה פנויה, או שתפנה כניסה קיימת באמצעות מדיניות החלפה (לרוב LRU או FIFO), ותכניס את המיפוי החדש.\n    *   **השפעה על ביצועים**: במקרה זה, הגישה הראשונה ל-`VA_X` תהיה איטית מאוד בגלל ה-TLB Miss וה-Page Faults (אם מתרחשים). אולם, גישות עתידיות ל-`VA_X` (אם הכניסה נשארת ב-TLB ולא מוחלפת) ייהנו מ-TLB Hit ויהיו מהירות מאוד. ה-TLB משפר ביצועים עבור גישות חוזרות לאותם דפים, ומקטין את העומס על טבלאות הדפים בזיכרון הראשי."
    },
    "difficulty_estimation": "Hard"
  }
}