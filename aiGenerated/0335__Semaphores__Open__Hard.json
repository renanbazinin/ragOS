{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:54:42",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4278,
      "output_tokens": 3041,
      "total_tokens": 13912
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Deadlock Prevention",
      "Concurrency"
    ],
    "content": {
      "text": "נתבונן במערכת הכוללת שני סוגי משאבים: R1 ו-R2. קיימים N יחידות של R1 ו-M יחידות של R2. תהליכים במערכת צריכים יחידה אחת מכל סוג משאב (יחידה אחת מ-R1 ויחידה אחת מ-R2) כדי לבצע משימה כלשהי. התהליכים מבצעים את הפעולות הבאות ברצף:\n1.  מנסים לרכוש יחידה אחת מ-R1.\n2.  מנסים לרכוש יחידה אחת מ-R2.\n3.  מבצעים את המשימה.\n4.  משחררים את היחידה מ-R1.\n5.  משחררים את היחידה מ-R2.\n\nנתון קטע הקוד הבא המדמה תהליך כזה, כאשר sem_R1 ו-sem_R2 הם סמפורים המייצגים את כמות היחידות הזמינות מכל משאב בהתאמה (ערכם ההתחלתי הוא N ו-M):\n\nא. הסבירו מדוע קיים סיכון למצב של קיפאון (Deadlock) במערכת המתוארת. תארו תרחיש ספציפי שבו יתרחש קיפאון, בהינתן N=1, M=1, ושני תהליכים שמנסים לרכוש משאבים.\nב. הציעו פתרון לבעיית הקיפאון באמצעות סמפורים נוספים או שינוי באופן השימוש בסמפורים הקיימים, כך שהתהליכים יוכלו תמיד לבצע את משימתם ללא חשש מקיפאון, תוך שמירה על רמת מקביליות סבירה. צרפו קטע קוד מתוקן המדגים את הפתרון שלכם. הסבירו מדוע הפתרון שלכם מונע קיפאון ומהם היתרונות/חסרונות של הפתרון שבחרתם.",
      "code_snippet": "#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For usleep\n\n// Global semaphores (initialized elsewhere with N and M)\nsem_t sem_R1; // Represents available units of Resource 1\nsem_t sem_R2; // Represents available units of Resource 2\n\nvoid *process_task(void *arg) {\n    long process_id = (long)arg;\n\n    printf(\"Process %ld: Attempting to acquire R1...\\n\", process_id);\n    sem_wait(&sem_R1); // Acquire R1\n    printf(\"Process %ld: Acquired R1. Attempting to acquire R2...\\n\", process_id);\n    \n    // Simulate some delay to increase deadlock probability\n    usleep(100); \n    \n    sem_wait(&sem_R2); // Acquire R2\n    printf(\"Process %ld: Acquired R2. Performing task...\\n\", process_id);\n    \n    // Simulate task execution\n    usleep(500); \n    \n    printf(\"Process %ld: Task complete. Releasing R1 and R2...\\n\", process_id);\n    sem_post(&sem_R1); // Release R1\n    sem_post(&sem_R2); // Release R2\n    \n    printf(\"Process %ld: Resources released.\\n\", process_id);\n    return NULL;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "חלק א' - הסבר לקיפאון:\nמצב של קיפאון (Deadlock) מתרחש כאשר קבוצת תהליכים חוסמים זה את זה ללא הרף, כאשר כל תהליך בקבוצה ממתין למשאב המוחזק על ידי תהליך אחר בקבוצה. במערכת המתוארת, מתקיימים ארבעת התנאים ההכרחיים לקיפאון:\n1.  **הדרה הדדית (Mutual Exclusion):** משאבי R1 ו-R2 ניתנים לרכישה בלעדית. יחידה אחת מכל משאב יכולה להיות מוחזקת על ידי תהליך אחד בלבד בכל רגע נתון.\n2.  **החזקה והמתנה (Hold and Wait):** תהליך יכול להחזיק במשאב אחד (למשל R1) תוך כדי שהוא ממתין למשאב אחר (R2).\n3.  **אי-נשללות (No Preemption):** משאבים אינם נשללים בכוח מתהליכים שמחזיקים בהם; רק התהליך המחזיק יכול לשחררם.\n4.  **המתנה מעגלית (Circular Wait):** תרחיש ספציפי: נניח N=1, M=1 ושני תהליכים P0 ו-P1.\n    *   P0 מבצע sem_wait(&sem_R1) ומצליח לרכוש את יחידת R1.\n    *   P1 מבצע sem_wait(&sem_R2) ומצליח לרכוש את יחידת R2 (בהנחה ש-P0 עוד לא ניסה לרכוש R2, או ש-P1 רץ במקביל).\n    *   כעת, P0 מנסה לבצע sem_wait(&sem_R2) אך נחסם, כיוון ש-R2 מוחזק על ידי P1.\n    *   במקביל, P1 מנסה לבצע sem_wait(&sem_R1) אך נחסם, כיוון ש-R1 מוחזק על ידי P0.\n    *   נוצרה המתנה מעגלית: P0 ממתין ל-P1 ו-P1 ממתין ל-P0. אף אחד מהם לא ישחרר את המשאב שברשותו, והמערכת נכנסת לקיפאון.\n\nחלק ב' - פתרון והסבר:\n\nפתרון מוצע: סמפור גלובלי (Mutex) להבטחת רכישה אטומית של שני המשאבים.\nכדי למנוע קיפאון, נשבור את תנאי 'החזקה והמתנה' על ידי הבטחה שתהליך ירכוש את כל המשאבים הדרושים לו (R1 ו-R2) בפעולה אטומית, או שלא ירכוש אף אחד מהם. ניתן לעשות זאת באמצעות סמפור בינארי (mutex) נוסף, שיגן על קטע הקוד שבו מתבצעת רכישת שני המשאבים. רק תהליך אחד יוכל להיכנס לקטע קריטי זה בכל רגע נתון, ובכך למנוע מצב שבו תהליכים מחזיקים חלק מהמשאבים וממתינים לאחרים.\n\nקוד מתוקן:\n```c\n#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For usleep\n\n// Global semaphores\nsem_t sem_R1; // Represents available units of Resource 1\nsem_t sem_R2; // Represents available units of Resource 2\nsem_t acquisition_mutex; // New mutex for atomic resource acquisition\n\nvoid *process_task_fixed(void *arg) {\n    long process_id = (long)arg;\n\n    printf(\"Process %ld: Attempting to acquire both R1 and R2...\\n\", process_id);\n    sem_wait(&acquisition_mutex); // Enter critical section for acquisition\n    \n    // Now acquire R1 and R2 within the mutex protection\n    sem_wait(&sem_R1); // Acquire R1\n    sem_wait(&sem_R2); // Acquire R2\n    \n    sem_post(&acquisition_mutex); // Exit critical section for acquisition\n    \n    printf(\"Process %ld: Acquired R1 and R2. Performing task...\\n\", process_id);\n    \n    // Simulate task execution\n    usleep(500); \n    \n    printf(\"Process %ld: Task complete. Releasing R1 and R2...\\n\", process_id);\n    sem_post(&sem_R1); // Release R1\n    sem_post(&sem_R2); // Release R2\n    \n    printf(\"Process %ld: Resources released.\\n\", process_id);\n    return NULL;\n}\n```\n\nהסבר מדוע הפתרון מונע קיפאון:\nהוספת הסמפור acquisition_mutex מבטיחה שרק תהליך אחד יוכל לבצע את רכישת שני המשאבים (R1 ו-R2) בו-זמנית. מרגע שתהליך נכנס לקטע הקריטי המוגן על ידי acquisition_mutex, הוא ירכוש את sem_R1 ואת sem_R2 בזה אחר זה ללא הפרעה מתהליכים אחרים המנסים לרכוש משאבים. רק לאחר שירכוש את שניהם, הוא ישחרר את acquisition_mutex ויאפשר לתהליך אחר לנסות לרכוש.\nפתרון זה שובר את תנאי 'החזקה והמתנה' (Hold and Wait) בכך שהוא מבטיח שתהליך לא יחזיק במשאב אחד (R1) וימתין לאחר (R2) כאשר תהליך אחר יכול להיות במצב דומה. במקום זאת, תהליך ימתין על acquisition_mutex עד שיוכל לרכוש את *כל* המשאבים הדרושים לו לפני שהוא משחרר את ה-mutex. אם אין מספיק משאבים זמינים, הוא ייחסם בתוך ה-mutex (על sem_R1 או sem_R2), אך כיוון שהוא היחיד שמנסה לרכוש באותו רגע, לא תיווצר המתנה מעגלית עם תהליך אחר שמחזיק משאב אחר ומונע ממנו להתקדם.\nהוא גם מונע המתנה מעגלית מכיוון שכל תהליך שמצליח להיכנס לקטע הקריטי של הרכישה מבטיח לעצמו את כל המשאבים. אין מצב שבו תהליך A מחזיק R1 ומחכה ל-R2, ותהליך B מחזיק R2 ומחכה ל-R1, כיוון שרק אחד מהם יכול להיות בקטע הרכישה בו זמנית.\n\nיתרונות וחסרונות של הפתרון:\n*   **יתרונות:**\n    *   **מניעת קיפאון מובטחת:** הפתרון אכן מונע קיפאון ביעילות במקרה זה.\n    *   **פשטות יחסית:** קל להבנה וליישום.\n*   **חסרונות:**\n    *   **הפחתת מקביליות (Reduced Concurrency):** זהו החיסרון המרכזי. רק תהליך אחד יכול לרכוש משאבים (R1 ו-R2) בכל רגע נתון, גם אם יש מספיק יחידות מכל משאב כדי לאפשר לכמה תהליכים לרכוש בו-זמנית מבלי לגרום לקיפאון. לדוגמה, אם N=10 ו-M=10, יכולים להיות 10 תהליכים שמחזיקים R1 ו-10 תהליכים שמחזיקים R2 (אם נרכשו בסדר שונה), אך הפתרון שלנו מאפשר רק לתהליך אחד לרכוש את *זוג* המשאבים בכל רגע. זה מגביל את היכולת של המערכת לנצל את המקביליות הפוטנציאלית.\n    *   **בעיית רעב (Starvation) פוטנציאלית:** אם יש תהליכים רבים, ותהליך מסוים נתקל בחסימה על sem_R1 או sem_R2 בתוך ה-mutex, הוא יחזיק את ה-mutex וימנע מכל שאר התהליכים אפילו לנסות לרכוש משאבים, עד שיצליח או ישחרר (אם היינו משתמשים ב-trywait). במקרה הנוכחי, הוא פשוט ייחסם בתוך ה-mutex על אחד מסמפורי המשאבים, מה שיכול להוביל לחוסר יעילות."
    },
    "difficulty_estimation": "Hard"
  }
}