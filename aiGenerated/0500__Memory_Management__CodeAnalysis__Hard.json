{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:11:48",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2789,
      "output_tokens": 2266,
      "total_tokens": 11337
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Paging",
      "TLB"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת בזיכרון וירטואלי עם טבלאות דפים דו-שכבתיות (two-level page tables).\nמרחב הכתובות הווירטואלי הוא בגודל 32 ביט.\nגודל דף (page size) הוא 4 קילובייט (KB).\nכל כניסה בטבלת דפים (Page Table Entry - PTE) היא בגודל 4 בתים.\nגודל טבלת דפים (הן השכבה הראשונה והן השכבה השנייה) הוא 4 קילובייט.\n\nהמערכת מצוידת ב-TLB (Translation Lookaside Buffer) בגודל 16 כניסות, הפועל בשיטה אסוציאטיבית מלאה (fully associative) עם מדיניות החלפה LRU (Least Recently Used).\nנניח שה-TLB ריק לחלוטין בתחילת ריצת התוכנית.\n\nנתונה תוכנית ה-C הבאה שמבצעת גישה למערך גדול.\nיש לנתח את קטע הקוד ולחשב את:\n1.  מספר ה-TLB misses הכולל שיתרחשו במהלך ריצת הלולאה הפנימית בתוכנית הנתונה.\n2.  מספר הגישות הכולל לטבלאות הדפים (page table walks), כאשר כל \"walk\" כזה כולל גישה לכל רמת טבלת דפים.\nיש להניח שכל הדפים הדרושים נמצאים בזיכרון הפיזי (אין page faults) ושכל הגישות לזיכרון הפיזי, כולל גישות לטבלאות דפים, לוקחות זמן זהה. אין להניח שדפי טבלאות הדפים נשארים ב-CPU cache בין גישות שונות, אלא אם צוין אחרת במפורש.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ARRAY_SIZE (1024 * 1024) // 1M integers\n#define PAGE_SIZE (4 * 1024)     // 4KB\n#define INT_SIZE (sizeof(int))   // 4 bytes\n\nint main() {\n    int *arr = (int *)malloc(ARRAY_SIZE * INT_SIZE);\n    if (arr == NULL) {\n        perror(\"malloc failed\");\n        return 1;\n    }\n\n    // Access pattern\n    for (int i = 0; i < 1024; ++i) { // Outer loop\n        for (int j = 0; j < ARRAY_SIZE; j += (PAGE_SIZE / INT_SIZE)) { // Inner loop: Accesses start of each page\n            arr[j] = i; // Write access\n        }\n    }\n\n    free(arr);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "נתחיל בניתוח מבנה הזיכרון הווירטואלי והגישה לזיכרון:\n1.  **מבנה כתובת וירטואלית:**\n    *   גודל דף (Page Size) הוא 4KB = 2^12 בתים. לכן, ה-Offset בכתובת הווירטואלית הוא 12 ביטים.\n    *   גודל כניסה בטבלת דפים (PTE) הוא 4 בתים.\n    *   גודל טבלת דפים הוא 4KB. לכן, מספר הכניסות בכל טבלת דפים הוא 4KB / 4 בתים = 1024 כניסות = 2^10 כניסות.\n    *   מספר הביטים הנדרש לכל אינדקס בטבלת דפים (P1 Index ו-P2 Index) הוא 10 ביטים.\n    *   מבנה הכתובת הווירטואלית (32 ביטים): 10 ביטים עבור P1 Index, 10 ביטים עבור P2 Index, ו-12 ביטים עבור Offset.\n\n2.  **גודל המערך וכיסוי דפים:**\n    *   `ARRAY_SIZE = 1024 * 1024` שלמים.\n    *   גודל שלם (`sizeof(int)`) הוא 4 בתים.\n    *   סה\"כ גודל המערך בזיכרון הוא `1024 * 1024 * 4` בתים = `4MB`.\n    *   מספר הדפים שהמערך תופס בזיכרון הווירטואלי הוא `4MB / 4KB = (4 * 1024 * 1024) / (4 * 1024) = 1024` דפים.\n\n3.  **תבנית הגישה לזיכרון (Access Pattern):**\n    *   הלולאה החיצונית רצה 1024 פעמים (`i` מ-0 עד 1023).\n    *   הלולאה הפנימית רצה מ-`j=0` וקופצת בכל פעם ב-`PAGE_SIZE / INT_SIZE`.\n    *   `PAGE_SIZE / INT_SIZE = 4KB / 4 bytes = 1024`.\n    *   כלומר, הלולאה הפנימית ניגשת לאיברים `arr[0]`, `arr[1024]`, `arr[2048]`, וכן הלאה.\n    *   אלו הם בדיוק האיבר הראשון בכל אחד מהדפים של המערך. כל גישה בתוך הלולאה הפנימית מתבצעת לדף ייחודי (כל פעם לדף הבא מתוך 1024 הדפים שהמערך תופס).\n    *   מספר הגישות בלולאה הפנימית הוא `ARRAY_SIZE / (PAGE_SIZE / INT_SIZE) = (1024 * 1024) / 1024 = 1024` גישות.\n\n4.  **חישוב TLB Misses:**\n    *   גודל ה-TLB הוא 16 כניסות.\n    *   בכל איטרציה של הלולאה החיצונית (`i`), הלולאה הפנימית ניגשת ל-1024 דפים ייחודיים שונים בזיכרון.\n    *   מכיוון ש-1024 (מספר הדפים הייחודיים הנגשים) גדול בהרבה מ-16 (גודל ה-TLB), ה-TLB יחווה \"Thrashing\".\n    *   לאחר 16 הגישות הראשונות בלולאה הפנימית (עבור `i` מסוים), ה-TLB יתמלא. בכל גישה נוספת לדף חדש, יתרחש TLB miss ודף ישן (ה-LRU) ייזרק מה-TLB.\n    *   כאשר הלולאה החיצונית מתקדמת לאיטרציה הבאה (`i+1`), ה-TLB מכיל את ה-16 הדפים האחרונים שנגשו אליהם באיטרציה הקודמת של הלולאה הפנימית. אולם, הלולאה הפנימית תתחיל שוב מ-`arr[0]` (דף 0), ותעבור שוב על 1024 הדפים. אף אחד מהדפים הללו לא יימצא ב-TLB מהאיטרציה הקודמת של הלולאה החיצונית, שכן ה-TLB קטן מדי בכדי להחזיק את כל 1024 הדפים לאורך כל איטרציות הלולאה החיצונית.\n    *   לכן, בכל גישה לזיכרון בתוך הלולאה הפנימית, יתרחש TLB miss.\n    *   סה\"כ TLB misses = (מספר איטרציות הלולאה החיצונית) * (מספר גישות בלולאה הפנימית)\n    *   סה\"כ TLB misses = `1024 * 1024 = 1,048,576`.\n\n5.  **חישוב גישות לטבלאות הדפים (Page Table Walks):**\n    *   כל TLB miss גורם לביצוע Page Table Walk.\n    *   עבור טבלת דפים דו-שכבתית, כל Page Table Walk דורש שתי גישות לזיכרון הפיזי:\n        *   גישה אחת לטבלת הדפים של השכבה הראשונה (P1).\n        *   גישה אחת לטבלת הדפים של השכבה השנייה (P2).\n    *   סה\"כ גישות לטבלאות הדפים = (סה\"כ TLB misses) * (מספר גישות זיכרון לכל Page Table Walk).\n    *   סה\"כ גישות לטבלאות הדפים = `1,048,576 * 2 = 2,097,152`."
    },
    "difficulty_estimation": "Hard"
  }
}