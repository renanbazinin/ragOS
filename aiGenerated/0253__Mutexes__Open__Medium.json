{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:16:31",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2046,
      "output_tokens": 1783,
      "total_tokens": 7767
    }
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Mutexes",
      "Condition Variables",
      "Synchronization",
      "Producer-Consumer"
    ],
    "content": {
      "text": "נתונה בעיית ה-Producer-Consumer, בה מספר יצרנים מוסיפים פריטים למאגר משותף בעל גודל סופי, ומספר צרכנים מוציאים פריטים מהמאגר.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "8.1",
        "text": "א. נניח שרק Mutex אחד משמש להגנה על המאגר המשותף. הסבר מדוע שימוש ב-Mutex בלבד אינו מספיק לפתרון נכון ויעיל של בעיה זו. תאר תרחישים בהם ייווצרו בעיות.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "8.2",
        "text": "ב. תאר כיצד ניתן לשלב Mutex עם Condition Variables (משתני תנאי) כדי לפתור את בעיית ה-Producer-Consumer באופן נכון ויעיל. כלול הסבר על הפעולות העיקריות (wait, signal/broadcast) וכיצד הן עובדות יחד עם ה-Mutex.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון לשאלה 8.1 (סעיף א'):\nשימוש ב-Mutex בלבד אינו מספיק לפתרון בעיית ה-Producer-Consumer מכיוון ש-Mutex מספק רק הגנה על הגישה הקריטית למשאב המשותף (המאגר), אך אינו מאפשר סנכרון מורכב יותר הדורש המתנה על תנאי מסוים. Mutex מאפשר רק חסימה והתעוררות מפורשת של חוטים, אך אינו מאפשר לחוט לישון עד שתנאי מסוים מתקיים.\n\nתרחישים בהם ייווצרו בעיות:\n1.  **צרכן ינסה לצרוך ממאגר ריק:** אם צרכן מנסה להוציא פריט מהמאגר כשהוא ריק, ורק Mutex מגן על הגישה, הצרכן יקבל את ה-Mutex, יגלה שהמאגר ריק, ויאלץ לבצע פעולת busy-waiting (לולאה שבודקת שוב ושוב את מצב המאגר) או לצאת עם שגיאה. busy-waiting מבזבז משאבי מעבד יקרים. בנוסף, אם הצרכן מחזיק ב-Mutex בזמן ה-busy-waiting, הוא מונע מיצרנים לגשת למאגר, ובכך מונע את שינוי המצב (הוספת פריט) שיאפשר לצרכן להמשיך. זה עלול להוביל לקיפאון (deadlock) או לחוסר יעילות קיצוני.\n2.  **יצרן ינסה לייצר למאגר מלא:** באופן דומה, אם יצרן מנסה להכניס פריט למאגר כשהוא מלא, הוא יקבל את ה-Mutex, יגלה שהמאגר מלא, ויאלץ לבצע busy-waiting או לצאת עם שגיאה. גם כאן, החזקת ה-Mutex ב-busy-waiting תמנע מצרכנים לגשת למאגר ולפנות מקום, מה שיוביל לבעיות דומות.\n\nפתרון לשאלה 8.2 (סעיף ב'):\nכדי לפתור את בעיית ה-Producer-Consumer באופן נכון ויעיל, יש לשלב Mutex עם Condition Variables (משתני תנאי).\nה-Mutex ישמש להגנה על הגישה למאגר המשותף ועל משתני המצב שלו (כמו מספר הפריטים במאגר, ראש וזנב המאגר וכו').\nמשתני התנאי ישמשו לאפשר לחוטים להמתין באופן יעיל כאשר תנאי מסוים אינו מתקיים, ולהתעורר כאשר התנאי כן מתקיים, מבלי לבזבז משאבי מעבד ב-busy-waiting.\n\nנשתמש בשני משתני תנאי:\n*   `not_empty`: עבור צרכנים שצריכים להמתין כאשר המאגר ריק.\n*   `not_full`: עבור יצרנים שצריכים להמתין כאשר המאגר מלא.\n\n**התהליך עבור יצרן:**\n1.  היצרן נועל את ה-Mutex כדי להבטיח גישה בלעדית למאגר ולמשתני המצב שלו.\n2.  בתוך לולאה (לטיפול ב-spurious wakeups), היצרן בודק אם המאגר מלא. אם כן, הוא קורא לפעולה `wait(not_full, mutex)`. פעולת `wait` מבצעת באופן אטומי שתי פעולות: היא משחררת את ה-Mutex ומכניסה את החוט למצב שינה, עד שהוא יתעורר על ידי `signal` או `broadcast` על `not_full`. כשהחוט מתעורר, ה-Mutex ננעל מחדש אוטומטית לפני ש-`wait` חוזרת.\n3.  כאשר המאגר אינו מלא, היצרן מוסיף פריט למאגר.\n4.  היצרן קורא לפעולה `signal(not_empty)` (או `broadcast`) כדי להעיר צרכנים שממתינים למאגר שאינו ריק, מכיוון שכעת יש פריט זמין.\n5.  היצרן משחרר את ה-Mutex.\n\n**התהליך עבור צרכן:**\n1.  הצרכן נועל את ה-Mutex כדי להבטיח גישה בלעדית למאגר ולמשתני המצב שלו.\n2.  בתוך לולאה, הצרכן בודק אם המאגר ריק. אם כן, הוא קורא לפעולה `wait(not_empty, mutex)`. פעולה זו מבצעת את אותן פעולות אטומיות כמו אצל היצרן: משחררת את ה-Mutex ומכניסה את החוט למצב שינה, ונועלת את ה-Mutex בחזרה עם ההתעוררות.\n3.  כאשר המאגר אינו ריק, הצרכן מוציא פריט מהמאגר.\n4.  הצרכן קורא לפעולה `signal(not_full)` (או `broadcast`) כדי להעיר יצרנים שממתינים למאגר שאינו מלא, מכיוון שכעת התפנה מקום.\n5.  הצרכן משחרר את ה-Mutex.\n\nהשימוש ב-`wait` בתוך לולאה (לדוגמה `while (buffer_is_full) { wait(not_full, mutex); }`) מבטיח שהתנאי נבדק שוב לאחר ההתעוררות, למקרה שהחוט התעורר מסיבה שאינה קשורה לתנאי (spurious wakeup) או שחוט אחר תפס את המשאב לפניו."
    },
    "difficulty_estimation": "Medium"
  }
}