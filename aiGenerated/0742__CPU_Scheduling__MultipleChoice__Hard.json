{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 00:00:52",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 969,
      "output_tokens": 1771,
      "total_tokens": 7078
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "CPU Scheduling",
      "Preemptive Priority",
      "Round Robin"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת באלגוריתם תזמון מעבדים (CPU Scheduling) מונע (Preemptive Priority).\nכלל התזמון הוא כדלקמן:\n1.  תהליכים בעלי עדיפות נמוכה יותר (מספר נמוך יותר) יקבלו את המעבד לפני תהליכים בעלי עדיפות גבוהה יותר.\n2.  אם שני תהליכים או יותר בעלי אותה עדיפות נמצאים במצב Ready, הם יתוזמנו בשיטת Round Robin עם קוונטום (Quantum) של 2 מילישניות.\n3.  אין התחשבות בזמן החלפת קשר (Context Switch Overhead).\n\nנתונים שלושה תהליכים: P1, P2, P3.\n*   **P1:** מגיע בזמן 0. עדיפות: 2. דורש 4 מילישניות CPU, לאחר מכן מבצע פעולת I/O שאורכת 3 מילישניות, ולאחר מכן דורש 2 מילישניות CPU נוספות.\n*   **P2:** מגיע בזמן 0. עדיפות: 1. דורש 6 מילישניות CPU.\n*   **P3:** מגיע בזמן 1. עדיפות: 2. דורש 3 מילישניות CPU.\n\nלהלן קטע קוד המייצג את התנהגותו של תהליך P1:\n```c\n// מבנה קוד כללי של תהליך P1\nvoid process_P1_task() {\n    // פרץ CPU ראשון\n    for (long i = 0; i < 400000000; ++i) { /* ביצוע עבודה של המעבד */ } \n\n    // פעולת קלט/פלט\n    perform_io_operation(3); // מדמה פעולת I/O באורך 3 מילישניות\n\n    // פרץ CPU שני\n    for (long i = 0; i < 200000000; ++i) { /* ביצוע עבודה של המעבד */ }\n}\n```\n\nמהו זמן המחזור (Turnaround Time) של תהליך P1?",
      "code_snippet": "// מבנה קוד כללי של תהליך P1\nvoid process_P1_task() {\n    // פרץ CPU ראשון\n    for (long i = 0; i < 400000000; ++i) { /* ביצוע עבודה של המעבד */ } \n\n    // פעולת קלט/פלט\n    perform_io_operation(3); // מדמה פעולת I/O באורך 3 מילישניות\n\n    // פרץ CPU שני\n    for (long i = 0; i < 200000000; ++i) { /* ביצוע עבודה של המעבד */ }\n}",
      "options": [
        "א. 12 מילישניות",
        "ב. 15 מילישניות",
        "ג. 17 מילישניות",
        "ד. 18 מילישניות",
        "ה. 19 מילישניות"
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ג",
      "explanation": "נבצע מעקב אחר ביצוע התהליכים:\n\n*   **זמן 0:**\n    *   P1 מגיע (עדיפות 2, דורש 4ms CPU).\n    *   P2 מגיע (עדיפות 1, דורש 6ms CPU).\n    *   P2 בעל העדיפות הגבוהה ביותר (1), ולכן מתחיל לרוץ.\n*   **זמן 0 - 6:**\n    *   P2 רץ. \n    *   בזמן 1: P3 מגיע (עדיפות 2, דורש 3ms CPU). P2 עדיין בעל העדיפות הגבוהה ביותר.\n    *   P2 מסיים את פרץ ה-CPU שלו בזמן 6.\n*   **זמן 6:**\n    *   P1 מוכן (עדיפות 2, נותרו 4ms CPU).\n    *   P3 מוכן (עדיפות 2, נותרו 3ms CPU).\n    *   ל-P1 ול-P3 יש אותה עדיפות (2). הם יתוזמנו ב-Round Robin עם קוונטום 2ms. P1 הגיע ראשון מבין השניים (בזמן 0), ולכן P1 יתחיל לרוץ.\n*   **זמן 6 - 8:**\n    *   P1 רץ למשך 2ms (קוונטום). ל-P1 נותרו 2ms CPU.\n    *   בזמן 8, P1 נדחה על ידי RR. P3 מקבל את תורו.\n*   **זמן 8 - 10:**\n    *   P3 רץ למשך 2ms (קוונטום). ל-P3 נותר 1ms CPU.\n    *   בזמן 10, P3 נדחה על ידי RR. P1 מקבל את תורו.\n*   **זמן 10 - 12:**\n    *   P1 רץ למשך 2ms. P1 מסיים את פרץ ה-CPU הראשון שלו.\n    *   בזמן 12, P1 עובר למצב I/O למשך 3ms.\n*   **זמן 12:**\n    *   P3 הוא התהליך היחיד שמוכן (עדיפות 2, נותר 1ms CPU). P3 מתחיל לרוץ.\n*   **זמן 12 - 13:**\n    *   P3 רץ למשך 1ms. P3 מסיים את פרץ ה-CPU שלו.\n*   **זמן 13 - 15:**\n    *   המעבד אינו פעיל (Idle) בזמן זה, מכיוון שאין תהליכים מוכנים.\n*   **זמן 15:**\n    *   P1 מסיים את פעולת ה-I/O שלו וחוזר למצב Ready (עדיפות 2, נותרו 2ms CPU).\n    *   P1 הוא התהליך היחיד שמוכן. P1 מתחיל לרוץ.\n*   **זמן 15 - 17:**\n    *   P1 רץ למשך 2ms. P1 מסיים את פרץ ה-CPU השני שלו. P1 מסתיים.\n\nזמן הסיום של P1 הוא 17.\nזמן ההגעה של P1 הוא 0.\nזמן המחזור (Turnaround Time) של P1 = זמן סיום - זמן הגעה = 17 - 0 = 17 מילישניות.\nלכן, התשובה הנכונה היא ג'."
    },
    "difficulty_estimation": "Hard"
  }
}