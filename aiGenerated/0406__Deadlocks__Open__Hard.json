{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 21:21:01",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3443,
      "output_tokens": 3342,
      "total_tokens": 12122
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Deadlocks",
      "Synchronization",
      "Resource Management",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה שבה מספר רב של תהליכים ניגשים למספר סוגים שונים של משאבים. נניח שישנם M סוגי משאבים, המסומנים R0, R1, ..., RM-1. לכל סוג משאב יש מופע יחיד (לדוגמה, מדפסת ספציפית, סורק ספציפי). תהליכים צריכים לרכוש גישה למשאבים אלו כדי לבצע את עבודתם. המערכת משתמשת במנעולים (mutexes) כדי להבטיח מניעה הדדית לכל מופע משאב. נתון קטע הקוד הבא המדגים רכישת משאבים על ידי תהליך, כאשר הסדר שבו התהליך רוכש את המשאבים הוא שרירותי:\n\n```c\n// M הוא מספר סוגי המשאבים הכולל במערכת\npthread_mutex_t resource_locks[M]; // מערך מנעולים, אחד לכל סוג משאב\n\nvoid acquire_resources_arbitrary(int resource1_type_id, int resource2_type_id) {\n    // תהליך רוכש משאב ראשון\n    pthread_mutex_lock(&resource_locks[resource1_type_id]);\n    printf(\"Acquired R%d\\n\", resource1_type_id);\n\n    // תהליך רוכש משאב שני\n    pthread_mutex_lock(&resource_locks[resource2_type_id]);\n    printf(\"Acquired R%d\\n\", resource2_type_id);\n\n    // ... שימוש במשאבים ...\n\n    // שחרור משאבים (בסדר הפוך לרכישה, או בכל סדר)\n    pthread_mutex_unlock(&resource_locks[resource2_type_id]);\n    pthread_mutex_unlock(&resource_locks[resource1_type_id]);\n}\n```\n\n1.  הסבירו כיצד מצב של קיפאון (Deadlock) יכול להתרחש במערכת זו. תארו תרחיש ספציפי הכולל שני תהליכים ושני סוגי משאבים (לדוגמה, R0 ו-R1) כדי להדגים את הקיפאון.\n\n2.  הציעו פתרון למניעת קיפאון במערכת זו, על ידי שינוי אופן רכישת המשאבים. ספקו מימוש קוד ב-C/C++ (או פסאודו-קוד) המדגים את הפתרון שלכם, והסבירו איזו משלוש התכונות ההכרחיות לקיפאון נשברת על ידי הפתרון.\n\n3.  דונו בשני חסרונות פוטנציאליים של הפתרון שהצעתם (לדוגמה, השפעה על מקביליות, רעב).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **הסבר לקיפאון:**\n    מצב של קיפאון (deadlock) יכול להתרחש במערכת זו כאשר מתקיימים ארבעת התנאים ההכרחיים לקיפאון: מניעה הדדית, החזקה והמתנה, אי-יכולת לדרוס, והמתנה מעגלית.\n    *   **מניעה הדדית (Mutual Exclusion):** תנאי זה מתקיים, שכן כל מופע משאב מוגן על ידי מנעול (mutex), ורק תהליך אחד יכול להחזיק בו זמנית מנעול על משאב ספציפי.\n    *   **החזקה והמתנה (Hold and Wait):** תנאי זה מתקיים, שכן תהליך יכול להחזיק במשאב אחד (על ידי נעילת המוטקס שלו) ובמקביל להמתין לרכישת משאב נוסף (על ידי ניסיון לנעול מוטקס אחר).\n    *   **אי-יכולת לדרוס (No Preemption):** תנאי זה מתקיים, שכן משאבים אינם נלקחים מתהליכים בכוח; הם משוחררים רק מרצון על ידי התהליך שהחזיק בהם.\n    *   **המתנה מעגלית (Circular Wait):** זהו התנאי שעלול להיווצר כתוצאה מהרכישה השרירותית של המשאבים. אם תהליך A רוכש את R_i וממתין ל-R_j, ובמקביל תהליך B רוכש את R_j וממתין ל-R_i, נוצר מעגל המתנה שבו כל תהליך ממתין למשאב המוחזק על ידי התהליך הבא במעגל.\n\n    **תרחיש ספציפי לקיפאון (שני תהליכים, שני משאבים R0, R1):**\n    נניח שיש לנו שני תהליכים, `P1` ו-`P2`, ושני סוגי משאבים `R0` ו-`R1`. שני התהליכים מנסים לרכוש את שני המשאבים.\n    1.  `P1` קורא ל-`acquire_resources_arbitrary(0, 1)`. הוא מבצע `pthread_mutex_lock(&resource_locks[0])` ורוכש את `R0`.\n    2.  מיד לאחר מכן (לפני ש-`P1` רוכש את `R1`), `P2` קורא ל-`acquire_resources_arbitrary(1, 0)`. הוא מבצע `pthread_mutex_lock(&resource_locks[1])` ורוכש את `R1`.\n    3.  כעת, `P1` מנסה לבצע `pthread_mutex_lock(&resource_locks[1])`. `R1` מוחזק על ידי `P2`, ולכן `P1` נחסם וממתין.\n    4.  במקביל, `P2` מנסה לבצע `pthread_mutex_lock(&resource_locks[0])`. `R0` מוחזק על ידי `P1`, ולכן `P2` נחסם וממתין.\n    בשלב זה, `P1` מחזיק ב-`R0` וממתין ל-`R1`, ו-`P2` מחזיק ב-`R1` וממתין ל-`R0`. נוצרה המתנה מעגלית, ושני התהליכים נמצאים בקיפאון.\n\n2.  **פתרון למניעת קיפאון (רכישה בסדר קבוע):**\n    כדי למנוע קיפאון, ניתן לשבור את תנאי ה**המתנה מעגלית** (Circular Wait). הדרך הנפוצה לעשות זאת היא על ידי הטלת סדר גלובלי (Total Ordering) על כל סוגי המשאבים. כלומר, תהליכים חייבים לרכוש משאבים תמיד בסדר עולה (או יורד) של מזהי המשאבים שלהם. לדוגמה, אם יש לנו `M` סוגי משאבים עם מזהים מ-0 עד `M-1`, תהליך שזקוק למשאבים `R_i` ו-`R_j` ירכוש תמיד את המשאב בעל המזהה הנמוך יותר תחילה.\n\n    **מימוש קוד ב-C/C++:**\n    ```c\n    // M הוא מספר סוגי המשאבים הכולל במערכת\n    pthread_mutex_t resource_locks[M]; // מערך מנעולים, אחד לכל סוג משאב\n\n    // פונקציה כללית לרכישת מערך של משאבים בסדר קבוע\n    // resource_types הוא מערך של מזהי סוגי המשאבים הנדרשים\n    // count הוא מספר המשאבים במערך resource_types\n    void acquire_multiple_resources_ordered(int* resource_types, int count) {\n        // צור עותק של המזהים ומין אותם בסדר עולה\n        int* sorted_resource_types = (int*)malloc(sizeof(int) * count);\n        for (int i = 0; i < count; i++) {\n            sorted_resource_types[i] = resource_types[i];\n        }\n\n        // מיון פשוט (לדוגמה, מיון בועות) יכול לשמש כאן\n        for (int i = 0; i < count - 1; i++) {\n            for (int j = i + 1; j < count; j++) {\n                if (sorted_resource_types[i] > sorted_resource_types[j]) {\n                    int temp = sorted_resource_types[i];\n                    sorted_resource_types[i] = sorted_resource_types[j];\n                    sorted_resource_types[j] = temp;\n                }\n            }\n        }\n\n        // רכוש את המשאבים בסדר הממוין\n        for (int i = 0; i < count; i++) {\n            // הימנע מרכישה כפולה אם יש מזהים זהים במערך הממוין (לאחר מיון ובמקרה של קלט עם כפילויות)\n            if (i > 0 && sorted_resource_types[i] == sorted_resource_types[i-1]) {\n                continue;\n            }\n            pthread_mutex_lock(&resource_locks[sorted_resource_types[i]]);\n            printf(\"Acquired R%d\\n\", sorted_resource_types[i]);\n        }\n\n        // ... שימוש במשאבים ...\n\n        // שחרור משאבים בסדר הפוך לרכישה (מומלץ לשחרור נכון של המנעולים)\n        for (int i = count - 1; i >= 0; i--) {\n            if (i < count - 1 && sorted_resource_types[i] == sorted_resource_types[i+1]) {\n                continue;\n            }\n            pthread_mutex_unlock(&resource_locks[sorted_resource_types[i]]);\n            printf(\"Released R%d\\n\", sorted_resource_types[i]);\n        }\n        free(sorted_resource_types);\n    }\n    ```\n\n    **איזו תכונה נשברת:**\n    הפתרון שובר את תנאי ה**המתנה מעגלית** (Circular Wait). על ידי אכיפת סדר גלובלי לרכישת משאבים, לא ניתן ליצור שרשרת המתנה מעגלית. אם תהליך A מחזיק ב-R_i וממתין ל-R_j, ו-R_i < R_j, אז תהליך B לא יכול להחזיק ב-R_j ולהמתין ל-R_i, מכיוון שהוא יצטרך לרכוש את R_i (שהוא בעל מזהה נמוך יותר) לפני שיוכל לרכוש את R_j. כלומר, לא ייתכן מצב שבו תהליך P1 מחכה ל-Rj שמוחזק על ידי P2, ותהליך P2 מחכה ל-Ri שמוחזק על ידי P1, כאשר Ri < Rj. לכן, כל שרשרת המתנה תהיה ליניארית ולא מעגלית, ובכך נמנע קיפאון.\n\n3.  **חסרונות פוטנציאליים של הפתרון:**\n    *   **הפחתת מקביליות (Reduced Concurrency):** הטלת סדר גלובלי על רכישת משאבים עלולה להפחית את רמת המקביליות במערכת. תהליך שזקוק למשאב בעל מזהה גבוה (לדוגמה, R_M-1) אך גם למשאב בעל מזהה נמוך (לדוגמה, R0) חייב לרכוש קודם את R0. אם R0 מוחזק על ידי תהליך אחר, התהליך הראשון ייאלץ להמתין, גם אם R_M-1 פנוי וזמין לשימוש. זה עלול לגרום לתהליכים להחזיק משאבים לזמן ארוך יותר ממה שהיה נחוץ באמת, או להמתין זמן רב למשאבים פנויים, ובכך להפחית את ניצולת המשאבים הכוללת ואת ביצועי המערכת.\n    *   **פוטנציאל לרעב (Potential for Starvation):** למרות שהפתרון מונע קיפאון, הוא עלול לגרום לרעב (starvation) במקרים מסוימים. תהליך שדורש משאבים רבים בעלי מזהים נמוכים מאוד, או משאב בעל מזהה נמוך במיוחד שנמצא בשימוש תדיר, עלול להיתקל בקשיים תמידיים ברכישת המשאבים הללו ולהידחק הצידה שוב ושוב על ידי תהליכים אחרים. לדוגמה, תהליך שזקוק ל-R0 יחכה זמן רב אם ישנם תהליכים רבים אחרים שרוכשים ומשחררים את R0 כל הזמן, גם אם הוא זקוק רק ל-R0 ול-R_M-1, בעוד R_M-1 פנוי. זה אמנם אינו קיפאון, אך עדיין מונע מהתהליך להתקדם בביצועו ללא הגבלת זמן."
    },
    "difficulty_estimation": "Hard"
  }
}