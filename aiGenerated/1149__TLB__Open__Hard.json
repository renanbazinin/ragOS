{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "TLB",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:16:03",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4186,
      "output_tokens": 4093,
      "total_tokens": 18133
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "TLB",
      "Memory Management",
      "Virtual Memory",
      "Paging"
    ],
    "content": {
      "text": "נתונה מערכת זיכרון וירטואלי עם המאפיינים הבאים:\n- כתובת וירטואלית: 48 ביטים\n- כתובת פיזית: 40 ביטים\n- גודל דף: 4KB\n- גודל כניסה בטבלת דפים (PTE): 8 בתים\n- ה-TLB הוא בגודל 128 כניסות, אסוציאטיבי מלא (fully associative) ומשתמש במדיניות החלפה LRU.\n- זמני גישה:\n  - פגיעה ב-TLB (TLB Hit): 1 ננו-שנייה\n  - גישה לזיכרון פיזי (לדף נתונים או לכניסת טבלת דפים): 100 ננו-שנייה\n\nתהליך מריץ את קטעי הקוד הבאים, המבצעים איטרציה על מטריצה בגודל N x M, כאשר N=4096 ו-M=4096, וכל איבר הוא בגודל `int` (4 בתים). יש להתייחס למצב שבו ה-TLB ריק בתחילת כל קטע קוד. יש לפרט ולנמק את כל החישובים.",
      "code_snippet": "/* הגדרות קבועים */\n#define N 4096 \n#define M 4096 \nint matrix[N][M]; // כל איבר int הוא 4 בתים\n\n/* גישה לפי שורה */\nvoid access_matrix_row_major() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            matrix[i][j]++; \n        }\n    }\n}\n\n/* גישה לפי עמודה */\nvoid access_matrix_col_major() {\n    for (int j = 0; j < M; j++) {\n        for (int i = 0; i < N; i++) {\n            matrix[i][j]++; \n        }\n    }\n}\n",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "בהתבסס על נתוני המערכת, כמה רמות יש לטבלת הדפים? כמה כניסות (PTEs) יכולות להיות בכל דף של טבלת דפים?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "חשב את אחוז הפגיעות ב-TLB (TLB Hit Rate) ואת זמן הגישה האפקטיבי הממוצע (Effective Access Time - EAT) לגישה אחת לאלמנט בזיכרון, כאשר התהליך מריץ את הפונקציה `access_matrix_row_major()`.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "חשב את אחוז הפגיעות ב-TLB (TLB Hit Rate) ואת זמן הגישה האפקטיבי הממוצע (EAT) לגישה אחת לאלמנט בזיכרון, כאשר התהליך מריץ את הפונקציה `access_matrix_col_major()`. הסבר מדוע יש הבדל בינו לבין התוצאה של סעיף 1.2.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.4",
        "text": "כיצד משפיע מעבר הקשר (Context Switch) בין תהליכים על ביצועי ה-TLB? אילו מנגנונים קיימים כדי למזער השפעה זו?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1: חישוב רמות טבלת הדפים וכניסות לדף:\n- גודל דף: 4KB = 2^12 בתים. לכן, היסט הדף (Page Offset) הוא 12 ביטים.\n- כתובת וירטואלית: 48 ביטים. מספר הדף הווירטואלי (VPN) הוא 48 - 12 = 36 ביטים.\n- גודל כניסה בטבלת דפים (PTE): 8 בתים.\n- מספר הכניסות בכל דף טבלת דפים: גודל דף / גודל PTE = 4096 בתים / 8 בתים = 512 כניסות.\n- כל רמה בטבלת הדפים משתמשת ב-log2(512) = 9 ביטים כדי לאנדקס כניסה בדף טבלה.\n- מספר רמות טבלת הדפים: VPN / (ביטים לרמה) = 36 ביטים / 9 ביטים/רמה = 4 רמות.\n\n1.2: חישוב EAT ו-TLB Hit Rate עבור `access_matrix_row_major()`:\n- גודל איבר `int`: 4 בתים.\n- מספר איברים בדף: גודל דף / גודל איבר = 4096 / 4 = 1024 איברים.\n- גודל שורה במטריצה: M * sizeof(int) = 4096 * 4 = 16384 בתים = 16KB.\n- מספר דפים לשורה: 16KB / 4KB = 4 דפים.\n- סך כל הגישות: N * M = 4096 * 4096 = 16,777,216 גישות.\n\nניתוח TLB עבור גישה לפי שורה:\nהמטריצה נשמרת בזיכרון לפי שורה (row-major order). כאשר ניגשים ל-`matrix[i][j]`, הגישות בתוך אותה שורה הן רציפות בזיכרון הווירטואלי.\n- עבור כל שורה `i`, ניגשים ל-4 דפים שונים (4 דפים מכסים שורה אחת). הגישה הראשונה לכל אחד מ-4 הדפים הללו תגרום ל-TLB Miss. לאחר מכן, כל הגישות הבאות לאותו דף (1023 גישות נוספות) יהיו TLB Hit.\n- ה-TLB מכיל 128 כניסות. 4 דפים לשורה. ה-TLB יכול להכיל `128 / 4 = 32` שורות בו זמנית.\n- כאשר עוברים לשורה חדשה (למשל, מ-`i` ל-`i+1`), 4 דפים חדשים נטענים ל-TLB. מכיוון שה-TLB מספיק גדול להכיל דפים של 32 שורות, וגם משתמש ב-LRU, ה-4 דפים של שורה `i-32` יוצאו מה-TLB כאשר נגיע לשורה `i` חדשה. כלומר, עבור כל אחת מ-N השורות, 4 דפים חדשים יגרמו ל-TLB Miss. \n- סך הכל TLB Misses: N * (מספר דפים לשורה) = 4096 * 4 = 16,384 Misses.\n\nחישוב TLB Hit Rate:\nHit Rate = (סך הגישות - סך ה-TLB Misses) / סך הגישות\nHit Rate = (16,777,216 - 16,384) / 16,777,216 = 1 - (16,384 / 16,777,216) = 1 - (1/1024) = 1 - 0.0009765625 = 0.9990234375 (כ-99.9%).\n\nחישוב זמן גישה אפקטיבי (EAT):\n- עלות TLB Hit: 1 ננו-שנייה.\n- עלות TLB Miss: יש לבצע Page Table Walk. מכיוון שיש 4 רמות, כל Page Table Walk דורש 4 גישות זיכרון (ל-PTE מכל רמה) + גישה אחת לדף הנתונים עצמו. סה\"כ 5 גישות זיכרון.\n- עלות TLB Miss = 5 * 100 ננו-שנייה = 500 ננו-שנייה.\nEAT = (Hit Rate * עלות Hit) + ((1 - Hit Rate) * עלות Miss)\nEAT = (0.9990234375 * 1) + (0.0009765625 * 500)\nEAT = 0.9990234375 + 0.48828125 = 1.4873046875 ננו-שנייה.\n\n1.3: חישוב EAT ו-TLB Hit Rate עבור `access_matrix_col_major()`:\n- סך כל הגישות: N * M = 16,777,216 גישות.\n\nניתוח TLB עבור גישה לפי עמודה:\nכאשר ניגשים ל-`matrix[i][j]` בגישה לפי עמודה, עבור `j` קבוע ו-`i` משתנה, הכתובות הפיזיות של `matrix[i][j]` ו-`matrix[i+1][j]` רחוקות זו מזו בזיכרון (M * sizeof(int) = 16KB). משמעות הדבר היא שכל גישה ל-`matrix[i][j]` (עבור `i` שונה) תהיה כמעט בוודאות לדף זיכרון אחר.\n- בכל איטרציה של הלולאה הפנימית (עבור `j` קבוע), ניגשים ל-N דפים שונים (4096 דפים).\n- ה-TLB מכיל רק 128 כניסות. מכיוון ש-N (4096) גדול בהרבה מ-128, ה-TLB יתמלא במהירות.\n- כאשר ניגשים ל-`matrix[i][j]` עבור `i` הולך וגדל, לאחר 128 גישות, ה-TLB יהיה מלא. הגישה ה-129 תגרום לדף הישן ביותר (LRU) לצאת מה-TLB ולהיכנס דף חדש.\n- לכן, כל גישה ל-`matrix[i][j]` (עבור `i` שונה) תגרום ל-TLB Miss. אין כמעט ניצול של לוקליות בזמן (temporal locality) או לוקליות במרחב (spatial locality) בתוך ה-TLB עבור גישה זו.\n- סך הכל TLB Misses: N * M = 4096 * 4096 = 16,777,216 Misses.\n\nחישוב TLB Hit Rate:\nHit Rate = (16,777,216 - 16,777,216) / 16,777,216 = 0 (0%).\n\nחישוב זמן גישה אפקטיבי (EAT):\nEAT = (0 * 1) + (1 * 500) = 500 ננו-שנייה.\n\nההבדל בין הסעיפים:\nההבדל המשמעותי נובע מהאופן שבו הנתונים מאוחסנים בזיכרון וכיצד קטעי הקוד ניגשים אליהם (לוקליות במרחב). מטריצות ב-C/C++ נשמרות בזיכרון לפי שורה (row-major order).:\n- בגישה לפי שורה (`access_matrix_row_major`), הגישות הן רציפות בזיכרון הווירטואלי. לאחר TLB Miss ראשוני לדף, כל הגישות הבאות לאותו דף (1023 איברים) יהיו TLB Hit. בנוסף, שורה שלמה (4 דפים) נכנסת בקלות ל-TLB, מה שמבטיח לוקליות גבוהה ושיעור פגיעות גבוה.\n- בגישה לפי עמודה (`access_matrix_col_major`), כל גישה ל-`matrix[i][j]` (עבור `i` שונה ו-`j` קבוע) קופצת לכתובת זיכרון המרוחקת מאוד מהגישה הקודמת, ולכן כמעט תמיד תהיה לדף וירטואלי חדש. מכיוון שה-TLB קטן בהרבה ממספר הדפים שנגישים בו זמנית בתוך עמודה אחת (4096 דפים לעומת 128 כניסות TLB), כל גישה כמעט תהיה TLB Miss. זהו ניצול גרוע של לוקליות במרחב ומוביל לביצועים ירודים משמעותית.\n\n1.4: השפעת מעבר הקשר על ביצועי ה-TLB ומנגנונים למיזעור ההשפעה:\nכאשר מתרחש מעבר הקשר בין תהליכים (Context Switch), מערכת ההפעלה מחליפה את התהליך הרץ. לכל תהליך מרחב כתובות וירטואלי משלו וטבלת דפים משלו. מכיוון שכניסות ב-TLB ממפות כתובות וירטואליות לכתובות פיזיות, כניסות אלו ספציפיות למרחב הכתובות של התהליך.\n\nהשפעה:\n- **ריקון TLB (TLB Flush):** במערכות ללא תמיכה מיוחדת, כאשר מתרחש מעבר קשר, יש לרוקן את כל ה-TLB. הסיבה היא שכניסות ה-TLB של התהליך הקודם אינן תקפות עבור התהליך החדש (אותה כתובת וירטואלית יכולה למפות לדף פיזי שונה בתהליך אחר). ריקון ה-TLB גורם ל-'TLB קר' עבור התהליך החדש, מה שמוביל למספר רב של TLB Misses בתחילת ריצתו ולפגיעה משמעותית בביצועים.\n\nמנגנונים למיזעור ההשפעה:\n1.  **מזהי מרחב כתובות (ASIDs - Address Space Identifiers):** מעבדים מודרניים רבים כוללים תמיכה ב-ASIDs. כל כניסה ב-TLB מתויגת עם ה-ASID של מרחב הכתובות אליו היא שייכת. כאשר מתרחש מעבר קשר, אין צורך לרוקן את כל ה-TLB. במקום זאת, המעבד פשוט משנה את ה-ASID הנוכחי. כניסות TLB עם ASID שאינו תואם את ה-ASID הנוכחי פשוט נהיות בלתי פעילות. זה מאפשר לכניסות של תהליכים שונים לדור בכפיפה אחת ב-TLB, ומפחית את מספר ה-TLB Misses לאחר מעבר קשר, כל עוד הכניסות של התהליך הבא עדיין נמצאות ב-TLB.\n2.  **TLB עם תמיכה סלקטיבית לריקון (Selective Invalidation):** במקום לרוקן את כל ה-TLB, ניתן לבצע ריקון סלקטיבי של כניסות ספציפיות, למשל כאשר דף מסוים משתנה או נמחק. עם זאת, במעבר קשר לרוב עדיף להשתמש ב-ASIDs או בריקון מלא אם אין ASIDs.\n3.  **TLB בעל גודל גדול יותר / אסוציאטיביות גבוהה יותר:** באופן כללי, TLB גדול יותר או בעל אסוציאטיביות גבוהה יותר יכול להכיל יותר מיפויים של דפים, וזה יכול לעזור להפחית את הצורך בריקון או להכיל יותר מיפויים של תהליכים שונים גם עם ASIDs.\n\nהשימוש ב-ASIDs הוא המנגנון הנפוץ והיעיל ביותר למיזעור השפעת מעבר הקשר על ביצועי ה-TLB, מכיוון שהוא מאפשר שמירה של כניסות TLB של תהליכים שונים בו זמנית ומפחית את הצורך בריקון מלא תכוף."
    },
    "difficulty_estimation": "Hard"
  }
}