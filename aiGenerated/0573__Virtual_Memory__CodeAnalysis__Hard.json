{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:49:33",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3618,
      "output_tokens": 3907,
      "total_tokens": 17277
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Paging",
      "TLB",
      "Locality of Reference",
      "Performance"
    ],
    "content": {
      "text": "נתונה תוכנית C המבצעת גישה למטריצה גדולה בזיכרון. המערכת פועלת עם זיכרון וירטואלי בעל המאפיינים הבאים:\n*   גודל עמוד (Page Size): 4KB (4096 בתים).\n*   גודל TLB (Translation Lookaside Buffer): 4 כניסות (entries). ה-TLB משתמש באסטרטגיית החלפה LRU (Least Recently Used).\n*   גודל הזיכרון הפיזי: גדול מספיק כדי להכיל את כל המטריצה.\n*   גודל int: 4 בתים.\n\nהמטריצה מוגדרת כ- `int matrix[ARRAY_DIM][ARRAY_DIM]` כאשר `ARRAY_DIM` הוא 1024.\nלצורך הניתוח, הניחו כי בתחילת כל לולאת גישה (לפני לולאת ה-for החיצונית הראשונה עבור כל דפוס גישה), ה-TLB ריק וכל דפי המטריצה אינם נמצאים בזיכרון הפיזי.\n\nנתח את קטע הקוד הבא וענה על השאלות:",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ARRAY_DIM 1024\n#define INT_SIZE 4 // bytes\n\nint main() {\n    int (*matrix)[ARRAY_DIM] = malloc(ARRAY_DIM * ARRAY_DIM * INT_SIZE);\n\n    if (matrix == NULL) {\n        perror(\"malloc failed\");\n        return 1;\n    }\n\n    // Access pattern 1: Row-major\n    printf(\"Accessing in row-major order...\\n\");\n    for (int i = 0; i < ARRAY_DIM; ++i) {\n        for (int j = 0; j < ARRAY_DIM; ++j) {\n            matrix[i][j] = i * ARRAY_DIM + j;\n        }\n    }\n\n    // Access pattern 2: Column-major\n    printf(\"Accessing in column-major order...\\n\");\n    for (int j = 0; j < ARRAY_DIM; ++j) {\n        for (int i = 0; i < ARRAY_DIM; ++i) {\n            matrix[i][j] = i * ARRAY_DIM + j;\n        }\n    }\n\n    free(matrix);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "101.1",
        "text": "כמה דפים (pages) דורשת המטריצה כולה?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.2",
        "text": "עבור \"Access pattern 1\" (גישה לפי שורות):\nא. כמה Page Faults יתרחשו בסך הכל?\nב. כמה TLB Misses יתרחשו בסך הכל?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.3",
        "text": "עבור \"Access pattern 2\" (גישה לפי עמודות):\nא. כמה Page Faults יתרחשו בסך הכל?\nב. כמה TLB Misses יתרחשו בסך הכל?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.4",
        "text": "הסבר בקצרה מדוע יש הבדל משמעותי במספר ה-Page Faults וה-TLB Misses בין שני דפוסי הגישה, וכיצד ניתן לייעל את הביצועים במקרים כאלה.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 25,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**חישובים ופתרונות:**\n\n**1. כמה דפים (pages) דורשת המטריצה כולה?**\n*   גודל המטריצה: `ARRAY_DIM * ARRAY_DIM * INT_SIZE = 1024 * 1024 * 4 בתים = 4,194,304 בתים = 4MB`.\n*   גודל עמוד: `4KB = 4096 בתים`.\n*   מספר הדפים הנדרש: `4,194,304 / 4096 = 1024 דפים`.\n\n**2. עבור \"Access pattern 1\" (גישה לפי שורות):**\n*   כל שורה במטריצה היא בגודל `ARRAY_DIM * INT_SIZE = 1024 * 4 = 4096 בתים`. זהו בדיוק גודל של עמוד אחד.\n*   ישנן 1024 שורות, כלומר 1024 דפים שונים, כאשר כל שורה תופסת דף בודד.\n\nא. **כמה Page Faults יתרחשו בסך הכל?**\n    *   בתחילת כל לולאת `for` חיצונית, כל הדפים אינם בזיכרון הפיזי.\n    *   כאשר ניגשים לאיבר הראשון בכל שורה (`matrix[i][0]`), מתרחש Page Fault מכיוון שהדף של השורה הזו אינו בזיכרון. פעולה זו מכניסה את כל הדף (השורה) לזיכרון הפיזי.\n    *   לאחר מכן, כל הגישות הבאות לאותה שורה (`matrix[i][j]` עבור `j > 0`) יהיו Page Hits, מכיוון שהדף כבר נמצא בזיכרון.\n    *   מכיוון שיש 1024 שורות, וכל שורה נטענת פעם אחת, סך הכל יתרחשו **1024 Page Faults**.\n\nב. **כמה TLB Misses יתרחשו בסך הכל?**\n    *   ה-TLB ריק בתחילה וגודלו 4 כניסות. הוא משתמש באסטרטגיית LRU.\n    *   עבור כל שורה `i`:\n        *   הגישה הראשונה לאיבר בשורה (`matrix[i][0]`) תגרום ל-TLB Miss. המיפוי של דף `i` יוכנס ל-TLB (או יחליף את כניסת ה-LRU אם ה-TLB מלא).\n        *   כל שאר הגישות לאיברי אותה שורה (`matrix[i][j]` עבור `j > 0`) יהיו TLB Hits, מכיוון שהמיפוי של דף `i` נמצא כעת ב-TLB והוא ה-MRU (Most Recently Used).\n    *   מכיוון שיש 1024 שורות, וכל שורה גורמת ל-TLB Miss אחד (כאשר ניגשים אליה לראשונה), סך הכל יתרחשו **1024 TLB Misses**.\n\n**3. עבור \"Access pattern 2\" (גישה לפי עמודות):**\n*   הלולאה החיצונית עוברת על עמודות (`j`), והלולאה הפנימית עוברת על שורות (`i`).\n*   גישה ל-`matrix[i][j]` עבור `j` קבוע ו-`i` משתנה, פירושה גישה לאיברים שנמצאים בדפים שונים לחלוטין. לדוגמה, `matrix[0][0]` נמצא בדף 0, `matrix[1][0]` בדף 1, וכן הלאה, עד `matrix[1023][0]` שנמצא בדף 1023.\n\nא. **כמה Page Faults יתרחשו בסך הכל?**\n    *   בתחילת כל לולאת `for` חיצונית, כל הדפים אינם בזיכרון הפיזי.\n    *   כאשר `j=0` (העמודה הראשונה):\n        *   הגישה ל-`matrix[0][0]` תגרום ל-Page Fault ותטען את דף 0.\n        *   הגישה ל-`matrix[1][0]` תגרום ל-Page Fault ותטען את דף 1.\n        *   ...וכן הלאה, עד הגישה ל-`matrix[1023][0]` שתגרום ל-Page Fault ותטען את דף 1023.\n        *   בסך הכל, עבור העמודה הראשונה, יטענו 1024 דפים שונים, ולכן יתרחשו 1024 Page Faults.\n    *   מכיוון שהזיכרון הפיזי גדול מספיק כדי להכיל את כל המטריצה (כל 1024 הדפים), לאחר העמודה הראשונה, כל דפי המטריצה כבר נמצאים בזיכרון הפיזי.\n    *   לכן, עבור כל העמודות הבאות (`j > 0`), לא יתרחשו Page Faults נוספים.\n    *   סך הכל יתרחשו **1024 Page Faults**.\n\nב. **כמה TLB Misses יתרחשו בסך הכל?**\n    *   ה-TLB ריק בתחילה וגודלו 4 כניסות. הוא משתמש באסטרטגיית LRU.\n    *   עבור `j=0` (העמודה הראשונה):\n        *   הגישה ל-`matrix[0][0]` גורמת ל-TLB Miss (דף 0 נכנס). TLB: {P0}\n        *   הגישה ל-`matrix[1][0]` גורמת ל-TLB Miss (דף 1 נכנס). TLB: {P0, P1}\n        *   הגישה ל-`matrix[2][0]` גורמת ל-TLB Miss (דף 2 נכנס). TLB: {P0, P1, P2}\n        *   הגישה ל-`matrix[3][0]` גורמת ל-TLB Miss (דף 3 נכנס). TLB: {P0, P1, P2, P3}\n        *   הגישה ל-`matrix[4][0]` גורמת ל-TLB Miss (דף 0, שהוא ה-LRU, יוצא; דף 4 נכנס). TLB: {P1, P2, P3, P4}\n        *   כיוון שאנו ניגשים ברצף ל-1024 דפים שונים (`P0, P1, ..., P1023`) וה-TLB יכול להכיל רק 4 כניסות, כל גישה לאיבר תגרום ל-TLB Miss מכיוון שהמיפוי לדף הדרוש לא יהיה ב-TLB (הוא כבר הוחלף).\n        *   לכן, עבור העמודה הראשונה, יתרחשו `1024 TLB Misses`.\n    *   עבור `j=1` (העמודה השנייה):\n        *   שוב, אנו ניגשים ברצף לדפים `P0, P1, ..., P1023`. גם כאן, כל גישה תגרום ל-TLB Miss מאותה הסיבה שה-TLB קטן מדי כדי להכיל את כל המיפויים הרלוונטיים, ומיפויים ישנים יוחלפו לפני שנגיע אליהם שוב.\n        *   לכן, עבור העמודה השנייה, יתרחשו `1024 TLB Misses`.\n    *   דפוס זה חוזר על עצמו עבור כל 1024 העמודות.\n    *   סך הכל יתרחשו `ARRAY_DIM * ARRAY_DIM = 1024 * 1024 = 1,048,576 TLB Misses`.\n\n**4. הסבר בקצרה מדוע יש הבדל משמעותי במספר ה-Page Faults וה-TLB Misses בין שני דפוסי הגישה, וכיצד ניתן לייעל את הביצועים במקרים כאלה.**\n\n**הבדלים עיקריים וסיבותיהם:**\n*   **עקרון המיקום (Locality of Reference):** השוני המשמעותי נובע ממידת הניצול של עקרון המיקום, ובפרט מיקום מרחבי (Spatial Locality).\n    *   **גישה לפי שורות (Row-major):** ב-C, מטריצות מאוחסנות בזיכרון ב\"סדר שורה ראשי\" (row-major order), כלומר איברי שורה רצופים מאוחסנים באופן רציף בזיכרון. כאשר ניגשים לשורה, איברים סמוכים נטענים יחד באותו דף זיכרון. לכן, לאחר ה-Page Fault וה-TLB Miss הראשוני לטעינת דף של שורה, כל הגישות הבאות לאיברים באותה שורה יהיו Page Hits ו-TLB Hits (עד שהדף יוחלף או ה-TLB יתמלא ויחליף את הכניסה). זהו ניצול יעיל של מיקום מרחבי.\n    *   **גישה לפי עמודות (Column-major):** כאשר ניגשים לעמודה, אנו עוברים בין איברים שאינם סמוכים בזיכרון, אלא מרוחקים זה מזה בגודל שורה שלמה (4096 בתים). המשמעות היא שכל גישה לאיבר בתוך אותה עמודה (למעט 4 הגישות הראשונות שייכנסו ל-TLB) תהיה לדף זיכרון אחר, וכמעט תמיד תגרום ל-TLB Miss (מכיוון שה-TLB קטן מאוד ולא יכול להכיל את כל המיפויים הרלוונטיים). למרות שכל הדפים נטענים לזיכרון הפיזי פעם אחת (ב-1024 Page Faults), הגישה החוזרת אליהם דרך ה-TLB היא לא יעילה בגלל חוסר מיקום מרחבי, מה שמוביל למספר עצום של TLB Misses.\n\n**ייעול ביצועים:**\n*   **התאמה למבנה הנתונים:** תמיד עדיף לגשת לנתונים באופן התואם לאופן אחסונם בזיכרון. במקרה של מטריצות ב-C, גישה לפי שורות עדיפה בהרבה על גישה לפי עמודות.\n*   **שיפור מיקום מרחבי וזמני (Spatial and Temporal Locality):** ארגון מחדש של אלגוריתמים ומבני נתונים כך שגישות לזיכרון יהיו קרובות ככל האפשר בזמן ובמרחב.\n*   **טכניקת \"חסימה\" או \"אריחים\" (Blocking/Tiling):** עבור אלגוריתמים (כמו כפל מטריצות) הדורשים גישה שאינה תואמת למיקום בזיכרון, ניתן לחלק את המטריצה ל\"בלוקים\" קטנים (אריחים) ולעבד כל בלוק בנפרד. בלוקים אלה יהיו קטנים מספיק כדי להיכנס כולם לזיכרון המטמון (cache) או ל-TLB, מה שימזער את מספר ה-Page Faults וה-TLB Misses. לדוגמה, במקום לעבד עמודה שלמה, נעבד רק חלק קטן מעמודה שמתאים בגודלו ל-TLB/cache, ואז נעבור לחלק קטן של עמודה הבאה, וכן הלאה, עד שנסיים בלוק שלם."
    },
    "difficulty_estimation": "Hard"
  }
}