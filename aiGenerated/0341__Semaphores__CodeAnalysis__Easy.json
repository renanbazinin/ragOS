{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:57:13",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3853,
      "output_tokens": 784,
      "total_tokens": 7083
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Semaphores",
      "Concurrency",
      "Threads"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בסמפור (semaphore) ובמספר תהליכונים (threads) כדי לגשת למשאב משותף. עיין בקוד המצורף וענה על השאלה:\n\nמה יהיה הערך הסופי של המשתנה `shared_resource` לאחר שכל התהליכונים יסיימו את ריצתם? הסבר מדוע.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#define NUM_THREADS 5\n\nsem_t my_semaphore;\nint shared_resource = 0;\n\nvoid* thread_function(void* arg) {\n    // Wait for the semaphore\n    sem_wait(&my_semaphore);\n\n    // Critical section\n    shared_resource++;\n    printf(\"Thread %ld entered. shared_resource = %d\\n\", (long)arg, shared_resource);\n\n    // Signal the semaphore\n    sem_post(&my_semaphore);\n\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    int i;\n\n    // Initialize the semaphore to 1 (binary semaphore)\n    sem_init(&my_semaphore, 0, 1);\n\n    for (i = 0; i < NUM_THREADS; i++) {\n        pthread_create(&threads[i], NULL, thread_function, (void*)(long)i);\n    }\n\n    for (i = 0; i < NUM_THREADS; i++) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final shared_resource value: %d\\n\", shared_resource);\n\n    // Destroy the semaphore\n    sem_destroy(&my_semaphore);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הערך הסופי של המשתנה `shared_resource` יהיה 5. הסיבה לכך היא שהסמפור `my_semaphore` מאותחל לערך 1, מה שהופך אותו לסמפור בינארי (או mutex). זה מבטיח שבכל רגע נתון, רק תהליכון אחד יכול להיכנס לקטע הקריטי (החלק בקוד שבין `sem_wait` ל-`sem_post`) ולגשת למשתנה `shared_resource`. פעולת ההגדלה `shared_resource++` מתבצעת באופן אטומי עבור כל תהליכון, כך שאין אובדן של עדכונים עקב תנאי מירוץ (race conditions). מכיוון שישנם 5 תהליכונים (`NUM_THREADS` מוגדר כ-5), וכל אחד מהם מגדיל את המשתנה פעם אחת באופן בטוח, הערך הסופי יהיה 5."
    },
    "difficulty_estimation": "Easy"
  }
}