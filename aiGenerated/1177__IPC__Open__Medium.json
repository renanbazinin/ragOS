{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 08:27:32",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2071,
      "output_tokens": 3595,
      "total_tokens": 11396
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Pipes",
      "Processes",
      "Inter-Process Communication"
    ],
    "content": {
      "text": "תהליך אב יוצר תהליך בן. תהליך האב מייצר 10 מספרים שלמים אקראיים (int) ושולח אותם לתהליך הבן דרך צינור (pipe). תהליך הבן קורא את המספרים, מחשב את סכומם, ושולח את הסכום בחזרה לאב דרך צינור אחר. האב מדפיס את הסכום שהתקבל.\n\nענה על השאלות הבאות:",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "א. תאר את השלבים העיקריים שיש לבצע במערכת ההפעלה (קריאות מערכת) כדי לממש תקשורת זו.",
        "code_snippet": null,
        "options": null,
        "solution": {
          "is_present_in_file": true,
          "correct_option": null,
          "explanation": "כדי לממש תקשורת זו באמצעות צינורות (pipes), יש לבצע את השלבים הבאים:\n1.  **יצירת צינורות**: יש ליצור שני צינורות באמצעות קריאת המערכת `pipe()`. צינור אחד ישמש לתקשורת מהאב לבן, והשני לתקשורת מהבן לאב. כל קריאת `pipe()` מחזירה שני מתארי קבצים (file descriptors): אחד לכתיבה ואחד לקריאה.\n2.  **יצירת תהליך בן**: תהליך האב קורא ל-`fork()` כדי ליצור תהליך בן. לאחר ה-`fork()`, לשני התהליכים יש עותקים של מתארי הקבצים של הצינורות.\n3.  **סגירת מתארי קבצים מיותרים**: חיוני שכל תהליך יסגור את הקצוות של הצינורות שאינם בשימוש. לדוגמה, האב יסגור את קצה הקריאה של הצינור הראשון ואת קצה הכתיבה של הצינור השני. הבן יסגור את קצה הכתיבה של הצינור הראשון ואת קצה הקריאה של הצינור השני. סגירת הקצוות הלא-רלוונטיים מונעת מצבי קיפאון (deadlock) ומאפשרת ל-`read()` להחזיר EOF כאשר קצה הכתיבה נסגר.\n4.  **כתיבה וקריאה**: תהליך האב ישתמש ב-`write()` כדי לשלוח את המספרים לצינור הראשון. תהליך הבן ישתמש ב-`read()` כדי לקרוא את המספרים מהצינור הראשון, יבצע את החישוב, ולאחר מכן ישתמש ב-`write()` כדי לשלוח את הסכום לצינור השני. תהליך האב ישתמש ב-`read()` כדי לקבל את הסכום מהצינור השני.\n5.  **המתנה לסיום תהליך הבן**: תהליך האב יקרא ל-`wait()` (או `waitpid()`) כדי להמתין לסיום תהליך הבן, ובכך למנוע תהליכי זומבי (zombie processes)."
        }
      },
      {
        "id": "1.2",
        "text": "ב. כתוב קטע קוד ב-C המדגים את חלקו של תהליך האב בשליחת המספרים וקבלת הסכום, וחלקו של תהליך הבן בקבלת המספרים ושליחת הסכום.",
        "code_snippet": null,
        "options": null,
        "solution": {
          "is_present_in_file": true,
          "correct_option": null,
          "explanation": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <time.h>\n\n#define NUM_INTEGERS 10\n\n// Helper function to ensure all bytes are written\nssize_t write_all(int fd, const void *buf, size_t count) {\n    size_t bytes_written = 0;\n    while (bytes_written < count) {\n        ssize_t res = write(fd, (const char *)buf + bytes_written, count - bytes_written);\n        if (res == -1) {\n            perror(\"write_all error\");\n            return -1;\n        } else if (res == 0) {\n            // Should not happen for pipes unless write end is closed\n            break;\n        }\n        bytes_written += res;\n    }\n    return bytes_written;\n}\n\n// Helper function to ensure all bytes are read\nssize_t read_all(int fd, void *buf, size_t count) {\n    size_t bytes_read = 0;\n    while (bytes_read < count) {\n        ssize_t res = read(fd, (char *)buf + bytes_read, count - bytes_read);\n        if (res == -1) {\n            perror(\"read_all error\");\n            return -1;\n        } else if (res == 0) {\n            // EOF\n            break;\n        }\n        bytes_read += res;\n    }\n    return bytes_read;\n}\n\nint main() {\n    int pipe_parent_to_child[2]; // pipe_parent_to_child[0] for read, [1] for write\n    int pipe_child_to_parent[2]; // pipe_child_to_parent[0] for read, [1] for write\n    pid_t pid;\n\n    // Create first pipe (parent -> child)\n    if (pipe(pipe_parent_to_child) == -1) {\n        perror(\"pipe_parent_to_child failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Create second pipe (child -> parent)\n    if (pipe(pipe_child_to_parent) == -1) {\n        perror(\"pipe_child_to_parent failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        // Close unused pipe ends\n        close(pipe_parent_to_child[1]); // Child doesn't write to this pipe\n        close(pipe_child_to_parent[0]); // Child doesn't read from this pipe\n\n        int received_num;\n        long long sum = 0;\n        printf(\"Child: Ready to receive numbers.\\n\");\n\n        for (int i = 0; i < NUM_INTEGERS; ++i) {\n            if (read_all(pipe_parent_to_child[0], &received_num, sizeof(int)) != sizeof(int)) {\n                perror(\"Child: Failed to read all bytes or EOF before expected\");\n                break;\n            }\n            printf(\"Child: Received %d\\n\", received_num);\n            sum += received_num;\n        }\n        printf(\"Child: Calculated sum: %lld\\n\", sum);\n\n        // Write sum back to parent\n        if (write_all(pipe_child_to_parent[1], &sum, sizeof(long long)) != sizeof(long long)) {\n            perror(\"Child: Failed to write sum\");\n            exit(EXIT_FAILURE);\n        }\n        printf(\"Child: Sent sum to parent.\\n\");\n\n        // Close remaining pipe ends\n        close(pipe_parent_to_child[0]);\n        close(pipe_child_to_parent[1]);\n\n        exit(EXIT_SUCCESS);\n\n    } else { // Parent process\n        // Close unused pipe ends\n        close(pipe_parent_to_child[0]); // Parent doesn't read from this pipe\n        close(pipe_child_to_parent[1]); // Parent doesn't write to this pipe\n\n        srand(time(NULL)); // Seed random number generator\n        int numbers[NUM_INTEGERS];\n        printf(\"Parent: Generating and sending numbers.\\n\");\n\n        for (int i = 0; i < NUM_INTEGERS; ++i) {\n            numbers[i] = rand() % 100 + 1; // Random numbers between 1 and 100\n            if (write_all(pipe_parent_to_child[1], &numbers[i], sizeof(int)) != sizeof(int)) {\n                perror(\"Parent: Failed to write all bytes\");\n                exit(EXIT_FAILURE);\n            }\n            printf(\"Parent: Sent %d\\n\", numbers[i]);\n        }\n        // Close the write end of pipe_parent_to_child to signal EOF to child\n        close(pipe_parent_to_child[1]);\n        printf(\"Parent: Finished sending numbers and closed write end of pipe_parent_to_child.\\n\");\n\n        long long received_sum;\n        // Read sum from child\n        if (read_all(pipe_child_to_parent[0], &received_sum, sizeof(long long)) != sizeof(long long)) {\n            perror(\"Parent: Failed to read sum from child\");\n            exit(EXIT_FAILURE);\n        }\n        printf(\"Parent: Received sum from child: %lld\\n\", received_sum);\n\n        // Close remaining pipe ends\n        close(pipe_child_to_parent[0]);\n\n        // Wait for child to terminate\n        wait(NULL);\n        printf(\"Parent: Child terminated. Exiting.\\n\");\n\n        exit(EXIT_SUCCESS);\n    }\n\n    return 0;\n}\n```"
        }
      },
      {
        "id": "1.3",
        "text": "ג. נניח שהמספרים נשלחים אחד אחרי השני. אילו בעיות עשויות להתעורר אם תהליך הבן מנסה לקרוא את המספרים לפני שהאב סיים לכתוב את כולם? וכיצד ניתן להבטיח קריאה וכתיבה אמינות של כל הנתונים?",
        "code_snippet": null,
        "options": null,
        "solution": {
          "is_present_in_file": true,
          "correct_option": null,
          "explanation": "**בעיות אפשריות אם הבן קורא לפני שהאב סיים לכתוב:**\n1.  **חסימה (Blocking)**: צינורות הם מנגנון תקשורת חוסם כברירת מחדל. אם הבן מנסה לקרוא נתונים מהצינור כאשר הצינור ריק, תהליך הבן ייחסם עד שהאב יכתוב נתונים לצינור. זהו התנהגות רגילה ומצופה, אך אם אין קונפורמציה ברורה של כמות הנתונים, הבן יכול להישאר חסום לנצח אם האב לא יכתוב מספיק או יסגור בטעות את קצה הכתיבה מוקדם מדי.\n2.  **קריאה חלקית (Partial Reads)**: קריאת המערכת `read()` אינה מבטיחה לקרוא את כל כמות הבתים המבוקשת בפעם אחת, גם אם הנתונים זמינים בצינור. היא תחזיר את מספר הבתים שנקראו בפועל (שיכול להיות פחות מהמבוקש), 0 אם הגיע לסוף קובץ (EOF, כלומר כל קצוות הכתיבה נסגרו), או -1 במקרה של שגיאה. אם הבן מצפה לקרוא `sizeof(int)` בתים ומקבל פחות, הוא עלול לפרש נתונים שגויים או להיתקע בלולאת קריאה אינסופית אם לא יטפל בכך כראוי.\n3.  **סיום מוקדם של הצינור**: אם תהליך האב סוגר את קצה הכתיבה של הצינור לפני שכל המספרים נכתבו והבן לא קרא את כולם, הבן יקבל EOF מוקדם מהצפוי, ויפסיק לקרוא למרות שלא קיבל את כל הנתונים.\n\n**הבטחת קריאה וכתיבה אמינות של כל הנתונים:**\nכדי להבטיח שכל הנתונים נשלחים ומתקבלים באופן אמין, יש ליישם את השיטות הבאות:\n1.  **לולאות קריאה/כתיבה (Looping read/write)**: יש להשתמש בלולאות עבור קריאות `read()` ו-`write()` כדי להבטיח שכל כמות הבתים המבוקשת אכן נכתבת או נקראת. בלולאה זו, יש לעקוב אחר מספר הבתים שכבר נכתבו/נקראו, ולהמשיך לקרוא/לכתוב את היתרה עד שכל הכמות הנדרשת הושלמה (כפי שהודגם בפונקציות `read_all` ו-`write_all` בקטע הקוד). יש לטפל במקרי שגיאה (`res == -1`) ובמקרה של EOF (`res == 0` ב-`read`).\n2.  **סגירה נכונה של מתארי קבצים (Proper File Descriptor Closure)**: יש לוודא שכל קצוות הצינורות שאינם בשימוש נסגרים באופן מיידי. במיוחד, סגירת קצה הכתיבה של הצינור על ידי השולח היא האות לתהליך הקורא שאין עוד נתונים בדרך (EOF). במקרה שלנו, האב צריך לסגור את קצה הכתיבה לצינור שמוביל לבן רק לאחר שכל המספרים נשלחו, והבן צריך לסגור את קצה הכתיבה לצינור שמוביל לאב רק לאחר שהסכום נשלח.\n3.  **טיפול בשגיאות (Error Handling)**: יש לבדוק תמיד את ערך ההחזרה של קריאות המערכת `read()`, `write()`, `pipe()`, ו-`fork()` ולטפל בשגיאות באמצעות `perror()` ו-`exit()`."
        }
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": null
    },
    "difficulty_estimation": "Medium"
  }
}