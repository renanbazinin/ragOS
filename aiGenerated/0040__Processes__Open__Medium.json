{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 18:18:46",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3602,
      "output_tokens": 989,
      "total_tokens": 6649
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Processes",
      "Fork",
      "Address Space"
    ],
    "content": {
      "text": "נתונה תוכנית בשפת C המשתמשת בקריאת המערכת fork. הניחו כי כל הקריאות למערכת מצליחות וכי התהליכים מסתיימים כסדרם (אין תהליכי זומבי או יתומים במהלך הריצה שימנעו את ההדפסות).",
      "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int x = 10;\n    pid_t p1 = fork();\n    if (p1 == 0) {\n        x += 5;\n        pid_t p2 = fork();\n        if (p2 == 0) {\n            x += 5;\n            printf(\"Child-Child: x = %d\\n\", x);\n        } else {\n            wait(NULL);\n            printf(\"Child: x = %d\\n\", x);\n        }\n    } else {\n        wait(NULL);\n        x -= 5;\n        printf(\"Parent: x = %d\\n\", x);\n    }\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מה יהיה פלט התוכנית? יש להסביר את סדר ההדפסות ואת הערך של x בכל הדפסה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "כמה תהליכים נוצרו בסך הכל במהלך ריצת התוכנית (כולל התהליך הראשי)?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "האם שינוי הערך של x בתהליך הבן משפיע על ערכו של x בתהליך האב? הסבר מדוע בהתבסס על ניהול הזיכרון של תהליכים.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1: פלט התוכנית יהיה:\nChild-Child: x = 20\nChild: x = 15\nParent: x = 5\nהסבר: התהליך הראשי (P1) מפצל את P2. ב-P2 המשתנה x הופך ל-15. P2 מפצל את P3. ב-P3 המשתנה x הופך ל-20 ומודפס. בגלל פקודות ה-wait, P3 מסיים ומדפיס ראשון, אחריו P2 מדפיס (x=15) ואז P1 מבצע x-=5 (מתוך ה-10 המקורי שלו) ומדפיס (x=5).\n\n1.2: נוצרו 3 תהליכים בסך הכל: התהליך המקורי (P1), הבן שלו (P2), והנכד (P3 - הבן של P2).\n\n1.3: לא, השינוי אינו משפיע. בעת ביצוע fork(), מערכת ההפעלה יוצרת עותק של מרחב הכתובות (Address Space) של תהליך האב עבור תהליך הבן. למרות שהם משתמשים באותן כתובות וירטואליות, הן ממופות למסגרות פיזיות שונות בזיכרון (או משתמשות במנגנון Copy-on-Write שיוצר עותק פיזי רק בעת כתיבה). לכן, לכל תהליך יש עותק פרטי משלו של המשתנה x."
    },
    "difficulty_estimation": "Medium"
  }
}