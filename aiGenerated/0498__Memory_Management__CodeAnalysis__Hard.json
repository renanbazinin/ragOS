{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:09:57",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2789,
      "output_tokens": 3458,
      "total_tokens": 12480
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Paging",
      "Address Translation"
    ],
    "content": {
      "text": "מערכת הפעלה נתונה משתמשת בזיכרון וירטואלי עם כתובות וירטואליות בנות 32 סיביות, וגודל עמוד (page size) של 4KB. המערכת מיישמת טבלת עמודים דו-שלבית לתרגום כתובות. פורמט הכתובת הווירטואלית מחולק לשלושה חלקים: 10 סיביות עבור אינדקס טבלת ספריות העמודים (Page Directory Index), 10 סיביות עבור אינדקס טבלת העמודים (Page Table Index), ו-12 סיביות עבור היסט בתוך העמוד (Offset).\n\nמבנה כניסה בטבלת עמודים (PTE) מוגדר כדלקמן:\n```c\ntypedef struct {\n    uint32_t present : 1;      // 1: page is in physical memory, 0: not present (page fault)\n    uint32_t rw : 1;           // 1: read/write, 0: read-only\n    uint32_t user_supervisor : 1; // 1: user access allowed, 0: supervisor only\n    uint32_t accessed : 1;     // Set by hardware on access\n    uint32_t dirty : 1;        // Set by hardware on write\n    uint32_t global : 1;       // Global page (TLB won't flush on context switch)\n    uint32_t unused : 6;       // Unused/available for OS use\n    uint32_t frame_addr_high : 20; // High 20 bits of the physical frame address (bits 12-31)\n} pte_t;\n```\n\nהפונקציה `translate_virtual_to_physical` מקבלת את הכתובת הפיזית של בסיס ספריית העמודים (page_directory_base), כתובת וירטואלית לתרגום (virtual_address), ודגל המציין האם הגישה היא גישת כתיבה (is_write_access). עליכם להשלים את מימוש הפונקציה כך שתחזיר את הכתובת הפיזית המתאימה, או קוד שגיאה במקרה של כשל.\n\nהפונקציה צריכה לטפל במקרים הבאים:\n1. **כשל עמוד (Page Fault)**: אם כניסה כלשהי בטבלת העמודים (PTE או PDE) אינה מסומנת כ-'present' (הסיבית present היא 0), יש להחזיר את קוד השגיאה `E_PAGE_FAULT`.\n2. **שגיאת הרשאה (Permission Denied)**: אם מבוצעת גישת כתיבה (is_write_access הוא true) לעמוד המסומן כ'קריאה בלבד' (הסיבית rw היא 0), יש להחזיר את קוד השגיאה `E_PERMISSION_DENIED`.\n3. **תרגום מוצלח**: אם כל הבדיקות עוברות, יש לחשב ולהחזיר את הכתובת הפיזית המלאה.\n\nלצורך פשטות המודל, יש להניח כי `page_directory_base` וכן השדה `frame_addr_high` ב-`pte_t` מכילים כתובות פיזיות שניתן להתייחס אליהן ישירות כאל מצביעים בזיכרון הסימולטבי שלנו (כלומר, אין צורך לדאוג למיפוי זיכרון פיזי לכתובות וירטואליות של הקרנל בתוך הפונקציה עצמה).\n\n```c\n#include <stdint.h>\n\n// Constants for system parameters\n#define PAGE_SIZE 4096 // 4KB\n#define BITS_FOR_OFFSET 12\n#define BITS_FOR_INDEX 10 // (32 - BITS_FOR_OFFSET) / 2 = 10\n\n// Masks for extracting parts of a virtual address\n#define PD_INDEX_MASK 0xFFC00000 // Bits 31-22\n#define PT_INDEX_MASK 0x003FF000 // Bits 21-12\n#define OFFSET_MASK   0x00000FFF // Bits 11-0\n\n// Page Table Entry (PTE) structure (as described in the problem)\ntypedef struct {\n    uint32_t present : 1;      // 1: page is in physical memory, 0: not present (page fault)\n    uint32_t rw : 1;           // 1: read/write, 0: read-only\n    uint32_t user_supervisor : 1; // 1: user access allowed, 0: supervisor only\n    uint32_t accessed : 1;     // Set by hardware on access\n    uint32_t dirty : 1;        // Set by hardware on write\n    uint32_t global : 1;       // Global page (TLB won't flush on context switch)\n    uint32_t unused : 6;       // Unused/available for OS use\n    uint32_t frame_addr_high : 20; // High 20 bits of the physical frame address (bits 12-31)\n} pte_t;\n\n// Error codes (using uint64_t to ensure distinct values from valid 32-bit physical addresses)\n#define E_PAGE_FAULT        ((uint64_t)-1)\n#define E_PERMISSION_DENIED ((uint64_t)-2)\n\n// Function signature to implement\nuint64_t translate_virtual_to_physical(uint64_t page_directory_base, uint32_t virtual_address, int is_write_access) {\n    // השלם את הקוד כאן\n}\n```",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון דורש פירוק של הכתובת הווירטואלית למרכיביה: אינדקס ספריית עמודים (PD_INDEX), אינדקס טבלת עמודים (PT_INDEX) והיסט בתוך העמוד (OFFSET). כל אינדקס משמש לגישה לכניסה המתאימה בטבלת העמודים ברמתה. לאחר מכן, יש לבצע בדיקות תקינות והרשאות בכל שלב.\n\n**שלבי הפתרון:**\n1.  **פירוק כתובת וירטואלית**: באמצעות מסכות והזזות סיביות, מחלצים את ה-PD_INDEX, PT_INDEX וה-OFFSET מה-`virtual_address`.\n    *   PD_INDEX (10 סיביות עליונות): מחושב מסיביות 22-31.\n    *   PT_INDEX (10 סיביות אמצעיות): מחושב מסיביות 12-21.\n    *   OFFSET (12 סיביות תחתונות): מחושב מסיביות 0-11.\n2.  **גישה ל-PDE (Page Directory Entry)**: ה-`page_directory_base` מצביע לתחילת ספריית העמודים. אנו מחשבים את הכתובת של ה-PDE המתאים באמצעות `pd_index` וכופלים בגודל של `pte_t`.\n3.  **בדיקת PDE**:\n    *   אם `pde->present` הוא 0, מחזירים `E_PAGE_FAULT`.\n    *   אם `is_write_access` הוא true וגם `pde->rw` הוא 0, מחזירים `E_PERMISSION_DENIED` (בהנחה שסיבית ה-rw ב-PDE חלה על כל טבלת העמודים שהיא מפנה אליה).\n    *   השדה `pde->frame_addr_high` מכיל את 20 הסיביות העליונות של הכתובת הפיזית של טבלת העמודים מהרמה השנייה. אנו משלבים אותו עם 12 סיביות אפסים (הזזה שמאלה ב-`BITS_FOR_OFFSET`) כדי לקבל את כתובת הבסיס של טבלת העמודים.\n4.  **גישה ל-PTE (Page Table Entry)**: באמצעות כתובת הבסיס של טבלת העמודים ו-`pt_index`, מחשבים את הכתובת של ה-PTE המתאים.\n5.  **בדיקת PTE**:\n    *   אם `pte->present` הוא 0, מחזירים `E_PAGE_FAULT`.\n    *   אם `is_write_access` הוא true וגם `pte->rw` הוא 0, מחזירים `E_PERMISSION_DENIED`.\n    *   השדה `pte->frame_addr_high` מכיל את 20 הסיביות העליונות של הכתובת הפיזית של העמוד בפועל (frame).\n6.  **חישוב כתובת פיזית סופית**: משלבים את 20 הסיביות העליונות של כתובת ה-frame (מתוך `pte->frame_addr_high` לאחר הזזה) עם ה-OFFSET כדי לקבל את הכתובת הפיזית המלאה.\n\n```c\n#include <stdint.h>\n#include <stdio.h> // רק לצורך הדגמה/בדיקה, לא נדרש לפתרון עצמו\n\n// Constants for system parameters\n#define PAGE_SIZE 4096 // 4KB\n#define BITS_FOR_OFFSET 12\n#define BITS_FOR_INDEX 10 // (32 - BITS_FOR_OFFSET) / 2 = 10\n\n// Masks for extracting parts of a virtual address\n#define PD_INDEX_MASK 0xFFC00000 // Bits 31-22\n#define PT_INDEX_MASK 0x003FF000 // Bits 21-12\n#define OFFSET_MASK   0x00000FFF // Bits 11-0\n\n// Page Table Entry (PTE) structure\ntypedef struct {\n    uint32_t present : 1;      // 1: page is in physical memory, 0: not present (page fault)\n    uint32_t rw : 1;           // 1: read/write, 0: read-only\n    uint32_t user_supervisor : 1; // 1: user access allowed, 0: supervisor only\n    uint32_t accessed : 1;     // Set by hardware on access\n    uint32_t dirty : 1;        // Set by hardware on write\n    uint32_t global : 1;       // Global page (TLB won't flush on context switch)\n    uint32_t unused : 6;       // Unused/available for OS use\n    uint32_t frame_addr_high : 20; // High 20 bits of the physical frame address (bits 12-31)\n} pte_t;\n\n// Error codes (using uint64_t to ensure distinct values from valid 32-bit physical addresses)\n#define E_PAGE_FAULT        ((uint64_t)-1)\n#define E_PERMISSION_DENIED ((uint64_t)-2)\n\nuint64_t translate_virtual_to_physical(uint64_t page_directory_base, uint32_t virtual_address, int is_write_access) {\n    // Extract indices and offset\n    uint32_t pd_index = (virtual_address & PD_INDEX_MASK) >> (BITS_FOR_OFFSET + BITS_FOR_INDEX);\n    uint32_t pt_index = (virtual_address & PT_INDEX_MASK) >> BITS_FOR_OFFSET;\n    uint32_t offset   = (virtual_address & OFFSET_MASK);\n\n    // Level 1: Page Directory Entry (PDE)\n    // The page_directory_base points to the start of an array of pte_t\n    // Each entry is sizeof(pte_t) bytes\n    pte_t* pde = (pte_t*)(page_directory_base + (pd_index * sizeof(pte_t)));\n\n    // Check PDE validity\n    if (!pde->present) {\n        return E_PAGE_FAULT;\n    }\n\n    // Check PDE permissions for write access (if PDE itself is read-only)\n    // This check assumes PDE's `rw` bit applies to the entire page table it points to.\n    if (is_write_access && !pde->rw) {\n        return E_PERMISSION_DENIED;\n    }\n\n    // Level 2: Page Table Entry (PTE)\n    // The frame_addr_high of the PDE gives the base physical address of the Page Table\n    uint64_t page_table_base = (uint64_t)pde->frame_addr_high << BITS_FOR_OFFSET;\n    pte_t* pte = (pte_t*)(page_table_base + (pt_index * sizeof(pte_t)));\n\n    // Check PTE validity\n    if (!pte->present) {\n        return E_PAGE_FAULT;\n    }\n\n    // Check PTE permissions for write access\n    if (is_write_access && !pte->rw) {\n        return E_PERMISSION_DENIED;\n    }\n\n    // If all checks pass, calculate physical address\n    uint64_t physical_frame_base = (uint64_t)pte->frame_addr_high << BITS_FOR_OFFSET;\n    uint64_t physical_address = physical_frame_base | offset;\n\n    return physical_address;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}