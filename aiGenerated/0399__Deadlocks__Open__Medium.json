{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 21:17:21",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3559,
      "output_tokens": 1598,
      "total_tokens": 7279
    }
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Deadlocks",
      "Synchronization",
      "Resource Allocation"
    ],
    "content": {
      "text": "נתונה מערכת עם שני סוגי משאבים, R1 ו-R2, כאשר כל אחד מהם מוגן על ידי מנעול (mutex_R1, mutex_R2). קיימים N חוטים, וכל חוט נדרש לרכוש את R1 ו-R2 כדי לבצע את משימתו, ולאחר מן לשחרר אותם. מוצגים שני חוטים, חוט A וחוט B, המנסים לרכוש משאבים אלו:\n\n**חוט A:**\n```c\npthread_mutex_lock(&mutex_R1);\npthread_mutex_lock(&mutex_R2);\n// גישה למשאבים R1 ו-R2\npthread_mutex_unlock(&mutex_R2);\npthread_mutex_unlock(&mutex_R1);\n```\n\n**חוט B:**\n```c\npthread_mutex_lock(&mutex_R2);\npthread_mutex_lock(&mutex_R1);\n// גישה למשאבים R1 ו-R2\npthread_mutex_unlock(&mutex_R1);\npthread_mutex_unlock(&mutex_R2);\n```\n\nא. הסבירו מדוע תרחיש זה עלול להוביל לקיפאון (deadlock).\nב. הציעו פתרון למניעת קיפאון זה, וספקו קטע קוד עבור לוגיקת רכישת המשאבים המתוקנת עבור שני החוטים.\nג. דון בתנאי מניעת הקיפאון שהפתרון שלך מטפל בו.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. תרחיש זה עלול להוביל לקיפאון מכיוון שהוא מקיים את כל ארבעת התנאים ההכרחיים לקיפאון:\n1.  **מניעה הדדית (Mutual Exclusion):** כל משאב (mutex_R1 ו-mutex_R2) יכול להיות מוחזק על ידי חוט אחד בלבד בכל רגע נתון. זהו מאפיין מובנה של מנעולים.\n2.  **החזק והמתן (Hold and Wait):** חוט יכול להחזיק במשאב אחד (לדוגמה, חוט A מחזיק ב-mutex_R1) ובמקביל להמתין למשאב אחר (חוט A ממתין ל-mutex_R2).\n3.  **ללא דריסה (No Preemption):** משאבים אינם נלקחים בכוח מחוט שמחזיק בהם; חוט חייב לשחרר את המשאבים מרצונו.\n4.  **המתנה מעגלית (Circular Wait):** תנאי זה מתקיים כאשר קיים מעגל של חוטים, כאשר כל חוט בשרשרת ממתין למשאב המוחזק על ידי החוט הבא בשרשרת. בתרחיש הנתון, אם חוט A רוכש את mutex_R1 וחוט B רוכש את mutex_R2 בו-זמנית (או בסמיכות), אז חוט A ממתין ל-mutex_R2 (שמוחזק על ידי B), וחוט B ממתין ל-mutex_R1 (שמוחזק על ידי A). זה יוצר מעגל המתנה: A ממתין ל-B, ו-B ממתין ל-A.\n\nב. הפתרון למניעת קיפאון זה הוא לכפות סדר רכישה עקבי של המשאבים על כל החוטים. כלומר, כל החוטים ינסו תמיד לרכוש את המשאבים באותו סדר. לדוגמה, כל החוטים ירכשו תמיד את mutex_R1 ואז את mutex_R2. שינוי זה מונע את התנאי של המתנה מעגלית.\n\nלהלן קטע הקוד המתוקן עבור שני החוטים:\n\n```c\npthread_mutex_t mutex_R1; // יש לאתחל את המנעולים\npthread_mutex_t mutex_R2;\n\nvoid *thread_A_func(void *arg) {\n    // ... עבודה כלשהי ...\n    pthread_mutex_lock(&mutex_R1); // תמיד רכוש את R1 ראשון\n    pthread_mutex_lock(&mutex_R2); // ואז את R2\n    // גישה למשאבים R1 ו-R2\n    pthread_mutex_unlock(&mutex_R2);\n    pthread_mutex_unlock(&mutex_R1);\n    // ... עבודה נוספת ...\n    return NULL;\n}\n\nvoid *thread_B_func(void *arg) {\n    // ... עבודה כלשהי ...\n    pthread_mutex_lock(&mutex_R1); // גם חוט B רוכש את R1 ראשון\n    pthread_mutex_lock(&mutex_R2); // ואז את R2\n    // גישה למשאבים R1 ו-R2\n    pthread_mutex_unlock(&mutex_R2);\n    pthread_mutex_unlock(&mutex_R1);\n    // ... עבודה נוספת ...\n    return NULL;\n}\n```\n\nג. הפתרון המוצע מטפל בתנאי מניעת הקיפאון של **המתנה מעגלית (Circular Wait)**. על ידי אכיפת סדר רכישה עקבי וגלובלי (לדוגמה, תמיד R1 ואז R2), אנו מבטיחים שלא יכולה להיווצר שרשרת המתנה מעגלית. אם חוט A מחזיק ב-R1 וממתין ל-R2, וחוט B רוצה גם הוא את R1 ו-R2, הוא יצטרך להמתין ש-R1 ישוחרר על ידי A לפני שיוכל לרכוש אותו. מכיוון שכל החוטים רוכשים את המשאבים באותו סדר, לא ייתכן מצב שחוט A ממתין ל-R2 שמוחזק על ידי B, ובמקביל B ממתין ל-R1 שמוחזק על ידי A, מכיוון ש-B לא היה מנסה לרכוש את R2 לפני שרכש את R1 (שמוחזק על ידי A). כך אנו שוברים את המעגל הפוטנציאלי."
    },
    "difficulty_estimation": "Medium"
  }
}