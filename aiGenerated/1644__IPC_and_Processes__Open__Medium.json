{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 19:41:32",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2411,
      "output_tokens": 2349,
      "total_tokens": 10384
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Processes",
      "Pipes"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת במנגנון IPC מסוג pipe ליצירת תקשורת בין תהליך אב לתהליך בן. תהליך האב שולח הודעה לתהליך הבן, ולאחר מכן תהליך הבן מנסה לשלוח הודעת תגובה בחזרה לאב, תוך שימוש באותו ה-pipe.\n\nעיינו בקוד המצורף וענו על השאלות הבאות:",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n\n#define MSG_SIZE 256\n\nint main() {\n    int pipefd[2]; // pipefd[0] for read, pipefd[1] for write\n    pid_t pid;\n    char buffer[MSG_SIZE];\n\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Child closes its write end, as it will read first\n\n        // Child reads from parent\n        ssize_t bytes_read = read(pipefd[0], buffer, MSG_SIZE);\n        if (bytes_read > 0) {\n            printf(\"Child: Received message: %s\\n\", buffer);\n        } else {\n            perror(\"Child read error or pipe closed\");\n        }\n\n        // Child attempts to send a reply back to the parent using the same pipe.\n        strcpy(buffer, \"Hello from child!\");\n        printf(\"Child: Attempting to send reply...\\n\");\n        // This write will cause an error because pipefd[1] was closed by the child.\n        if (write(pipefd[1], buffer, strlen(buffer) + 1) == -1) {\n            perror(\"Child write error\"); // Expected: Bad file descriptor\n        }\n\n        close(pipefd[0]); // Child closes its read end\n        exit(EXIT_SUCCESS);\n\n    } else { // Parent process\n        close(pipefd[0]); // Parent closes its read end, as it will write first\n\n        // Parent writes to child\n        strcpy(buffer, \"Hello from parent!\");\n        write(pipefd[1], buffer, strlen(buffer) + 1);\n        printf(\"Parent: Sent message: %s\\n\", buffer);\n\n        // Parent closes its write end after writing\n        close(pipefd[1]);\n\n        wait(NULL); // Wait for child to terminate\n\n        printf(\"Parent: Child process finished.\\n\");\n    }\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מה יהיה הפלט הצפוי של התוכנית? הסבירו בקצרה כל שורה בפלט.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "מדוע ניסיון התגובה של תהליך הבן נכשל (או מפיק שגיאה/התנהגות בלתי צפויה)? הסבירו בהתייחס למנגנון ה-pipe.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "כיצד הייתם משנים את הקוד כדי לאפשר תקשורת דו-כיוונית תקינה בין האב לבן?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1:\nהפלט הצפוי של התוכנית יהיה כדלקמן:\n```\nParent: Sent message: Hello from parent!\nChild: Received message: Hello from parent!\nChild: Attempting to send reply...\nChild write error: Bad file descriptor\nParent: Child process finished.\n```\n**הסבר:**\n*   `Parent: Sent message: Hello from parent!` - תהליך האב כותב את ההודעה ל-pipe ומדפיס אישור על כך.\n*   `Child: Received message: Hello from parent!` - תהליך הבן קורא בהצלחה את ההודעה מה-pipe ומדפיס אותה.\n*   `Child: Attempting to send reply...` - תהליך הבן מנסה לשלוח הודעה בחזרה ומדפיס הודעת כוונה.\n*   `Child write error: Bad file descriptor` - ניסיון הכתיבה של הבן נכשל מכיוון שקצה הכתיבה של ה-pipe (`pipefd[1]`) נסגר על ידי הבן מוקדם יותר, ונוצרת שגיאת `EBADF` (קובץ מתאר שגוי).\n*   `Parent: Child process finished.` - תהליך האב ממתין לסיום הבן ומדפיס הודעת סיום.\n\n1.2:\nניסיון התגובה של תהליך הבן נכשל מכיוון ש-pipe יחיד הוא ערוץ תקשורת חד-כיווני. כאשר נוצר ה-pipe, `pipefd[0]` משמש לקריאה ו-`pipefd[1]` משמש לכתיבה. לאחר ה-`fork()`:\n*   תהליך האב סוגר את `pipefd[0]` (קצה הקריאה), מכיוון שהוא מתכוון רק לכתוב ל-pipe תחילה.\n*   תהליך הבן סוגר את `pipefd[1]` (קצה הכתיבה), מכיוון שהוא מתכוון רק לקרוא מה-pipe תחילה.\nכאשר תהליך הבן מנסה מאוחר יותר לכתוב בחזרה לאב באמצעות `write(pipefd[1], ...)`, הוא מנסה לכתוב לקובץ מתאר (`pipefd[1]`) שכבר נסגר על ידו. ניסיון זה מוביל לשגיאת `Bad file descriptor` (`EBADF`). גם אם הבן לא היה סוגר את `pipefd[1]`, האב סגר את קצה הקריאה שלו (`pipefd[0]`), כך שלא היה יכול לקרוא את ההודעה anyway.\n\n1.3:\nכדי לאפשר תקשורת דו-כיוונית תקינה בין האב לבן באמצעות pipes, הגישה הסטנדרטית היא להשתמש בשני pipes נפרדים:\n1.  **Pipe אחד** לתקשורת מהאב לבן (נקרא לו `pipe_pc`).\n2.  **Pipe שני** לתקשורת מהבן לאב (נקרא לו `pipe_cp`).\n\n**שינויים נדרשים בקוד:**\n\n*   **הצהרת pipes:**\n    ```c\n    int pipe_pc[2]; // Parent to Child: pipe_pc[0] read, pipe_pc[1] write\n    int pipe_cp[2]; // Child to Parent: pipe_cp[0] read, pipe_cp[1] write\n    ```\n\n*   **יצירת pipes:**\n    ```c\n    if (pipe(pipe_pc) == -1) { perror(\"pipe_pc\"); exit(EXIT_FAILURE); }\n    if (pipe(pipe_cp) == -1) { perror(\"pipe_cp\"); exit(EXIT_FAILURE); }\n    ```\n\n*   **תהליך האב (Parent):**\n    *   סוגר את קצוות ה-pipe שאינם בשימוש עבורו:\n        *   `close(pipe_pc[0]);` (האב לא קורא מ-`pipe_pc`)\n        *   `close(pipe_cp[1]);` (האב לא כותב ל-`pipe_cp`)\n    *   **כתיבה לבן:** `write(pipe_pc[1], buffer_to_child, ...);`\n    *   **קריאה מהבן:** `read(pipe_cp[0], buffer_from_child, ...);`\n    *   סוגר את הקצוות הנותרים לאחר סיום התקשורת.\n\n*   **תהליך הבן (Child):**\n    *   סוגר את קצוות ה-pipe שאינם בשימוש עבורו:\n        *   `close(pipe_pc[1]);` (הבן לא כותב ל-`pipe_pc`)\n        *   `close(pipe_cp[0]);` (הבן לא קורא מ-`pipe_cp`)\n    *   **קריאה מהאב:** `read(pipe_pc[0], buffer_from_parent, ...);`\n    *   **כתיבה לאב:** `write(pipe_cp[1], buffer_to_parent, ...);`\n    *   סוגר את הקצוות הנותרים לאחר סיום התקשורת.\n\nבצורה זו, כל pipe מוקדש לכיוון תקשורת אחד, ואין ניסיונות כתיבה/קריאה לקצוות שנסגרו או לכיוון הלא נכון."
    },
    "difficulty_estimation": "Medium"
  }
}