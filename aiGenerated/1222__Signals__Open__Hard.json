{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:48:44",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3748,
      "output_tokens": 3015,
      "total_tokens": 14568
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "Process Management",
      "Synchronization",
      "Race Conditions"
    ],
    "content": {
      "text": "תהליך אב (parent) יוצר תהליך בן (child) וממתין לסיום עבודתו. במקביל, תהליך האב צריך להיות מסוגל לטפל באות SIGINT (לדוגמה, כאשר המשתמש לוחץ Ctrl+C) ולסיים את פעולתו בצורה מסודרת.\n\nהמטרה היא להבטיח שתהליך האב יטפל בסיום הבן (על ידי קריאה ל-`waitpid`) לפני שהוא מגיב ל-`SIGINT` ומסיים את פעולתו. כלומר, אם `SIGINT` מגיע בזמן שהבן עדיין רץ, האב צריך להתעלם ממנו זמנית עד שהבן יסיים או יטופל. רק לאחר שהבן טופל (התבצעה קריאה ל-`waitpid` בהצלחה), האב יכול להגיב ל-`SIGINT` ולצאת.\n\nכתבו קוד C המממש את ההתנהגות המתוארת. עליכם להשתמש בפונקציות מתאימות לטיפול באותות (`sigaction`, `sigprocmask`, `sigsuspend` וכדומה) ולהסביר מדוע בחרתם בפתרון זה, תוך התייחסות לבעיות תזמון (race conditions) וכיצד הפתרון שלכם מונע אותן.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון כולל טיפול זהיר באותות `SIGCHLD` ו-`SIGINT` באמצעות `sigaction`, `sigprocmask` ו-`sigsuspend`.\n\n**הסבר מפורט:**\n\n1.  **מניעת מרוצי תזמון (Race Conditions) ואיבוד אותות:**\n    *   **חסימת אותות מראש:** לפני קריאה ל-`fork` ולאורך כל הלולאה הראשית של האב, האותות `SIGCHLD` ו-`SIGINT` נחסמים באמצעות `sigprocmask(SIG_BLOCK, &blocked_mask, NULL)`. זה מבטיח שאם הבן יסיים את פעולתו במהירות רבה מיד לאחר ה-`fork`, האות `SIGCHLD` לא יאבד לפני שהאב מוכן לטפל בו. במקום זאת, האות יישאר 'ממתין' (pending) ויימסר ברגע שהאות יבוטל חסימתו. באופן דומה, `SIGINT` נחסם כדי לאפשר לאב שליטה מלאה על מתי הוא מגיב לאות זה.\n    *   **שימוש ב-`volatile sig_atomic_t`:** דגלים גלובליים (`child_exited`, `sigint_received`) משמשים לתקשורת בין מטפלי האותות ללולאה הראשית. הם מוגדרים כ-`volatile` כדי למנוע אופטימיזציות קומפיילר שגויות, וכ-`sig_atomic_t` כדי להבטיח שקריאה וכתיבה אליהם הן פעולות אטומיות (כלומר, לא יופרעו על ידי אות באמצע העדכון).\n\n2.  **טיפול אטומי בהמתנה לאותות עם `sigsuspend`:**\n    *   הלולאה הראשית של האב משתמשת ב-`sigsuspend(&empty_mask)` כדי להמתין לאותות. הפעולה `sigsuspend` היא קריטית מכיוון שהיא מבצעת שתי פעולות באופן אטומי:\n        א.  היא מחליפה את מסכת האותות הנוכחית של התהליך במסכה הנתונה (במקרה זה, `empty_mask`, שאינה חוסמת אף אות), ובכך מאפשרת לאותות `SIGCHLD` ו-`SIGINT` להימסר.\n        ב.  היא משעה את התהליך עד שאחד מהאותות המותרים נמסר.\n    *   כאשר אות נמסר ומטפל האות מסיים את פעולתו (ומעדכן את הדגלים הגלובליים), `sigsuspend` חוזרת, ומסכת האותות המקורית (שחוסמת את `SIGCHLD` ו-`SIGINT`) משוחזרת. זה מבטיח שהבדיקה והטיפול בדגלים (`child_exited`, `sigint_received`) וקריאה ל-`waitpid` מתבצעות כאשר האותות הללו חסומים, ומונע מרוצי תזמון נוספים בזמן הטיפול.\n\n3.  **סדר טיפול באותות:**\n    *   הלוגיקה בלולאה הראשית בודקת קודם כל את הדגל `child_exited`. אם הוא מוגדר, האב קורא ל-`waitpid` כדי לקצור את הבן. רק לאחר שהבן נקצר (`child_reaped` הופך ל-`1`), האב בודק את הדגל `sigint_received`.\n    *   אם `SIGINT` התקבל אך הבן עדיין לא נקצר, האב מדפיס הודעה וחוזר להמתין ב-`sigsuspend`. הדגל `sigint_received` נשאר מוגדר, מה שמבטיח שהאב יגיב ל-`SIGINT` ברגע שהבן יטופל. זה מונע מהאב לצאת בטרם עת כפי שנדרש בשאלה.\n    *   בתוך מטפלי האותות, נחסמים אותות אחרים באופן זמני (למשל, `SIGINT` במטפל `SIGCHLD`), כדי למנוע הפרעות ובעיות כניסה חוזרת (reentrancy) אם שני אותות יגיעו בו-זמנית או בסמיכות גבוהה.\n\n**קוד C:**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <string.h>\n\n// דגלים גלובליים לתקשורת בין מטפלי האותות ללולאה הראשית\nvolatile sig_atomic_t child_exited = 0;\nvolatile sig_atomic_t sigint_received = 0;\n\n// מטפל אות עבור SIGCHLD\nvoid child_handler(int signum) {\n    child_exited = 1;\n    printf(\"\\n[Handler] SIGCHLD received. Child exited flag set.\\n\");\n}\n\n// מטפל אות עבור SIGINT\nvoid sigint_handler(int signum) {\n    sigint_received = 1;\n    printf(\"\\n[Handler] SIGINT received. SIGINT flag set.\\n\");\n}\n\nint main() {\n    struct sigaction sa_chld, sa_int;\n    sigset_t blocked_mask, empty_mask;\n    pid_t pid;\n    int child_reaped = 0;\n\n    // 1. הגדרת מסכות אותות\n    // blocked_mask: חוסמת SIGCHLD ו-SIGINT\n    sigemptyset(&blocked_mask);\n    sigaddset(&blocked_mask, SIGCHLD);\n    sigaddset(&blocked_mask, SIGINT);\n\n    // empty_mask: אינה חוסמת אף אות (לשימוש עם sigsuspend)\n    sigemptyset(&empty_mask);\n\n    // 2. הגדרת מטפל אות עבור SIGCHLD\n    memset(&sa_chld, 0, sizeof(sa_chld));\n    sa_chld.sa_handler = child_handler;\n    // חוסמים את SIGINT בתוך מטפל ה-SIGCHLD כדי למנוע הפרעות\n    sigaddset(&sa_chld.sa_mask, SIGINT);\n    if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 3. הגדרת מטפל אות עבור SIGINT\n    memset(&sa_int, 0, sizeof(sa_int));\n    sa_int.sa_handler = sigint_handler;\n    // חוסמים את SIGCHLD בתוך מטפל ה-SIGINT כדי למנוע הפרעות\n    sigaddset(&sa_int.sa_mask, SIGCHLD);\n    if (sigaction(SIGINT, &sa_int, NULL) == -1) {\n        perror(\"sigaction SIGINT\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 4. חסימת SIGCHLD ו-SIGINT בתהליך האב לפני ה-fork\n    // זה מונע איבוד אותות אם הבן יסיים מהר מדי.\n    if (sigprocmask(SIG_BLOCK, &blocked_mask, NULL) == -1) {\n        perror(\"sigprocmask BLOCK\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Parent: SIGCHLD and SIGINT are blocked.\\n\");\n\n    // 5. יצירת תהליך בן\n    pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork\");\n        // ביטול חסימת אותות לפני יציאה במקרה של שגיאה\n        sigprocmask(SIG_UNBLOCK, &blocked_mask, NULL);\n        exit(EXIT_FAILURE);\n    } else if (pid == 0) { // קוד הבן\n        printf(\"Child (%d): Starting work for 3 seconds...\\n\", getpid());\n        sleep(3);\n        printf(\"Child (%d): Exiting.\\n\", getpid());\n        exit(EXIT_SUCCESS);\n    } else { // קוד האב\n        printf(\"Parent (%d): Child created with PID %d.\\n\", getpid(), pid);\n\n        while (1) {\n            // 6. בדיקת דגלים וטיפול באותות כאשר SIGCHLD ו-SIGINT חסומים\n            if (child_exited) {\n                waitpid(pid, NULL, 0); // קצירת הבן\n                printf(\"Parent: Child %d reaped.\\n\", pid);\n                child_reaped = 1;\n                child_exited = 0; // איפוס הדגל\n            }\n\n            if (child_reaped && sigint_received) {\n                printf(\"Parent: SIGINT received AND child reaped. Exiting cleanly.\\n\");\n                break; // יציאה מהלולאה\n            } else if (sigint_received && !child_reaped) {\n                printf(\"Parent: SIGINT received, but child not yet reaped. Continuing to wait for child.\\n\");\n                // לא מאפסים את sigint_received. נמשיך לבדוק אותו עד שהבן יקצר.\n            }\n\n            printf(\"Parent: Waiting for signals (child_reaped=%d, sigint_received=%d)...\\n\", child_reaped, sigint_received);\n            fflush(stdout);\n\n            // 7. המתנה אטומית לאותות באמצעות sigsuspend\n            // sigsuspend מחליפה באופן זמני את מסכת האותות הנוכחית ב-empty_mask\n            // (המאפשרת את קבלת SIGCHLD ו-SIGINT), ומשעה את התהליך. כאשר אות נמסר,\n            // המטפל שלו מופעל, ולאחר מכן מסכת האותות המקורית (blocked_mask) משוחזרת.\n            sigsuspend(&empty_mask);\n        }\n\n        // 8. ביטול חסימת אותות לפני יציאה מסודרת\n        if (sigprocmask(SIG_UNBLOCK, &blocked_mask, NULL) == -1) {\n            perror(\"sigprocmask UNBLOCK\");\n            exit(EXIT_FAILURE);\n        }\n        printf(\"Parent: Unblocked SIGCHLD and SIGINT. Exiting.\\n\");\n    }\n\n    return 0;\n}\n```",
      "difficulty_estimation": "Hard"
    }
  }
}