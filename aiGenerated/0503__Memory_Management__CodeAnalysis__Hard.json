{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:14:41",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2789,
      "output_tokens": 3422,
      "total_tokens": 24007
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Memory Management",
      "Dynamic Allocation",
      "Heap Management",
      "Fragmentation",
      "Coalescing"
    ],
    "content": {
      "text": "נתונה תוכנית המממשת מנהל זיכרון פשוט משלה, הכולל פונקציות `my_malloc` ו-`my_free`. המנהל משתמש ברשימה מקושרת של בלוקים פנויים. הפונקציה `my_malloc` מיישמת אסטרטגיית \"ההתאמה הראשונה\" (First-Fit) ומפצלת בלוקים גדולים מדי. הפונקציה `my_free` מוסיפה בלוקים פנויים בחזרה לרשימה הממוינת לפי כתובת ומנסה לאחד בלוקים סמוכים פיזית (coalescing) כדי למנוע פיצול חיצוני (external fragmentation).\n\nקראו בעיון את הקוד המצורף וענו על השאלות הבאות:\n\n1.  **זיהוי באג ודוגמה:** תארו תרחיש ספציפי (רצף של קריאות ל-`my_malloc` ו-`my_free` עם גדלים מסוימים) שבו הבאג בפונקציה `my_free` מוביל לפיצול חיצוני שניתן היה למנוע. הסבירו מדוע הפיצול מתרחש בתרחיש שתיארתם.\n2.  **הסבר הבאג:** הסבירו לעומק את שורש הבאג בקוד של `my_free` שגורם לפיצול החיצוני. התייחסו לאופן שבו לולאת האיחוד עובדת ומהי הבעיה בה.\n3.  **תיקון הבאג:** הציעו תיקון לקוד של `my_free` שיפתור את הבאג שתואר לעיל, ויבטיח איחוד מלא של בלוקים סמוכים פיזית. כתבו את קטע הקוד המתוקן.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For sbrk\n\n// Define block structure\ntypedef struct Block {\n    size_t size; // Total size of the block including header\n    struct Block *next;\n    // Data area starts here\n} Block;\n\n#define BLOCK_HEADER_SIZE sizeof(Block)\n#define ALIGNMENT 8 // Align all allocations to 8 bytes\n\n// Global head of the free list.\nBlock *free_list_head = NULL;\n\n// Helper to align size\nsize_t align_size(size_t size) {\n    return (size + ALIGNMENT - 1) & ~(ALIGNMENT - 1);\n}\n\n// Custom malloc - first fit\nvoid* my_malloc(size_t size) {\n    size = align_size(size);\n    size_t total_required_size = size + BLOCK_HEADER_SIZE;\n\n    Block *current = free_list_head;\n    Block *prev = NULL;\n\n    while (current != NULL) {\n        if (current->size >= total_required_size) {\n            // Found a suitable block\n            if (current->size - total_required_size >= BLOCK_HEADER_SIZE + ALIGNMENT) { // If enough space to split\n                // Split the block\n                Block *new_free_block = (Block*)((char*)current + total_required_size);\n                new_free_block->size = current->size - total_required_size;\n                new_free_block->next = current->next; // The new free block inherits the rest of the list\n\n                current->size = total_required_size; // 'current' is now the allocated block\n\n                // Update the free list: 'new_free_block' replaces 'current'\n                if (prev == NULL) {\n                    free_list_head = new_free_block;\n                } else {\n                    prev->next = new_free_block;\n                }\n            } else { // Not enough space to split, take the whole block\n                // Remove 'current' from the free list\n                if (prev == NULL) {\n                    free_list_head = current->next;\n                } else {\n                    prev->next = current->next;\n                }\n            }\n            current->next = NULL; // Mark allocated block's next as NULL for safety/clarity\n            return (void*)((char*)current + BLOCK_HEADER_SIZE);\n        }\n        prev = current;\n        current = current->next;\n    }\n\n    // No suitable block found, extend heap\n    Block *new_block = (Block*)sbrk(total_required_size);\n    if (new_block == (void*)-1) {\n        return NULL; // sbrk failed\n    }\n    new_block->size = total_required_size;\n    new_block->next = NULL; // This block is fully allocated, not part of free list yet\n\n    return (void*)((char*)new_block + BLOCK_HEADER_SIZE);\n}\n\n// Custom free with merging logic (BUGGY VERSION for the question)\nvoid my_free(void *ptr) {\n    if (ptr == NULL) return;\n\n    Block *block_to_free = (Block*)((char*)ptr - BLOCK_HEADER_SIZE);\n    \n    // Insert the block into the free list, keeping it sorted by address\n    Block *current_node = free_list_head;\n    Block *prev_node = NULL;\n\n    while (current_node != NULL && current_node < block_to_free) {\n        prev_node = current_node;\n        current_node = current_node->next;\n    }\n\n    if (prev_node == NULL) { // Insert at head\n        block_to_free->next = free_list_head;\n        free_list_head = block_to_free;\n    } else { // Insert in middle or at end\n        block_to_free->next = current_node;\n        prev_node->next = block_to_free;\n    }\n\n    // Now, attempt to merge adjacent free blocks in a single pass.\n    // This is where the bug lies for the question.\n    current_node = free_list_head;\n    while (current_node != NULL && current_node->next != NULL) {\n        // Check if current_node and its successor are physically adjacent\n        if ((char*)current_node + current_node->size == (char*)current_node->next) {\n            // Merge current_node and current_node->next\n            current_node->size += current_node->next->size;\n            current_node->next = current_node->next->next; // Skip the merged block\n            // BUG: After merging, current_node is immediately advanced in the next line,\n            // preventing it from checking if the newly enlarged block can merge with its new successor.\n        } \n        current_node = current_node->next; // BUG: This line executes unconditionally, even after a merge.\n    }\n}"
    },
    "sub_questions": null,
    "points": 25,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **זיהוי באג ודוגמה:**\n    נניח מצב התחלתי שבו הזיכרון הפנוי מכיל שלושה בלוקים סמוכים פיזית (A, B, C) שמופיעים ברשימה המקושרת בסדר פיזי:\n    `free_list_head -> [Block A, size=X] -> [Block B, size=Y] -> [Block C, size=Z] -> NULL`\n    (כאשר A, B, C הם בלוקים סמוכים פיזית בזיכרון, וגודלם כולל את ה-header). נניח ש-X, Y, Z מספיק גדולים.\n    \n    כאשר לולאת האיחוד ב-`my_free` רצה:\n    1.  `current_node = A`. `current_node->next = B`. נניח ש-A ו-B סמוכים פיזית.\n        *   מתבצע איחוד: `A->size` גדל (לכלול את B), ו-`A->next` מצביע כעת על `C`. הרשימה נראית כעת: `free_list_head -> [Block A+B] -> [Block C] -> NULL`.\n        *   **הבאג:** שורת `current_node = current_node->next;` מתבצעת מיד לאחר האיחוד, מכיוון שהיא מחוץ לתנאי ה-`if`.\n            לכן, `current_node` מקודם ל-`C`.\n    2.  `current_node = C`. `current_node->next = NULL`. הלולאה מסתיימת.\n    \n    **תוצאה:** הבלוקים A ו-B אוחדו בהצלחה לבלוק גדול אחד `A+B`. עם זאת, הבלוק `C` נשאר בלוק נפרד, למרות שהוא סמוך פיזית לבלוק `A+B`. נוצר פיצול חיצוני: במקום בלוק אחד גדול בגודל `X+Y+Z`, יש לנו שני בלוקים: `A+B` ו-`C`. אם נבקש עכשיו `my_malloc(X+Y+Z-BLOCK_HEADER_SIZE)` (גודל שיתאים ל-`A+B+C` אך לא לכל אחד מהם בנפרד), הבקשה תיכשל למרות שיש מספיק זיכרון פנוי בסך הכל.\n\n2.  **הסבר הבאג:**\n    הבאג טמון בלולאת האיחוד ב-`my_free`. כאשר מתבצע איחוד בין `current_node` לבין `current_node->next`, הבלוק `current_node` גדל ו-`current_node->next` מעודכן לדלג על הבלוק שאוחד. הבעיה היא שאחרי האיחוד, ייתכן ש-`current_node` (שגדל) סמוך פיזית גם לבלוק הבא ברשימה (שהיה במקור `current_node->next->next`). אך שורת `current_node = current_node->next;` מתבצעת באופן בלתי מותנה, כלומר, היא תמיד מקדמת את `current_node` לשלב הבא בלולאה, גם אם הרגע בוצע איחוד. כתוצאה מכך, `current_node` (לאחר שגדל) לא נבדק שוב לאפשרות של איחוד עם הבלוק הבא בתור. למעשה, ברגע ש-`current_node` גדל, הוא צריך לנסות שוב לאחד את עצמו עם הבלוק שאליו הוא מצביע כעת (שבמקור היה הבלוק שאחרי הבלוק שאוחד). הקידום הבלתי מותנה של `current_node` לאחר איחוד גורם לכך שרצף של בלוקים סמוכים פיזית יאוחד לכל היותר לשני בלוקים במקום לבלוק אחד גדול ויחיד.\n\n3.  **תיקון הבאג:**\n    כדי לתקן את הבאג, יש לשנות את לולאת האיחוד כך שאחרי איחוד מוצלח, הבלוק `current_node` יישאר באותה עמדה בלולאה וינסה שוב לבצע איחוד עם הבלוק הבא ברשימה. רק אם לא התרחש איחוד, `current_node` יתקדם לבלוק הבא. בכך, בלוק שגדל יוכל להמשיך ולאחד בלוקים סמוכים נוספים ברצף.\n\n    **קוד מתוקן עבור `my_free`:**\n    ```c\n// Custom free with merging logic (FIXED VERSION)\nvoid my_free(void *ptr) {\n    if (ptr == NULL) return;\n\n    Block *block_to_free = (Block*)((char*)ptr - BLOCK_HEADER_SIZE);\n    \n    // Insert the block into the free list, keeping it sorted by address\n    Block *current_node_for_insertion = free_list_head;\n    Block *prev_node_for_insertion = NULL;\n\n    while (current_node_for_insertion != NULL && current_node_for_insertion < block_to_free) {\n        prev_node_for_insertion = current_node_for_insertion;\n        current_node_for_insertion = current_node_for_insertion->next;\n    }\n\n    if (prev_node_for_insertion == NULL) { // Insert at head\n        block_to_free->next = free_list_head;\n        free_list_head = block_to_free;\n    } else { // Insert in middle or at end\n        block_to_free->next = current_node_for_insertion;\n        prev_node_for_insertion->next = block_to_free;\n    }\n\n    // Now, attempt to merge adjacent free blocks.\n    // Iterate and re-check current_node after each merge.\n    Block *current_node = free_list_head; \n    while (current_node != NULL && current_node->next != NULL) {\n        // Check if current_node and its successor are physically adjacent\n        if ((char*)current_node + current_node->size == (char*)current_node->next) {\n            // Merge current_node and current_node->next\n            current_node->size += current_node->next->size;\n            current_node->next = current_node->next->next; // Skip the merged block\n            // IMPORTANT: Do NOT advance current_node here. Re-evaluate it for further merges.\n            // The loop will re-check current_node with its *new* next pointer in the next iteration.\n        } else {\n            // Only advance if no merge happened\n            current_node = current_node->next;\n        }\n    }\n}\n    ```"
    },
    "difficulty_estimation": "Hard"
  }
}