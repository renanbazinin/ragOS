{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 08:29:00",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2071,
      "output_tokens": 1948,
      "total_tokens": 8018
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "IPC",
      "Synchronization",
      "Message Queues",
      "Shared Memory",
      "Semaphores"
    ],
    "content": {
      "text": "תהליך יצרן (Producer) מייצר מספרים שלמים בקצב קבוע, ותהליך צרכן (Consumer) צורך אותם. נדרש מנגנון IPC שיאפשר תקשורת אמינה ומסונכרנת בין שני התהליכים, כך שהצרכן לא ינסה לקרוא נתונים שטרם נכתבו, והיצרן לא יכתוב נתונים כאשר מאגר התקשורת מלא.\n\n1. בחר שני מנגנוני IPC שונים המתאימים לפתרון בעיה זו (לדוגמה: תור הודעות, זיכרון משותף עם סמפורים).\n2. עבור כל אחד מהמנגנונים שבחרת, הסבר בקצרה את אופן פעולתו הכללי ואת האופן שבו ניתן להשתמש בו לפתרון הבעיה הספציפית הזו (התייחס לסנכרון, העברת הנתונים וטיפול במצבי קצה).\n3. השווה בין שני המנגנונים שבחרת בהיבטים של ביצועים, קלות יישום, וגמישות.\n4. איזה מנגנון היית בוחר לפתרון זה, ומדוע?",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "להלן פירוט עבור שני מנגנוני IPC אפשריים:\n\n**מנגנון 1: תורי הודעות (Message Queues)**\n1.  **אופן פעולה:** תור הודעות הוא אובייקט בקרנל המאפשר לתהליכים לשלוח ולקבל הודעות. כל הודעה היא בלוק נתונים עם סוג (type). מערכת ההפעלה מטפלת בניהול התור, בבופר ובסנכרון. כאשר תהליך שולח הודעה לתור מלא, הוא נחסם עד שיתפנה מקום. כאשר תהליך מנסה לקבל הודעה מתור ריק, הוא נחסם עד שתגיע הודעה.\n2.  **שימוש לבעיית יצרן-צרכן:**\n    *   **סנכרון:** הסנכרון מטופל באופן מובנה על ידי מערכת ההפעלה. תהליך היצרן ישלח הודעות (מספרים שלמים) באמצעות `msgsnd()`. אם התור מלא, `msgsnd()` יחסום את היצרן. תהליך הצרכן יקבל הודעות באמצעות `msgrcv()`. אם התור ריק, `msgrcv()` יחסום את הצרכן. אין צורך בסמפורים מפורשים לסנכרון גישה למאגר או לסנכרון יצרן-צרכן.\n    *   **העברת נתונים:** הנתונים מועתקים ממרחב המשתמש של השולח למרחב הקרנל (לתור ההודעות), ולאחר מכן מועתקים ממרחב הקרנל למרחב המשתמש של המקבל. כל הודעה מכילה את המספר השלם.\n    *   **טיפול במצבי קצה:** מצב של תור מלא או ריק מטופל אוטומטית על ידי חסימת התהליך הרלוונטי עד שיתאפשר להמשיך.\n\n**מנגנון 2: זיכרון משותף (Shared Memory) עם סמפורים (Semaphores)**\n1.  **אופן פעולה:** זיכרון משותף הוא אזור בזיכרון הפיזי שאליו יכולים לגשת מספר תהליכים. תהליכים \"ממפים\" (attach) אזור זה למרחב הכתובות שלהם. כדי למנוע מצבי מירוץ (race conditions) ולהבטיח סנכרון נכון, יש להשתמש בסמפורים.\n2.  **שימוש לבעיית יצרן-צרכן:**\n    *   **סנכרון:** יש להשתמש במספר סמפורים:\n        *   סמפור בינארי (`mutex`): להבטחת גישה הדדית בלעדית (mutual exclusion) למאגר המשותף (לדוגמה, מערך מעגלי) בעת כתיבה או קריאה.\n        *   סמפור ספירה (`empty`): מאותחל לגודל המאגר. היצרן מבצע `wait` עליו לפני כתיבה (מפחית את מספר המקומות הריקים), והצרכן מבצע `post` עליו לאחר קריאה (מגדיל את מספר המקומות הריקים).\n        *   סמפור ספירה (`full`): מאותחל ל-0. היצרן מבצע `post` עליו לאחר כתיבה (מגדיל את מספר הפריטים המלאים), והצרכן מבצע `wait` עליו לפני קריאה (מפחית את מספר הפריטים המלאים).\n    *   **העברת נתונים:** הנתונים (מספרים שלמים) נכתבים ונקראים ישירות מאזור הזיכרון המשותף. אין העתקה למרחב הקרנל עבור הנתונים עצמם, רק עבור פעולות הסמפורים.\n    *   **טיפול במצבי קצה:** הסמפורים `empty` ו-`full` מטפלים במצבים של מאגר מלא או ריק על ידי חסימת התהליכים המתאימים עד שיתאפשר להם להמשיך.\n\n**השוואה בין המנגנונים:**\n*   **ביצועים:** זיכרון משותף מהיר יותר באופן משמעותי מכיוון שאין העתקת נתונים בין מרחב המשתמש למרחב הקרנל עבור כל פריט נתונים. הגישה לנתונים היא ישירה. תורי הודעות דורשים העתקה לכל הודעה, מה שיוצר תקורה נוספת.\n*   **קלות יישום:** תורי הודעות בדרך כלל קלים יותר ליישום עבור בעיות יצרן-צרכן בסיסיות, מכיוון שמערכת ההפעלה מטפלת ברוב היבטי הסנכרון וניהול המאגר. זיכרון משותף דורש קוד מפורש יותר לניהול המאגר (לדוגמה, מאגר מעגלי) ולסנכרון באמצעות סמפורים, והוא מועד יותר לשגיאות אם הסנכרון לא מיושם נכון.\n*   **גמישות:** זיכרון משותף גמיש יותר עבור מבני נתונים מורכבים וזרימות נתונים בנפח גבוה, שכן ניתן למקם כל מבנה נתונים בזיכרון המשותף. תורי הודעות מתאימים יותר לתקשורת מבוססת הודעות ומוגבלים בגודל ההודעה המקסימלי ובגודל התור הכולל.\n\n**בחירה ונימוק:**\nעבור בעיה זו, בה \"תהליך יצרן מייצר מספרים שלמים בקצב קבוע\", אם הקצב גבוה ונדרשת תפוקה מקסימלית, **זיכרון משותף עם סמפורים** יהיה הבחירה העדיפה. הסיבה לכך היא יתרון הביצועים המשמעותי הנובע מהימנעות מהעתקת נתונים. למרות המורכבות הגבוהה יותר ביישום, היתרון בביצועים יהיה קריטי במערכות הדורשות תגובה מהירה והעברת נתונים בנפח גבוה. אם קלות היישום והימנעות משגיאות סנכרון הן בראש סדר העדיפויות, ודרישות הביצועים פחות קריטיות, תורי הודעות יכולים להיות פתרון מספק."
    },
    "difficulty_estimation": "Medium"
  }
}