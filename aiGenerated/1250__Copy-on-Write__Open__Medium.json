{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 08:57:28",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3509,
      "output_tokens": 3778,
      "total_tokens": 11931
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Copy-on-Write",
      "Process Creation"
    ],
    "content": {
      "text": "מנגנון ה-Copy-on-Write (CoW) הוא אסטרטגיה נפוצה במערכות הפעלה לניהול זיכרון, במיוחד בהקשר של יצירת תהליכים חדשים באמצעות קריאת המערכת `fork()`.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "הסבירו בפירוט את מנגנון ה-Copy-on-Write בהקשר של יצירת תהליכים (fork). איזו בעיה הוא פותר, וכיצד הוא עושה זאת?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "נתונה תוכנית ה-C הבאה:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint global_var = 10;\n\nint main() {\n    int local_var = 20;\n    pid_t pid;\n\n    printf(\"Before fork: global_var = %d, local_var = %d (PID: %d)\\n\", global_var, local_var, getpid());\n\n    pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        exit(1);\n    } else if (pid == 0) { // Child process\n        printf(\"Child process (PID: %d) before modification: global_var = %d, local_var = %d\\n\", getpid(), global_var, local_var);\n        global_var = 100;\n        local_var = 200;\n        printf(\"Child process (PID: %d) after modification: global_var = %d, local_var = %d\\n\", getpid(), global_var, local_var);\n        exit(0);\n    } else { // Parent process\n        wait(NULL); // Wait for child to finish\n        printf(\"Parent process (PID: %d) after child finished: global_var = %d, local_var = %d\\n\", getpid(), global_var, local_var);\n        global_var = 1000;\n        local_var = 2000;\n        printf(\"Parent process (PID: %d) after modification: global_var = %d, local_var = %d\\n\", getpid(), global_var, local_var);\n    }\n\n    return 0;\n}\n```\nתארו את מצב הזיכרון (בדגש על דפי זיכרון פיזיים וירטואליים, וביטי הגנה בדפיות) של המשתנים `global_var` ו-`local_var` בנקודות הזמן הבאות:\nא. מיד לאחר קריאת המערכת `fork()` ולפני כל כתיבה על ידי תהליך הבן או האב.\nב. לאחר שהתהליך הבן משנה את ערכי המשתנים `global_var` ו-`local_var`.\nג. לאחר שהתהליך האב משנה את ערכי המשתנים `global_var` ו-`local_var` (לאחר שהבן סיים).\nהניחו שכל משתנה שוכן בדף זיכרון נפרד.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "מהם היתרונות העיקריים של שימוש במנגנון CoW? האם קיימים תרחישים שבהם CoW עלול להוביל לירידה בביצועים, ומדוע?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1: מנגנון ה-Copy-on-Write (CoW) הוא אופטימיזציה שנועדה לייעל את יצירת תהליכים חדשים באמצעות `fork()`. כאשר תהליך אב קורא ל-`fork()`, במקום להעתיק באופן מיידי את כל מרחב הכתובות של האב לבן, מערכת ההפעלה יוצרת עותק לוגי בלבד. כל דפי הזיכרון של האב משותפים בין האב לבן, אך מסומנים כדפי קריאה בלבד (read-only) בטבלאות הדפים של שני התהליכים. ביט מיוחד (לרוב 'writable' או 'dirty' בטבלת הדפים) מוגדר כ-0 עבור דפים אלה.\nהבעיה ש-CoW פותר היא העלות הגבוהה של העתקת זיכרון רבה, במיוחד אם התהליך הבן מבצע מיד `exec()` (כלומר, טוען תוכנית חדשה ומחליף את מרחב הכתובות שלו) או אם הוא קורא רק מנתונים אלה ולא משנה אותם.\nCoW פותר זאת על ידי דחיית העתקה בפועל של הדפים עד לרגע שבו אחד התהליכים (האב או הבן) מנסה לכתוב לדף משותף. כאשר מתרחש ניסיון כתיבה לדף המסומן כ-read-only, נוצר 'page fault'. מנהל הזיכרון של מערכת ההפעלה מיירט את ההפרעה, מקצה דף פיזי חדש, מעתיק אליו את תוכן הדף המשותף המקורי, ולאחר מכן מעדכן את טבלת הדפים של התהליך המבצע את הכתיבה כך שתצביע על הדף החדש. הדף החדש מסומן כעת כ-read/write עבור אותו תהליך. הדף המקורי נשאר משותף (אם יש לו עדיין שותפים) או מוקצה לתהליך השני. באופן זה, רק דפים שבאמת משתנים עוברים העתקה פיזית, מה שמפחית משמעותית את זמן יצירת התהליך ואת צריכת הזיכרון.\n\n1.2: א. **מיד לאחר קריאת המערכת `fork()` ולפני כל כתיבה:**\n   *   `global_var` ו-`local_var` (וכל שאר זיכרון התהליך) מצביעים על אותם דפים פיזיים.\n   *   בטבלאות הדפים של תהליך האב ושל תהליך הבן, הרשומות עבור הדפים המכילים את `global_var` ו-`local_var` (וכל שאר הדפים המשותפים) מסומנות כ-read-only. כלומר, ביט הכתיבה (writable bit) עבור דפים אלה מוגדר ל-0 בשתי טבלאות הדפים.\n   *   ערכים: `global_var = 10`, `local_var = 20` בשני התהליכים (מצביעים על אותם נתונים פיזיים).\n\nב. **לאחר שהתהליך הבן משנה את ערכי המשתנים `global_var` ו-`local_var`:**\n   *   כאשר הבן מנסה לשנות את `global_var` ל-100: מכיוון שהדף שמכיל את `global_var` מסומן כ-read-only, נוצר page fault. מערכת ההפעלה מקצה דף פיזי חדש, מעתיקה אליו את הערך 10 המקורי, מעדכנת את רשומת טבלת הדפים של הבן עבור הדף הזה כך שתצביע על הדף הפיזי החדש, ומסמנת אותו כ-read/write. הבן כותב 100 לדף החדש.\n   *   כאשר הבן מנסה לשנות את `local_var` ל-200: תהליך זהה ל-`global_var`. נוצר page fault, מוקצה דף פיזי חדש, מועתק הערך 20, רשומת הדף של הבן מתעדכנת ומסומנת כ-read/write. הבן כותב 200 לדף החדש.\n   *   **מצב סופי לאחר שינויי הבן:**\n      *   תהליך הבן:\n          *   `global_var`: מצביע על דף פיזי חדש (עותק), ערכו 100. רשומת הדף בטבלת הדפים של הבן מצביעה על הדף החדש ומסומנת כ-read/write.\n          *   `local_var`: מצביע על דף פיזי חדש (עותק), ערכו 200. רשומת הדף בטבלת הדפים של הבן מצביעה על הדף החדש ומסומנת כ-read/write.\n      *   תהליך האב:\n          *   `global_var`: עדיין מצביע על הדף הפיזי המקורי, ערכו 10. רשומת הדף בטבלת הדפים של האב עדיין מצביעה על הדף המקורי ומסומנת כ-read-only.\n          *   `local_var`: עדיין מצביע על הדף הפיזי המקורי, ערכו 20. רשומת הדף בטבלת הדפים של האב עדיין מצביעה על הדף המקורי ומסומנת כ-read-only.\n      *   הדפים הפיזיים המקוריים של `global_var` ו-`local_var` עדיין קיימים ומכילים 10 ו-20 בהתאמה, והם משותפים רק על ידי האב (או אולי תהליכים אחרים שנוצרו קודם, אך בהקשר זה רק האב).\n\nג. **לאחר שהתהליך האב משנה את ערכי המשתנים `global_var` ו-`local_var` (לאחר שהבן סיים):**\n   *   כאשר האב מנסה לשנות את `global_var` ל-1000: בדומה לבן, הדף שמכיל את `global_var` מסומן כ-read-only (כי הוא שותף במקור עם הבן, וגם אם הבן יצא, הביט לא השתנה לאב). נוצר page fault. מערכת ההפעלה מקצה דף פיזי חדש, מעתיקה אליו את הערך 10 המקורי, מעדכנת את רשומת טבלת הדפים של האב עבור הדף הזה כך שתצביע על הדף הפיזי החדש, ומסמנת אותו כ-read/write. האב כותב 1000 לדף החדש.\n   *   כאשר האב מנסה לשנות את `local_var` ל-2000: תהליך זהה. נוצר page fault, מוקצה דף פיזי חדש, מועתק הערך 20, רשומת הדף של האב מתעדכנת ומסומנת כ-read/write. האב כותב 2000 לדף החדש.\n   *   **מצב סופי לאחר שינויי האב:**\n      *   תהליך הבן (כבר סיים, אך אם היה ממשיך): `global_var = 100`, `local_var = 200` (בדפים פיזיים משלו).\n      *   תהליך האב:\n          *   `global_var`: מצביע על דף פיזי חדש (עותק), ערכו 1000. רשומת הדף בטבלת הדפים של האב מצביעה על הדף החדש ומסומנת כ-read/write.\n          *   `local_var`: מצביע על דף פיזי חדש (עותק), ערכו 2000. רשומת הדף בטבלת הדפים של האב מצביעה על הדף החדש ומסומנת כ-read/write.\n      *   הדפים הפיזיים המקוריים שהכילו 10 ו-20 (שאותם האב והבן חלקו בתחילה) כעת אינם בשימוש על ידי אף אחד מהתהליכים (האב והבן קיבלו עותקים), וניתן לשחררם (אם אין להם התייחסויות אחרות).\n\n1.3: **יתרונות עיקריים של CoW:**\n1.  **חיסכון בזיכרון:** אם תהליך הבן אינו משנה את הנתונים, או משנה רק חלק קטן מהם, אין צורך להחזיק מספר עותקים של אותם דפים בזיכרון הפיזי. זה מפחית את צריכת הזיכרון הכוללת של המערכת.\n2.  **שיפור ביצועים ביצירת תהליכים (fork):** זמן הנדרש ליצירת תהליך חדש מצטמצם משמעותית, מכיוון שלא מתבצעת העתקה מיידית של כל הזיכרון. פעולת ה-`fork()` הופכת למהירה יותר.\n3.  **שימושי במיוחד עבור `fork()` ואחריו `exec()`:** במקרים רבים, תהליך הבן נוצר רק כדי להריץ תוכנית אחרת (לדוגמה, כאשר מעטפת (shell) מריצה פקודה). במצב כזה, מרחב הכתובות של הבן יוחלף מיד בזה של התוכנית החדשה. ללא CoW, כל הזיכרון היה מועתק לשווא. עם CoW, כמעט שום העתקה לא מתרחשת לפני ה-`exec()`, מה שחוסך משאבים רבים.\n\n**תרחישים שבהם CoW עלול להוביל לירידה בביצועים:**\nCoW עלול להוביל לירידה בביצועים בתרחישים שבהם שני התהליכים (האב והבן) משנים כמעט את כל הדפים המשותפים. במצב כזה:\n1.  **עלויות Page Fault מרובות:** כל ניסיון כתיבה לדף משותף גורם ל-page fault, שדורש התערבות של מערכת ההפעלה, הקצאת דף פיזי חדש, העתקת נתונים ועדכון טבלאות דפים. אם זה קורה לדפים רבים, סך העלות של ה-page faults וההעתקות עשויה להיות גבוהה יותר מאשר העתקה ראשונית אחת ופשוטה.\n2.  **השהיית כתיבה (Latency):** פעולת הכתיבה הראשונה לדף נתון תהיה איטית יותר בגלל ה-page fault והעתקת הדף. אם יישום מסוים רגיש לזמני תגובה קצרים עבור פעולות כתיבה, זה יכול להוות בעיה.\n3.  **ניצול זיכרון פחות יעיל באופן זמני:** למרות ש-CoW חוסך זיכרון בטווח הארוך אם לא כל הדפים משתנים, במקרה שכל הדפים כן משתנים, נצטרך בסופו של דבר להחזיק עותקים נפרדים. ייתכן שבשלבי הביניים (כאשר דפים עדיין משותפים אך עומדים להשתנות), הזיכרון הפיזי מנוצל באופן פחות יעיל מאשר אם היינו מקצים עותקים מלאים מראש."
    },
    "difficulty_estimation": "Medium"
  }
}