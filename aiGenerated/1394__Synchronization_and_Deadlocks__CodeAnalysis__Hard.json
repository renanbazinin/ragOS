{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Synchronization and Deadlocks",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:51:56",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 5388,
      "output_tokens": 3388,
      "total_tokens": 19803
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Deadlocks",
      "Resource Management",
      "Atomic Operations",
      "Concurrency"
    ],
    "content": {
      "text": "מערכת הפעלה מנהלת מאגר של N משאבים זהים. כל משאב מיוצג על ידי מצב (state) שלם, כאשר 0 מציין שהמשאב פנוי ו-1 מציין שהמשאב תפוס. גישה למערך המצבים של המשאבים (resource_state) מוגנת על ידי מנעול גלובלי (pool_mutex), המאפשר לחוטים למצוא משאבים פנויים. נעילה ושחרור של משאב ספציפי מתבצעת באמצעות פקודת חומרה אטומית atomic_cas.\n\nחוטים בתוכנית צריכים לרכוש K משאבים *בו-זמנית* (atomically). כלומר, חוט חייב להצליח לרכוש את כל K המשאבים המבוקשים בבת אחת, או שאף אחד מהם לא יירכש. אם חוט אינו יכול לרכוש את כל K המשאבים הנדרשים, עליו לחסום (block) עד שיוכל. כאשר חוט משחרר משאבים, עליו ליידע חוטים אחרים שיתכן שהם ממתינים.\n\nיש לדאוג למניעה הדדית (mutual exclusion), הימנעות מקיפאון (deadlock-free) וחופש מרעב (starvation-free) עבור כל החוטים.\n\nפקודת חומרה אטומית: משווה ומחליפה\nמחזירה את הערך הישן של *ptr. אם הערך הישן שווה ל-expected, אז *ptr מקבל את desired.\nפעולה זו מתבצעת באופן אטומי.",
      "code_snippet": "int atomic_cas(int* ptr, int expected, int desired) {\n    int actual_old_value = *ptr;\n    if (actual_old_value == expected) {\n        *ptr = desired;\n    }\n    return actual_old_value;\n}\n\n// Global variables (assume declared and accessible)\n// extern int resource_state[MAX_RESOURCES_GLOBAL];\n// extern int NUM_RESOURCES;\n// extern pthread_mutex_t pool_mutex;\n// extern pthread_cond_t pool_cond;\n\n// Implement these functions\nvoid init_resource_manager(int num_resources) {\n    // Your implementation here\n}\n\nvoid acquire_resources(int k, int* acquired_indices) {\n    // Your implementation here\n}\n\nvoid release_resources(int k, int* released_indices) {\n    // Your implementation here\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון משתמש במנעול גלובלי (pool_mutex) ובמשתנה תנאי (pool_cond) כדי לתאם את הגישה למאגר המשאבים. משתנים גלובליים נוספים (resource_state, NUM_RESOURCES) נדרשים לאחסון מצב המשאבים ומספרם.\n\nפונקציית `init_resource_manager`:\nמאתחלת את המשאבים כולם כפנויים (0), ואת המוטקס ומשתנה התנאי.\n\nפונקציית `acquire_resources`:\n1.  הפונקציה נכנסת ללולאה אינסופית שממתינה עד שניתן יהיה לרכוש את המשאבים.\n2.  בתוך הלולאה, היא נועלת את `pool_mutex` כדי לגשת למערך `resource_state` בבטחה ולמצוא `k` משאבים פנויים. אם לא נמצאו מספיק משאבים, החוט ממתין על `pool_cond` (לאחר שחרור המוטקס) וחוזר לבדוק שוב כאשר הוא מתעורר.\n3.  אם נמצאו `k` משאבים פוטנציאליים, הפונקציה משחררת את `pool_mutex` *לפני* שהיא מנסה לנעול את המשאבים הבודדים באמצעות `atomic_cas`. שחרור המוטקס בשלב זה הוא קריטי למניעת קיפאון: הוא מאפשר לחוטים אחרים לגשת למאגר המשאבים (למשל, כדי לשחרר משאבים או למצוא משאבים אחרים) בזמן שחוט זה מנסה לרכוש את המשאבים הספציפיים שלו. זה מבטיח שה-`atomic_cas` יתבצעו באופן עצמאי עבור כל משאב, ללא החזקה בלעדית על המוטקס הגלובלי.\n4.  החוט מנסה לנעול כל אחד מ-`k` המשאבים שנבחרו באמצעות `atomic_cas` (מ-0 ל-1). אם כל ה-`atomic_cas` הצליחו, המשאבים נרכשו בהצלחה, האינדקסים נשמרים ב-`acquired_indices`, והפונקציה מסתיימת.\n5.  אם אחד ה-`atomic_cas` נכשל (כלומר, משאב שכבר נראה פנוי נתפס על ידי חוט אחר בין שחרור `pool_mutex` לביצוע ה-`atomic_cas`), או אם לא נמצאו מספיק משאבים פנויים מלכתחילה, יש לשחרר את כל המשאבים שכבר נתפסו בהצלחה (באמצעות `atomic_cas` חזרה ל-0), ולחזור לתחילת הלולאה לאחר רכישה מחדש של `pool_mutex` והמתנה על `pool_cond`.\n\nפונקציית `release_resources`:\n1.  הפונקציה משחררת כל משאב ברשימת `released_indices` על ידי הגדרתו ל-0 באמצעות `atomic_cas` (מ-1 ל-0). פעולה זו לא דורשת החזקת `pool_mutex` מכיוון שהיא אטומית ברמת המשאב הבודד.\n2.  לאחר שחרור המשאבים, הפונקציה נועלת את `pool_mutex` ושולחת `pthread_cond_broadcast` ל-`pool_cond` כדי להעיר את כל החוטים הממתינים. `broadcast` נבחר על פני `signal` כדי למנוע רעב, במיוחד במקרה שבו מספר חוטים ממתינים לסט משאבים שונה, וחוט אחד שמתעורר עשוי לא להיות זה שיכול לרכוש את המשאבים ששוחררו.\n\nהבטחת Deadlock-free ו-Starvation-free:\n*   **Deadlock-free**: המנגנון נמנע מקיפאון על ידי כך שכל חוט שמנסה לרכוש משאבים ונתקל בכישלון (או בחוסר זמינות) משחרר את כל המשאבים שרכש עד כה (אם רכש) וחוזר למצב המתנה. אין מצב שבו חוטים מחזיקים משאבים וממתינים למשאבים שמוחזקים על ידי חוטים אחרים שגם הם ממתינים. ה-`pool_mutex` ננעל רק לצורך סריקת המשאבים ולזמן קצר, ומשוחרר לפני ניסיונות ה-`atomic_cas` על המשאבים הספציפיים.\n*   **Starvation-free**: השימוש ב-`pthread_cond_broadcast` מבטיח שכל החוטים הממתינים יתעוררו כאשר משאבים משתחררים, ויקבלו הזדמנות לנסות לרכוש אותם מחדש. זה מקטין משמעותית את הסיכון לרעב בהשוואה לשימוש ב-`pthread_cond_signal` בלבד.",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_RESOURCES_GLOBAL 100 // Maximum possible resources\n\n// Global variables\nint resource_state[MAX_RESOURCES_GLOBAL]; // 0 = free, 1 = locked\nint NUM_RESOURCES; // Actual number of resources in use\npthread_mutex_t pool_mutex;\npthread_cond_t pool_cond;\n\n// Atomic Compare And Swap (conceptual)\n// Returns the value *before* the operation. If it matches 'expected', *ptr is updated to 'desired'.\nint atomic_cas(int* ptr, int expected, int desired) {\n    int actual_old_value = *ptr;\n    if (actual_old_value == expected) {\n        *ptr = desired;\n    }\n    return actual_old_value;\n}\n\nvoid init_resource_manager(int num_resources) {\n    if (num_resources <= 0 || num_resources > MAX_RESOURCES_GLOBAL) {\n        fprintf(stderr, \"Invalid number of resources.\\n\");\n        exit(EXIT_FAILURE);\n    }\n    NUM_RESOURCES = num_resources;\n    for (int i = 0; i < NUM_RESOURCES; ++i) {\n        resource_state[i] = 0; // All resources are initially free\n    }\n    pthread_mutex_init(&pool_mutex, NULL);\n    pthread_cond_init(&pool_cond, NULL);\n}\n\nvoid acquire_resources(int k, int* acquired_indices) {\n    if (k <= 0 || k > NUM_RESOURCES) {\n        fprintf(stderr, \"Invalid number of resources to acquire.\\n\");\n        return;\n    }\n\n    int temp_acquired_indices[k]; // Temporarily store indices\n    \n    pthread_mutex_lock(&pool_mutex); // Lock for initial search and condition waiting\n\n    while (true) {\n        int found_indices[k];\n        int found_count = 0;\n\n        // 1. Find k free resources under the protection of pool_mutex\n        for (int i = 0; i < NUM_RESOURCES && found_count < k; ++i) {\n            if (resource_state[i] == 0) {\n                found_indices[found_count++] = i;\n            }\n        }\n\n        if (found_count < k) {\n            // Not enough resources currently free. Wait.\n            pthread_cond_wait(&pool_cond, &pool_mutex);\n            continue; // Re-evaluate after waking up\n        }\n\n        // Enough potential resources found.\n        // Release pool_mutex before attempting CAS to allow concurrency\n        // and prevent deadlocks if CAS takes time or other threads need pool_mutex.\n        pthread_mutex_unlock(&pool_mutex);\n\n        // 2. Attempt to atomically lock the identified resources using CAS\n        bool all_locked = true;\n        int current_successful_cas = 0;\n        for (int i = 0; i < k; ++i) {\n            int resource_idx = found_indices[i];\n            if (atomic_cas(&resource_state[resource_idx], 0, 1) == 0) {\n                // Successfully locked this specific resource\n                temp_acquired_indices[current_successful_cas++] = resource_idx;\n            } else {\n                // Failed to lock this resource (another thread acquired it between search and CAS)\n                all_locked = false;\n                break; // Stop trying to acquire more\n            }\n        }\n\n        if (all_locked) {\n            // All k resources successfully acquired.\n            for (int i = 0; i < k; ++i) {\n                acquired_indices[i] = temp_acquired_indices[i];\n            }\n            // No need to re-lock pool_mutex as we are done.\n            // (The initial lock was released before CAS attempts).\n            return; // Success\n        } else {\n            // Failed to acquire all k resources.\n            // Release any resources that were successfully locked in this attempt.\n            for (int i = 0; i < current_successful_cas; ++i) {\n                atomic_cas(&resource_state[temp_acquired_indices[i]], 1, 0); // Release it\n            }\n            // Re-acquire pool_mutex to go back to the top of the loop and wait.\n            pthread_mutex_lock(&pool_mutex);\n            // This `pthread_cond_wait` is crucial for avoiding busy-waiting.\n            pthread_cond_wait(&pool_cond, &pool_mutex);\n            // After `pthread_cond_wait` returns, `pool_mutex` is re-acquired, loop continues.\n        }\n    } // End of while(true)\n}\n\nvoid release_resources(int k, int* released_indices) {\n    if (k <= 0 || k > NUM_RESOURCES) {\n        fprintf(stderr, \"Invalid number of resources to release.\\n\");\n        return;\n    }\n\n    for (int i = 0; i < k; ++i) {\n        int resource_idx = released_indices[i];\n        if (resource_idx < 0 || resource_idx >= NUM_RESOURCES) {\n            fprintf(stderr, \"Attempted to release invalid resource index %d.\\n\", resource_idx);\n            continue;\n        }\n        // Atomically set resource state to free\n        if (atomic_cas(&resource_state[resource_idx], 1, 0) != 1) {\n            // This indicates a logical error, resource was not locked by this thread or was already free\n            // In a real system, you might log this or assert, but for exam, it's a warning.\n        }\n    }\n\n    pthread_mutex_lock(&pool_mutex); // Lock to signal safely\n    pthread_cond_broadcast(&pool_cond); // Notify all waiting threads that resources might be available\n    pthread_mutex_unlock(&pool_mutex);\n}\n"
    },
    "difficulty_estimation": "Hard"
  }
}