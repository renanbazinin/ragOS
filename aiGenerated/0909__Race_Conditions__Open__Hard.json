{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Race Conditions",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 01:14:51",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4708,
      "output_tokens": 3979,
      "total_tokens": 13714
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Race Conditions",
      "Synchronization",
      "Linked List"
    ],
    "content": {
      "text": "נתונה תוכנית C המממשת רשימה מקושרת (linked list) פשוטה. מספר תהליכונים (threads) מוסיפים איברים לרשימה באופן קונקרנטי, ותהליכון אחר מחשב את סכום האיברים ברשימה. הקוד הבא מציג את המבנים והפונקציות המרכזיות בתוכנית:\n\nבהתבסס על הקוד הנתון ותיאור הפעילות:\n\n1.  זהו את כל תנאי המירוץ (Race Conditions) הפוטנציאליים בקוד. עבור כל אחד, הסבירו מדוע הוא תנאי מירוץ ומהן ההשלכות האפשריות (לדוגמה: קריסה, נתונים שגויים, לולאה אינסופית וכו').\n2.  הציעו פתרון מלא לסינכרון הרשימה המקושרת על מנת למנוע את תנאי המירוץ שזיהיתם. השתמשו במנעולים (mutexes) של pthreads. הציגו את הקוד המתוקן עבור הפונקציות `add_node` ו-`calculate_sum`, והסבירו את הלוגיקה של הסינכרון.\n3.  נתחו את השפעת פתרון הסינכרון שהצעתם על ביצועי המערכת (performance). האם הוא משפר או פוגע בהם? מדוע? האם ישנן דרכים לשפר את הקונקרנטיות תוך שמירה על נכונות?",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h> // For usleep\n\n// Node structure for the linked list\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\n// Global head of the linked list\nNode* head = NULL;\n\n// Function to add a new node to the beginning of the list\nvoid add_node(int value) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    if (new_node == NULL) {\n        perror(\"Failed to allocate new node\");\n        exit(EXIT_FAILURE);\n    }\n    new_node->data = value;\n    new_node->next = head; // Potential race condition 1: reading head\n    head = new_node;       // Potential race condition 2: writing head\n}\n\n// Function to calculate the sum of all elements in the list\nlong long calculate_sum() {\n    long long sum = 0;\n    Node* current = head; // Potential race condition 3: reading head\n    while (current != NULL) {\n        sum += current->data;\n        current = current->next; // Potential race condition 4: reading next\n    }\n    return sum;\n}\n\n// Thread function for adding nodes\nvoid* producer_thread(void* arg) {\n    int num_items = *(int*)arg;\n    for (int i = 0; i < num_items; ++i) {\n        add_node(i + 1); // Add values 1, 2, 3...\n        // Simulate some work\n        usleep(100);\n    }\n    return NULL;\n}\n\n// Thread function for calculating sum\nvoid* consumer_thread(void* arg) {\n    // Wait for some nodes to be added\n    usleep(50000);\n    long long sum = calculate_sum();\n    printf(\"Calculated sum: %lld\\n\", sum);\n    return NULL;\n}\n"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **זיהוי תנאי מירוץ והשלכותיהם:**\n\n    בקוד הנתון, ישנם מספר תנאי מירוץ קריטיים הנובעים מגישה קונקרנטית למשתנה הגלובלי `head` ולשדות `next` של הצמתים ברשימה:\n\n    *   **תנאי מירוץ 1: עדכון `head` בפונקציה `add_node`:**\n        *   **תיאור:** הפעולות `new_node->next = head;` ו-`head = new_node;` אינן אטומיות. הן מהוות קטע קריטי.\n        *   **תרחיש בעייתי:** נניח ששני תהליכונים, T1 ו-T2, קוראים שניהם את הערך הנוכחי של `head` (נניח `H_old`). שניהם יוצרים `new_node` משלהם. T1 מבצע `new_node_T1->next = H_old;` ואז `head = new_node_T1;`. מיד לאחר מכן, T2 מבצע `new_node_T2->next = H_old;` ואז `head = new_node_T2;`. (T1 סיים את הקטע הקריטי, T2 מתחיל את הקטע הקריטי עם `H_old`).\n        *   **השלכות:** במקרה זה, `new_node_T1` מצביע ל-`H_old` ו-`new_node_T2` מצביע גם הוא ל-`H_old`. לאחר ש-T2 מסיים, `head` יצביע ל-`new_node_T2`. הצומת `new_node_T1` למעשה \"אבד\" מהרשימה מכיוון שאין אף מצביע אליו מ-`head` או מצומת אחר ברשימה. זה מוביל לאובדן נתונים (lost update) ולדליפת זיכרון (memory leak).\n\n    *   **תנאי מירוץ 2: קריאת `head` בפונקציה `calculate_sum` בזמן עדכון:**\n        *   **תיאור:** תהליכון שקורא את `head` ב-`calculate_sum` (כדי להתחיל את המעבר על הרשימה) עלול לעשות זאת בזמן שתהליכון אחר (ב-`add_node`) משנה את `head`.\n        *   **תרחיש בעייתי:** תהליכון C קורא `current = head;` כאשר `head` מצביע על צומת X. מיד לאחר מכן, תהליכון P משנה את `head` לצומת Y (שהוא הצומת החדש ביותר). C ממשיך במעבר שלו מצומת X, ולא יראה לעולם את צומת Y ואת שאר הצמתים שנוספו אחריו, או לחלופין, אם C קורא את `head` כ-NULL ותהליכון P מוסיף צומת, C יחשב סכום 0. מצב נוסף הוא ש-`head` משתנה ל-NULL (למשל בפעולת מחיקה) בזמן ש-C כבר קרא אותו, ואז C יקרוס כשיינסה לגשת ל-`current->data` או `current->next` של צומת שכבר לא חלק מהרשימה.\n        *   **השלכות:** תוצאת הסכום תהיה שגויה (לא כוללת את כל האיברים). במקרים קיצוניים, אם `head` משתנה לכתובת לא חוקית או משתחרר, זה עלול לגרום ל-segmentation fault.\n\n    *   **תנאי מירוץ 3: מעבר על הרשימה ב-`calculate_sum` בזמן עדכון `next`:**\n        *   **תיאור:** תהליכון C מבצע `current = current->next;` בזמן שתהליכון P משנה את שדה `next` של צומת מסוים (למשל, הופך אותו ל-`NULL` אם הוא מבצע מחיקה, או משנה אותו לצומת אחר). \n        *   **השלכות:** יכול להוביל ל-segmentation fault (גישה לכתובת זיכרון לא חוקית אם `current->next` הופך ל-NULL או לכתובת שגויה), לולאה אינסופית (אם נוצר מצב מעגלי כתוצאה משינוי `next`), או דילוג על צמתים (אם שדה `next` משתנה לפני ש-C הספיק לקרוא אותו).\n\n2.  **פתרון סינכרון עם mutexes:**\n\n    כדי למנוע את תנאי המירוץ, יש להגן על הגישה למשתנה `head` ולשדות `next` של הצמתים באמצעות מנעול. גישה פשוטה ויעילה היא להשתמש במנעול יחיד שחוסם את כל פעולות הגישה לרשימה (הוספה וקריאת סכום).\n\n    ```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h> // For usleep\n\n// Node structure for the linked list\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n\n// Global head of the linked list\nNode* head = NULL;\n\n// Mutex for protecting the linked list\npthread_mutex_t list_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n// Function to add a new node to the beginning of the list (synchronized)\nvoid add_node_sync(int value) {\n    pthread_mutex_lock(&list_mutex); // Acquire lock\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    if (new_node == NULL) {\n        perror(\"Failed to allocate new node\");\n        exit(EXIT_FAILURE);\n    }\n    new_node->data = value;\n    new_node->next = head;\n    head = new_node;\n    pthread_mutex_unlock(&list_mutex); // Release lock\n}\n\n// Function to calculate the sum of all elements in the list (synchronized)\nlong long calculate_sum_sync() {\n    long long sum = 0;\n    pthread_mutex_lock(&list_mutex); // Acquire lock\n    Node* current = head;\n    while (current != NULL) {\n        sum += current->data;\n        current = current->next;\n    }\n    pthread_mutex_unlock(&list_mutex); // Release lock\n    return sum;\n}\n\n// Thread function for adding nodes (using synchronized version)\nvoid* producer_thread_sync(void* arg) {\n    int num_items = *(int*)arg;\n    for (int i = 0; i < num_items; ++i) {\n        add_node_sync(i + 1);\n        usleep(100);\n    }\n    return NULL;\n}\n\n// Thread function for calculating sum (using synchronized version)\nvoid* consumer_thread_sync(void* arg) {\n    usleep(50000);\n    long long sum = calculate_sum_sync();\n    printf(\"Calculated sum: %lld (synchronized)\\n\", sum);\n    return NULL;\n}\n    ```\n\n    **הסבר לוגיקת הסינכרון:**\n    על ידי שימוש ב-`pthread_mutex_lock` לפני כל גישה למבנה הנתונים המשותף (הרשימה המקושרת) וב-`pthread_mutex_unlock` לאחריה, אנו מבטיחים שרק תהליכון אחד יוכל לבצע שינויים או לעבור על הרשימה בכל רגע נתון. זה יוצר \"קטע קריטי\" (critical section) שמוגן מפני גישות קונקרנטיות.\n    *   ב-`add_node_sync`, המנעול מגן על שתי השורות שמעדכנות את `head` ואת `new_node->next`, ובכך מונע את אובדן הצמתים שתואר לעיל.\n    *   ב-`calculate_sum_sync`, המנעול מגן על כל פעולת המעבר על הרשימה. זה מבטיח שהרשימה לא תשתנה (לא יתווספו או יימחקו צמתים) בזמן שתהליכון מחשב את הסכום, ובכך מונע קריאות שגויות או קריסות. כל הפעולות על הרשימה הופכות לאטומיות ביחס זו לזו.\n\n3.  **השפעת פתרון הסינכרון על ביצועי המערכת:**\n\n    *   **השפעה:** פתרון הסינכרון שהוצע (מנעול יחיד המגן על כל הרשימה) **פוגע בביצועים** ומפחית באופן משמעותי את רמת הקונקרנטיות (concurrency).\n    *   **הסבר:** המנעול הופך את כל פעולות הוספת האיברים וחישוב הסכום לטוריות (sequential). למרות שישנם מספר תהליכונים, רק אחד מהם יכול לבצע פעולה על הרשימה בזמן נתון. תהליכונים אחרים ייאלצו להמתין שהמנעול ישוחרר. זה יוצר צוואר בקבוק (bottleneck) סביב המנעול.\n        *   **במקרה של `add_node_sync`:** כל הוספה מחייבת נעילה ושחרור של המנעול. אם יש הרבה תהליכוני כותבים, הם יתחרו על המנעול ויבלו זמן רב בהמתנה (lock contention).\n        *   **במקרה של `calculate_sum_sync`:** חישוב הסכום דורש מעבר על כל הרשימה, מה שאומר שהמנעול נשאר נעול למשך זמן רב יחסית. בזמן זה, אף תהליכון אחר לא יכול להוסיף איברים לרשימה, גם אם תיאורטית ההוספה הייתה יכולה להתבצע באופן בטוח ללא הפרעה לפעולת הקריאה.\n\n    *   **דרכים לשיפור הקונקרנטיות תוך שמירה על נכונות:**\n        *   **Reader-Writer Locks (מנעולי קורא-כותב):** ניתן להשתמש במנעולי קורא-כותב (לדוגמה `pthread_rwlock_t`). מנעולים אלו מאפשרים למספר תהליכוני קוראים לגשת למבנה הנתונים במקביל (shared access), אך רק תהליכון כותב אחד בלבד יכול לגשת למבנה הנתונים בכל רגע נתון (exclusive access), ומונעים מכותבים וקוראים לגשת במקביל. זה יכול לשפר ביצועים משמעותית בתרחישים שבהם יש הרבה יותר פעולות קריאה מאשר כתיבה, או כאשר פעולות הקריאה ארוכות, על ידי הגדלת הקונקרנטיות עבור קוראים.\n        *   **Fine-grained Locking:** במקום מנעול יחיד על כל הרשימה, ניתן להשתמש במספר מנעולים קטנים יותר, כל אחד מגן על חלק אחר של הרשימה. לדוגמה, ברשימה מקושרת, ניתן להשתמש בטכניקת \"hand-over-hand locking\" (או \"lock coupling\") בה תהליכון נועל את הצומת הבא לפני שחרור המנעול על הצומת הנוכחי. זה מגדיל את הקונקרנטיות על ידי צמצום גודל הקטע הקריטי, אך מוסיף מורכבות לניהול המנעולים ודורש תכנון זהיר כדי למנוע deadlock. ביישום הנוכחי של הוספה לראש הרשימה, fine-grained locking יהיה מורכב יותר ליישום מאחר שרוב הפעולות נוגעות ב-`head`.\n        *   **Lock-Free Data Structures:** שימוש במבני נתונים ללא מנעולים (lock-free data structures) המסתמכים על פעולות אטומיות (כמו Compare-And-Swap) הנתמכות בחומרה. גישה זו מורכבת מאוד ליישום נכון ומצריכה הבנה עמוקה של ארכיטקטורת זיכרון, אך מציעה את רמת הקונקרנטיות הגבוהה ביותר האפשרית."
    },
    "difficulty_estimation": "Hard"
  }
}