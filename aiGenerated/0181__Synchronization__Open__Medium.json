{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Synchronization",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 19:53:00",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1598,
      "output_tokens": 1927,
      "total_tokens": 8338
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Race Condition",
      "Mutex",
      "Threads"
    ],
    "content": {
      "text": "נתון קטע הקוד הבא המדמה גישה למשתנה גלובלי משותף `balance` על ידי מספר חוטים. חוטים מסוג `deposit_thread` מגדילים את `balance` וחוטים מסוג `withdraw_thread` מקטינים אותו. כל חוט מבצע את הפעולה מספר רב של פעמים. בתום ריצת התוכנית, מצפים שהערך הסופי של `balance` יהיה 0.\n\n1. מהי הבעיה המרכזית בקוד זה בהקשר של מערכות הפעלה מקביליות? הסבר מדוע היא מתרחשת וכיצד היא יכולה להוביל לתוצאה שגויה.\n2. הצע פתרון לבעיה זו באמצעות סמפורים או מנעולים (mutexes) ב-C. הצג את קטע הקוד המתוקן עבור הפונקציות `deposit_thread` ו-`withdraw_thread` ואת האתחול והסיום הנדרשים בפונקציית `main`.\n3. הסבר כיצד הפתרון שלך מונע את הבעיה ומבטיח נכונות.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nint balance = 0; // Shared global variable\n\nvoid* deposit_thread(void* arg) {\n    int i;\n    for (i = 0; i < 100000; i++) {\n        balance++;\n    }\n    return NULL;\n}\n\nvoid* withdraw_thread(void* arg) {\n    int i;\n    for (i = 0; i < 100000; i++) {\n        balance--;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2, tid3, tid4;\n\n    pthread_create(&tid1, NULL, deposit_thread, NULL);\n    pthread_create(&tid2, NULL, deposit_thread, NULL);\n    pthread_create(&tid3, NULL, withdraw_thread, NULL);\n    pthread_create(&tid4, NULL, withdraw_thread, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n    pthread_join(tid3, NULL);\n    pthread_join(tid4, NULL);\n\n    printf(\"Final balance: %d\\n\", balance);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### הסבר לבעיה (שאלה 1):\nהבעיה המרכזית בקוד היא תנאי מרוץ (Race Condition) בגישה למשתנה הגלובלי המשותף `balance`. הפעולות `balance++` ו-`balance--` אינן אטומיות. הן מורכבות ממספר פעולות מכונה ברמה נמוכה יותר (לדוגמה, עבור `balance++`:\n1. קריאת הערך של `balance` מהזיכרון לתוך רגיסטר.\n2. הגדלת הערך ברגיסטר.\n3. כתיבת הערך המעודכן מהרגיסטר בחזרה לזיכרון).\nכאשר מספר חוטים מנסים לבצע פעולות אלו בו-זמנית, ייתכן שחוט אחד יקרא את הערך של `balance`, יבוצע מיתוג הקשר (context switch) לחוט אחר שישנה את `balance`, וכאשר החוט הראשון יחזור לרוץ הוא יכתוב בחזרה ערך שגוי (מבוסס על הערך הישן שקרא לפני שהחוט השני שינה אותו). כתוצאה מכך, חלק מהעדכונים עלולים 'לאבד' (lost updates) והערך הסופי של `balance` יהיה שגוי ולא צפוי, ובדרך כלל לא יהיה 0 כפי שמצופה (שני חוטי הפקדה ושני חוטי משיכה, כל אחד 100,000 פעמים, אמורים לבטל זה את זה).\n\n### קוד מתוקן באמצעות מנעול (mutex) (שאלה 2):\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\npthread_mutex_t balance_mutex; // Mutex for synchronization\nint balance = 0; // Shared global variable\n\nvoid* deposit_thread_sync(void* arg) {\n    int i;\n    for (i = 0; i < 100000; i++) {\n        pthread_mutex_lock(&balance_mutex); // Acquire lock\n        balance++;\n        pthread_mutex_unlock(&balance_mutex); // Release lock\n    }\n    return NULL;\n}\n\nvoid* withdraw_thread_sync(void* arg) {\n    int i;\n    for (i = 0; i < 100000; i++) {\n        pthread_mutex_lock(&balance_mutex); // Acquire lock\n        balance--;\n        pthread_mutex_unlock(&balance_mutex); // Release lock\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2, tid3, tid4;\n\n    pthread_mutex_init(&balance_mutex, NULL); // Initialize mutex\n\n    pthread_create(&tid1, NULL, deposit_thread_sync, NULL);\n    pthread_create(&tid2, NULL, deposit_thread_sync, NULL);\n    pthread_create(&tid3, NULL, withdraw_thread_sync, NULL);\n    pthread_create(&tid4, NULL, withdraw_thread_sync, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n    pthread_join(tid3, NULL);\n    pthread_join(tid4, NULL);\n\n    printf(\"Final balance with sync: %d\\n\", balance);\n\n    pthread_mutex_destroy(&balance_mutex); // Destroy mutex\n    return 0;\n}\n```\n\n### הסבר לפתרון (שאלה 3):\nהפתרון המוצע הוא שימוש במנעול (mutex). מנעול הוא פרימיטיב סנכרון המבטיח הדרה הדדית (mutual exclusion), כלומר, רק חוט אחד יכול להחזיק במנעול בכל רגע נתון. לפני כל גישה למשתנה המשותף `balance` (בין אם לצורך הגדלה או הקטנה), החוט קורא לפונקציה `pthread_mutex_lock(&balance_mutex)` כדי לנעול את המנעול. אם המנעול כבר נעול על ידי חוט אחר, החוט הנוכחי נחסם וממתין עד שהמנעול ישוחרר. לאחר סיום הפעולה על `balance` (הקטע הקריטי), החוט קורא לפונקציה `pthread_mutex_unlock(&balance_mutex)` כדי לשחרר את המנעול, ובכך מאפשר לחוטים אחרים שחסומים לנסות לרכוש אותו. \n\nבצורה זו, פעולות `balance++` ו-`balance--` הופכות לאטומיות מבחינה לוגית: מרגע שחוט נעל את המנעול ועד ששחרר אותו, אף חוט אחר לא יוכל להיכנס לקטע הקריטי ולשנות את `balance`. זה מונע תנאי מרוץ ומבטיח שכל עדכון ל-`balance` יתבצע באופן מלא וללא הפרעה מחוטים אחרים, ובכך מבטיח שהחישוב הסופי של `balance` יהיה נכון (במקרה זה, 0)."
    },
    "difficulty_estimation": "Medium"
  }
}