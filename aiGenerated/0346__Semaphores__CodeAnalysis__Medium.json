{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:58:48",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2864,
      "output_tokens": 1885,
      "total_tokens": 8130
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Semaphores",
      "Concurrency",
      "Threads",
      "Race Conditions"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה המשתמשת בסמפורים להגנה על משאב משותף:\n",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#define NUM_THREADS 5\n#define INCREMENTS_PER_THREAD 100000\n\nint counter = 0;\nsem_t mutex; // סמפור בינארי\n\nvoid *thread_func(void *arg) {\n    for (int i = 0; i < INCREMENTS_PER_THREAD; ++i) {\n        sem_wait(&mutex); // נעל את המשאב\n        counter++;        // קטע קריטי\n        sem_post(&mutex); // שחרר את המשאב\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    // אתחל את הסמפור הבינארי ל-1\n    sem_init(&mutex, 0, 1); // pshared = 0 (בין תהליכונים), value = 1\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, thread_func, NULL);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", counter);\n\n    sem_destroy(&mutex); // השמד את הסמפור\n    return 0;\n}"
    },
    "sub_questions": [
      {
        "id": "8.1",
        "text": "מה יהיה הערך הסופי של המונה (`counter`) לאחר שכל התהליכונים יסיימו את ריצתם? נמקו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "8.2",
        "text": "האם קיים תנאי מרוץ (race condition) בקטע הקוד הזה? נמקו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "8.3",
        "text": "נניח שהשורה `sem_init(&mutex, 0, 1);` שונתה ל-`sem_init(&mutex, 0, NUM_THREADS);`. מה יהיה טווח הערכים האפשריים לערך הסופי של המונה (`counter`)? נמקו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **ערך סופי של המונה:**\n    הערך הסופי של המונה יהיה `500,000`. ישנם `NUM_THREADS` (5) תהליכונים, וכל תהליכון מבצע `INCREMENTS_PER_THREAD` (100,000) הגדלות. בסך הכל יבוצעו `5 * 100,000 = 500,000` הגדלות. הסמפור `mutex` מאותחל ל-1, ומשמש כסמפור בינארי (או מיוטקס). הקריאות `sem_wait` ו-`sem_post` עוטפות כהלכה את הפעולה `counter++`, המהווה קטע קריטי. זה מבטיח שרק תהליכון אחד יכול לגשת למשתנה `counter` בכל רגע נתון, ובכך מונע אובדן עדכונים וכל ההגדלות נספרות כהלכה.\n\n2.  **תנאי מרוץ (race condition):**\n    לא, לא קיים תנאי מרוץ בקטע הקוד הזה. הפעולה `counter++` היא קטע קריטי מכיוון שהיא כוללת רצף של קריאה, שינוי וכתיבה (טעינת הערך של `counter`, הגדלתו, ואחסון הערך החדש). ללא הגנה, מספר תהליכונים יכלו לקרוא את אותו ערך, לבצע הגדלה, ולכתוב בחזרה את אותו ערך מוגדל, מה שיוביל לאובדן עדכונים. עם זאת, הקריאות ל-`sem_wait(&mutex)` ו-`sem_post(&mutex)` מבטיחות הדדיות (mutual exclusion). רק תהליכון אחד יכול לעבור בהצלחה את `sem_wait` ולהיכנס לקטע הקריטי בכל פעם. תהליכונים אחרים יחסמו עד שהסמפור ישוחרר. זה מבטיח ש-`counter++` מבוצע באופן אטומי ביחס לתהליכונים אחרים, ומונע תנאי מרוץ.\n\n3.  **שינוי אתחול הסמפור ל-`NUM_THREADS`:**\n    אם השורה `sem_init(&mutex, 0, 1);` תשונה ל-`sem_init(&mutex, 0, NUM_THREADS);` (כלומר, `sem_init(&mutex, 0, 5);`), הסמפור יהפוך לסמפור סופר (counting semaphore) שיאפשר עד 5 תהליכונים להיכנס לקטע הקריטי בו זמנית. מכיוון שישנם בדיוק 5 תהליכונים בתוכנית, זה למעשה אומר שאין הגנה של הדדיות על הפעולה `counter++`. הפעולה `counter++` אינה אטומית בפני עצמה, וכאשר מספר תהליכונים יבצעו אותה במקביל, ייווצר תנאי מרוץ. כתוצאה מכך, חלק מההגדלות ילכו לאיבוד.\n    \n    *   **הערך המקסימלי האפשרי:** `NUM_THREADS * INCREMENTS_PER_THREAD = 500,000`. זה יקרה אם, במקרה, מתזמן מערכת ההפעלה יאפשר לתהליכונים לבצע את הפעולה `counter++` בטוריות מלאה, אחד אחרי השני, ללא שילוב שלבי הקריאה/שינוי/כתיבה שלהם.\n    *   **הערך המינימלי האפשרי:** `INCREMENTS_PER_THREAD = 100,000`. זה יכול לקרות אם, עבור כל פעולת `counter++`, כל 5 התהליכונים קוראים את אותו ערך נוכחי של `counter`, ואז כולם מגדילים אותו לערך הבא, וכולם כותבים בחזרה את אותו ערך חדש. בתרחיש קיצוני זה, רק הגדלה אפקטיבית אחת תתרחש עבור כל 5 הגדלות מיועדות. לדוגמה, אם `counter` הוא 0, כל 5 התהליכונים קוראים 0, כולם מחשבים 1, וכולם כותבים 1. ערך המונה הוא כעת 1. אם דפוס זה חוזר על עצמו, לאחר 100,000 \"מחזורים\" כאלה על ידי כל תהליכון, הספירה הכוללת תהיה 100,000.\n    \n    לכן, טווח הערכים האפשריים לערך הסופי של המונה הוא `[100,000, 500,000]`."
    },
    "difficulty_estimation": "Medium"
  }
}