{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:02:01",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4965,
      "output_tokens": 3210,
      "total_tokens": 12542
    }
  },
  "question": {
    "id": 9,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Copy-on-Write",
      "Processes"
    ],
    "content": {
      "text": "תהליך אב (Parent) יוצר תהליך בן (Child) באמצעות קריאת המערכת `fork()`. מערכת ההפעלה מממשת Copy-on-Write (CoW) עבור דפי זיכרון, וזאת כדי לייעל את פעולת `fork()` ולשתף דפים בין תהליכים. נניח שגודל דף זיכרון הוא 4KB.\n\nתהליך האב כולל 100MB של קוד (text segment), 50MB של נתונים לקריאה בלבד (read-only data segment), ו-20MB של נתונים לקריאה וכתיבה (read-write data segment). בנוסף, התהליך מקצה 30MB של ערימה (heap) ומשתמש ב-10MB של מחסנית (stack).\n\nלאחר ה-`fork()`:\nהתהליך הבן מבצע סדרה של פעולות:\nא. הוא משנה 5MB מתוך קטע הנתונים לקריאה וכתיבה (read-write data segment) שלו.\nב. הוא מקצה 15MB נוספים של ערימה (heap) וכותב לכל ה-15MB הללו.\nג. הוא מבצע קריאה ל-`execve()` כדי לטעון ולהריץ תוכנית חדשה. התוכנית החדשה דורשת 40MB של זיכרון כולל (קוד, נתונים, ערימה, מחסנית).\n\nיש לפרט ולנמק את כל החישובים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "9.1",
        "text": "מצב מיידי לאחר `fork()`: כמה דפים פיזיים משותפים (shared) וכמה דפים פיזיים פרטיים (private) קיימים עבור כל אחד מהתהליכים (האב והבן) מיד לאחר קריאת `fork()` ולפני כל פעולת כתיבה על ידי הבן? כמה דפים פיזיים בסך הכל נצרכים על ידי המערכת?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "9.2",
        "text": "לאחר פעולות הכתיבה של הבן: כמה דפים פיזיים משותפים וכמה דפים פיזיים פרטיים קיימים עבור כל אחד מהתהליכים (האב והבן) לאחר שהתהליך הבן השלים את פעולות הכתיבה המתוארות בסעיפים א' ו-ב' (אך לפני `execve()`)? כמה דפים פיזיים בסך הכל נצרכים על ידי המערכת?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "9.3",
        "text": "לאחר `execve()`: כמה דפים פיזיים בסך הכל נדרשים עבור התוכנית החדשה שהתהליך הבן טוען באמצעות `execve()`? האם קיימים עדיין דפים פיזיים משותפים בין התהליך הבן לתהליך האב לאחר ה-`execve()`? נמק.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "9.4",
        "text": "השפעת CoW על ביצועים: דון בקצרה בשני יתרונות ושני חסרונות של מנגנון ה-Copy-on-Write בהקשר של פעולות `fork()` ו-`execve()` על ביצועי המערכת.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "נתונים:\nגודל דף זיכרון = 4KB = 4096 בתים.\n\nחישוב מספר דפים עבור כל קטע זיכרון באב:\n*   קוד (Text): 100MB = (100 * 1024KB) / 4KB = 25600 דפים (לקריאה בלבד).\n*   נתונים לקריאה בלבד (Read-only Data): 50MB = (50 * 1024KB) / 4KB = 12800 דפים (לקריאה בלבד).\n*   נתונים לקריאה וכתיבה (Read-write Data): 20MB = (20 * 1024KB) / 4KB = 5120 דפים (לקריאה וכתיבה).\n*   ערימה (Heap): 30MB = (30 * 1024KB) / 4KB = 7680 דפים (לקריאה וכתיבה).\n*   מחסנית (Stack): 10MB = (10 * 1024KB) / 4KB = 2560 דפים (לקריאה וכתיבה).\n\nסה\"כ דפים של האב = 25600 + 12800 + 5120 + 7680 + 2560 = 53760 דפים.\n\n**9.1. מצב מיידי לאחר `fork()`:**\n*   **הסבר:** מיד לאחר `fork()`, מערכת ההפעלה משתמשת ב-CoW. כל הדפים הפיזיים של תהליך האב משותפים עם תהליך הבן. דפים המיועדים לקריאה בלבד (קוד ונתונים לקריאה בלבד) נשארים משותפים ללא צורך בהעתקה. דפים המיועדים לקריאה וכתיבה (נתונים לקריאה וכתיבה, ערימה, מחסנית) מסומנים כ-CoW, כך שרק כשתתבצע כתיבה אליהם, ייווצר עותק פרטי.\n*   **חישוב:**\n    *   **עבור האב:**\n        *   דפים פרטיים: 0\n        *   דפים משותפים: 53760\n    *   **עבור הבן:**\n        *   דפים פרטיים: 0\n        *   דפים משותפים: 53760\n    *   **סה\"כ דפים פיזיים במערכת:** 53760 (אין הכפלה של דפים בשלב זה).\n\n**9.2. לאחר פעולות הכתיבה של הבן:**\n*   **הסבר:** דפים מסוג Read-only יישארו משותפים. דפים מסוג Read-write שבהם הבן כותב, יועתקו, והבן יקבל עותק פרטי. דפים חדשים שהבן מקצה וככל הנראה כותב אליהם, יהיו פרטיים לו.\n    *   פעולה א': שינוי 5MB מתוך קטע הנתונים לקריאה וכתיבה של הבן.\n        *   5MB = 5 * 1024 / 4 = 1280 דפים.\n        *   דפים אלו היו במקור חלק מ-5120 דפי ה-RW Data של האב. כעת, 1280 דפים מתוכם יועתקו, והבן יקבל עותק פרטי. האב עדיין משתמש ב-1280 הדפים המקוריים (שנשארים משותפים עם שאר הדפים הלא-משוכתבים).\n    *   פעולה ב': הקצאת 15MB נוספים של ערימה וכתיבה לכולם.\n        *   15MB = 15 * 1024 / 4 = 3840 דפים.\n        *   דפים אלו הם חדשים לחלוטין, יוקצו כדפים פרטיים עבור הבן. הם לא היו חלק מהדפים המשותפים המקוריים.\n\n*   **חישוב:**\n    *   **דפים לקריאה בלבד (קוד + נתונים לקריאה בלבד):** 25600 + 12800 = 38400 דפים. אלו נשארים משותפים.\n    *   **דפים לקריאה וכתיבה שהיו קיימים במקור:**\n        *   RW Data: 5120 דפים.\n        *   Heap (מקורי): 7680 דפים.\n        *   Stack: 2560 דפים.\n        *   סה\"כ דפי RW מקוריים = 5120 + 7680 + 2560 = 15360 דפים.\n\n    *   **עבור האב:**\n        *   דפים פרטיים: 0 (האב לא שינה דבר).\n        *   דפים משותפים: 38400 (RO) + (15360 - 1280) (RW שלא שונו) = 38400 + 14080 = 52480 דפים.\n    *   **עבור הבן:**\n        *   דפים פרטיים: 1280 (עותקים של דפי RW Data ששונו) + 3840 (דפי Heap חדשים שהוקצו) = 5120 דפים.\n        *   דפים משותפים: 52480 דפים (אלו אותם דפים משותפים כמו האב).\n    *   **סה\"כ דפים פיזיים במערכת:** 53760 (דפים מקוריים) + 1280 (עותקים פרטיים לבן) + 3840 (דפים חדשים לבן) = 58880 דפים.\n\n**9.3. לאחר `execve()`:**\n*   **הסבר:** קריאת `execve()` גורמת לטעינת תוכנית חדשה לזיכרון הוירטואלי של התהליך הבן. כל הדפים הקודמים של התהליך הבן (בין אם היו משותפים או פרטיים) משוחררים. מפת הזיכרון הוירטואלי של הבן מאופסת, ודפים חדשים מוקצים עבור התוכנית החדשה.\n*   **חישוב:**\n    *   התוכנית החדשה דורשת 40MB של זיכרון כולל.\n    *   40MB = 40 * 1024 / 4 = 10240 דפים פיזיים.\n    *   **האם קיימים עדיין דפים פיזיים משותפים בין התהליך הבן לתהליך האב לאחר ה-`execve()`?** לא. כל הדפים שהיו שייכים לתהליך הבן (בין אם פרטיים או משותפים עם האב) משוחררים. התוכנית החדשה נטענת לזיכרון נקי, ללא קשר לאב או לדפים שהיו שייכים לו. התהליך הבן למעשה \"מחליף\" את התוכנית שהוא מריץ.\n\n**9.4. השפעת CoW על ביצועים:**\n*   **יתרונות:**\n    *   **חיסכון בזיכרון פיזי:** מונע שכפול מיידי של כל זיכרון האב לאחר `fork()`. זה חוסך צריכת זיכרון פיזי משמעותית, במיוחד אם התהליך הבן לא משנה את רוב הדפים או אם הוא מבצע `execve()` במהירות (כמו במעטפת פקודה).\n    *   **ביצועים משופרים ל-`fork()`:** קריאת `fork()` הופכת להיות מהירה יותר באופן משמעותי, שכן היא דורשת רק העתקת מפת הדפים וסימון דפים כ-CoW, במקום העתקה פיזית של כל התוכן. זה שימושי במיוחד עבור תהליכים המבצעים `execve()` מיד לאחר `fork()` (כי אין צורך להעתיק דפים שלעולם לא ישמשו את התוכנית החדשה).\n*   **חסרונות:**\n    *   **תקורה בעת כתיבה ראשונה (CoW Fault):** כל כתיבה ראשונה לדף משותף גורמת ל-page fault (CoW fault). זה דורש התערבות של מערכת ההפעלה כדי להקצות דף פיזי חדש, להעתיק את תוכן הדף המקורי לדף החדש, ולעדכן את מפת הדפים של התהליך הכותב. זהו תהליך יקר יחסית מבחינת זמן CPU וגישות לזיכרון.\n    *   **מורכבות ניהול זיכרון:** מערכת ההפעלה צריכה לנהל את מנגנון ה-CoW, לכלול מידע על ספירת הפניות לדפים (או מנגנון דומה), ולטפל ב-page faults מסוג CoW. זה מוסיף מורכבות למערכת ניהול הזיכרון ועלול להגדיל את התקורה של פעולות ניהול זיכרון מסוימות."
    },
    "difficulty_estimation": "Hard"
  }
}