{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Synchronization",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 19:51:38",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1598,
      "output_tokens": 1692,
      "total_tokens": 6019
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Race Conditions",
      "Mutexes"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת במספר חוטים (threads) כדי להגדיל מונה גלובלי משותף. קטע הקוד הבא מציג את פונקציית החוט (thread function) ואת המונה הגלובלי. ענו על השאלות הבאות:",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h> // For exit\n\nint shared_counter = 0;\n\nvoid* thread_func(void* arg) {\n    int i;\n    for (i = 0; i < 100000; i++) {\n        shared_counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    int i;\n\n    for (i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, thread_func, NULL);\n    }\n\n    for (i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", shared_counter);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "א. מהי הבעיה העיקרית בקוד זה בהקשר של סנכרון? הסבירו מדוע הבעיה מתרחשת וכיצד היא יכולה להשפיע על הפלט הסופי של המונה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "ב. כתבו מחדש את פונקציית ה-`thread_func` ואת קטע הקוד ב-`main` שנדרש לאתחול ולשחרור משאבים, כך שהמונה המשותף יעודכן באופן בטוח ונכון באמצעות מנעול הדדי (mutex). הציגו את הקוד המתוקן במלואו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 10,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. הבעיה העיקרית בקוד זה היא תנאי מירוץ (race condition). מספר חוטים מנסים לגשת ולשנות את המשתנה הגלובלי `shared_counter` בו-זמנית ללא מנגנון סנכרון מתאים. פעולת הגידול `shared_counter++` אינה פעולה אטומית. היא מורכבת בדרך כלל משלוש פעולות בסיסיות:\n1.  קריאת הערך הנוכחי של `shared_counter` לתוך אוגר.\n2.  הגדלת הערך באוגר באחד.\n3.  כתיבת הערך החדש מהאוגר בחזרה ל-`shared_counter`.\n\nאם שני חוטים (או יותר) מבצעים פעולות אלה במקביל, ייתכן ששניהם יקראו את אותו ערך ישן של `shared_counter`, יגדילו אותו באחד, ויכתבו בחזרה את אותו ערך (מוגדל באחד) - במקום שכל אחד מהם יגדיל אותו בנפרד. לדוגמה, אם `shared_counter` הוא 10, חוט A קורא 10, חוט B קורא 10. חוט A מגדיל ל-11 וכותב 11. חוט B מגדיל ל-11 וכותב 11. התוצאה הסופית היא 11 במקום 12. כתוצאה מכך, הערך הסופי של `shared_counter` יהיה בדרך כלל נמוך מהערך הצפוי (5 חוטים * 100,000 איטרציות = 500,000).\n\nב. כדי לפתור את בעיית תנאי המירוץ, נשתמש במנעול הדדי (mutex) כדי להגן על הקטע הקריטי, שהוא פעולת הגידול של `shared_counter`. יש לאתחל את המוטקס לפני יצירת החוטים ולשחרר אותו לאחר סיום עבודתם.\n\n**הקוד המתוקן:**\n```c\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h> // For exit\n\nint shared_counter = 0;\npthread_mutex_t counter_mutex; // הצהרה על המוטקס\n\nvoid* thread_func(void* arg) {\n    int i;\n    for (i = 0; i < 100000; i++) {\n        pthread_mutex_lock(&counter_mutex);   // נעילת המוטקס לפני כניסה לקטע הקריטי\n        shared_counter++;                     // הקטע הקריטי\n        pthread_mutex_unlock(&counter_mutex); // שחרור המוטקס לאחר היציאה מהקטע הקריטי\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    int i;\n\n    pthread_mutex_init(&counter_mutex, NULL); // אתחול המוטקס\n\n    for (i = 0; i < 5; i++) {\n        pthread_create(&threads[i], NULL, thread_func, NULL);\n    }\n\n    for (i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", shared_counter); // הפלט הצפוי כעת הוא 500000\n\n    pthread_mutex_destroy(&counter_mutex); // שחרור המוטקס\n\n    return 0;\n}\n```\n\n**הסבר:**\nהשימוש ב-`pthread_mutex_lock` וב-`pthread_mutex_unlock` מבטיח שרק חוט אחד יכול להיכנס לקטע הקריטי (שבו `shared_counter` מוגדל) בכל רגע נתון. כאשר חוט אחד נכנס לקטע הקריטי ונועל את המוטקס, כל חוט אחר שינסה להיכנס יחסם (ימתין) עד שהחוט הראשון ישחרר את המוטקס. זה מונע את תנאי המירוץ ומבטיח שפעולת הגידול של המונה תתבצע באופן אטומי מבחינה לוגית, מה שמוביל לערך סופי נכון של `shared_counter`."
    },
    "difficulty_estimation": "Medium"
  }
}