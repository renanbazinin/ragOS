{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling and Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 11:48:27",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2319,
      "output_tokens": 2158,
      "total_tokens": 7668
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "CPU Scheduling",
      "Context Switching",
      "Round Robin"
    ],
    "content": {
      "text": "מערכת הפעלה משתמשת באלגוריתם תזמון Round Robin. נתון תהליך המבצע מספר רב של משימות קצרות ועתירות CPU.\n\n7.1. הסבירו מהי החלפת הקשר (Context Switch) ומהם המרכיבים העיקריים של עלותה.\n\n7.2. כיצד גודל הקוונטום (quantum) באלגוריתם Round Robin משפיע על מספר החלפות ההקשר ועל ביצועי המערכת הכוללים, במיוחד עבור תהליכים המאופיינים בפרצי CPU קצרים מרובים?\n\n7.3. נתון קטע הקוד הבא של תהליך יחיד שרץ במערכת. הניחו שאין תהליכים נוספים מתחרים על ה-CPU, ושהתהליך לא מבצע קריאות מערכת חוסמות (blocking system calls) בתוך הלולאה:\n",
      "code_snippet": "#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    long long sum = 0;\n    for (int i = 0; i < 100000000; i++) { /* Loop performing a CPU-bound task */\n        sum += i;\n    }\n    printf(\"Process %d finished. Sum: %lld\\n\", getpid(), sum);\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "7.3.1",
        "text": "כיצד ישפיע גודל קוונטום קטן (למשל, 1ms) לעומת גודל קוונטום גדול (למשל, 100ms) על זמן הריצה הכולל של התהליך במקרה זה, בהתחשב בעלות החלפת ההקשר? נמקו את תשובתכם.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "7.1. החלפת הקשר היא תהליך שבו מערכת ההפעלה שומרת את מצבו (הקשרו) של תהליך אחד (או חוט) וטוענת את מצבו של תהליך אחר, כדי לאפשר ל-CPU להמשיך את ביצועו של התהליך השני. מצב התהליך כולל את ערכי האוגרים של ה-CPU (מונה התוכניות, מצביע המחסנית, אוגרי נתונים), מצב הזיכרון (טבלאות דפים), ומידע אחר הקשור למערכת ההפעלה (כמו טבלת קבצים פתוחים). המרכיבים העיקריים של עלותה כוללים:\n1. שמירה וטעינה של אוגרי ה-CPU.\n2. שמירה וטעינה של מידע ספציפי למערכת ההפעלה (כגון נתוני לוח זמנים, מידע I/O).\n3. עלויות הקשורות לזיכרון: ביטול מטמון ה-TLB (Translation Lookaside Buffer) וריקון מטמוני המעבד (CPU caches), מכיוון שהתהליך החדש משתמש במרחב כתובות שונה ובנתונים שונים.\n4. זמן שהייה במצב ליבה (kernel mode) לביצוע ההחלפה עצמה.\n\n7.2. גודל הקוונטום ב-Round Robin הוא משך הזמן המקסימלי שתהליך יכול לרוץ לפני שהוא נקטע (preempted) כדי לאפשר לתהליך אחר לרוץ. השפעתו על מספר החלפות ההקשר וביצועים היא:\n\n**קוונטום קטן:**\n   - **מספר החלפות הקשר גבוה:** תהליכים נקטעים לעיתים קרובות יותר, מה שמוביל למספר רב של החלפות הקשר. זה נכון במיוחד עבור תהליכים עם פרצי CPU קצרים, שעלולים להיקטע לפני שהם מסיימים את פרץ ה-CPU שלהם.\n   - **ביצועים:** עלות החלפות ההקשר מצטברת ועלולה להפוך לגורם משמעותי בזמן הריצה הכולל. זמן רב יותר מבוזבז על ניהול המערכת במקום על עבודה שימושית. זה יכול להוביל לניצול CPU נמוך יותר ולזמני תגובה גבוהים יותר בממוצע, למרות שזה עשוי להיראות כמעניק 'הוגנות' רבה יותר.\n\n**קוונטום גדול:**\n   - **מספר החלפות הקשר נמוך:** תהליכים נוטים לרוץ זמן רב יותר, לעיתים קרובות משלימים את פרץ ה-CPU שלהם לפני שהקוונטום נגמר. מספר החלפות ההקשר פוחת.\n   - **ביצועים:** עלות החלפות ההקשר פחות משמעותית. ניצול ה-CPU גבוה יותר. עם זאת, קוונטום גדול מדי עלול לגרום לזמני תגובה גרועים עבור תהליכים אינטראקטיביים, מכיוון שתהליך אחד יכול להחזיק את ה-CPU לזמן רב לפני שתהליכים אחרים מקבלים הזדמנות לרוץ. במקרה קיצון, קוונטום אינסופי הופך את RR ל-FCFS.\n\nעבור תהליכים עם פרצי CPU קצרים מרובים, קוונטום קטן יגרום להחלפות הקשר רבות ומיותרות, שיפגעו בביצועים. קוונטום בינוני-גדול יותר יאפשר לתהליכים אלו לסיים את פרציהם ללא הפרעה תכופה, ובכך יפחית את עלויות החלפת ההקשר וישפר את זמן הריצה הכולל.\n\n7.3.1. קטע הקוד מבצע לולאה עתירת CPU. בהיעדר תהליכים מתחרים וקריאות מערכת חוסמות, התהליך ירצה לרוץ ברציפות עד שיסיים את הלולאה.\n\n**קוונטום קטן (לדוגמה, 1ms):**\n   - התהליך ייקטע על ידי המתזמן פעמים רבות מאוד במהלך הלולאה. כל קטיעה תגרור כניסה למצב ליבה (kernel mode) כדי לטפל בטיימר אירוע (timer interrupt) ולבחור את התהליך הבא לריצה. אם אין תהליכים אחרים מוכנים, המתזמן יחליט להריץ את אותו תהליך שוב. פעולה זו, למרות שהיא לא מחליפה תהליך בפועל, עדיין נושאת את רוב עלויות החלפת ההקשר (שמירה/טעינה של אוגרים, ניקוי מטמונים וכד') או לפחות את עלות הכניסה והיציאה ממצב ליבה. מספר הקטיעות יהיה שווה בערך לזמן הריצה הכולל של הלולאה חלקי גודל הקוונטום. כל קטיעה כזו מוסיפה זמן תקורה (overhead) משמעותי.\n   - **השפעה:** זמן הריצה הכולל של התהליך יהיה ארוך יותר באופן ניכר עקב צבירת עלויות החלפת ההקשר הרבות.\n\n**קוונטום גדול (לדוגמה, 100ms):**\n   - סביר להניח שהתהליך יסיים את כל הלולאה בתוך קוונטום יחיד (בהנחה שזמן הריצה הכולל של הלולאה קצר מ-100ms, או קרוב אליו), או ייקטע מספר קטן מאוד של פעמים אם הלולאה ארוכה יותר. במקרה זה, עלות החלפת ההקשר תהיה אפסית או נמוכה מאוד, מכיוון שהתהליך פשוט ירוץ עד לסיום.\n   - **השפעה:** זמן הריצה הכולל של התהליך יהיה קרוב מאוד לזמן הנדרש לביצוע החישובים נטו, ללא תוספת משמעותית של זמן תקורה מהחלפות הקשר.\n\n**לסיכום:** במקרה זה, קוונטום גדול יותר יוביל לזמן ריצה כולל מהיר יותר עבור התהליך, מכיוון שהוא יצמצם משמעותית את עלויות התקורה של החלפות ההקשר המיותרות."
    },
    "difficulty_estimation": "Medium"
  }
}