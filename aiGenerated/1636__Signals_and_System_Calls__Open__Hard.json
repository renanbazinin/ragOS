{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:56:50",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 3796,
      "total_tokens": 14560
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "Inter-Process Communication",
      "Pipes",
      "Process Management"
    ],
    "content": {
      "text": "התבוננו בתוכנית ה-C הבאה המדגימה תקשורת בין תהליכים (IPC) באמצעות צינורות (pipes) וטיפול באותות (signals). התוכנית יוצרת תהליך בן, האב כותב הודעה לצינור, והבן מנסה לקרוא ממנו. תוך כדי, האב שולח אות `SIGUSR1` לבן. קטע הקוד של ה-`sigaction` עבור `SIGUSR1` אינו כולל את הדגל `SA_RESTART`.\n\nנתחו את התוכנית וענו על השאלות הבאות:\n\n1.  **פלט התוכנית:** מה יהיה הפלט המדויק של התוכנית כפי שהיא נתונה? הסבירו את תשובתכם בפירוט, כולל סדר האירועים הצפוי, כיצד האות `SIGUSR1` משפיע על קריאת המערכת `read()` בתהליך הבן, וכיצד מטופלת שגיאת `EINTR` (אם היא מתרחשת).\n\n2.  **שינוי עם `SA_RESTART`:** כיצד ישתנה הפלט אם הדגל `SA_RESTART` יתווסף למבנה `sigaction` עבור `SIGUSR1` בתהליך הבן (כלומר, השורה `sa.sa_flags = SA_RESTART;` תהיה פעילה)? הסבירו מדוע השינוי הזה מתרחש ומה משמעותו.\n\n3.  **קריאה חסינה מפני הפרעות:** שנו את לוגיקת ה-`read()` בתהליך הבן כך שתטפל באופן חזק בשגיאות `EINTR` ותבטיח שכל ההודעה תיקרא במלואה, גם אם היא מופרעת על ידי מספר אותות. ספקו את קטע הקוד המתוקן עבור לולאת הקריאה בתהליך הבן.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n\nvolatile sig_atomic_t sigusr1_received = 0;\n\nvoid sigusr1_handler(int signum) {\n    if (signum == SIGUSR1) {\n        sigusr1_received = 1;\n        printf(\"CHILD: SIGUSR1 handler called.\\n\");\n    }\n}\n\nint main() {\n    int pipefd[2];\n    pid_t pid;\n    char buffer[256];\n    const char *message = \"Hello from parent!\";\n\n    // Setup signal handler for SIGUSR1\n    struct sigaction sa;\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigusr1_handler;\n    // sa.sa_flags = SA_RESTART; // This line is commented out initially\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGUSR1, &sa, NULL) == -1) {\n        perror(\"sigaction\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Close unused write end\n\n        printf(\"CHILD: Started, PID %d.\\n\", getpid());\n\n        // Attempt to read from pipe\n        ssize_t bytes_read;\n        printf(\"CHILD: Attempting to read from pipe...\\n\");\n        bytes_read = read(pipefd[0], buffer, sizeof(buffer) - 1);\n\n        if (bytes_read == -1) {\n            if (errno == EINTR) {\n                printf(\"CHILD: Read interrupted by signal (errno = EINTR).\\n\");\n            } else {\n                perror(\"CHILD: read error\");\n            }\n        } else if (bytes_read == 0) {\n            printf(\"CHILD: Read returned 0 bytes (EOF).\\n\");\n        } else {\n            buffer[bytes_read] = '\\0';\n            printf(\"CHILD: Read %zd bytes: \\\"%s\\\"\\n\", bytes_read, buffer);\n        }\n\n        if (sigusr1_received) {\n            printf(\"CHILD: Global flag indicates SIGUSR1 was received.\\n\");\n        }\n        \n        close(pipefd[0]);\n        printf(\"CHILD: Exiting.\\n\");\n        exit(EXIT_SUCCESS);\n\n    } else { // Parent process\n        close(pipefd[0]); // Close unused read end\n\n        printf(\"PARENT: Started, PID %d, child PID %d.\\n\", getpid(), pid);\n\n        // Parent writes to pipe\n        printf(\"PARENT: Writing message to pipe...\\n\");\n        write(pipefd[1], message, strlen(message));\n        printf(\"PARENT: Message written.\\n\");\n        \n        // Wait a bit to ensure child is likely blocked on read\n        sleep(1); \n\n        // Parent sends SIGUSR1 to child\n        printf(\"PARENT: Sending SIGUSR1 to child %d.\\n\", pid);\n        if (kill(pid, SIGUSR1) == -1) {\n            perror(\"kill\");\n        }\n        printf(\"PARENT: SIGUSR1 sent.\\n\");\n\n        // Wait for child to finish\n        wait(NULL);\n        printf(\"PARENT: Child finished.\\n\");\n        close(pipefd[1]);\n        printf(\"PARENT: Exiting.\\n\");\n    }\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### פתרון מפורט:\n\n1.  **פלט התוכנית (ללא `SA_RESTART`):**\n    הפלט יהיה בערך כזה (סדר הודעות ה-`printf` בין תהליכים עשוי להשתנות מעט, אך סדר האירועים בתוך כל תהליך הוא קבוע):\n    ```\n    PARENT: Started, PID <parent_pid>, child PID <child_pid>.\n    CHILD: Started, PID <child_pid>.\n    CHILD: Attempting to read from pipe...\n    PARENT: Writing message to pipe...\n    PARENT: Message written.\n    PARENT: Sending SIGUSR1 to child <child_pid>.\n    CHILD: SIGUSR1 handler called.\n    PARENT: SIGUSR1 sent.\n    CHILD: Read interrupted by signal (errno = EINTR).\n    CHILD: Global flag indicates SIGUSR1 was received.\n    CHILD: Exiting.\n    PARENT: Child finished.\n    PARENT: Exiting.\n    ```\n    **הסבר:**\n    *   התהליך האב יוצר את הבן וממשיך לכתוב לצינור. הבן מתחיל לקרוא מהצינור. מכיוון שהאב כתב את ההודעה, הבן יתחיל לקרוא אותה. אך מכיוון שהאב שולח אות `SIGUSR1` לאחר שההודעה נכתבת ולפני שהבן מספיק לסיים את הקריאה (ה-`sleep(1)` בתהליך האב נועד לוודא שהבן נמצא ב-`read()` כשנשלח האות), קריאת המערכת `read()` של הבן תופרע על ידי האות.\n    *   כאשר `SIGUSR1` נשלח, הקרנל מפסיק את קריאת המערכת `read()` של הבן ומריץ את ה-`sigusr1_handler`. ה-handler מדפיס הודעה ומגדיר את הדגל `sigusr1_received` ל-1.\n    *   לאחר שה-handler מסיים, הקרנל מחזיר את הבקרה לנקודה שבה נקרא ה-`read()` המקורי. מכיוון שהדגל `SA_RESTART` **אינו** מוגדר, קריאות מערכת איטיות (כמו `read()` מצינור) **אינן** מופעלות מחדש אוטומטית. במקום זאת, `read()` מחזיר `-1` ומגדיר את `errno` ל-`EINTR` (Interrupted system call).\n    *   הבן מזהה את `EINTR`, מדפיס הודעה מתאימה, ובודק את הדגל הגלובלי שהוגדר על ידי ה-handler. לאחר מכן, הוא סוגר את קצה הקריאה של הצינור ויוצא.\n    *   האב ממתין שהבן יסיים, סוגר את קצה הכתיבה של הצינור ויוצא.\n\n2.  **שינוי עם `SA_RESTART`:**\n    אם הדגל `sa.sa_flags = SA_RESTART;` יופעל, הפלט ישתנה כך:\n    ```\n    PARENT: Started, PID <parent_pid>, child PID <child_pid>.\n    CHILD: Started, PID <child_pid>.\n    CHILD: Attempting to read from pipe...\n    PARENT: Writing message to pipe...\n    PARENT: Message written.\n    PARENT: Sending SIGUSR1 to child <child_pid>.\n    CHILD: SIGUSR1 handler called.\n    PARENT: SIGUSR1 sent.\n    CHILD: Read 18 bytes: \"Hello from parent!\"\n    CHILD: Global flag indicates SIGUSR1 was received.\n    CHILD: Exiting.\n    PARENT: Child finished.\n    PARENT: Exiting.\n    ```\n    **הסבר:**\n    *   כאשר `SA_RESTART` מוגדר עבור אות, מערכת ההפעלה מנסה להפעיל מחדש באופן אוטומטי קריאות מערכת איטיות שהופרעו על ידי אותו אות, לאחר שה-handler סיים את ריצתו. במקרה זה, קריאת ה-`read()` בתהליך הבן תופרע על ידי `SIGUSR1`, ה-handler ירוץ, ולאחר מכן הקרנל יפעיל מחדש את `read()` אוטומטית.\n    *   ה-`read()` ימשיך מנקודת ההפרעה (או יתחיל מחדש אם לא נקראו בתים כלל) ויצליח לקרוא את ההודעה במלואה מהצינור (מכיוון שההודעה כבר נכתבה לצינור על ידי האב לפני שליחת האות).\n    *   לכן, הבן ידפיס את ההודעה שנקראה בהצלחה, בנוסף להודעה מה-handler והודעת הדגל הגלובלי.\n\n3.  **קריאה חסינה מפני הפרעות (קוד מתוקן):**\n    כדי לטפל באופן חזק ב-`EINTR` ולוודא שכל ההודעה נקראת, יש להשתמש בלולאה שחוזרת על קריאת ה-`read()` כל עוד היא מופרעת וכל עוד יש עוד בתים לקרוא. הנה קטע הקוד המתוקן:\n\n    ```c\n    // Child process - modified read logic\n    close(pipefd[1]); // Close unused write end\n\n    printf(\"CHILD: Started, PID %d.\\n\", getpid());\n\n    // Attempt to read from pipe robustly\n    ssize_t total_bytes_read = 0;\n    ssize_t current_bytes_read;\n    char *buf_ptr = buffer;\n    size_t bytes_to_read = sizeof(buffer) - 1;\n\n    printf(\"CHILD: Attempting to read from pipe (robustly)...\\n\");\n    while (total_bytes_read < bytes_to_read) {\n        current_bytes_read = read(pipefd[0], buf_ptr, bytes_to_read - total_bytes_read);\n\n        if (current_bytes_read == -1) {\n            if (errno == EINTR) {\n                printf(\"CHILD: Read interrupted by signal (errno = EINTR), retrying.\\n\");\n                // Signal handler already ran, just retry the read\n                continue; // Continue loop to retry read\n            } else {\n                perror(\"CHILD: read error\");\n                exit(EXIT_FAILURE);\n            }\n        } else if (current_bytes_read == 0) {\n            // EOF reached, no more data to read\n            printf(\"CHILD: Read returned 0 bytes (EOF), no more data.\\n\");\n            break;\n        } else {\n            // Successfully read some bytes\n            total_bytes_read += current_bytes_read;\n            buf_ptr += current_bytes_read;\n            // printf(\"CHILD: Read %zd bytes, total %zd.\\n\", current_bytes_read, total_bytes_read); // Optional for debugging\n        }\n    }\n\n    if (total_bytes_read > 0) {\n        buffer[total_bytes_read] = '\\0';\n        printf(\"CHILD: Successfully read %zd bytes: \\\"%s\\\"\\n\", total_bytes_read, buffer);\n    } else {\n        printf(\"CHILD: No bytes were read or an error occurred after retries.\\n\");\n    }\n\n    if (sigusr1_received) {\n        printf(\"CHILD: Global flag indicates SIGUSR1 was received.\\n\");\n    }\n    \n    close(pipefd[0]);\n    printf(\"CHILD: Exiting.\\n\");\n    exit(EXIT_SUCCESS);\n    ```\n    **הסבר לתיקון:**\n    *   הקוד משתמש בלולאת `while` כדי להבטיח שקריאת ה-`read()` תמשיך עד שכל הבתים הרצויים נקראו או שהגיע סוף קובץ (EOF).\n    *   `total_bytes_read` עוקב אחר סך הבתים שנקראו בהצלחה עד כה.\n    *   `buf_ptr` ו-`bytes_to_read - total_bytes_read` מותאמים בכל איטרציה של הלולאה כדי להצביע על המיקום הבא ב-`buffer` ולציין כמה בתים נותרו לקרוא.\n    *   אם `read()` מחזיר `-1` ו-`errno` הוא `EINTR`, הלולאה ממשיכה (באמצעות `continue`) ומנסה לקרוא שוב, ללא יציאה מהלולאה או מהתהליך. זה מאפשר לטיפול באות להתרחש, ולאחר מכן לחדש את הקריאה.\n    *   אם מתרחשת שגיאת `read()` אחרת (שאינה `EINTR`), התוכנית מדפיסה שגיאה ויוצאת.\n    *   אם `read()` מחזיר `0`, זה מצביע על EOF, והלולאה נשברת.\n    *   בסיום, אם נקראו בתים, התוצאה מודפסת."
    },
    "difficulty_estimation": "Hard"
  }
}