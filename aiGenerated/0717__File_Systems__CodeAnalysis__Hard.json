{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 23:51:25",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3062,
      "output_tokens": 3717,
      "total_tokens": 12913
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "File Systems",
      "Links",
      "Inodes",
      "Processes",
      "System Calls"
    ],
    "content": {
      "text": "נתונה תוכנית C המבצעת סדרת פעולות על קבצים וקישורים (links) במערכת הקבצים, תוך שימוש בתהליכי אב ובן. מטרת השאלה היא לנתח את מצב מערכת הקבצים והפלט של התוכנית לאחר ביצוע כל הפעולות.\n\nיש להניח כי כל קריאות המערכת מצליחות, וכי התוכנית רצה בסביבה נקייה בה הקבצים `fileA.txt`, `linkH.txt`, ו-`linkS.txt` אינם קיימים לפני הרצת התוכנית.\n\nנתחו את הקוד וציינו במדויק מה יהיה הפלט המודפס למסך, ומה יהיה מצב מערכת הקבצים הסופי עבור כל אחד מהנתיבים `fileA.txt`, `linkH.txt`, ו-`linkS.txt` (האם קיים, אם כן, מה מספר ה-inode שלו, כמה קישורים קשיחים מצביעים אליו, ואם הוא קישור סימבולי, למי הוא מצביע. כמו כן, מה תהיה תכולת הקובץ המקורי אם ניתן יהיה לגשת אליו דרך קישור כלשהו).",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n\n// פונקציית עזר להדפסת מידע על קובץ/קישור\nvoid print_file_info(const char* path, const char* label) {\n    struct stat st;\n    printf(\"--- %s (%s) ---\\n\", label, path);\n    if (lstat(path, &st) == -1) { // שימוש ב-lstat כדי להבחין בין קישור סימבולי למטרה שלו\n        if (errno == ENOENT) {\n            printf(\"File/Link '%s' does not exist.\\n\", path);\n        } else {\n            perror(\"lstat error\");\n        }\n        return;\n    }\n    printf(\"Inode: %ld\\n\", (long)st.st_ino);\n    printf(\"Links: %ld\\n\", (long)st.st_nlink);\n    if (S_ISLNK(st.st_mode)) {\n        char buf[256];\n        ssize_t len = readlink(path, buf, sizeof(buf) - 1);\n        if (len != -1) {\n            buf[len] = '\\0';\n            printf(\"Symlink points to: %s\\n\", buf);\n        } else {\n            perror(\"readlink error\");\n        }\n    }\n    // מדפיס תוכן אם זה קובץ רגיל או קישור סימבולי תקין לקובץ רגיל\n    // stat(path, &st) עוקב אחר קישורים סימבוליים. אם הוא נכשל, זה אומר שהיעד לא קיים.\n    if (S_ISREG(st.st_mode) || (S_ISLNK(st.st_mode) && stat(path, &st) != -1 && S_ISREG(st.st_mode))) {\n        FILE* f = fopen(path, \"r\");\n        if (f) {\n            printf(\"Content: \\\"\");\n            int c;\n            while ((c = fgetc(f)) != EOF) {\n                putchar(c);\n            }\n            printf(\"\\\"\\n\");\n            fclose(f);\n        } else {\n            perror(\"fopen for content read error\");\n        }\n    }\n}\n\nint main() {\n    const char* fileA = \"fileA.txt\";\n    const char* linkH = \"linkH.txt\";\n    const char* linkS = \"linkS.txt\";\n\n    // ניקוי ריצות קודמות\n    unlink(fileA);\n    unlink(linkH);\n    unlink(linkS);\n\n    // 1. יצירת fileA.txt וכתיבת \"Hello\" אליו\n    FILE* f_a = fopen(fileA, \"w\");\n    if (!f_a) { perror(\"fopen fileA\"); return 1; }\n    fprintf(f_a, \"Hello\");\n    fclose(f_a);\n\n    printf(\"Initial state:\\n\");\n    print_file_info(fileA, \"fileA\");\n\n    // 2. יצירת קישור קשיח linkH.txt ל-fileA.txt\n    if (link(fileA, linkH) == -1) { perror(\"link hard\"); return 1; }\n\n    // 3. יצירת קישור סימבולי linkS.txt המצביע על fileA.txt\n    if (symlink(fileA, linkS) == -1) { perror(\"symlink soft\"); return 1; }\n\n    printf(\"\\nAfter creating links:\\n\");\n    print_file_info(fileA, \"fileA\");\n    print_file_info(linkH, \"linkH\");\n    print_file_info(linkS, \"linkS\");\n\n    pid_t pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork error\");\n        return 1;\n    } else if (pid == 0) { // תהליך הבן\n        printf(\"\\n--- Child Process (%d) ---\\n\", getpid());\n        // פתיחת fileA.txt לכתיבה, כתיבת \" child\"\n        f_a = fopen(fileA, \"a\"); // הוספה לתוכן קיים\n        if (!f_a) { perror(\"child fopen fileA\"); exit(1); }\n        fprintf(f_a, \" child\");\n        fclose(f_a);\n        printf(\"Child wrote to %s.\\n\", fileA);\n\n        // מחיקת linkH.txt\n        if (unlink(linkH) == -1) { perror(\"child unlink linkH\"); exit(1); }\n        printf(\"Child unlinked %s.\\n\", linkH);\n\n        exit(0);\n    } else { // תהליך האב\n        printf(\"\\n--- Parent Process (%d) ---\\n\", getpid());\n        int status;\n        wait(&status); // המתנה שהבן יסיים\n        printf(\"Parent finished waiting for child.\\n\");\n\n        // פתיחת linkS.txt לכתיבה, כתיבת \" parent\"\n        f_a = fopen(linkS, \"a\"); // הוספה לתוכן קיים, עוקב אחר הקישור הסימבולי\n        if (!f_a) { perror(\"parent fopen linkS\"); return 1; }\n        fprintf(f_a, \" parent\");\n        fclose(f_a);\n        printf(\"Parent wrote to %s (via symlink).\\n\", linkS);\n\n        // מחיקת fileA.txt\n        if (unlink(fileA) == -1) { perror(\"parent unlink fileA\"); return 1; }\n        printf(\"Parent unlinked %s.\\n\", fileA);\n\n        printf(\"\\nFinal state (from parent):\\n\");\n        print_file_info(fileA, \"fileA (after unlink)\");\n        print_file_info(linkH, \"linkH (after child unlink)\");\n        print_file_info(linkS, \"linkS\");\n    }\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "התוכנית מבצעת את הפעולות הבאות:\n\n1.  **אתחול:**\n    *   התוכנית מוחקת קבצים קודמים בשמות `fileA.txt`, `linkH.txt`, `linkS.txt` אם קיימים.\n    *   יוצרת את `fileA.txt` וכותבת לתוכו \"Hello\".\n    *   **מצב ראשוני (לפני יצירת קישורים):**\n        *   `fileA.txt`: קיים. Inode: X (מספר כלשהו), קישורים קשיחים: 1, תוכן: \"Hello\".\n\n2.  **יצירת קישורים:**\n    *   `link(\"fileA.txt\", \"linkH.txt\")`: יוצר קישור קשיח (`linkH.txt`) ל-`fileA.txt`. כעת שני השמות מצביעים לאותו Inode X.\n    *   `symlink(\"fileA.txt\", \"linkS.txt\")`: יוצר קישור סימבולי (`linkS.txt`) המצביע על המחרוזת \"fileA.txt\". ל-`linkS.txt` יש Inode משלו (נניח Y), והוא מכיל את הנתיב \"fileA.txt\".\n    *   **מצב לאחר יצירת קישורים:**\n        *   `fileA.txt`: קיים. Inode: X, קישורים קשיחים: 2, תוכן: \"Hello\".\n        *   `linkH.txt`: קיים. Inode: X, קישורים קשיחים: 2, תוכן: \"Hello\".\n        *   `linkS.txt`: קיים. Inode: Y, קישורים קשיחים: 1 (עבור הקישור הסימבולי עצמו), מצביע ל-`fileA.txt`. תוכן (דרך המעקב אחר הקישור): \"Hello\".\n\n3.  **פיצול תהליכים (fork):**\n    *   התוכנית מתפצלת לתהליך אב ותהליך בן.\n\n4.  **תהליך הבן:**\n    *   פותח את `fileA.txt` במצב הוספה (`\"a\"`). זה פותח את Inode X.\n    *   כותב \" child\" לתוך הקובץ. תוכן Inode X הופך ל-\"Hello child\".\n    *   סוגר את הקובץ.\n    *   `unlink(\"linkH.txt\")`: מוחק את הערך `linkH.txt` מהתיקייה. מונה הקישורים הקשיחים של Inode X יורד מ-2 ל-1. הקובץ עצמו (ה-Inode) עדיין קיים ונגיש דרך `fileA.txt` (או `linkS.txt`).\n    *   הבן מסיים את פעולתו ויוצא.\n\n5.  **תהליך האב (לאחר שהבן סיים):**\n    *   ממתין שהבן יסיים (`wait`).\n    *   פותח את `linkS.txt` במצב הוספה (`\"a\"`). כיוון ש-`linkS.txt` הוא קישור סימבולי ל-`fileA.txt`, ו-`fileA.txt` עדיין קיים (כי מונה הקישורים של Inode X הוא 1), הקריאה `fopen` עוקבת אחר הקישור ופותחת את Inode X.\n    *   כותב \" parent\" לתוך הקובץ. תוכן Inode X הופך ל-\"Hello child parent\".\n    *   סוגר את הקובץ.\n    *   `unlink(\"fileA.txt\")`: מוחק את הערך `fileA.txt` מהתיקייה. מונה הקישורים הקשיחים של Inode X יורד מ-1 ל-0.\n    *   **מכיוון שמונה הקישורים הקשיחים של Inode X הגיע ל-0, ואין יותר file descriptors פתוחים המצביעים אליו (כי תהליך האב סגר את הקובץ לאחר הכתיבה), הקובץ (ה-Inode והנתונים שלו) נמחק בפועל ממערכת הקבצים.**\n\n**פלט התוכנית (מספרי ה-Inode וה-PID ישתנו בין הרצות):**\n\n```\nInitial state:\n--- fileA (fileA.txt) ---\nInode: <מספר Inode X>\nLinks: 1\nContent: \"Hello\"\n\nAfter creating links:\n--- fileA (fileA.txt) ---\nInode: <מספר Inode X>\nLinks: 2\nContent: \"Hello\"\n--- linkH (linkH.txt) ---\nInode: <מספר Inode X>\nLinks: 2\nContent: \"Hello\"\n--- linkS (linkS.txt) ---\nInode: <מספר Inode Y>\nLinks: 1\nSymlink points to: fileA.txt\nContent: \"Hello\"\n\n--- Child Process (<PID של הבן>) ---\nChild wrote to fileA.txt.\nChild unlinked linkH.txt.\n\n--- Parent Process (<PID של האב>) ---\nParent finished waiting for child.\nParent wrote to linkS (via symlink).\nParent unlinked fileA.txt.\n\nFinal state (from parent):\n--- fileA (fileA.txt (after unlink)) ---\nFile/Link 'fileA.txt' does not exist.\n--- linkH (linkH.txt (after child unlink)) ---\nFile/Link 'linkH.txt' does not exist.\n--- linkS (linkS.txt) ---\nInode: <מספר Inode Y>\nLinks: 1\nSymlink points to: fileA.txt\nfopen for content read error: No such file or directory\n```\n\n**מצב מערכת הקבצים הסופי:**\n\n*   **`fileA.txt`**: אינו קיים במערכת הקבצים. נמחק על ידי תהליך האב (כי מונה הקישורים שלו ירד ל-0).\n*   **`linkH.txt`**: אינו קיים במערכת הקבצים. נמחק על ידי תהליך הבן.\n*   **`linkS.txt`**: קיים במערכת הקבצים. זהו קישור סימבולי.\n    *   Inode: Y (ה-Inode המקורי של הקישור הסימבולי עצמו).\n    *   קישורים קשיחים: 1 (רק הקישור הסימבולי עצמו).\n    *   מצביע ל-\"fileA.txt\".\n    *   **הערה**: כיוון ש-`fileA.txt` נמחק, `linkS.txt` הוא כעת קישור סימבולי \"תלוי\" (dangling symlink) המצביע לנתיב שאינו קיים. ניסיון לגשת לתוכן דרך `linkS.txt` ייכשל (לדוגמה, `cat linkS.txt` יחזיר שגיאה \"No such file or directory\" או דומה)."
    },
    "difficulty_estimation": "Hard"
  }
}