{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:55:16",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 3857,
      "total_tokens": 13835
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "Process Management",
      "Concurrency"
    ],
    "content": {
      "text": "מערכת ההפעלה מאפשרת תקשורת ושליטה בין תהליכים באמצעות אותות (Signals). בשאלה זו, עליכם לממש תרחיש שליטה מורכב בין תהליך אב לתהליך בן תוך שימוש באותות וקריאות מערכת.\n\nתהליך האב יוצר תהליך בן. תפקידו של התהליך הבן הוא לבצע באופן מחזורי \"יחידת עבודה\" כלשהי (לדוגמה, הדפסת הודעה ועיכוב קצר). תהליך האב צריך להיות מסוגל להשהות (Pause) ולחדש (Resume) את עבודת התהליך הבן באמצעות אותות.\n\nדרישות המימוש:\n1.  **התחלה במצב מושהה**: התהליך הבן יתחיל את פעולתו במצב מושהה וימתין לאות התחלה מהאב.\n2.  **אותות שליטה**:\n    *   האב ישלח `SIGUSR1` לבן כדי לחדש את עבודתו.\n    *   האב ישלח `SIGUSR2` לבן כדי להשהות את עבודתו.\n3.  **התנהגות התהליך הבן**:\n    *   כאשר הבן מקבל `SIGUSR2` (או מתחיל במצב מושהה), עליו להפסיק מיד את ביצוע יחידות העבודה, להדפיס הודעה המציינת שהוא מושהה (לדוגמה: \"Child [PID] paused.\"), ולאחר מכן להמתין לאות `SIGUSR1` מהאב.\n    *   כאשר הבן מקבל `SIGUSR1` (בעודו מושהה), עליו להדפיס הודעה המציינת שהוא ממשיך בעבודה (לדוגמה: \"Child [PID] resumed.\") ולחזור לבצע יחידות עבודה.\n    *   הבן צריך לטפל גם באות `SIGTERM` מהאב על ידי הדפסת הודעה מתאימה ויציאה מסודרת.\n4.  **התנהגות התהליך האב**:\n    *   האב צריך לשלוט על הבן למשך מספר מחזורים של השהיה/חידוש (לדוגמה: חדש, המתן מספר שניות, השהה, המתן מספר שניות, חדש, המתן מספר שניות, ואז שלח `SIGTERM` ו המתן לסיום הבן).\n    *   האב צריך להדפיס הודעות מתאימות על הפעולות שהוא מבצע (לדוגמה: \"Parent [PID] sending SIGUSR1 to child [CHILD_PID].\").\n5.  **טיפול באותות**: יש להשתמש ב-`sigaction` לטיפול באותות. יש למנוע תנאי מרוץ אפשריים ולוודא שהבן מגיב בצורה אמינה לאותות, גם אם הם מגיעים במהירות או במצב בלתי צפוי (לדוגמה, אות `SIGUSR1` מגיע בזמן שהבן עדיין לא קורא ל-`sigsuspend`).\n6.  **קוד**: כתבו את הקוד המלא ב-C/C++.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון נועד להתמודד עם אתגרי השליטה באותות בין תהליך אב לבן, תוך התחשבות במצבים שונים ותנאי מרוץ.\n\n**עקרונות מרכזיים:**\n1.  **שימוש ב-`sigaction`**: במקום `signal()`, אנו משתמשים ב-`sigaction()` להגדרת מטפלי האותות. `sigaction` מספקת שליטה טובה יותר, כולל היכולת למנוע הפסקת קריאות מערכת (באמצעות `SA_RESTART`) ולקבוע אילו אותות יהיו חסומים בזמן שהמטפל רץ (במקרה זה, `sa_mask` ריקה, מה שאומר שאף אות נוסף אינו נחסם באופן אוטומטי בתוך המטפל).\n2.  **דגלים אטומיים (Atomic Flags)**: המשתנים הגלובליים `paused_flag` ו-`term_flag` מוגדרים כ-`volatile sig_atomic_t`. `volatile` מבטיח שהמהדר לא יבצע אופטימיזציות שימנעו קריאה/כתיבה לזיכרון בכל פעם (חשוב מכיוון שהם משתנים גם במטפל אותות וגם בלולאה הראשית). `sig_atomic_t` מבטיח שקריאה וכתיבה למשתנים אלו תהיה אטומית, כלומר, לא תיקטע באמצע על ידי אות נוסף. זה קריטי כדי למנוע מצב שבו ערך המשתנה אינו עקבי.\n3.  **התחלה במצב מושהה וטיפול בתנאי מרוץ**:\n    *   הבן מתחיל עם `paused_flag = 1`.\n    *   מיד לאחר יצירת הבן, לפני הגדרת מטפלי האותות ולפני הכניסה ללולאת העבודה הראשית, הבן חוסם את `SIGUSR1` ו-`SIGUSR2` באמצעות `sigprocmask(SIG_BLOCK, ...)`. פעולה זו מבטיחה שאם האב ישלח את `SIGUSR1` או `SIGUSR2` מוקדם מדי (לפני שהבן מוכן לקרוא ל-`sigsuspend`), האותות לא יאבדו אלא יישארו ממתינים (pending).\n    *   כאשר הבן מגיע למצב \"מושהה\" וצריך להמתין ל-`SIGUSR1`, הוא משתמש ב-`sigsuspend()`.\n4.  **שימוש ב-`sigsuspend()` למצב המתנה**:\n    *   `sigsuspend()` היא קריאת מערכת חיונית למצבי המתנה לאותות. היא פועלת בשלושה שלבים אטומיים:\n        1.  היא מחליפה את מסכת האותות הנוכחית של התהליך עם המסכה שניתנה לה כפרמטר (`suspend_mask`).\n        2.  היא משהה את התהליך עד לקבלת אות שאינו חסום במסכה החדשה.\n        3.  כאשר אות כזה מתקבל והמטפל שלו מסתיים, `sigsuspend()` משחזרת את מסכת האותות המקורית שהייתה לתהליך לפני הקריאה אליה, ומחזירה.\n    *   במקרה שלנו, כאשר הבן מושהה, הוא יוצר `suspend_mask` שבה `SIGUSR1` אינו חסום (אך `SIGUSR2` ו-`SIGTERM` נשארים חסומים, או לפי המסכה המקורית). זה מאפשר ל-`SIGUSR1` לעבור ולהפעיל את המטפל שלו, בזמן שהבן ממתין ביעילות מבלי לבזבז משאבים (busy-waiting).\n    *   הלולאה `while (paused_flag && !term_flag) { sigsuspend(&suspend_mask); }` מבטיחה שאם `sigsuspend` תופרע על ידי אות אחר (שאינו `SIGUSR1` או `SIGTERM`) שאינו חסום, התהליך יחזור להמתין אם הוא עדיין במצב מושהה.\n5.  **טיפול ב-`SIGTERM`**: מטפל ה-`SIGTERM` מגדיר את `term_flag` ל-1. הלולאה הראשית בודקת תמיד את `term_flag` כדי לצאת בצורה מסודרת ברגע שהאות התקבל, גם אם הוא התקבל בזמן שהתהליך היה מושהה ב-`sigsuspend` או במהלך ביצוע יחידת עבודה.\n6.  **שליטת האב**:\n    *   האב משתמש ב-`kill(pid, signal)` כדי לשלוח אותות לבן.\n    *   האב משתמש ב-`sleep()` כדי להמתין פרקי זמן מסוימים בין שליחת אות לאות, מה שמאפשר לבן לבצע עבודה או להגיב לאות.\n    *   בסיום, האב שולח `SIGTERM` ולאחר מכן ממתין לסיום הבן באמצעות `waitpid()`, כדי למנוע תהליכי זומבי (zombie processes).\n\nפתרון זה מספק מנגנון אמין ומבוקר לשליטה בתהליכים באמצעות אותות, תוך התחשבות בפרטי המימוש העדינים של טיפול באותות במערכות הפעלה.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n\n// Global flags for signal handlers. volatile sig_atomic_t ensures atomic access\n// and prevents compiler optimizations that might break signal handler logic.\nvolatile sig_atomic_t paused_flag = 1; // Child starts in a paused state\nvolatile sig_atomic_t term_flag = 0;   // Flag to indicate SIGTERM received\n\n// Signal handler for SIGUSR1 (Resume)\nvoid sigusr1_handler(int signum) {\n    printf(\"Child %d: Received SIGUSR1. Resuming...\\n\", getpid());\n    paused_flag = 0;\n}\n\n// Signal handler for SIGUSR2 (Pause)\nvoid sigusr2_handler(int signum) {\n    printf(\"Child %d: Received SIGUSR2. Pausing...\\n\", getpid());\n    paused_flag = 1;\n}\n\n// Signal handler for SIGTERM (Terminate gracefully)\nvoid sigterm_handler(int signum) {\n    printf(\"Child %d: Received SIGTERM. Exiting gracefully...\\n\", getpid());\n    term_flag = 1;\n}\n\n// Function to set up signal handlers using sigaction\nvoid setup_signal_handlers() {\n    struct sigaction sa;\n\n    // Configure SIGUSR1 handler\n    sa.sa_handler = sigusr1_handler;\n    sigemptyset(&sa.sa_mask); // No additional signals blocked while in handler\n    sa.sa_flags = SA_RESTART; // Restart interrupted system calls\n    if (sigaction(SIGUSR1, &sa, NULL) == -1) {\n        perror(\"sigaction SIGUSR1\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Configure SIGUSR2 handler\n    sa.sa_handler = sigusr2_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGUSR2, &sa, NULL) == -1) {\n        perror(\"sigaction SIGUSR2\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Configure SIGTERM handler\n    sa.sa_handler = sigterm_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGTERM, &sa, NULL) == -1) {\n        perror(\"sigaction SIGTERM\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint main() {\n    pid_t pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        printf(\"Child %d: Starting in paused state.\\n\", getpid());\n\n        setup_signal_handlers();\n\n        // Create signal masks for blocking and suspending.\n        // Initially block SIGUSR1 and SIGUSR2 to prevent them from being lost\n        // if sent by the parent before the child enters sigsuspend.\n        sigset_t block_mask, old_mask, suspend_mask;\n        sigemptyset(&block_mask);\n        sigaddset(&block_mask, SIGUSR1);\n        sigaddset(&block_mask, SIGUSR2);\n        // Block SIGUSR1 and SIGUSR2, and save the current mask (old_mask)\n        sigprocmask(SIG_BLOCK, &block_mask, &old_mask);\n\n        while (!term_flag) { // Main loop for child process\n            if (paused_flag) {\n                printf(\"Child %d: Currently paused. Waiting for SIGUSR1...\\n\", getpid());\n                // Prepare suspend_mask: it should unblock SIGUSR1 to allow it to be received,\n                // but keep other signals (like SIGUSR2 or SIGTERM) blocked as per old_mask.\n                suspend_mask = old_mask; // Start with the mask that was active before blocking SIGUSR1/SIGUSR2\n                sigdelset(&suspend_mask, SIGUSR1); // Unblock SIGUSR1 for sigsuspend\n\n                // Use sigsuspend to atomically unblock SIGUSR1 and wait for a signal.\n                // It will re-block SIGUSR1 upon return.\n                while (paused_flag && !term_flag) { \n                    // Loop in case sigsuspend is interrupted by a different, unblocked signal\n                    // (e.g., if we had other unblocked signals), or if SIGUSR1 was already pending.\n                    sigsuspend(&suspend_mask);\n                }\n                // If we exited the loop because term_flag is set, break out of main loop.\n                if (term_flag) break;\n                printf(\"Child %d: Resumed work after SIGUSR1.\\n\", getpid());\n            } else {\n                // Perform work unit\n                printf(\"Child %d: Working...\\n\", getpid());\n                sleep(1); // Simulate work being done\n            }\n        }\n\n        printf(\"Child %d: Exiting.\\n\", getpid());\n        // Restore original signal mask before exiting\n        sigprocmask(SIG_SETMASK, &old_mask, NULL);\n        exit(EXIT_SUCCESS);\n\n    } else { // Parent process\n        printf(\"Parent %d: Child PID is %d.\\n\", getpid(), pid);\n        sleep(1); // Give child time to set up handlers and enter paused state\n\n        printf(\"Parent %d: Sending SIGUSR1 to child %d to resume.\\n\", getpid(), pid);\n        kill(pid, SIGUSR1);\n        sleep(3); // Let child work for a while\n\n        printf(\"Parent %d: Sending SIGUSR2 to child %d to pause.\\n\", getpid(), pid);\n        kill(pid, SIGUSR2);\n        sleep(3); // Let child stay paused for a while\n\n        printf(\"Parent %d: Sending SIGUSR1 to child %d to resume.\\n\", getpid(), pid);\n        kill(pid, SIGUSR1);\n        sleep(3); // Let child work again\n\n        printf(\"Parent %d: Sending SIGTERM to child %d to terminate.\\n\", getpid(), pid);\n        kill(pid, SIGTERM);\n\n        int status;\n        // Wait for the child process to terminate\n        waitpid(pid, &status, 0);\n        if (WIFEXITED(status)) {\n            printf(\"Parent %d: Child %d exited with status %d.\\n\", getpid(), pid, WEXITSTATUS(status));\n        } else {\n            printf(\"Parent %d: Child %d terminated abnormally.\\n\", getpid(), pid);\n        }\n        exit(EXIT_SUCCESS);\n    }\n\n    return 0; // Should not be reached\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}