{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:11:13",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2789,
      "output_tokens": 6280,
      "total_tokens": 21696
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Memory Management",
      "Virtual Memory",
      "Custom Allocator",
      "Concurrency",
      "Synchronization"
    ],
    "content": {
      "text": "נתבקשתם לתכנן ולממש מנהל זיכרון (Memory Allocator) מותאם אישית עבור יישום הדורש שליטה מדויקת על הקצאת זיכרון, ביצועים גבוהים, ויכולת פעולה בסביבה מרובת חוטים. המנהל אמור לנהל מאגר זיכרון גדול וקבוע בגודלו, שיוקצה פעם אחת בתחילת ריצת התוכנית באמצעות `mmap`.\n\nדרישות המימוש הן כדלקמן:\n1.  **אתחול (Initialization)**: פונקציה `init_allocator()` שתקצה מאגר זיכרון בגודל קבוע (לדוגמה, 1GB) באמצעות `mmap`. קריאה זו תתבצע פעם אחת בלבד.\n2.  **הקצאה (Allocation)**: פונקציה `void *my_malloc(size_t size)` שתקצה בלוק זיכרון בגודל `size` בתים מתוך המאגר המנוהל. הפונקציה צריכה להחזיר מצביע לאזור הנתונים של הבלוק המוקצה. אם אין מספיק זיכרון, הפונקציה תחזיר `NULL`.\n3.  **שחרור (Deallocation)**: פונקציה `void my_free(void *ptr)` שתשחרר בלוק זיכרון שהוקצה בעבר על ידי `my_malloc`. שחרור כפול או שחרור מצביע לא חוקי צריך להיות מטופל באופן בטוח (לדוגמה, על ידי הדפסת שגיאה).\n4.  **איחוד בלוקים (Coalescing)**: כאשר בלוק משוחרר, יש לאחד אותו עם בלוקים חופשיים סמוכים פיזית (אם קיימים) כדי למנוע פיצול חיצוני (External Fragmentation). בלוקים מאוחדים צריכים ליצור בלוק חופשי גדול יותר.\n5.  **בטיחות חוטים (Thread-Safety)**: המנהל חייב להיות בטוח לשימוש בסביבה מרובת חוטים, כלומר, קריאות מקבילות ל-`my_malloc` ו-`my_free` לא יגרמו לשחיתות נתונים או למצבי מרוץ (Race Conditions).\n6.  **יישור (Alignment)**: הזיכרון המוקצה למשתמש צריך להיות מיושר כראוי (לדוגמה, ליישור של `sizeof(long)` או 8 בתים) כדי למנוע שגיאות גישה לזיכרון.\n7.  **יעילות**: יש לשאוף ליעילות סבירה הן מבחינת זמן הריצה של ההקצאה/שחרור והן מבחינת ניצול הזיכרון (overhead מינימלי למטא-דאטה).\n8.  **הגבלות**: אין להשתמש בפונקציות `malloc`, `free`, `calloc`, `realloc` או `sbrk` בתוך המימוש של מנהל הזיכרון. מותר להשתמש ב-`mmap` וב-`pthread_mutex_t` בלבד.\n\nיש להשלים את הקוד המצורף, כולל הגדרות המבנים ומשתנים גלובליים נדרשים.",
      "code_snippet": "#include <stddef.h> // For size_t\n#include <sys/mman.h> // For mmap, munmap\n#include <unistd.h> // For sysconf (page size)\n#include <pthread.h> // For pthread_mutex_t\n#include <stdio.h> // For perror, fprintf\n\n#define HEAP_SIZE (1 * 1024 * 1024 * 1024UL) // 1GB\n\n// Global variables for the allocator state\nstatic void *heap_start = NULL;\n// Add necessary synchronization primitives and free list structures here\n\n// Forward declaration for block_header_t\ntypedef struct block_header block_header_t;\n\nstruct block_header {\n    size_t size; // Size of the block (including header and footer). MSB indicates allocated/free.\n    // Add pointers for free list or status flags\n    struct block_header *next_free; // Used only if block is free.\n    struct block_header *prev_free; // Used only if block is free.\n};\n\n// Mutex for thread safety\nstatic pthread_mutex_t allocator_mutex;\n\n// Pointer to the head of the free list\nstatic block_header_t *free_list_head = NULL;\n\n// Initialization function\nvoid init_allocator() {\n    // 1. Initialize mutex (if not static)\n    // 2. mmap the HEAP_SIZE region\n    // 3. Initialize the first block_header_t to cover the entire heap\n    // 4. Add this block to the free list\n}\n\n// Allocation function\nvoid *my_malloc(size_t size) {\n    // 1. Lock the mutex\n    // 2. Adjust size for alignment, header, and footer\n    // 3. Search free list for a suitable block (e.g., best-fit)\n    // 4. If found:\n    //    a. Remove block from free list\n    //    b. Split block if remaining space is large enough for another block\n    //    c. Mark block as allocated (update header and footer)\n    // 5. Unlock mutex\n    // 6. Return pointer to user data area\n}\n\n// Deallocation function\nvoid my_free(void *ptr) {\n    // 1. Lock the mutex\n    // 2. Get block header from ptr\n    // 3. Basic validation (is it valid, is it allocated?)\n    // 4. Mark block as free (update header and footer)\n    // 5. Coalesce with adjacent free blocks (previous and next in memory) using boundary tags\n    // 6. Insert/update block in free list, maintaining address order\n    // 7. Unlock mutex\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון המוצע מממש מנהל זיכרון מותאם אישית המבוסס על רשימה מקושרת כפולה של בלוקים חופשיים (Free List). הבלוקים ברשימה מסודרים לפי כתובת זיכרון עולה, מה שמקל על איחוד בלוקים סמוכים פיזית. כל בלוק זיכרון, בין אם הוא מוקצה או חופשי, מכיל כותרת (Header) ורגל (Footer) עם מידע על גודלו, מה שמאפשר מעבר קדימה ואחורה בין בלוקים פיזיים במאגר הזיכרון.\n\n**מבנה הבלוק (`block_header_t`)**:\n- `size_t size`: גודל הבלוק הכולל (כולל הכותרת והרגל). הסיבית המשמעותית ביותר (MSB) של השדה משמשת כדגל לציון אם הבלוק מוקצה (1) או חופשי (0).\n- `block_header_t *next_free`, `block_header_t *prev_free`: מצביעים לבלוק החופשי הבא והקודם ברשימת הבלוקים החופשיים, בהתאמה. מצביעים אלו רלוונטיים רק כאשר הבלוק חופשי.\n- בנוסף, כל בלוק מכיל `size_t` בסופו (כ'רגל' או 'Boundary Tag') המכיל את גודל הבלוק. זה מאפשר לבלוקים 'להביט לאחור' ולמצוא את הכותרת של הבלוק הפיזי הקודם.\n\n**פונקציות עזר:**\n- `is_allocated(block_header_t *block)`: בודקת אם הבלוק מוקצה על ידי בדיקת ה-MSB של שדה הגודל.\n- `get_block_total_size(block_header_t *block)`: מחזירה את גודל הבלוק האמיתי (ללא דגל ההקצאה).\n- `mark_allocated(block_header_t *block, size_t size)`: מסמנת בלוק כמוקצה ומעדכנת את הכותרת והרגל.\n- `mark_free(block_header_t *block, size_t size)`: מסמנת בלוק כחופשי ומעדכנת את הכותרת והרגל.\n- `remove_from_free_list(block_header_t *block)`: מסירה בלוק מרשימת הבלוקים החופשיים.\n- `insert_into_free_list(block_header_t *block)`: מכניסה בלוק לרשימת הבלוקים החופשיים, תוך שמירה על סדר כתובות עולה.\n- `calculate_aligned_block_size(size_t user_size)`: מחשבת את הגודל הכולל של הבלוק (כולל כותרת, רגל ויישור) הנדרש עבור `user_size` נתון. היא גם מבטיחה גודל מינימלי לבלוק על מנת שיוכל להכיל את המטא-דאטה הדרושה.\n\n**`init_allocator()`**:\n- משתמשת ב-`mmap` כדי להקצות מאגר זיכרון רציף בגודל `HEAP_SIZE`.\n- מאתחלת בלוק חופשי יחיד בגודל המאגר כולו, ומכניסה אותו לרשימת הבלוקים החופשיים.\n\n**`my_malloc(size_t size)`**:\n- נועלת Mutex כדי להבטיח בטיחות חוטים.\n- מחשבת את הגודל הכולל הנדרש לבלוק (כולל מטא-דאטה ויישור).\n- סורקת את רשימת הבלוקים החופשיים (בסטרטגיית Best-Fit) כדי למצוא את הבלוק החופשי הקטן ביותר שיכול להכיל את הבקשה.\n- אם נמצא בלוק מתאים:\n    - מסירה אותו מרשימת הבלוקים החופשיים.\n    - בודקת אם ניתן לפצל את הבלוק: אם הגודל הנותר לאחר ההקצאה מספיק גדול עבור בלוק חופשי חדש (כולל מטא-דאטה מינימלית), הבלוק מפוצל. החלק המוקצה מסומן כמוקצה, והחלק הנותר מסומן כחופשי ומוכנס חזרה לרשימת הבלוקים החופשיים בסדר כתובות.\n    - אם לא ניתן לפצל, הבלוק כולו מוקצה.\n- מחזירה מצביע לאזור הנתונים של הבלוק המוקצה (לאחר הכותרת), ומשחררת את ה-Mutex.\n- אם לא נמצא בלוק מתאים, מחזירה `NULL`.\n\n**`my_free(void *ptr)`**:\n- נועלת Mutex.\n- ממירה את מצביע המשתמש למצביע לכותרת הבלוק.\n- מבצעת בדיקת תקינות בסיסית (האם המצביע בתוך המאגר והאם הבלוק אכן מוקצה) כדי למנוע שחרור כפול או שחרור מצביע לא חוקי.\n- מסמנת את הבלוק כחופשי ומעדכנת את הכותרת והרגל.\n- **איחוד (Coalescing)**:\n    - בודקת את הבלוק הפיזי הקודם: באמצעות הרגל של הבלוק הנוכחי, ניתן למצוא את גודלו של הבלוק הפיזי הקודם, ולפיכך את כותרתו. אם הבלוק הפיזי הקודם חופשי, הוא מאוחד עם הבלוק הנוכחי. הבלוק הקודם מוסר מרשימת הבלוקים החופשיים, וגודלו מעודכן.\n    - בודקת את הבלוק הפיזי הבא: אם הבלוק הפיזי הבא חופשי, הוא מאוחד לתוך הבלוק המאוחד הקיים. הבלוק הבא מוסר מרשימת הבלוקים החופשיים, וגודלו של הבלוק המאוחד מעודכן.\n- לאחר איחודים אפשריים, הבלוק (המאוחד כעת) מוכנס חזרה לרשימת הבלוקים החופשיים, תוך שמירה על סדר כתובות עולה.\n- משחררת את ה-Mutex.\n\nפתרון זה מציע איזון טוב בין יעילות (Best-Fit, רשימה מקושרת כפולה ממוינת, איחוד) לבין מורכבות, ועומד בכל הדרישות, כולל בטיחות חוטים וטיפול בפיצול זיכרון.\n\n```c\n#include <stddef.h> // For size_t\n#include <sys/mman.h> // For mmap, munmap\n#include <unistd.h> // For sysconf (page size)\n#include <pthread.h> // For pthread_mutex_t\n#include <stdio.h> // For perror, fprintf\n\n#define HEAP_SIZE (1 * 1024 * 1024 * 1024UL) // 1GB\n#define MIN_ALLOC_USER_SIZE 16 // Minimum user data size to ensure block can hold pointers for free list\n#define ALIGNMENT sizeof(long) // General alignment for malloc\n\n// Block header structure (for both free and allocated blocks)\ntypedef struct block_header {\n    size_t size; // Size of the block (including header and footer). MSB indicates allocated/free.\n    struct block_header *next_free; // Used only if block is free. Points to next free block in address order.\n    struct block_header *prev_free; // Used only if block is free. Points to previous free block in address order.\n} block_header_t;\n\n// A block also has a footer, which is just a size_t storing the block's total size (without flag).\n// This allows traversing backwards.\n\nstatic void *heap_start = NULL;\nstatic block_header_t *free_list_head = NULL; // Head of the doubly linked list of FREE blocks, sorted by address.\nstatic pthread_mutex_t allocator_mutex = PTHREAD_MUTEX_INITIALIZER; // Statically initialize mutex\n\n// Helper to get the footer pointer for a given block header\nstatic size_t *get_footer(block_header_t *block) {\n    return (size_t *)((char *)block + (block->size & ~(1UL << (sizeof(size_t)*8 - 1))) - sizeof(size_t));\n}\n\n// Helper to check if a block is allocated (MSB of size is set)\nstatic int is_allocated(block_header_t *block) {\n    return (block->size & (1UL << (sizeof(size_t)*8 - 1))) != 0;\n}\n\n// Helper to get the true size of a block (without allocated flag)\nstatic size_t get_block_total_size(block_header_t *block) {\n    return block->size & ~(1UL << (sizeof(size_t)*8 - 1));\n}\n\n// Helper to mark a block as allocated\nstatic void mark_allocated(block_header_t *block, size_t size) {\n    block->size = size | (1UL << (sizeof(size_t)*8 - 1)); // Set MSB\n    *get_footer(block) = size; // Update footer\n}\n\n// Helper to mark a block as free\nstatic void mark_free(block_header_t *block, size_t size) {\n    block->size = size; // Clear MSB\n    *get_footer(block) = size; // Update footer\n}\n\n// Helper to remove a block from the free list\nstatic void remove_from_free_list(block_header_t *block) {\n    if (block->prev_free) {\n        block->prev_free->next_free = block->next_free;\n    } else {\n        free_list_head = block->next_free;\n    }\n    if (block->next_free) {\n        block->next_free->prev_free = block->prev_free;\n    }\n    block->next_free = NULL; // Clear pointers\n    block->prev_free = NULL;\n}\n\n// Helper to insert a block into the free list (maintaining address order)\nstatic void insert_into_free_list(block_header_t *block) {\n    block_header_t *current = free_list_head;\n    block_header_t *prev = NULL;\n\n    while (current != NULL && current < block) {\n        prev = current;\n        current = current->next_free;\n    }\n\n    if (prev == NULL) { // Insert at head\n        block->next_free = free_list_head;\n        if (free_list_head) free_list_head->prev_free = block;\n        free_list_head = block;\n    } else { // Insert in middle or at end\n        block->next_free = current;\n        block->prev_free = prev;\n        prev->next_free = block;\n        if (current) current->prev_free = block;\n    }\n}\n\n// Helper to get actual aligned size needed for user data + header + footer\nstatic size_t calculate_aligned_block_size(size_t user_size) {\n    // Minimum block size must accommodate header, footer, and MIN_ALLOC_USER_SIZE\n    // This ensures that even small user requests result in a block large enough to be split later\n    size_t min_effective_user_size = (user_size < MIN_ALLOC_USER_SIZE) ? MIN_ALLOC_USER_SIZE : user_size;\n    size_t total_size = sizeof(block_header_t) + min_effective_user_size + sizeof(size_t); // Header + user_data + Footer\n    return (total_size + ALIGNMENT - 1) & ~(ALIGNMENT - 1); // Align total block size\n}\n\n// Function to initialize the allocator\nvoid init_allocator() {\n    if (heap_start != NULL) {\n        return; // Already initialized\n    }\n\n    // Allocate the heap using mmap\n    heap_start = mmap(NULL, HEAP_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (heap_start == MAP_FAILED) {\n        perror(\"mmap failed\");\n        // In a real system, handle this gracefully, perhaps by exiting or throwing an exception.\n        return;\n    }\n\n    // Initialize the first (and only) free block spanning the entire heap\n    block_header_t *initial_block = (block_header_t *)heap_start;\n    mark_free(initial_block, HEAP_SIZE); // Mark free, set size in header and footer\n    initial_block->next_free = NULL;\n    initial_block->prev_free = NULL;\n    free_list_head = initial_block;\n}\n\n// Function to allocate memory\nvoid *my_malloc(size_t size) {\n    if (size == 0) {\n        return NULL;\n    }\n\n    pthread_mutex_lock(&allocator_mutex);\n\n    // Calculate the total block size needed (user_size + header + footer), aligned\n    size_t required_block_total_size = calculate_aligned_block_size(size);\n\n    block_header_t *current = free_list_head;\n    block_header_t *best_fit = NULL; // Best-fit strategy\n\n    // Search for the best-fit free block\n    while (current != NULL) {\n        if (get_block_total_size(current) >= required_block_total_size) {\n            if (best_fit == NULL || get_block_total_size(current) < get_block_total_size(best_fit)) {\n                best_fit = current;\n            }\n        }\n        current = current->next_free;\n    }\n\n    if (best_fit == NULL) {\n        // No suitable block found\n        pthread_mutex_unlock(&allocator_mutex);\n        return NULL;\n    }\n\n    block_header_t *block_to_allocate = best_fit;\n    size_t original_block_total_size = get_block_total_size(block_to_allocate);\n\n    // Remove block_to_allocate from the free list\n    remove_from_free_list(block_to_allocate);\n\n    // Check if the remaining part after allocation is large enough to form a new free block\n    if (original_block_total_size - required_block_total_size >= calculate_aligned_block_size(1)) { // Check against minimal block size\n        // Split the block\n        mark_allocated(block_to_allocate, required_block_total_size); // Mark the allocated part\n\n        block_header_t *new_free_block = (block_header_t *)((char *)block_to_allocate + required_block_total_size);\n        mark_free(new_free_block, original_block_total_size - required_block_total_size); // Mark the new free part\n\n        // Insert the new free block back into the free list, maintaining address order\n        insert_into_free_list(new_free_block);\n    } else {\n        // Not enough space to split, allocate the entire block\n        mark_allocated(block_to_allocate, original_block_total_size);\n    }\n\n    pthread_mutex_unlock(&allocator_mutex);\n    return (void *)((char *)block_to_allocate + sizeof(block_header_t)); // Return pointer to user data area\n}\n\n// Function to free memory\nvoid my_free(void *ptr) {\n    if (ptr == NULL) {\n        return;\n    }\n\n    pthread_mutex_lock(&allocator_mutex);\n\n    // Get the block header from the user pointer\n    block_header_t *block_to_free = (block_header_t *)((char *)ptr - sizeof(block_header_t));\n\n    // Basic validation: ensure it's within our heap and marked as allocated\n    if ((void*)block_to_free < heap_start || (void*)block_to_free >= (char*)heap_start + HEAP_SIZE || !is_allocated(block_to_free)) {\n        fprintf(stderr, \"Error: Attempt to free an invalid or unallocated block at %p.\\n\", ptr);\n        pthread_mutex_unlock(&allocator_mutex);\n        return;\n    }\n\n    // Mark the current block as free\n    size_t current_block_total_size = get_block_total_size(block_to_free);\n    mark_free(block_to_free, current_block_total_size);\n\n    // Attempt to coalesce with physically adjacent free blocks\n\n    // Check previous physical block using its footer\n    block_header_t *prev_phys_block = NULL;\n    if (block_to_free > (block_header_t *)heap_start) { // If not the very first block in the heap\n        size_t *prev_footer_ptr = (size_t *)((char *)block_to_free - sizeof(size_t));\n        size_t prev_phys_size = *prev_footer_ptr; // Get size of previous block from its footer\n        prev_phys_block = (block_header_t *)((char *)block_to_free - prev_phys_size);\n\n        // Ensure prev_phys_block is valid and free\n        if ((void*)prev_phys_block >= heap_start && !is_allocated(prev_phys_block)) {\n            // Merge current block into prev_phys_block\n            remove_from_free_list(prev_phys_block); // Remove prev_phys_block from free list\n            mark_free(prev_phys_block, get_block_total_size(prev_phys_block) + current_block_total_size);\n            block_to_free = prev_phys_block; // Now block_to_free refers to the merged block\n            current_block_total_size = get_block_total_size(block_to_free); // Update size\n        }\n    }\n\n    // Check next physical block\n    block_header_t *next_phys_block = (block_header_t *)((char *)block_to_free + current_block_total_size);\n    if ((void *)next_phys_block < (char *)heap_start + HEAP_SIZE && !is_allocated(next_phys_block)) {\n        // Ensure next_phys_block is valid and free\n        // Merge next_phys_block into block_to_free\n        remove_from_free_list(next_phys_block); // Remove next_phys_block from free list\n        mark_free(block_to_free, get_block_total_size(block_to_free) + get_block_total_size(next_phys_block));\n    }\n\n    // Insert the (potentially merged) block into the free list\n    insert_into_free_list(block_to_free);\n\n    pthread_mutex_unlock(&allocator_mutex);\n}\n```\n"
    },
    "difficulty_estimation": "Hard"
  }
}