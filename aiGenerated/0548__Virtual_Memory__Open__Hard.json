{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 06:45:21",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3218,
      "output_tokens": 2841,
      "total_tokens": 10140
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Virtual Memory",
      "Paging",
      "Memory Management",
      "TLB",
      "Page Tables",
      "Performance"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המממשת זיכרון וירטואלי באמצעות דפדוף (Paging).\n*   גודל הזיכרון הווירטואלי: 2^48 בתים.\n*   גודל הזיכרון הפיזי: 2^36 בתים.\n*   גודל דף: 8KB.\n*   מנגנון טבלאות הדפים הוא רב-רמתי, כאשר כל כניסה בטבלת דפים (PTE) בגודל 8 בתים.\n*   כל טבלת דפים מאוחסנת בדף אחד בדיוק.\n*   ה-TLB מכיל 1024 כניסות, והוא בעל אסוציאטיביות מלאה (fully associative).\n",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "כמה ביטים נדרשים עבור ה-VPN (Virtual Page Number) וכמה עבור ה-Offset? כמה רמות של טבלאות דפים נדרשות במערכת זו? פרטו את חלוקת הביטים של ה-VPN בין הרמות השונות.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "מהו המספר המקסימלי של גישות לזיכרון הראשי, לדיסק, ול-TLB עבור גישת קריאה אחת לכתובת וירטואלית, במקרה הגרוע ביותר (TLB miss, Page Fault, וצורך ב-Page Replacement)? פרטו את שלבי הפעולה המלאים המובילים למספר זה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "בנוסף לביט ה-Valid, נניח שכל PTE מכיל גם ביט Dirty וביט Accessed (Reference). תהליך מבצע קריאה לכתובת וירטואלית שאינה בזיכרון הפיזי וגורמת ל-Page Fault. המערכת מחליטה לטעון את הדף מהדיסק. לאחר מכן, התהליך מבצע כתיבה לאותה כתובת. הסבירו אילו ביטים (Valid, Dirty, Accessed) ישונו ב-PTE של הדף הרלוונטי, ובאיזה שלב של הפעולה. כמו כן, האם שינויים אלו יגרמו לכתיבה חוזרת של ה-PTE לזיכרון הראשי, ומתי?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1 חישוב מבנה כתובת:\n*   **גודל כתובת וירטואלית**: 2^48 בתים -> 48 ביטים.\n*   **גודל דף**: 8KB = 2^3 * 2^10 = 2^13 בתים.\n*   **Offset**: 13 ביטים (הביטים הפחות משמעותיים של הכתובת הווירטואלית).\n*   **VPN (Virtual Page Number)**: 48 - 13 = 35 ביטים.\n\n*   **מספר כניסות לדף**: גודל דף הוא 8KB. גודל PTE הוא 8 בתים.\n    *   מספר PTEs בדף אחד = 8KB / 8 בתים = 2^13 / 2^3 = 2^10 = 1024 כניסות.\n    *   כלומר, כל רמה בטבלת הדפים יכולה למפות 2^10 דפים, ולכן כל אינדקס לרמה הוא בגודל 10 ביטים.\n\n*   **מספר רמות**: ה-VPN הוא 35 ביטים. כל רמה צורכת 10 ביטים.\n    *   35 / 10 = 3 עם שארית 5. לכן, נצטרך 4 רמות.\n    *   **חלוקת ביטים**:\n        *   רמה 1 (P1): 5 ביטים (הביטים המשמעותיים ביותר).\n        *   רמה 2 (P2): 10 ביטים.\n        *   רמה 3 (P3): 10 ביטים.\n        *   רמה 4 (P4): 10 ביטים.\n    *   סה\"כ 5 + 10 + 10 + 10 = 35 ביטים עבור ה-VPN.\n\n1.2 גישות לזיכרון במקרה הגרוע ביותר:\nמקרה גרוע ביותר כולל: TLB miss, Page Fault, וצורך ב-Page Replacement (כאשר ה-Dirty bit של הדף המוחלף דולק).\n\n1.  **גישה ל-TLB**: (1 גישה - חומרה)\n    *   Process מבצע גישה לכתובת וירטואלית. ה-CPU שולח את ה-VPN ל-TLB.\n    *   **TLB Miss**: הכניסה אינה נמצאת ב-TLB. (0 גישות לזיכרון ראשי, 1 ל-TLB)\n\n2.  **מעבר על טבלאות הדפים (Page Table Walk)**: (4 גישות - זיכרון ראשי)\n    *   לאחר TLB miss, ה-CPU ניגש לזיכרון הראשי כדי לעבור על טבלאות הדפים.\n    *   4 רמות -> 4 גישות לזיכרון הראשי (אחת לכל טבלת דפים ברמה).\n\n3.  **Page Fault**: (0 גישות - זיכרון ראשי)\n    *   בסוף ה-Page Table Walk, מתגלה שה-PTE של הדף המבוקש אינו תקף (Valid bit = 0) או שהדף אינו בזיכרון הראשי (Present bit = 0).\n    *   מתרחשת פסיקת דף (Page Fault). מערכת ההפעלה משתלטת.\n\n4.  **בחירת קורבן (Page Replacement) וכתיבה לדיסק (אם Dirty)**: (1 גישה - זיכרון ראשי, 1 גישה - דיסק)\n    *   מערכת ההפעלה בוחרת דף \"קורבן\" לפנות מהזיכרון הראשי.\n    *   אם ה-Dirty bit של הדף הקורבן דולק, יש לכתוב את הדף לדיסק.\n    *   **גישה 1 לזיכרון ראשי**: קריאת ה-PTE של הדף הקורבן כדי לבדוק את ה-Dirty bit.\n    *   **גישה 1 לדיסק**: כתיבת תוכן הדף הקורבן לדיסק.\n\n5.  **טעינת הדף המבוקש מהדיסק**: (1 גישה - דיסק)\n    *   **גישה 1 לדיסק**: קריאת הדף המבוקש מהדיסק לתוך מסגרת פנויה בזיכרון הראשי.\n\n6.  **עדכון טבלת הדפים**: (1 גישה - זיכרון ראשי)\n    *   **גישה 1 לזיכרון ראשי**: עדכון ה-PTE של הדף המבוקש בטבלת הדפים (Valid=1, Present=1, PFN, Accessed=1).\n\n7.  **עדכון ה-TLB**: (1 גישה - חומרה)\n    *   ה-CPU מעדכן את ה-TLB עם הכניסה החדשה.\n\n8.  **גישה מחודשת לנתון**: (1 גישה - זיכרון ראשי)\n    *   הפקודה שגרמה ל-Page Fault מבוצעת שוב.\n    *   **גישה 1 ל-TLB**: (Hit הפעם)\n    *   **גישה 1 לזיכרון ראשי**: קריאת הנתון עצמו.\n\n**סיכום גישות:**\n*   **TLB**: 2 גישות (אחת Miss, אחת Hit).\n*   **זיכרון ראשי**:\n    *   Page Table Walk: 4 גישות.\n    *   קריאת PTE של קורבן: 1 גישה.\n    *   עדכון PTE של דף מבוקש: 1 גישה.\n    *   קריאת הנתון עצמו: 1 גישה.\n    *   סה\"כ: 4 + 1 + 1 + 1 = 7 גישות לזיכרון הראשי.\n*   **דיסק**:\n    *   כתיבת דף קורבן: 1 גישה.\n    *   קריאת דף מבוקש: 1 גישה.\n    *   סה\"כ: 2 גישות לדיסק.\n\n1.3 השפעת PTE flags:\n\n*   **תהליך מבצע קריאה לכתובת וירטואלית שאינה בזיכרון הפיזי וגורמת ל-Page Fault**: \n    *   **שלב 1: Page Fault Handling (טעינת הדף)**:\n        *   מערכת ההפעלה טוענת את הדף מהדיסק למסגרת פיזית.\n        *   **Valid Bit**: ה-Valid bit ב-PTE של הדף המבוקש ישונה ל-1.\n        *   **Accessed Bit**: ה-Accessed bit ב-PTE של הדף המבוקש ישונה ל-1 (מכיוון שבוצעה גישה לדף).\n        *   **Dirty Bit**: ה-Dirty bit יישאר 0 (זו הייתה גישת קריאה, והדף עכשיו טרי מהדיסק, לא שונה).\n        *   **כתיבת PTE לזיכרון הראשי**: כן. שינויים אלו ב-PTE יחייבו כתיבה חוזרת של ה-PTE לזיכרון הראשי, בטבלת הדפים המתאימה. זה קורה מיד לאחר שהדף נטען וה-PTE עודכן על ידי מערכת ההפעלה, כדי שהמיפוי החדש יהיה זמין ל-CPU.\n\n*   **לאחר מכן, התהליך מבצע כתיבה לאותה כתובת**:\n    *   **שלב 2: ביצוע כתיבה לכתובת**:\n        *   ה-CPU ניגש שוב לכתובת (דרך ה-TLB או Page Table Walk).\n        *   **Accessed Bit**: ה-Accessed bit ב-PTE של הדף המבוקש יישאר 1 (או יוגדר מחדש ל-1 אם אופס).\n        *   **Dirty Bit**: ה-Dirty bit ב-PTE של הדף המבוקש ישונה ל-1, כדי לסמן שהדף שונה בזיכרון הראשי וגרסתו בדיסק אינה עדכנית.\n        *   **Valid Bit**: ה-Valid bit יישאר 1.\n        *   **כתיבת PTE לזיכרון הראשי**: כן. שינוי ה-Dirty bit מחייב כתיבה חוזרת של ה-PTE לזיכרון הראשי. זה קורה מיד לאחר שה-CPU (או יחידת ניהול הזיכרון - MMU) מבצע את הכתיבה לנתון בזיכרון הפיזי ומעדכן את ה-PTE."
    },
    "difficulty_estimation": "Hard"
  }
}