{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Processes and Memory Management",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-09 20:59:02",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1726,
      "output_tokens": 1754,
      "total_tokens": 5723
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Processes",
      "Memory Management",
      "Copy-on-Write"
    ],
    "content": {
      "text": "תהליך P מבצע פעולת fork() ליצירת תהליך בן C. לפני ה-fork, תהליך P הקצה זיכרון דינמי של 10MB ומילא אותו בנתונים. המערכת משתמשת במנגנון זיכרון וירטואלי עם דפים בגודל 4KB, ותומכת ב-Copy-on-Write (COW).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "מיד לאחר ביצוע ה-fork() וטרם בוצעה כל כתיבה על ידי P או C, כמה זיכרון (בבתים) מועתק בפועל עבור התהליך הבן, ומהו המנגנון המאפשר זאת?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "בהנחה שגם P וגם C מנסים לכתוב לאותה כתובת וירטואלית בטווח ה-10MB שהוקצה, תאר בפירוט את השלבים המתרחשים במערכת ההפעלה ובחומרה (MMU) על מנת לטפל בכתיבה זו, וכיצד היא משפיעה על זיכרון התהליכים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "ציין שני יתרונות מרכזיים של מנגנון ה-Copy-on-Write בהקשר של יצירת תהליכים.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 20,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.   **מיד לאחר ביצוע ה-fork()**: בפועל, כמעט ולא מועתק זיכרון כלל עבור התהליך הבן (למעט אולי זיכרון קטן הכרחי כמו מחסנית ליבה ורישומי מעבד, שהם זניחים ביחס ל-10MB). במנגנון Copy-on-Write (COW), גם תהליך P וגם תהליך C חולקים את אותם דפים פיזיים בזיכרון. טבלאות הדפים של שני התהליכים יצביעו על אותן מסגרות פיזיות עבור אזור ה-10MB. דפים אלו מסומנים כ-read-only (או כדפים שדורשים העתקה לפני כתיבה) ב-PTE (Page Table Entry) שלהם. המנגנון מאפשר זאת על ידי שינוי ערכי ה-PTE בטבלת הדפים של שני התהליכים כך שיצביעו על אותן מסגרות פיזיות, וסימון הדפים כדורשי העתקה בעת כתיבה.\n\n2.   **כאשר P או C מנסים לכתוב לאותה כתובת וירטואלית**: כאשר אחד מהתהליכים (לדוגמה, P) מנסה לכתוב לכתובת וירטואלית בטווח ה-10MB המשותף, מתרחשים השלבים הבאים:\n    *   **Page Fault / Write Protection Fault**: ה-MMU (Memory Management Unit) מזהה ניסיון כתיבה לדף המסומן כ-read-only (או כדף COW). זה גורם ל-trap למערכת ההפעלה (page fault מסוג write protection fault).\n    *   **בדיקת סוג התקלה**: מערכת ההפעלה מזהה שהתקלה נגרמה מדף COW ולא מדף שאינו קיים בזיכרון.\n    *   **ספירת הפניות (Reference Count)**: מערכת ההפעלה בודקת כמה תהליכים מפנים לדף הפיזי המקורי. במקרה של COW לאחר fork, ספירת ההפניות לדף אמורה להיות 2 (P ו-C).\n    *   **העתקת הדף**: אם ספירת ההפניות גדולה מ-1, מערכת ההפעלה מקצה מסגרת פיזית חדשה ומעתיקה אליה את תוכן הדף המקורי.\n    *   **עדכון טבלת הדפים**: טבלת הדפים של התהליך שביצע את הכתיבה (P במקרה זה) מתעדכנת כך שה-PTE המתאים יצביע כעת על המסגרת הפיזית החדשה שהועתקה אליה. הדף מסומן כעת כ-writable. טבלת הדפים של התהליך השני (C) נשארת ללא שינוי, וה-PTE שלו עדיין מצביע על המסגרת הפיזית המקורית (שכעת מכילה את הגרסה הישנה של הנתונים). הוא עדיין מסומן כדורש העתקה בעת כתיבה.\n    *   **המשך ביצוע**: ה-TLB (Translation Lookaside Buffer) מעודכן (הערך הישן נפסל), והפקודה שגרמה לתקלה מבוצעת מחדש (retry). כעת הכתיבה תתבצע למסגרת החדשה. התוצאה היא שלכל תהליך יש כעת עותק פרטי משלו של הדף שבו בוצעה הכתיבה, ושינויים שכל אחד מהם יבצע בדף זה לא ישפיעו על השני.\n\n3.   **יתרונות מנגנון ה-Copy-on-Write**: שני יתרונות מרכזיים של מנגנון ה-Copy-on-Write בהקשר של יצירת תהליכים:\n    *   **חיסכון בזיכרון**: במקרים רבים, תהליך בן (child process) מבצע `exec()` מיד לאחר ה-`fork()`, ומחליף את מרחב הכתובות שלו בתוכנית חדשה. ללא COW, היה מתבצע העתקה מלאה של זיכרון התהליך האב, שהייתה מתבזבזת מיד. עם COW, רק דפים שבאמת משתנים על ידי אחד מהתהליכים מועתקים, מה שמפחית משמעותית את צריכת הזיכרון הכוללת במערכת.\n    *   **שיפור ביצועים (זמן יצירת תהליך)**: הימנעות מהעתקה פיזית של זיכרון רב משמעותה שפעולת ה-`fork()` מהירה בהרבה. במקום להעתיק את כל ה-10MB (או יותר), רק טבלאות דפים (או חלקים מהן) דורשות שינוי קל וסימון הדפים כדורשי העתקה. זה משפר את זמן התגובה של יצירת תהליכים חדשים באופן דרמטי, מכיוון שעלות יצירת תהליך הופכת להיות פרופורציונלית לכמות הזיכרון שבאמת משתנה, ולא לכלל זיכרון התהליך האב."
    },
    "difficulty_estimation": "Medium"
  }
}