{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:01:30",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4965,
      "output_tokens": 3562,
      "total_tokens": 16477
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Copy-on-Write",
      "Virtual Memory",
      "Process Management"
    ],
    "content": {
      "text": "מערכות הפעלה מודרניות רבות משתמשות במנגנון Copy-on-Write (CoW) בעת יצירת תהליכים חדשים באמצעות קריאת המערכת `fork()`. מנגנון זה מאפשר לשפר ביצועים ולחסוך בזיכרון פיזי על ידי שיתוף דפי זיכרון בין תהליך האב לתהליך הבן, ורק כאשר אחד מהם מנסה לכתוב לדף משותף, הדף משוכפל. יש לפרט ולנמק את כל החישובים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "101.1",
        "text": "הסבר בקצרה את אופן הפעולה של מנגנון ה-Copy-on-Write בהקשר של `fork()`: כיצד מנוהלות כניסות לטבלאות דפים (Page Table Entries) עבור דפים משותפים, וכיצד מטופל ניסיון כתיבה לדף כזה? ציין את היתרונות העיקריים של גישה זו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.2",
        "text": "נתונה מערכת הפעלה עם גודל דף (Page Size) של 4KB. תהליך אב (Parent) מריץ תוכנית המשתמשת באזור נתונים בגודל 1MB אשר מאותחל במלואו. תהליך האב מבצע קריאת `fork()` ליצירת תהליך בן (Child). לאחר מכן, מתרחשות הפעולות הבאות:\n1.  התהליך הבן כותב ל-100 דפים *שונים* בתוך אזור הנתונים שלו.\n2.  התהליך האב כותב ל-50 דפים *שונים* בתוך אזור הנתונים שלו.\nידוע כי מתוך 50 הדפים שהתהליך האב כתב אליהם, 20 דפים *גם* נכתבו על ידי התהליך הבן (כלומר, הם שייכים לחפיפה בין קבוצת הדפים שהבן כתב אליהם לקבוצת הדפים שהאב כתב אליהם). הנח כי לפני כל כתיבה, הדף הרלוונטי היה במצב CoW (משותף ולקריאה בלבד) או שכבר שוכפל על ידי התהליך השני כפי שצוין. אין צורך להתייחס ל-TLB או ל-CPU cache.\n\nחשב את הדברים הבאים, בסיום כל הפעולות:\nא. כמה דפים פיזיים בסך הכל יהיו בשימוש על ידי שני התהליכים (האב והבן)?\nב. כמה \"CoW page faults\" בסך הכל התרחשו במהלך כל פעולות הכתיבה?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.3",
        "text": "סטודנט הציע שבמקום לשמור מונה הפניות (reference count) לכל דף פיזי, המערכת תוכל בעת CoW page fault, לסרוק את כל טבלאות הדפים של כל התהליכים הפעילים כדי לבדוק כמה כניסות מצביעות לדף הפיזי הספציפי. אם המונה יגיע ל-1, הדף יומר ל-Read/Write עבור התהליך שגרם ל-fault. אם המונה יהיה גדול מ-1, הדף ישוכפל. דון בהיתכנות ובהשלכות של גישה זו, במיוחד בהיבטי ביצועים, מורכבות וניהול זיכרון.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "101.1:\n**אופן הפעולה:**\nבעת קריאת `fork()`, במקום לשכפל את כל מרחב הכתובות של האב לזיכרון פיזי חדש עבור הבן, מערכת ההפעלה מבצעת את הפעולות הבאות:\n1.  **העתקת טבלת דפים:** טבלת הדפים של תהליך הבן היא העתק (לוגי או פיזי) של טבלת הדפים של האב. כלומר, כניסות טבלת הדפים של הבן מצביעות לאותם דפים פיזיים כמו אלו של האב.\n2.  **סימון לקריאה בלבד (Read-Only):** כל הדפים המשותפים (שהיו במקור של האב וכעת משותפים עם הבן) מסומנים כדפי קריאה בלבד (Read-Only) בטבלאות הדפים של שני התהליכים (האב והבן).\n3.  **טיפול בכתיבה (CoW Page Fault):** כאשר אחד מהתהליכים (האב או הבן) מנסה לכתוב לדף משותף המסומן כ-Read-Only, נוצר \"CoW page fault\" (או \"Protection Fault\"). מנגנון זה מפעיל את שגרת הטיפול הבאה:\n    *   מערכת ההפעלה מקצה דף פיזי חדש. \n    *   תוכן הדף המקורי מועתק לדף הפיזי החדש שהוקצה.\n    *   כניסת טבלת הדפים של התהליך שגרם ל-fault מעודכנת כך שתצביע לדף החדש, והדף מסומן כעת כ-Read/Write עבור תהליך זה בלבד.\n    *   מונה ההפניות לדף המקורי (אם קיים) מופחת ב-1. אם מונה ההפניות מגיע ל-0, הדף המקורי יכול להיות משוחרר. אחרת, הוא נשאר משותף עם תהליכים אחרים (או עם התהליך השני) במצב Read-Only.\n\n**יתרונות עיקריים:**\n*   **חיסכון בזיכרון:** נמנע שכפול מיותר של דפים פיזיים אם התהליך הבן (או האב) אינו משנה את התוכן של הדפים המשותפים. זה חיוני במיוחד כאשר `fork()` מבוצע לפני `execve()` (לדוגמה, במעטפת פקודה), מכיוון שרוב הדפים לעולם לא ישונו על ידי הבן לפני שיטען תוכנית חדשה.\n*   **שיפור ביצועים:** זמן יצירת תהליך חדש (ה-`fork()`) מהיר יותר באופן משמעותי, מכיוון שאין צורך להעתיק את כל זיכרון התהליך מיד. העתקה מתבצעת רק \"על פי דרישה\" (on demand) כאשר יש צורך בכתיבה.\n*   **פשטות לוגית:** התהליכים רואים מרחב כתובות מלא של האב מיד, ללא צורך בטיפול מיוחד בתוכנית עצמה. \n\n101.2:\n**נתונים:**\n*   גודל דף: 4KB.\n*   אזור נתונים התחלתי של האב: 1MB = 1024KB. \n*   מספר דפים פיזיים התחלתי של האב: 1024KB / 4KB = 256 דפים.\n\n**א. כמה דפים פיזיים בסך הכל יהיו בשימוש בסיום הפעולות?**\n1.  **מצב התחלתי (לפני `fork()`):** האב משתמש ב-256 דפים פיזיים. \n2.  **לאחר `fork()`:** תהליך הבן מקבל טבלת דפים המצביעה לאותם 256 דפים פיזיים של האב. כל הדפים מסומנים כ-Read-Only. סך הדפים הפיזיים בשימוש: 256. \n3.  **הבן כותב ל-100 דפים שונים:** כל כתיבה לדף משותף גורמת ל-CoW page fault, הקצאת דף פיזי חדש, והעתקת תוכן. לכן, הבן יקצה 100 דפים פיזיים חדשים משלו. \n    *   דפים פיזיים חדשים שהוקצו לבן: 100. \n    *   סך הדפים הפיזיים בשימוש: 256 (מקוריים) + 100 (של הבן) = 356.\n4.  **האב כותב ל-50 דפים שונים:**\n    *   **20 דפים מתוך ה-50 הללו *גם* נכתבו על ידי הבן:** עבור 20 דפים אלו, הבן כבר יצר לעצמו עותק. האב עדיין מצביע לדפים המקוריים (ולא לעותקים של הבן). כאשר האב כותב לדפים אלו, יתרחשו 20 CoW page faults, והאב יקצה 20 דפים פיזיים חדשים משלו. \n    *   **30 דפים מתוך ה-50 הללו *לא* נכתבו על ידי הבן:** עבור 30 דפים אלו, גם האב וגם הבן עדיין מצביעים לדפים המקוריים (במצב Read-Only). כאשר האב כותב לדפים אלו, יתרחשו 30 CoW page faults, והאב יקצה 30 דפים פיזיים חדשים משלו. \n    *   דפים פיזיים חדשים שהוקצו לאב: 20 + 30 = 50. \n    *   סך הדפים הפיזיים בשימוש: 356 (לאחר פעולות הבן) + 50 (של האב) = 406 דפים פיזיים.\n\n**תשובה סופית א': 406 דפים פיזיים.**\n\n**ב. כמה \"CoW page faults\" בסך הכל התרחשו?**\n1.  **CoW page faults של הבן:** הבן כתב ל-100 דפים שונים. כל כתיבה לדף משותף גורמת ל-CoW page fault אחד. לכן: 100 CoW page faults.\n2.  **CoW page faults של האב:** האב כתב ל-50 דפים שונים. כל כתיבה לדף משותף (בין אם הבן כבר שוכפל או לא) גורמת ל-CoW page fault אחד עבור האב. לכן: 50 CoW page faults.\n\n**תשובה סופית ב': 100 (בן) + 50 (אב) = 150 CoW page faults.**\n\n101.3:\n**היתכנות והשלכות של גישת הסטודנט (בדיקת כל טבלאות הדפים):**\n\n**היתכנות:**\nתיאורטית, גישה זו אפשרית. מערכת ההפעלה יכולה, במקרה של CoW page fault, לזהות את הדף הפיזי המעורב ולסרוק את כל טבלאות הדפים של כל התהליכים הפעילים במערכת כדי למצוא כניסות המצביעות לדף זה ולספור אותן. \n\n**השלכות:**\n1.  **ביצועים (Performance):** זוהי ההשלכה הקריטית והשלילית ביותר. סריקת כל טבלאות הדפים של כל התהליכים הפעילים היא פעולה יקרה מאוד מבחינת זמן CPU וגישות לזיכרון. במערכת מודרנית עם עשרות או מאות תהליכים, ומיליוני כניסות לטבלאות דפים, פעולה זו תגרום לזמן השהייה (latency) ארוך מאוד עבור כל CoW page fault. מכיוון ש-CoW page faults יכולים להתרחש בתדירות גבוהה (במיוחד לאחר `fork()`), הדבר יפגע קשות בביצועי המערכת כולה. מנגנון מונה ההפניות (reference count) מספק פתרון מהיר ב-O(1) לעדכון ובדיקת מספר ההפניות.\n\n2.  **מורכבות (Complexity):** \n    *   **סנכרון:** סריקת טבלאות דפים מצריכה מנגנוני סנכרון מורכבים (לדוגמה, נעילת טבלאות דפים גלובלית או נעילות עדינות יותר) כדי למנוע מצבי מרוץ ולוודא שהמידע אינו משתנה בזמן הסריקה. זה מגביר מאוד את מורכבות הקוד של מנהל הזיכרון.\n    *   **מבני נתונים:** אם רוצים לשפר את הביצועים מעט, ייתכן שיהיה צורך במבני נתונים נוספים (כמו reverse mapping - מיפוי מדף פיזי לכניסות בטבלאות דפים המצביעות אליו), אך אלו עצמם מורכבים לתחזוקה ומצריכים זיכרון ועלויות עדכון.\n\n3.  **ניהול זיכרון (Memory Management):** \n    *   **זיהוי דפים פנויים:** מונה ההפניות מאפשר לדעת בקלות מתי דף פיזי אינו בשימוש יותר (המונה מגיע ל-0) וניתן לשחרר אותו. בגישת הסטודנט, זיהוי דף פנוי ידרוש סריקה דומה כדי לוודא שאין אליו הפניות. \n    *   **דפים בשימוש פנימי של הקרנל:** הקרנל עצמו משתמש בדפים פיזיים למטרות שונות. גישת הסטודנט עלולה להתעלם מהפניות פנימיות של הקרנל, או לדרוש מנגנון נפרד עבורם, מה שמסבך את הניהול. \n\n**לסיכום:** בעוד שגישת הסטודנט אפשרית מבחינה תיאורטית, היא אינה מעשית במערכות הפעלה מודרניות בשל הפגיעה הקשה בביצועים, המורכבות הגבוהה של המימוש ובעיות הסנכרון והניהול שהיא מציגה. מונה הפניות הוא פתרון יעיל ואלגנטי בהרבה לבעיה זו."
    },
    "difficulty_estimation": "Hard"
  }
}