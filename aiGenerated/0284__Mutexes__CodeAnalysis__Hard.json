{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:32:43",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4847,
      "output_tokens": 1852,
      "total_tokens": 15693
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Mutexes",
      "Concurrency",
      "Deadlocks"
    ],
    "content": {
      "text": "נתונה מערכת המשתמשת במאגר משותף (buffer) ובמונה משותף (counter). המערכת מוגדרת עם שני mutexes: `buffer_mutex` להגנה על המאגר ו-`counter_mutex` להגנה על המונה. המונה מאותחל ל-0. פונקציות העזר `produce_new_item()`, `add_item_to_buffer()`, `remove_item_from_buffer()`, ו-`consume_item()` בטוחות לשימוש ומתוארות בקצרה (אין צורך לממש אותן). להלן קוד המימוש של פונקציות היצרן (producer) והצרכן (consumer) במערכת, המשתמשות במנעולים אלו:",
      "code_snippet": "#include <pthread.h>\n\n// Global variables\nint counter = 0; // Tracks number of items in buffer\n// Assume a shared buffer implementation (e.g., array with head/tail)\n// For simplicity, buffer overflow/underflow is not the focus of this question.\n\npthread_mutex_t buffer_mutex; // Protects buffer, head, tail\npthread_mutex_t counter_mutex; // Protects counter\n\n// Assume these helper functions exist and are safe to call\n// (i.e., they don't handle their own synchronization, relying on caller)\nint produce_new_item();\nvoid add_item_to_buffer(int item);\nint remove_item_from_buffer();\nvoid consume_item(int item);\n\n// Producer thread function (buggy)\nvoid* producer(void* arg) {\n    while (1) {\n        int item = produce_new_item();\n\n        pthread_mutex_lock(&buffer_mutex); // Acquire buffer_mutex first\n        add_item_to_buffer(item);\n\n        pthread_mutex_lock(&counter_mutex); // Then acquire counter_mutex\n        counter++;\n        pthread_mutex_unlock(&counter_mutex);\n\n        pthread_mutex_unlock(&buffer_mutex);\n    }\n    return NULL;\n}\n\n// Consumer thread function (buggy)\nvoid* consumer(void* arg) {\n    while (1) {\n        pthread_mutex_lock(&counter_mutex); // Acquire counter_mutex first\n        if (counter > 0) {\n            counter--;\n\n            pthread_mutex_lock(&buffer_mutex); // Then acquire buffer_mutex\n            int item = remove_item_from_buffer();\n            pthread_mutex_unlock(&buffer_mutex);\n            consume_item(item);\n        }\n        pthread_mutex_unlock(&counter_mutex);\n    }\n    return NULL;\n}"
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "הקוד המתואר אינו תקין. תארו מה הבעיה וכיצד היא יכולה להתרחש. יש לתאר ריצה ספציפית המדגימה את הבעיה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "תקנו את הקוד כך שיעבוד באופן תקין וימנע את הבעיה שתוארה. יש להציג את הפונקציות producer ו-consumer המתוקנות.",
        "code_snippet": "void* producer(void* arg) {\n    // הקוד המתוקן של producer כאן\n}\n\nvoid* consumer(void* arg) {\n    // הקוד המתוקן של consumer כאן\n}",
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1. הבעיה בקוד היא קיפאון (Deadlock).\n   הקיפאון יכול להתרחש כתוצאה מסדר תפיסת מנעולים לא עקבי בין החוטים השונים. נניח שמתרחשת הריצה הבאה:\n   1. חוט יצרן (Producer Thread) מבצע `pthread_mutex_lock(&buffer_mutex)`. כעת הוא מחזיק במנעול `buffer_mutex`.\n   2. מתרחש מעבר הקשר (context switch) לחוט צרכן (Consumer Thread).\n   3. חוט צרכן מבצע `pthread_mutex_lock(&counter_mutex)`. כעת הוא מחזיק במנעול `counter_mutex`.\n   4. חוט צרכן ממשיך ובודק `if (counter > 0)`. נניח ש-`counter` אכן גדול מ-0. הוא מבצע `counter--`.\n   5. חוט צרכן מנסה לבצע `pthread_mutex_lock(&buffer_mutex)`, אך המנעול `buffer_mutex` כבר נתפס על ידי חוט היצרן. חוט הצרכן נחסם וממתין לשחרור `buffer_mutex`.\n   6. מתרחש מעבר הקשר בחזרה לחוט יצרן.\n   7. חוט יצרן מנסה לבצע `pthread_mutex_lock(&counter_mutex)`, אך המנעול `counter_mutex` כבר נתפס על ידי חוט הצרכן. חוט היצרן נחסם וממתין לשחרור `counter_mutex`.\n   בשלב זה, שני החוטים חסומים באופן הדדי: היצרן ממתין לצרכן שישחרר את `counter_mutex`, והצרכן ממתין ליצרן שישחרר את `buffer_mutex`. אף אחד מהם לא יכול להמשיך, והמערכת נכנסת למצב של קיפאון.\n\n1.2. כדי למנוע קיפאון, יש לוודא שכל החוטים תופסים את המנעולים באותו סדר עקבי. נבחר בסדר: תחילה `counter_mutex` ואז `buffer_mutex`. שינוי זה דורש התאמה בפונקציית היצרן.\n\nהקוד המתוקן:\n```c\nvoid* producer(void* arg) {\n    while (1) {\n        int item = produce_new_item();\n\n        pthread_mutex_lock(&counter_mutex); // Acquire counter_mutex first (consistent order)\n        pthread_mutex_lock(&buffer_mutex);  // Then acquire buffer_mutex\n\n        // Both mutexes are now held, ensuring atomicity for counter and buffer update.\n        // In a full producer-consumer, one would also check for buffer full here and use condition variables.\n        add_item_to_buffer(item);\n        counter++;\n\n        pthread_mutex_unlock(&buffer_mutex);\n        pthread_mutex_unlock(&counter_mutex);\n    }\n    return NULL;\n}\n\nvoid* consumer(void* arg) {\n    while (1) {\n        pthread_mutex_lock(&counter_mutex); // Acquire counter_mutex first (consistent order)\n        pthread_mutex_lock(&buffer_mutex);  // Then acquire buffer_mutex\n\n        if (counter > 0) { // Check counter under lock\n            counter--;\n            int item = remove_item_from_buffer();\n            consume_item(item);\n        }\n        // If counter <= 0, buffer is empty. Just unlock and retry.\n        \n        pthread_mutex_unlock(&buffer_mutex);\n        pthread_mutex_unlock(&counter_mutex);\n    }\n    return NULL;\n}\n```",
      "difficulty_estimation": "Hard"
    }
  }
}