{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 21:09:13",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2768,
      "output_tokens": 1773,
      "total_tokens": 8021
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Processes",
      "CPU Scheduling",
      "Algorithm Comparison"
    ],
    "content": {
      "text": "מערכת הפעלה מריצה מספר תהליכים בעלי מאפיינים שונים:\n*   **תהליכים אינטראקטיביים (Interactive Processes):** דורשים זמני תגובה מהירים וכוללים הפסקות קלט/פלט תכופות.\n*   **תהליכי אצווה (Batch Processes):** דורשים זמן מעבד רב ורציף ופחות רגישים לזמני תגובה.\n\nהמערכת משתמשת כרגע באלגוריתם תזמון Round-Robin (RR) עם קוונטום זמן קבוע וגדול יחסית (לדוגמה, 100ms).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "7.1",
        "text": "הסבר מדוע אלגוריתם RR עם קוונטום זמן גדול אינו אופטימלי עבור סוגי התהליכים הללו. ציין את הבעיות הספציפיות שייווצרו עבור כל אחד מסוגי התהליכים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.2",
        "text": "הצע שינוי או אלגוריתם תזמון אחר (או שילוב של אלגוריתמים) שיפתור טוב יותר את הבעיות שתוארו בסעיף א', תוך התחשבות במאפיינים השונים של התהליכים. נמק את בחירתך והסבר כיצד הפתרון המוצע מתמודד עם האתגרים.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**פתרון:**\n\n**א. מדוע RR עם קוונטום גדול אינו אופטימלי:**\n\n*   **עבור תהליכים אינטראקטיביים:**\n    *   **זמן תגובה גבוה (High Latency):** תהליכים אינטראקטיביים דורשים תגובה מיידית לפעולות המשתמש. עם קוונטום זמן גדול (100ms), תהליך אינטראקטיבי שיצטרך רק כמה מילישניות של מעבד ייאלץ להמתין עד שתהליכים אחרים יסיימו את הקוונטום שלהם (או עד שהוא עצמו יסיים את הקוונטום שלו אם הוא מבצע I/O מוקדם). המתנה זו גורמת למערכת להרגיש איטית ולא מגיבה.\n    *   **ניצול לא יעיל של המעבד:** אם תהליך אינטראקטיבי מבצע פעולת קלט/פלט לפני תום הקוונטום שלו, שאר הקוונטום מבוזבז, והתהליך הבא בתור ירוץ רק לאחר מכן, מה שמוסיף לעיכובים.\n\n*   **עבור תהליכי אצווה:**\n    *   **החלפות הקשר (Context Switches) מיותרות:** למרות שהקוונטום גדול, RR עדיין מחליף בין תהליכים באופן שוויוני. תהליכי אצווה הם CPU-bound ונהנים מריצה רציפה וארוכה. החלפות הקשר תכופות, גם אם עם קוונטום גדול, גורמות לתקורה (overhead) מיותרת ומפחיתות את התפוקה (throughput) הכוללת של המערכת עבורם, מכיוון שהם מופרעים לעיתים קרובות שלא לצורך.\n    *   **חוסר אופטימיזציה ל-CPU-bound:** אלגוריתם RR מתוכנן לספק הוגנות (fairness) וזמן תגובה, אך לא בהכרח תפוקה מקסימלית לתהליכי CPU-bound, במיוחד כאשר הם מעורבים עם תהליכים אינטראקטיביים.\n\n**ב. פתרון מוצע: אלגוריתם תזמון Multi-Level Feedback Queue (MLFQ)**\n\n*   **הסבר ובחירה:** MLFQ הוא אלגוריתם תזמון מבוסס עדיפויות דינמיות המשתמש במספר תורים, כאשר לכל תור עדיפות שונה וקוונטום זמן שונה (הקטן ביותר לתורים בעלי העדיפות הגבוהה ביותר, והגדול ביותר או FCFS לתורים בעלי העדיפות הנמוכה ביותר). תהליכים עוברים בין התורים על בסיס התנהגותם. הוא מתאים במיוחד למצבים בהם יש תמהיל של תהליכים אינטראקטיביים ותהליכי אצווה, מכיוון שהוא מנסה ללמוד את סוג התהליך באופן אוטומטי.\n\n*   **כיצד הפתרון מתמודד עם האתגרים:**\n    *   **טיפול בתהליכים אינטראקטיביים:**\n        *   תהליכים חדשים וכן תהליכים המבצעים פעולות קלט/פלט לעיתים קרובות (מאפיין של תהליכים אינטראקטיביים) יקבלו עדיפות גבוהה ויוצבו בתורים העליונים עם קוונטום זמן קצר (לדוגמה, 10ms).\n        *   זמני התגובה יהיו נמוכים מאוד, מכיוון שהם יקבלו גישה מהירה למעבד ויוכלו לבצע את מטלותיהם הקצרות במהירות.\n    *   **טיפול בתהליכי אצווה:**\n        *   תהליכי אצווה, שהם CPU-bound ומנצלים את כל הקוונטום שלהם שוב ושוב, יורדים בהדרגה לתורים בעלי עדיפות נמוכה יותר.\n        *   בתורים הנמוכים, הקוונטום ארוך יותר (או שהתור עובד ב-FCFS), מה שמאפשר להם לרוץ לפרקי זמן ארוכים יותר ללא הפרעה, מפחית את תקורת החלפות ההקשר ומשפר את התפוקה.\n    *   **מניעת הרעבה (Starvation Prevention):** מנגנון ה-\"Priority Boost\" ב-MLFQ מבטיח שגם תהליכים שנפלו לתורים הנמוכים ביותר יקבלו מדי פעם \"הזדמנות שנייה\" ויעלו לתור בעדיפות הגבוהה ביותר, ובכך מונע מצב של הרעבה.\n    *   **הוגנות (Fairness) דינמית:** האלגוריתם מספק הוגנות בכך שהוא נותן עדיפות לתהליכים אינטראקטיביים אך עדיין מבטיח שגם תהליכי אצווה יקבלו את זמנם, ומתאים את העדיפויות באופן דינמי לפי התנהגות התהליך."
    },
    "difficulty_estimation": "Medium"
  }
}