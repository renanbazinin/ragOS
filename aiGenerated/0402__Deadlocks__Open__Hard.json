{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 21:18:38",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3443,
      "output_tokens": 2295,
      "total_tokens": 9650
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Deadlocks",
      "Concurrency",
      "Resource Management"
    ],
    "content": {
      "text": "במערכת הפעלה מרובת תהליכים, נניח שיש לנו N תהליכים (או חוטים) שכל אחד מהם צריך לבצע משימה הדורשת שני סוגי משאבים: 'משאב X' ו'משאב Y'. קיימים `num_X` יחידות של משאב X ו-`num_Y` יחידות של משאב Y במערכת. כל תהליך זקוק ליחידה אחת מכל סוג משאב כדי להשלים את משימתו. התהליכים רוכשים את המשאבים באמצעות מנעולים (mutexes).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "תארו תרחיש ספציפי (באמצעות סדר פעולות של שני תהליכים לפחות) שבו עלול להתרחש קיפאון (deadlock) במערכת המתוארת. הסבירו מדוע תרחיש זה מוביל לקיפאון תוך התייחסות לארבעת התנאים של קיפאון (מניעה הדדית, החזקה והמתנה, אי-נשללות, המתנה מעגלית).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "הציעו אסטרטגיה למניעת קיפאון במערכת זו. לאחר מכן, כתבו מימוש בפסאודו-קוד (או C/C++) לפונקציות `acquire_resources` ו-`release_resources` עבור תהליך בודד, המשתמשות ב-`pthread_mutex_t` ומיישמות את האסטרטגיה שהצעתם. הניחו ש-`mutex_X` ו-`mutex_Y` הם מנעולים גלובליים המגנים על המשאבים.",
        "code_snippet": "pthread_mutex_t mutex_X; // מגן על משאב X\npthread_mutex_t mutex_Y; // מגן על משאב Y\n\nvoid acquire_resources() {\n    // יש לממש כאן את לוגיקת רכישת המשאבים עם מניעת קיפאון\n}\n\nvoid release_resources() {\n    // יש לממש כאן את לוגיקת שחרור המשאבים\n}",
        "options": null
      },
      {
        "id": "1.3",
        "text": "נתחו את השפעת האסטרטגיה שהצעתם על רמת המקביליות (concurrency) וניצול המשאבים במערכת. האם יש חסרונות לגישה זו? פרטו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "### סעיף 1.1: תרחיש קיפאון\nתרחיש קיפאון יכול להתרחש כדלקמן:\n\n**תהליך P1 מבצע:**\n1. `pthread_mutex_lock(&mutex_X);` // P1 רוכש את מנעול X\n\n**תהליך P2 מבצע בו זמנית:**\n1. `pthread_mutex_lock(&mutex_Y);` // P2 רוכש את מנעול Y\n\n**לאחר מכן:**\n2. `pthread_mutex_lock(&mutex_Y);` // P1 מנסה לרכוש את מנעול Y. P1 נחסם כיוון ש-P2 מחזיק ב-Y.\n\n2. `pthread_mutex_lock(&mutex_X);` // P2 מנסה לרכוש את מנעול X. P2 נחסם כיוון ש-P1 מחזיק ב-X.\n\nבשלב זה, P1 מחזיק ב-X וממתין ל-Y, בעוד P2 מחזיק ב-Y וממתין ל-X. זהו מצב של קיפאון.\n\n**הסבר לפי ארבעת התנאים לקיפאון:**\n1.  **מניעה הדדית (Mutual Exclusion):** מתקיים. כל מנעול (mutex) מאפשר לתהליך אחד בלבד להחזיק בו בו-זמנית. משאבים X ו-Y הם בלעדיים.\n2.  **החזקה והמתנה (Hold and Wait):** מתקיים. תהליך P1 מחזיק במנעול X וממתין למנעול Y. תהליך P2 מחזיק במנעול Y וממתין למנעול X.\n3.  **אי-נשללות (No Preemption):** מתקיים. המנעולים אינם ניתנים להילקח בכוח מתהליך שמחזיק בהם; רק התהליך המחזיק יכול לשחרר אותם.\n4.  **המתנה מעגלית (Circular Wait):** מתקיים. P1 ממתין למשאב המוחזק על ידי P2, ו-P2 ממתין למשאב המוחזק על ידי P1. נוצר מעגל המתנה: P1 -> P2 -> P1.\n\n### סעיף 1.2: אסטרטגיה למניעת קיפאון ומימוש\n**אסטרטגיה למניעת קיפאון:** הזמנה סדרתית של משאבים (Resource Ordering).\nעל מנת למנוע קיפאון, נקבע סדר גלובלי לרכישת המשאבים. לדוגמה, כל התהליכים ירכשו תמיד את `mutex_X` לפני `mutex_Y`. גישה זו מבטלת את תנאי ההמתנה המעגלית.\n\n**מימוש הפונקציות:**\n```c\npthread_mutex_t mutex_X; // מגן על משאב X\npthread_mutex_t mutex_Y; // מגן על משאב Y\n\nvoid acquire_resources() {\n    pthread_mutex_lock(&mutex_X); // רוכש תמיד את מנעול X ראשון\n    pthread_mutex_lock(&mutex_Y); // רוכש את מנעול Y שני\n}\n\nvoid release_resources() {\n    pthread_mutex_unlock(&mutex_Y); // משחרר את מנעול Y (בסדר הפוך לרכישה)\n    pthread_mutex_unlock(&mutex_X); // משחרר את מנעול X (בסדר הפוך לרכישה)\n}\n```\n**הערה:** יש לשחרר את המנעולים בסדר הפוך לסדר הרכישה כדי למנוע מצבי מירוץ ולשחרר את המשאבים כראוי.\n\n### סעיף 1.3: ניתוח השפעת האסטרטגיה\n**ניתוח השפעת האסטרטגיה:**\n\n**מקביליות (Concurrency):** אסטרטגיה זו עלולה להפחית את רמת המקביליות במערכת. אם תהליכים רבים זקוקים למשאבים X ו-Y, הם יתחרו כולם על `mutex_X` תחילה. תהליך אחד ירכוש את `mutex_X`, ולאחר מכן את `mutex_Y`. רק לאחר שישחרר את שניהם, יוכל תהליך אחר לרכוש את `mutex_X`. ייתכנו מקרים שבהם `mutex_Y` פנוי, אך תהליך נאלץ להמתין לשחרור `mutex_X` לפני שיוכל לרכוש את `mutex_Y`.\n\n**ניצול משאבים (Resource Utilization):** ניצול המשאבים עלול להיפגע. אם תהליך רוכש את `mutex_X` וממתין זמן רב לרכישת `mutex_Y` (או להיפך, אם הסדר היה הפוך), `mutex_X` יהיה תפוס ללא שימוש יעיל בזמן ההמתנה. זה יכול להוביל למשאבים שאינם בשימוש למרות שהם זמינים, רק בגלל סדר הרכישה הכפוי.\n\n**חסרונות נוספים לגישה זו:**\n1.  **מורכבות ביישום ובאכיפה:** דורש הקפדה קפדנית על סדר הרכישה בכל מקום בקוד שבו נדרשים משאבים אלו. במידה ונוספים משאבים או משתנה הדרישה, יש לעדכן את סדר הרכישה הגלובלי, וכל סטייה מהסדר עלולה להחזיר את בעיית הקיפאון.\n2.  **קשיים בהרחבה (Scalability):** במערכות עם סוגי משאבים רבים, קביעת סדר גלובלי אופטימלי ויעיל יכולה להיות קשה מאוד או בלתי אפשרית לניהול.\n3.  **הגבלת גמישות:** מגביל את הגמישות של התהליכים ברכישת משאבים בהתאם לצרכים הספציפיים שלהם או לזמינות המשאבים, מה שעלול להפחית את היעילות במקרים מסוימים שבהם סדר שונה היה יעיל יותר."
    },
    "difficulty_estimation": "Hard"
  }
}