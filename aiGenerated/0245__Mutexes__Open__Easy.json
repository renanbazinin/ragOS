{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:13:37",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2084,
      "output_tokens": 1034,
      "total_tokens": 4885
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Mutexes",
      "Synchronization",
      "Race Conditions"
    ],
    "content": {
      "text": "מהו Mutex ומדוע הוא נחוץ במערכות מרובות חוטים? הסבר כיצד Mutex פועל כדי למנוע תנאי מירוץ. הצג דוגמת קוד פשוטה ב-C/C++ הממחישה שימוש ב-Mutex להגנה על מונה משותף המעודכן על ידי מספר חוטים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "Mutex (קיצור של Mutual Exclusion) הוא מנגנון סנכרון המשמש במערכות מרובות חוטים (multi-threaded) כדי להבטיח שרק חוט אחד יוכל לגשת לקטע קוד קריטי או למשאב משותף (כמו משתנה גלובלי, קובץ, או מבנה נתונים) בכל רגע נתון. זה מונע 'תנאי מירוץ' (race conditions) שבהם סדר הגישה הלא מבוקר של חוטים מרובים למשאב משותף יכול להוביל לתוצאות שגויות או בלתי צפויות. Mutex פועל על ידי מתן 'נעילה' (lock) לחוט המבקש לגשת למשאב. אם המשאב נעול, חוטים אחרים המנסים לגשת אליו ימתינו עד שהחוט הנוכחי ישחרר את הנעילה (unlock).\n\nדוגמת קוד ב-C/C++ הממחישה שימוש ב-Mutex להגנה על מונה משותף:\n\n```c\n#include <iostream>\n#include <pthread.h>\n#include <vector>\n\n// משאב משותף\nint shared_counter = 0;\n\n// Mutex להגנה על המונה המשותף\npthread_mutex_t counter_mutex;\n\n// פונקציית החוט\nvoid* increment_counter(void* arg) {\n    for (int i = 0; i < 100000; ++i) {\n        // נעל את המוטקס לפני הגישה לקטע הקריטי\n        pthread_mutex_lock(&counter_mutex);\n        shared_counter++; // קטע קריטי\n        // שחרר את המוטקס לאחר סיום הגישה לקטע הקריטי\n        pthread_mutex_unlock(&counter_mutex);\n    }\n    return NULL;\n}\n\nint main() {\n    // אתחול המוטקס\n    pthread_mutex_init(&counter_mutex, NULL);\n\n    const int NUM_THREADS = 5;\n    std::vector<pthread_t> threads(NUM_THREADS);\n\n    // יצירת והפעלת החוטים\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, increment_counter, NULL);\n    }\n\n    // המתנה לסיום כל החוטים\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    // השמדת המוטקס\n    pthread_mutex_destroy(&counter_mutex);\n\n    // הדפסת הערך הסופי של המונה המשותף\n    std::cout << \"Final shared counter value: \" << shared_counter << std::endl;\n    // הערך הצפוי הוא 5 * 100000 = 500000\n\n    return 0;\n}\n```\nבדוגמה זו, `pthread_mutex_lock` מבטיח שרק חוט אחד יכול להיכנס לקטע שבו `shared_counter` מוגדל. חוטים אחרים שינסו לקרוא ל-`pthread_mutex_lock` כאשר המוטקס כבר נעול, ימתינו עד שהמוטקס ישוחרר על ידי `pthread_mutex_unlock`."
    },
    "difficulty_estimation": "Easy"
  }
}