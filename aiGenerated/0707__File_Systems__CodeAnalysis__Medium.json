{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 23:46:00",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2680,
      "output_tokens": 3700,
      "total_tokens": 11945
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "File Systems",
      "Inodes",
      "Disk Management",
      "Block Allocation"
    ],
    "content": {
      "text": "קובץ במערכת הפעלה מיוצג על ידי Inode המכיל מידע על הקובץ, כולל מצביעים לבלוקי הנתונים שלו על הדיסק. נתונה מערכת קבצים בה גודל בלוק הוא 4096 בתים. מבנה ה-Inode כולל 12 מצביעים ישירים, מצביע עקיף יחיד (Single Indirect), ומצביע עקיף כפול (Double Indirect). מצביע עקיף יחיד מצביע לבלוק המכיל מצביעים לבלוקי נתונים. מצביע עקיף כפול מצביע לבלוק המכיל מצביעים לבלוקים של מצביעים, אשר בתורם מצביעים לבלוקי נתונים.\nמספר המצביעים בבלוק אחד הוא `BLOCK_SIZE / sizeof(int)`.\n\nנתונה הגדרת המבנה `inode_t` וחתימת הפונקציה `getBlockAddress`. עליכם להשלים את מימוש הפונקציה `getBlockAddress` כך שהיא תחזיר את הכתובת הפיזית של בלוק הנתונים המתאים למספר הבלוק הלוגי הנתון `logical_block_num`. אם הבלוק הלוגי אינו קיים (כלומר, הוא מחוץ לטווח הגודל המקסימלי הנתמך על ידי מבנה ה-inode, או שמצביע ביניים כלשהו אינו חוקי), הפונקציה צריכה להחזיר -1.\n\nיש להניח שקיימת פונקציית עזר `read_block_pointers(int block_address, int* buffer)` אשר קוראת בלוק שלם מהדיסק (המכיל מצביעים) אל תוך המערך `buffer` ומחזירה 0 בהצלחה, או -1 בכשל (למשל, כתובת בלוק לא חוקית). במקרה של כשל בקריאת בלוק מצביעים, יש להחזיר -1 מהפונקציה `getBlockAddress`.\n\n**שימו לב:** יש להתייחס רק למצביעים הישירים, העקיפים היחידים והעקיפים הכפולים כפי שהוגדרו. אין צורך להתייחס למצביעים עקיפים משולשים או יותר.",
      "code_snippet": "#include <stdio.h>\n\n#define BLOCK_SIZE 4096 // 4KB\n#define POINTERS_PER_BLOCK (BLOCK_SIZE / sizeof(int)) // Assuming int is 4 bytes, so 1024 pointers\n#define NUM_DIRECT_BLOCKS 12\n\ntypedef struct {\n    int direct_blocks[NUM_DIRECT_BLOCKS];\n    int single_indirect_block;            // Pointer to a block of pointers\n    int double_indirect_block;            // Pointer to a block of pointers to blocks of pointers\n    // For simplicity, assume these are initialized to 0 if not pointing to a valid block\n    // A real system would use a special value like -1 or 0 to indicate an unallocated block\n} inode_t;\n\n// Helper function signature (assume it's implemented elsewhere).\n// Reads a block of pointers from disk into 'buffer'.\n// Returns 0 on success, -1 on failure (e.g., invalid block_address).\n// For the purpose of this problem, assume 'buffer' is pre-allocated by the caller\n// to BLOCK_SIZE bytes and can hold POINTERS_PER_BLOCK integers.\nint read_block_pointers(int block_address, int* buffer);\n\n// Complete this function\nint getBlockAddress(inode_t* inode, int logical_block_num) {\n    // Your implementation here\n    return -1; // Placeholder\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון מחשב את הכתובת הפיזית של בלוק נתונים על בסיס מספר הבלוק הלוגי (logical_block_num) על ידי בחינת שלושה מקרים עיקריים:\n\n1.  **בלוקים ישירים (Direct Blocks):**\n    אם `logical_block_num` קטן מ-`NUM_DIRECT_BLOCKS` (במקרה זה 12), הבלוק הוא בלוק ישיר. הכתובת הפיזית נמצאת ישירות במערך `direct_blocks` של ה-inode. במקרה זה, הפונקציה `getBlockAddress` אינה דורשת גישות דיסק נוספות (בהנחה שה-inode כבר נטען לזיכרון).\n\n2.  **בלוקים עקיפים יחידים (Single Indirect Blocks):**\n    אם `logical_block_num` נמצא בטווח הבלוקים המכוסים על ידי המצביע העקיף היחיד (כלומר, אחרי הבלוקים הישירים ועד `POINTERS_PER_BLOCK` בלוקים נוספים), יש לגשת לבלוק המצביעים העקיף.\n    ראשית, נבדוק אם `inode->single_indirect_block` מצביע לבלוק חוקי (לא 0 או שלילי). אם לא, נחזיר -1.\n    לאחר מכן, נקצה זיכרון לחוצץ (`ptr_block`) בגודל של בלוק אחד (כדי להכיל את המצביעים) ונקרא את הבלוק הזה מהדיסק באמצעות `read_block_pointers` אל תוך החוצץ. אם הקריאה נכשלת או ההקצאה נכשלת, נחזיר -1.\n    ההיסט בתוך בלוק המצביעים מחושב על ידי `logical_block_num - NUM_DIRECT_BLOCKS`. הכתובת הפיזית של בלוק הנתונים היא הערך במיקום זה בחוצץ. במקרה זה, נדרשת גישת דיסק אחת לפונקציה `getBlockAddress` (כדי לקרוא את בלוק המצביעים העקיף).\n\n3.  **בלוקים עקיפים כפולים (Double Indirect Blocks):**\n    אם `logical_block_num` נמצא בטווח הבלוקים המכוסים על ידי המצביע העקיף הכפול (כלומר, אחרי הבלוקים העקיפים היחידים ועד `POINTERS_PER_BLOCK * POINTERS_PER_BLOCK` בלוקים נוספים), יש לגשת לשתי רמות של בלוקי מצביעים.\n    ראשית, נבדוק אם `inode->double_indirect_block` מצביע לבלוק חוקי. אם לא, נחזיר -1.\n    נקצה זיכרון לחוצץ `ptr_block_lvl1` ונקרא את בלוק המצביעים ברמה הראשונה (Level 1) מהדיסק. אם הקריאה או ההקצאה נכשלות, נחזיר -1.\n    נחשב את האינדקסים `idx1` ו-`idx2`. `idx1` הוא האינדקס בבלוק המצביעים ברמה הראשונה, ו-`idx2` הוא האינדקס בבלוק המצביעים ברמה השנייה אליו מצביע `ptr_block_lvl1[idx1]`.\n    נבדוק אם `ptr_block_lvl1[idx1]` מצביע לבלוק חוקי. אם לא, נשחרר זיכרון ונחזיר -1.\n    נקצה זיכרון לחוצץ `ptr_block_lvl2` ונקרא את בלוק המצביעים ברמה השנייה (Level 2) מהדיסק. אם הקריאה או ההקצאה נכשלות, נשחרר זיכרון ונחזיר -1.\n    הכתובת הפיזית של בלוק הנתונים היא הערך במיקום `idx2` בחוצץ של בלוק המצביעים ברמה השנייה. במקרה זה, נדרשות שתי גישות דיסק לפונקציה `getBlockAddress` (אחת לבלוק המצביעים ברמה הראשונה, ואחת לבלוק המצביעים ברמה השנייה).\n\nבכל המקרים, אם `logical_block_num` חורג מהטווח המקסימלי הנתמך על ידי מבנה ה-inode, או אם מצביע ביניים כלשהו אינו חוקי (למשל, 0 או שלילי), הפונקציה תחזיר -1. יש שימוש ב-`malloc` כדי להקצות זיכרון לחוצצי המצביעים באופן זמני, וב-`free` כדי לשחררם לאחר השימוש בהם.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h> // For malloc, free\n\n#define BLOCK_SIZE 4096 // 4KB\n#define POINTERS_PER_BLOCK (BLOCK_SIZE / sizeof(int)) // Assuming int is 4 bytes, so 1024 pointers\n#define NUM_DIRECT_BLOCKS 12\n\ntypedef struct {\n    int direct_blocks[NUM_DIRECT_BLOCKS];\n    int single_indirect_block;            // Pointer to a block of pointers\n    int double_indirect_block;            // Pointer to a block of pointers to blocks of pointers\n} inode_t;\n\n// Mock helper function for demonstration. In a real scenario, this would interact with disk.\n// For the purpose of the exam question, it's just a signature.\n// For the solution, we assume it exists and works as described.\nint read_block_pointers(int block_address, int* buffer) {\n    // In a real system, this would read from disk into the buffer.\n    // For this problem, we just need to know it provides the array of pointers.\n    // We'll return 0 for success, and -1 for an invalid address or read error.\n    if (block_address <= 0) { // Assuming block addresses are positive integers\n        return -1; \n    }\n    // Simulate populating buffer with some values if necessary for testing,\n    // but for the logic of getBlockAddress, we just need the function signature.\n    return 0; // Success\n}\n\nint getBlockAddress(inode_t* inode, int logical_block_num) {\n    // 1. Direct blocks\n    if (logical_block_num < NUM_DIRECT_BLOCKS) {\n        // Ensure the direct block pointer is valid (not 0 or -1, assuming 0 is invalid)\n        if (inode->direct_blocks[logical_block_num] <= 0) {\n            return -1;\n        }\n        return inode->direct_blocks[logical_block_num];\n    }\n\n    // 2. Single Indirect blocks\n    int single_indirect_start = NUM_DIRECT_BLOCKS;\n    int single_indirect_end = single_indirect_start + POINTERS_PER_BLOCK;\n    if (logical_block_num >= single_indirect_start && logical_block_num < single_indirect_end) {\n        // Check if the single indirect block pointer itself is valid\n        if (inode->single_indirect_block <= 0) {\n            return -1;\n        }\n\n        int* ptr_block = (int*)malloc(BLOCK_SIZE);\n        if (ptr_block == NULL) {\n            return -1; // Memory allocation failed\n        }\n\n        // Read the single indirect block from disk\n        if (read_block_pointers(inode->single_indirect_block, ptr_block) == -1) {\n            free(ptr_block);\n            return -1; // Failed to read indirect block\n        }\n        \n        int offset_in_indirect_block = logical_block_num - single_indirect_start;\n        // Ensure the pointer within the indirect block is valid\n        if (ptr_block[offset_in_indirect_block] <= 0) {\n            free(ptr_block);\n            return -1;\n        }\n\n        int block_address = ptr_block[offset_in_indirect_block];\n        free(ptr_block);\n        return block_address;\n    }\n\n    // 3. Double Indirect blocks\n    int double_indirect_start = single_indirect_end;\n    int double_indirect_end = double_indirect_start + (POINTERS_PER_BLOCK * POINTERS_PER_BLOCK);\n    if (logical_block_num >= double_indirect_start && logical_block_num < double_indirect_end) {\n        // Check if the double indirect block pointer itself is valid\n        if (inode->double_indirect_block <= 0) {\n            return -1;\n        }\n\n        int* ptr_block_lvl1 = (int*)malloc(BLOCK_SIZE);\n        if (ptr_block_lvl1 == NULL) {\n            return -1; // Memory allocation failed\n        }\n\n        // Read the first level indirect block (which contains pointers to other indirect blocks)\n        if (read_block_pointers(inode->double_indirect_block, ptr_block_lvl1) == -1) {\n            free(ptr_block_lvl1);\n            return -1; // Failed to read first level indirect block\n        }\n\n        int offset_from_double_indirect_start = logical_block_num - double_indirect_start;\n        int idx1 = offset_from_double_indirect_start / POINTERS_PER_BLOCK; // Index in the first level indirect block\n        int idx2 = offset_from_double_indirect_start % POINTERS_PER_BLOCK; // Index in the second level indirect block\n\n        // Check if the pointer at idx1 in the first level indirect block is valid\n        if (idx1 >= POINTERS_PER_BLOCK || ptr_block_lvl1[idx1] <= 0) {\n            free(ptr_block_lvl1);\n            return -1;\n        }\n\n        int* ptr_block_lvl2 = (int*)malloc(BLOCK_SIZE);\n        if (ptr_block_lvl2 == NULL) {\n            free(ptr_block_lvl1); // Clean up previously allocated memory\n            return -1; // Memory allocation failed\n        }\n\n        // Read the second level indirect block (which contains pointers to data blocks)\n        if (read_block_pointers(ptr_block_lvl1[idx1], ptr_block_lvl2) == -1) {\n            free(ptr_block_lvl1);\n            free(ptr_block_lvl2);\n            return -1; // Failed to read second level indirect block\n        }\n\n        // Ensure the pointer within the second level indirect block is valid\n        if (ptr_block_lvl2[idx2] <= 0) {\n            free(ptr_block_lvl1);\n            free(ptr_block_lvl2);\n            return -1;\n        }\n\n        int block_address = ptr_block_lvl2[idx2];\n        free(ptr_block_lvl1);\n        free(ptr_block_lvl2);\n        return block_address;\n    }\n\n    // Logical block number is out of the range supported by this inode structure\n    return -1;\n}"
    },
    "difficulty_estimation": "Medium"
  }
}