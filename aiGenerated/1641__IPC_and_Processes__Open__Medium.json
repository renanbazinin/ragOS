{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 19:40:18",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2411,
      "output_tokens": 2902,
      "total_tokens": 9410
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "IPC",
      "Processes",
      "Pipes"
    ],
    "content": {
      "text": "נתונה תוכנית C הבאה המשתמשת במנגנוני IPC ליצירת תקשורת בין תהליכים. התוכנית יוצרת תהליך בן (child process) באמצעות `fork()`. תהליך האב שולח סדרה של מספרים שלמים לתהליך הבן דרך צינור (pipe) אחד. תהליך הבן קורא את המספרים, מחשב את סכומם, ושולח את הסכום בחזרה לתהליך האב דרך צינור שני. תהליך האב מדפיס את הסכום שהתקבל.\n\nהשלימו את הקוד החסר בתוכנית C הבאה כך שתקיים את דרישות התקשורת בין תהליך האב לתהליך הבן כפי שתוארו לעיל. הסבירו בקצרה כל חלק שהוספתם וכיצד הוא תורם לתקשורת בין התהליכים.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define MAX_NUMBERS 5\n\nint main() {\n    int pipe_parent_to_child[2]; // Parent writes, child reads\n    int pipe_child_to_parent[2]; // Child writes, parent reads\n    pid_t pid;\n    int numbers[MAX_NUMBERS] = {10, 20, 30, 40, 50};\n    int sum = 0; // Used by both parent (to print) and child (to calculate)\n\n    // Create the first pipe\n    if (pipe(pipe_parent_to_child) == -1) {\n        perror(\"pipe_parent_to_child failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Create the second pipe\n    if (pipe(pipe_child_to_parent) == -1) {\n        perror(\"pipe_child_to_parent failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        // Close unused pipe ends\n        close(pipe_parent_to_child[1]); // Child doesn't write to this pipe\n        close(pipe_child_to_parent[0]); // Child doesn't read from this pipe\n\n        // Read numbers from parent and sum them\n        // ... (missing code for reading and summing) ...\n\n        // Write sum back to parent\n        // ... (missing code for writing sum) ...\n\n        close(pipe_parent_to_child[0]);\n        close(pipe_child_to_parent[1]);\n        exit(EXIT_SUCCESS);\n    } else { // Parent process\n        // Close unused pipe ends\n        close(pipe_parent_to_child[0]); // Parent doesn't read from this pipe\n        close(pipe_child_to_parent[1]); // Parent doesn't write to this pipe\n\n        // Write numbers to child\n        // ... (missing code for writing numbers) ...\n\n        // Read sum from child\n        // ... (missing code for reading sum) ...\n\n        printf(\"Parent received sum: %d\\n\", sum);\n\n        close(pipe_parent_to_child[1]);\n        close(pipe_child_to_parent[0]);\n        wait(NULL); // Wait for child to terminate\n        exit(EXIT_SUCCESS);\n    }\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון כולל השלמת הקוד החסר בתוכנית C, ובפרט את קריאות ה-`read()` וה-`write()` המתאימות, ואת לוגיקת החישוב בתהליך הבן.\n\n**השלמת הקוד:**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define MAX_NUMBERS 5\n\nint main() {\n    int pipe_parent_to_child[2]; // Parent writes, child reads\n    int pipe_child_to_parent[2]; // Child writes, parent reads\n    pid_t pid;\n    int numbers[MAX_NUMBERS] = {10, 20, 30, 40, 50};\n    int sum = 0; // Used by both parent (to print) and child (to calculate)\n\n    // Create the first pipe\n    if (pipe(pipe_parent_to_child) == -1) {\n        perror(\"pipe_parent_to_child failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Create the second pipe\n    if (pipe(pipe_child_to_parent) == -1) {\n        perror(\"pipe_child_to_parent failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        // Close unused pipe ends\n        close(pipe_parent_to_child[1]); // Child doesn't write to this pipe\n        close(pipe_child_to_parent[0]); // Child doesn't read from this pipe\n\n        // Read numbers from parent and sum them\n        int received_num;\n        for (int i = 0; i < MAX_NUMBERS; i++) {\n            read(pipe_parent_to_child[0], &received_num, sizeof(int));\n            sum += received_num;\n        }\n\n        // Write sum back to parent\n        write(pipe_child_to_parent[1], &sum, sizeof(int));\n\n        close(pipe_parent_to_child[0]);\n        close(pipe_child_to_parent[1]);\n        exit(EXIT_SUCCESS);\n    } else { // Parent process\n        // Close unused pipe ends\n        close(pipe_parent_to_child[0]); // Parent doesn't read from this pipe\n        close(pipe_child_to_parent[1]); // Parent doesn't write to this pipe\n\n        // Write numbers to child\n        for (int i = 0; i < MAX_NUMBERS; i++) {\n            write(pipe_parent_to_child[1], &numbers[i], sizeof(int));\n        }\n\n        // Read sum from child\n        read(pipe_child_to_parent[0], &sum, sizeof(int));\n\n        printf(\"Parent received sum: %d\\n\", sum);\n\n        close(pipe_parent_to_child[1]);\n        close(pipe_child_to_parent[0]);\n        wait(NULL); // Wait for child to terminate\n        exit(EXIT_SUCCESS);\n    }\n    return 0;\n}\n```\n\n**הסבר:**\n\n1.  **יצירת צינורות (`pipe()`):**\n    *   `pipe(pipe_parent_to_child)`: יוצר צינור שמשמש לתקשורת מהאב לבן. `pipe_parent_to_child[0]` הוא קצה הקריאה, ו-`pipe_parent_to_child[1]` הוא קצה הכתיבה.\n    *   `pipe(pipe_child_to_parent)`: יוצר צינור שני, שמשמש לתקשורת מהבן לאב. `pipe_child_to_parent[0]` הוא קצה הקריאה, ו-`pipe_child_to_parent[1]` הוא קצה הכתיבה.\n    *   כל קריאה ל-`pipe()` יוצרת זוג מתארי קבצים (file descriptors) - אחד לקריאה ואחד לכתיבה.\n\n2.  **יצירת תהליך בן (`fork()`):**\n    *   `fork()` משכפל את תהליך האב ויוצר תהליך בן. לשני התהליכים יש עותקים של כל מתארי הקבצים הפתוחים, כולל אלו של הצינורות.\n\n3.  **סגירת קצוות צינורות לא בשימוש:**\n    *   **בתהליך הבן (`if (pid == 0)`):**\n        *   `close(pipe_parent_to_child[1])`: הבן לא כותב לצינור שנועד לקבל נתונים מהאב. סגירת קצה הכתיבה חשובה כדי שקריאות ה-`read()` של הבן ידעו מתי האב סיים לכתוב (ויחזירו 0).\n        *   `close(pipe_child_to_parent[0])`: הבן לא קורא מהצינור שנועד לשלוח נתונים לאב.\n    *   **בתהליך האב (`else`):**\n        *   `close(pipe_parent_to_child[0])`: האב לא קורא מהצינור שנועד לשלוח נתונים לבן.\n        *   `close(pipe_child_to_parent[1])`: האב לא כותב לצינור שנועד לקבל נתונים מהבן.\n    *   סגירת הקצוות הלא נחוצים מבטיחה שהתהליכים לא יחסמו באופן בלתי צפוי ומאפשרת ל-`read()` לזהות מתי הצד השני סיים לכתוב.\n\n4.  **תקשורת בין תהליכים:**\n    *   **אב לבן (דרך `pipe_parent_to_child`):**\n        *   **אב:** לולאת `for` משתמשת ב-`write(pipe_parent_to_child[1], &numbers[i], sizeof(int))` כדי לשלוח כל מספר מהמערך `numbers` אל הבן.\n        *   **בן:** לולאת `for` משתמשת ב-`read(pipe_parent_to_child[0], &received_num, sizeof(int))` כדי לקרוא את המספרים אחד אחרי השני.\n    *   **בן לאב (דרך `pipe_child_to_parent`):**\n        *   **בן:** לאחר חישוב הסכום, הבן משתמש ב-`write(pipe_child_to_parent[1], &sum, sizeof(int))` כדי לשלוח את הסכום הסופי לאב.\n        *   **אב:** קורא את הסכום באמצעות `read(pipe_child_to_parent[0], &sum, sizeof(int))` ומדפיס אותו.\n\n5.  **המתנה לבן (`wait(NULL)`):**\n    *   בתהליך האב, `wait(NULL)` גורם לאב להמתין שהתהליך הבן יסיים את ריצתו לפני שהאב עצמו מסתיים. זה מונע יצירת \"תהליכי זומבי\" (zombie processes) ומבטיח שהאב יקבל את הסכום מהבן לפני סיום.\n\nהקוד משתמש בשני צינורות דו-כיווניים (אחד לכל כיוון) כדי להבטיח תקשורת יעילה וברורה בין האב לבן, כאשר כל צד יודע מתי לצפות לנתונים ומתי לכתוב אותם."
    },
    "difficulty_estimation": "Medium"
  }
}