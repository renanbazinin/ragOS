{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory and Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:55:04",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2792,
      "output_tokens": 3676,
      "total_tokens": 12485
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Paging",
      "Memory Protection",
      "Signals",
      "mmap",
      "mprotect",
      "SIGSEGV"
    ],
    "content": {
      "text": "נתונה תוכנית C המבצעת פעולות ניהול זיכרון וטיפול באותות. התוכנית מקצה דף זיכרון, משנה את הרשאות הגישה אליו, ומנסה לכתוב אליו. קיים גם מטפל (handler) לאות SIGSEGV. יש לנתח את הקוד ולהבין את התנהגותו במערכת הפעלה המשתמשת בזיכרון וירטואלי ובדפדוף (Paging).\n\nבהנחה שכל קריאות המערכת מצליחות, ושהמערכת תומכת בהתנהגות סטנדרטית של טיפול באותות (כלומר, חזרה ממטפל SIGSEGV גורמת לניסיון חוזר של הפקודה שגרמה לכשל הגישה לזיכרון), ענו על השאלות הבאות:\n\n1. מה יהיה הפלט המדויק של התוכנית? (יש להניח שכתובות הזיכרון המודפסות יהיו כלשהן, אך יש לדייק בשאר הפלט).\n2. כמה פעמים יופעל מטפל ה-SIGSEGV? הסבירו מדוע.\n3. הסבירו בפירוט את מנגנוני הזיכרון הווירטואלי (כגון טבלת דפים, MMU, TLB, כשל דף) המעורבים בכל שלב בתוכנית, החל מהקצאת הזיכרון ועד לסיום הריצה.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <signal.h>\n#include <string.h>\n\n#define PAGE_SIZE 4096\n\nvolatile int sigsegv_count = 0;\nchar *fault_page = NULL;\n\nvoid sigsegv_handler(int signum, siginfo_t *info, void *context) {\n    printf(\"SIGSEGV handler invoked! Fault address: %p\\n\", info->si_addr);\n    sigsegv_count++;\n\n    // Change page permissions to read-write\n    if (mprotect(fault_page, PAGE_SIZE, PROT_READ | PROT_WRITE) == -1) {\n        perror(\"mprotect in handler failed\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Page permissions changed to R/W.\\n\");\n    // Returning from the handler will cause the faulting instruction to be re-executed.\n}\n\nint main() {\n    struct sigaction sa;\n    sa.sa_flags = SA_SIGINFO; // Use sa_sigaction for the handler\n    sa.sa_sigaction = sigsegv_handler;\n    sigemptyset(&sa.sa_mask);\n\n    if (sigaction(SIGSEGV, &sa, NULL) == -1) {\n        perror(\"sigaction\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Allocate a page of memory\n    fault_page = (char *)mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (fault_page == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Page allocated at address: %p\\n\", fault_page);\n\n    // Initialize the page\n    *fault_page = 'A';\n    printf(\"Initial write to page successful: %c\\n\", *fault_page);\n\n    // Set page permissions to read-only\n    if (mprotect(fault_page, PAGE_SIZE, PROT_READ) == -1) {\n        perror(\"mprotect to read-only\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Page permissions set to PROT_READ.\\n\");\n\n    printf(\"Attempting to write to read-only page...\\n\");\n    // This write will cause a SIGSEGV\n    *fault_page = 'B'; // This is the faulting instruction\n\n    printf(\"Write after first fault successful: %c\\n\", *fault_page);\n\n    printf(\"Attempting another write to page...\\n\");\n    // This write should succeed without a SIGSEGV\n    *(fault_page + 1) = 'C';\n    printf(\"Second write successful. Content: %c%c\\n\", *fault_page, *(fault_page + 1));\n\n    printf(\"Total SIGSEGV handler invocations: %d\\n\", sigsegv_count);\n\n    if (munmap(fault_page, PAGE_SIZE) == -1) {\n        perror(\"munmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. **פלט התוכנית:**\nהפלט המדויק יהיה כדלקמן (כתובת הזיכרון תהיה שונה בכל הרצה):\n\n```\nPage allocated at address: 0x...\nInitial write to page successful: A\nPage permissions set to PROT_READ.\nAttempting to write to read-only page...\nSIGSEGV handler invoked! Fault address: 0x...\nPage permissions changed to R/W.\nWrite after first fault successful: B\nAttempting another write to page...\nSecond write successful. Content: BC\nTotal SIGSEGV handler invocations: 1\n```\n\n2. **מספר הפעלות של מטפל ה-SIGSEGV:**\nמטפל ה-SIGSEGV יופעל פעם אחת בלבד. הסיבה לכך היא:\n*   הקריאה הראשונה `*fault_page = 'A'` מצליחה מכיוון שהדף הוקצה עם הרשאות קריאה וכתיבה (`PROT_READ | PROT_WRITE`).\n*   לאחר מכן, `mprotect` משנה את הרשאות הדף ל-`PROT_READ` בלבד.\n*   הניסיון הבא לכתוב לדף באמצעות `*fault_page = 'B'` גורם לכשל גישה (protection fault), מכיוון שניסיון כתיבה לדף עם הרשאות קריאה בלבד אינו חוקי. כשל זה מעורר אות SIGSEGV.\n*   מטפל ה-SIGSEGV נקרא. בתוכו, אנו משנים את הרשאות הדף בחזרה ל-`PROT_READ | PROT_WRITE` באמצעות קריאת `mprotect`.\n*   כאשר מטפל SIGSEGV חוזר (returns), ברירת המחדל במערכות לינוקס עבור כשל גישה לזיכרון היא לנסות מחדש את הפקודה שגרמה לכשל. כעת, כשהרשאות הדף שונו ל-R/W, ניסיון הכתיבה `*fault_page = 'B'` יצליח.\n*   לאחר מכן, התוכנית ממשיכה כרגיל, וניסיון הכתיבה השני `*(fault_page + 1) = 'C'` יצליח גם הוא ללא כשל נוסף.\n\n3. **מנגנוני הזיכרון הווירטואלי המעורבים:**\n\n*   **`mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)`:**\n    *   זוהי קריאת מערכת המבקשת להקצות דף זיכרון וירטואלי חדש (בגודל `PAGE_SIZE`).\n    *   `MAP_ANONYMOUS` מציין שזהו דף שאינו ממופה מקובץ, ו-`MAP_PRIVATE` שהוא פרטי לתהליך.\n    *   מערכת ההפעלה מוצאת אזור פנוי במרחב הכתובות הווירטואלי של התהליך ומחזירה כתובת וירטואלית.\n    *   בשלב זה, הדף הפיזי עצמו ייתכן שעדיין לא הוקצה, אלא רק \"הוזמן\". כאשר תתבצע הגישה הראשונה לדף (כמו `*fault_page = 'A'`), יתרחש כשל דף (page fault) מסוג \"minor fault\" (אם הדף עדיין לא הוקצה פיזית).\n    *   מערכת ההפעלה תאלץ להקצות דף פיזי פנוי, לאפס אותו (במקרה של `MAP_ANONYMOUS`), ולעדכן את טבלת הדפים (Page Table) של התהליך כך שהערך המתאים בטבלה יצביע על הדף הפיזי החדש, עם הרשאות קריאה וכתיבה (R/W) כפי שצוין ב-`PROT_READ | PROT_WRITE`.\n    *   ערך TLB (Translation Lookaside Buffer) חדש יתווסף עבור הכתובת הווירטואלית הזו, המצביע על הכתובת הפיזית ומכיל את הרשאות ה-R/W.\n\n*   **`*fault_page = 'A';`:**\n    *   המעבד מנסה לכתוב לכתובת וירטואלית.\n    *   יחידת ניהול הזיכרון (MMU) מנסה לתרגם את הכתובת הווירטואלית לכתובת פיזית.\n    *   ה-MMU בודקת תחילה את ה-TLB. אם הכתובת נמצאת ב-TLB, התרגום מהיר. אחרת, ה-MMU עוברת לטבלת הדפים בזיכרון הראשי.\n    *   במקרה זה, לאחר ה-`mmap` והגישה הראשונה, הערך נמצא ב-TLB (או נמצא בטבלת הדפים ועודכן ב-TLB) עם הרשאות R/W.\n    *   ה-MMU מאשרת שהגישה היא כתיבה והרשאות הדף מאפשרות כתיבה.\n    *   הכתיבה לדף הפיזי מתבצעת.\n\n*   **`mprotect(fault_page, PAGE_SIZE, PROT_READ)`:**\n    *   קריאת מערכת זו משנה את הרשאות הגישה לדף הזיכרון הווירטואלי `fault_page`.\n    *   מערכת ההפעלה מעדכנת את הערך המתאים בטבלת הדפים של התהליך, ומשנה את הרשאות הגישה ל-`PROT_READ` (קריאה בלבד).\n    *   שינוי הרשאות בטבלת הדפים מחייב ביטול (invalidation) של כל ערכי TLB קיימים עבור הדף הזה, מכיוון שהם עלולים להכיל מידע מיושן (הרשאות R/W). ה-MMU תאלץ לטעון מחדש את הערך מטבלת הדפים בגישה הבאה.\n\n*   **`*fault_page = 'B';` (הניסיון הראשון):**\n    *   המעבד מנסה לכתוב לכתובת וירטואלית.\n    *   ה-MMU מנסה לתרגם את הכתובת. ייתכן שהערך אינו ב-TLB (בגלל ה-invalidation מ-`mprotect`), אז הוא נטען מטבלת הדפים.\n    *   ה-MMU מוצאת שהרשאות הדף הן `PROT_READ`.\n    *   מכיוון שהגישה היא כתיבה והרשאות הדף אינן מאפשרות כתיבה, ה-MMU מדווחת על כשל הגנה (protection fault) למעבד.\n    *   המעבד עובר למצב קרנל (kernel mode) ומעלה חריגה (exception).\n    *   מערכת ההפעלה מזהה את החריגה ככשל דף (page fault) מסוג הגנה, ושולחת אות `SIGSEGV` לתהליך.\n\n*   **`sigsegv_handler`:**\n    *   התהליך עובר למצב קרנל (או חוזר אליו אם היה במצב קרנל), ואז מערכת ההפעלה מעבירה את הבקרה למטפל האותות שהותקן על ידי התהליך.\n    *   המטפל מבצע את הפעולות שבו: מדפיס הודעות, מעדכן מונה.\n    *   **`mprotect(fault_page, PAGE_SIZE, PROT_READ | PROT_WRITE)` (בתוך המטפל):**\n        *   קריאת מערכת זו משנה שוב את הרשאות הדף בטבלת הדפים ל-`PROT_READ | PROT_WRITE`.\n        *   שוב, כל ערכי TLB קיימים עבור הדף מבוטלים.\n    *   כאשר המטפל חוזר, מערכת ההפעלה מזהה שהאות נבע מכשל גישה לזיכרון. במקרה זה, ברירת המחדל היא לנסות מחדש את הפקודה שגרמה לכשל.\n\n*   **`*fault_page = 'B';` (הניסיון החוזר):**\n    *   המעבד מנסה שוב לכתוב לאותה כתובת וירטואלית.\n    *   ה-MMU מנסה לתרגם את הכתובת. כעת, לאחר ה-`mprotect` במטפל, טבלת הדפים מכילה הרשאות `PROT_READ | PROT_WRITE`. הערך נטען ל-TLB.\n    *   ה-MMU מאשרת שהגישה היא כתיבה והרשאות הדף מאפשרות כתיבה.\n    *   הכתיבה לדף הפיזי מתבצעת בהצלחה.\n\n*   **`*(fault_page + 1) = 'C';`:**\n    *   פעולה זו מתרחשת לאחר שהדף כבר עם הרשאות R/W.\n    *   ה-MMU מוצאת את הרשאות R/W ב-TLB (או בטבלת הדפים) ומאפשרת את הכתיבה.\n    *   הכתיבה לדף הפיזי מתבצעת בהצלחה.\n\nהתוכנית מדגימה כיצד ניתן להשתמש ב-`mprotect` ובמטפלי SIGSEGV כדי לשנות את התנהגות הזיכרון בזמן ריצה, לדוגמה לצורך מימוש מנגנוני \"copy-on-write\" או טעינה עצלה (lazy loading) ברמת המשתמש."
    },
    "difficulty_estimation": "Hard"
  }
}