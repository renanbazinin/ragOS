{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Synchronization and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:57:55",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3054,
      "output_tokens": 3185,
      "total_tokens": 14255
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Deadlocks",
      "Resource Allocation",
      "Starvation",
      "Condition Variables",
      "Mutexes"
    ],
    "content": {
      "text": "נתונה מערכת המנהלת M סוגי משאבים, כאשר לכל סוג משאב R_j קיימים count[j] עותקים זמינים. תהליכים במערכת דורשים סט של משאבים: בקשה מוגדרת כווקטור (r_0, r_1, ..., r_{M-1}), שבו r_j מייצג את מספר העותקים הנדרשים מסוג המשאב R_j.\nמנהל המשאבים (Resource Manager) חייב להקצות את המשאבים רק אם כל העותקים הנדרשים מכל סוגי המשאבים זמינים להקצאה בו-זמנית. אם לא, התהליך המבקש ימתין עד שכל המשאבים יהיו זמינים.\nממשו את הפונקציות acquire_resources ו-release_resources עבור מנהל משאבים זה, תוך הבטחת:\n1. מניעת קיפאון (Deadlock Prevention): המערכת לעולם לא תיכנס למצב קיפאון.\n2. חופש מהרעבה (Starvation Freedom): אף תהליך הממתין למשאבים לא יורעב לעולם.\n\nהשתמשו באובייקטי סנכרון שנלמדו (mutexes, semaphores, condition variables). נתחו את המימוש שלכם והסבירו מדוע הוא עומד בדרישות.",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h> // For memcpy\n\n#define MAX_RESOURCE_TYPES 10\n\n// Structure to hold a pending request\ntypedef struct WaitingRequest {\n    int request[MAX_RESOURCE_TYPES];\n    pthread_cond_t cond; // Condition variable for this specific request\n    struct WaitingRequest *next;\n} WaitingRequest;\n\ntypedef struct {\n    int num_resource_types;\n    int total_available[MAX_RESOURCE_TYPES]; // Total instances of each resource type\n    int currently_available[MAX_RESOURCE_TYPES]; // Currently available instances\n\n    // Synchronization primitives and queue for waiting requests\n    pthread_mutex_t mutex;\n    WaitingRequest *wait_queue_head; // Head of the queue of waiting requests\n    WaitingRequest *wait_queue_tail; // Tail of the queue\n} ResourceManager;\n\n// Initialize the resource manager\nvoid init_resource_manager(ResourceManager *rm, int num_types, int initial_counts[]);\n\n// Acquire resources: request is an array where request[j] is the number of instances of R_j needed\nvoid acquire_resources(ResourceManager *rm, int request[]);\n\n// Release resources: released is an array where released[j] is the number of instances of R_j being released\nvoid release_resources(ResourceManager *rm, int released[]);\n\n// Destroy the resource manager\nvoid destroy_resource_manager(ResourceManager *rm);\n\n// --- Implementation to be filled by student ---"
    },
    "sub_questions": null,
    "points": 20,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "המימוש המוצע משתמש במבנה `ResourceManager` המכיל mutex גלובלי להגנה על המצב המשותף (כמות המשאבים הזמינים ותור ההמתנה), ובתור FIFO של בקשות ממתינות. כל בקשה ממתינה בתור מקבלת `pthread_cond_t` משלה כדי לאפשר ספציפיות בסימון (signaling).\n\n**מבנה הנתונים:**\n- `currently_available`: מערך המייצג את מספר העותקים הזמינים מכל סוג משאב.\n- `mutex`: מנעול להגנה על גישה למצב המשותף של מנהל המשאבים.\n- `wait_queue_head`, `wait_queue_tail`: מצביעים לראש ולזנב של רשימה מקושרת המהווה תור FIFO של בקשות ממתינות.\n- `WaitingRequest`: מבנה פנימי המייצג בקשה ממתינה, הכולל את וקטור המשאבים המבוקשים (`request`) ואת `pthread_cond_t` הספציפי לבקשה זו.\n\n**המימוש המלא:**\n```c\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h> // For memcpy\n\n#define MAX_RESOURCE_TYPES 10\n\n// Structure to hold a pending request\ntypedef struct WaitingRequest {\n    int request[MAX_RESOURCE_TYPES];\n    pthread_cond_t cond; // Condition variable for this specific request\n    struct WaitingRequest *next;\n} WaitingRequest;\n\ntypedef struct {\n    int num_resource_types;\n    int total_available[MAX_RESOURCE_TYPES]; // Total instances of each resource type\n    int currently_available[MAX_RESOURCE_TYPES]; // Currently available instances\n\n    // Synchronization primitives and queue for waiting requests\n    pthread_mutex_t mutex;\n    WaitingRequest *wait_queue_head; // Head of the queue of waiting requests\n    WaitingRequest *wait_queue_tail; // Tail of the queue\n} ResourceManager;\n\n// Helper function to check if resources are available for a given request\nbool _can_allocate(ResourceManager *rm, int request[]) {\n    for (int i = 0; i < rm->num_resource_types; i++) {\n        if (rm->currently_available[i] < request[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Helper function to allocate resources\nvoid _allocate(ResourceManager *rm, int request[]) {\n    for (int i = 0; i < rm->num_resource_types; i++) {\n        rm->currently_available[i] -= request[i];\n    }\n}\n\n// Helper function to deallocate resources\nvoid _deallocate(ResourceManager *rm, int released[]) {\n    for (int i = 0; i < rm->num_resource_types; i++) {\n        rm->currently_available[i] += released[i];\n    }\n}\n\n// Initialize the resource manager\nvoid init_resource_manager(ResourceManager *rm, int num_types, int initial_counts[]) {\n    rm->num_resource_types = num_types;\n    for (int i = 0; i < num_types; i++) {\n        rm->total_available[i] = initial_counts[i];\n        rm->currently_available[i] = initial_counts[i];\n    }\n    pthread_mutex_init(&rm->mutex, NULL);\n    rm->wait_queue_head = NULL;\n    rm->wait_queue_tail = NULL;\n}\n\n// Acquire resources\nvoid acquire_resources(ResourceManager *rm, int request[]) {\n    pthread_mutex_lock(&rm->mutex);\n\n    // First, check if resources are available immediately and no one is waiting ahead\n    // This specific check ensures new requests don't jump ahead of waiting ones.\n    if (rm->wait_queue_head == NULL && _can_allocate(rm, request)) {\n        _allocate(rm, request);\n        pthread_mutex_unlock(&rm->mutex);\n        return;\n    }\n\n    // Resources not immediately available or there are waiting requests.\n    // Create a new waiting request.\n    WaitingRequest *my_request = (WaitingRequest *)malloc(sizeof(WaitingRequest));\n    if (!my_request) {\n        perror(\"Failed to allocate WaitingRequest\");\n        exit(EXIT_FAILURE);\n    }\n    memcpy(my_request->request, request, sizeof(int) * rm->num_resource_types);\n    pthread_cond_init(&my_request->cond, NULL);\n    my_request->next = NULL;\n\n    // Add to the end of the wait queue\n    if (rm->wait_queue_tail == NULL) {\n        rm->wait_queue_head = my_request;\n        rm->wait_queue_tail = my_request;\n    } else {\n        rm->wait_queue_tail->next = my_request;\n        rm->wait_queue_tail = my_request;\n    }\n\n    // Wait until this specific request can be fulfilled and it's its turn (at the head of the queue)\n    while (rm->wait_queue_head != my_request || !_can_allocate(rm, request)) {\n        pthread_cond_wait(&my_request->cond, &rm->mutex);\n    }\n\n    // If we reached here, it means this request is at the head of the queue AND resources are available.\n    _allocate(rm, request);\n\n    // Remove this request from the queue\n    rm->wait_queue_head = my_request->next;\n    if (rm->wait_queue_head == NULL) {\n        rm->wait_queue_tail = NULL;\n    }\n\n    // Clean up the condition variable and the request struct\n    pthread_cond_destroy(&my_request->cond);\n    free(my_request);\n\n    // Now, try to wake up the next waiting request in line, if any\n    if (rm->wait_queue_head != NULL) {\n        pthread_cond_signal(&rm->wait_queue_head->cond);\n    }\n\n    pthread_mutex_unlock(&rm->mutex);\n}\n\n// Release resources\nvoid release_resources(ResourceManager *rm, int released[]) {\n    pthread_mutex_lock(&rm->mutex);\n\n    _deallocate(rm, released);\n\n    // After releasing resources, check if any waiting request can now be fulfilled.\n    // We only need to signal the head of the queue if it's waiting, as it's the \"next in line\".\n    // If the head of the queue can't be fulfilled, then it will wait again.\n    // If it *can* be fulfilled, it will proceed, and then signal the *new* head.\n    if (rm->wait_queue_head != NULL) {\n        pthread_cond_signal(&rm->wait_queue_head->cond);\n    }\n\n    pthread_mutex_unlock(&rm->mutex);\n}\n\n// Destroy the resource manager\nvoid destroy_resource_manager(ResourceManager *rm) {\n    pthread_mutex_destroy(&rm->mutex);\n    // In a real system, you'd also need to free any remaining WaitingRequest structs\n    // and destroy their condition variables if the queue is not empty on destroy.\n    // For this context, assuming the queue is empty or ignoring cleanup of pending requests is acceptable.\n}\n```\n\n**ניתוח עמידה בדרישות:**\n\n1.  **מניעת קיפאון (Deadlock Prevention):**\n    המימוש מונע קיפאון על ידי שבירת תנאי \"החזק והמתן\" (Hold and Wait). תהליך לעולם אינו מחזיק במשאבים מסוימים תוך כדי המתנה למשאבים אחרים. הוא תמיד מנסה להקצות את *כל* המשאבים המבוקשים בבת אחת. אם הוא אינו יכול להשיג את כולם, הוא ממתין מבלי להחזיק באף משאב. גישה זו, של \"הקצה הכל או כלום\" (All or Nothing), מבטיחה שאין מצב שבו תהליכים מחזיקים בחלק ממשאבים וממתינים לחלקים אחרים במעגל, ובכך מונעת את התנאי ההכרחי לקיפאון.\n\n2.  **חופש מהרעבה (Starvation Freedom):**\n    המימוש מבטיח חופש מהרעבה באמצעות תור ה-FIFO של בקשות ממתינות (`wait_queue_head`/`wait_queue_tail`). כאשר תהליך נכנס למצב המתנה, הוא מתווסף לסוף התור. תהליך יכול להקצות משאבים רק כאשר הוא נמצא בראש התור (`rm->wait_queue_head == my_request`) וגם המשאבים זמינים (`_can_allocate`). כאשר משאבים משוחררים (`release_resources`), רק התהליך שבדיוק בראש התור מקבל איתות (`pthread_cond_signal`) כדי שיוכל לבדוק שוב את התנאים. גישה זו מבטיחה שכל בקשה תטופל לפי סדר הגעתה, ולא תיתכן סיטואציה שבה בקשות חדשות \"קופצות\" מעל בקשות ישנות יותר הממתינות. גם אם בקשה בראש התור לא יכולה להתקדם עקב חוסר במשאבים, היא תישאר בראש התור ותקבל איתות בכל שחרור משאבים, ובסופו של דבר תתקדם כאשר המשאבים יהיו זמינים עבורה, ובכך מונעת הרעבה."
    },
    "difficulty_estimation": "Hard"
  }
}