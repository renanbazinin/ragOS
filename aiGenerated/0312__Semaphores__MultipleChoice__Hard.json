{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:42:46",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 970,
      "output_tokens": 893,
      "total_tokens": 4238
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Deadlock",
      "Bounded Buffer"
    ],
    "content": {
      "text": "נתונה מערכת המשתמשת במאגר חלופי (bounded buffer) בגודל N, ותהליכי יצרן (producer) וצרכן (consumer). לצורך סנכרון וגישה הדדית למאגר, נעשה שימוש בשלושה סמפורים:\n1.  `mutex`: סמפור בינארי, מאותחל ל-1, לגישה הדדית (mutual exclusion) למאגר.\n2.  `empty`: סמפור סופר, מאותחל ל-N, המייצג את מספר המקומות הפנויים במאגר.\n3.  `full`: סמפור סופר, מאותחל ל-0, המייצג את מספר המקומות המלאים במאגר.\n\nקוד היצרן (producer) נראה כך:\n```c\nvoid producer() {\n    while (true) {\n        // produce item\n        wait(mutex);\n        wait(empty);\n        // add item to buffer\n        signal(full);\n        signal(mutex);\n    }\n}\n```\nוקוד הצרכן (consumer) נראה כך:\n```c\nvoid consumer() {\n    while (true) {\n        wait(full);\n        wait(mutex);\n        // remove item from buffer\n        signal(mutex);\n        signal(empty);\n        // consume item\n    }\n}\n```\nאיזו מהטענות הבאות נכונה לגבי התנהגות המערכת במצב זה?",
      "code_snippet": null,
      "options": [
        "א. המערכת תפעל באופן תקין וללא בעיות סנכרון או קיפאון כלשהן.",
        "ב. המערכת עלולה להיכנס למצב קיפאון (deadlock) אם המאגר יתמלא לחלוטין.",
        "ג. המערכת עלולה להיכנס למצב קיפאון (deadlock) אם המאגר יתרוקן לחלוטין.",
        "ד. המערכת תאפשר גישה בו-זמנית למאגר (race condition) ובכך תפגע בשלמות הנתונים.",
        "ה. המערכת תמיד תעבוד, אך תהיה לא יעילה בשל סדר הפעולות השגוי בקוד היצרן."
      ]
    },
    "sub_questions": null,
    "points": 5,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "ב. סדר הפעולות בקוד היצרן שגוי. אם המאגר יתמלא לחלוטין, סמפור `empty` יהיה שווה ל-0. תהליך יצרן שיגיע בשלב זה יבצע `wait(mutex)`, יתפוס את המנעול, ולאחר מכן יבצע `wait(empty)`. מכיוון ש-`empty` הוא 0, היצרן יחסם (block) תוך כדי שהוא מחזיק את ה-`mutex`. כעת, אף תהליך צרכן לא יוכל לגשת למאגר כדי להסיר פריט (ולבצע `signal(empty)`), מכיוון שה-`mutex` תפוס על ידי היצרן החסום. מצב זה יוביל לקיפאון (deadlock). סדר הפעולות הנכון ליצרן הוא: `wait(empty); wait(mutex); // add item; signal(mutex); signal(full);`."
    },
    "difficulty_estimation": "Hard"
  }
}