{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory and Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 11:10:07",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2412,
      "output_tokens": 3302,
      "total_tokens": 9694
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Virtual Memory",
      "Copy-on-Write",
      "Process Management"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה התומכת בזיכרון וירטואלי ובמנגנון Copy-on-Write (CoW).\nנתון שגודל דף הוא 4KB.\nהתבונן בקטע הקוד הבא:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define PAGE_SIZE 4096 // Typical page size\n#define ARRAY_SIZE (PAGE_SIZE * 5) // An array spanning 5 pages\n\nint main() {\n    int *arr = (int *)malloc(ARRAY_SIZE);\n    if (arr == NULL) {\n        perror(\"malloc failed\");\n        return 1;\n    }\n\n    // Initialize the array (writes to all pages)\n    for (int i = 0; i < ARRAY_SIZE / sizeof(int); ++i) {\n        arr[i] = i;\n    }\n\n    pid_t pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        return 1;\n    } else if (pid == 0) { // Child process\n        printf(\"Child process (PID: %d) modifying data...\\n\", getpid());\n        // Child modifies an element in the first page\n        arr[0] = 100;\n        // Child modifies an element in the third page\n        arr[ARRAY_SIZE / sizeof(int) / 2] = 200;\n        printf(\"Child: arr[0] = %d, arr[ARRAY_SIZE/sizeof(int)/2] = %d\\n\", arr[0], arr[ARRAY_SIZE / sizeof(int) / 2]);\n        free(arr);\n        exit(0);\n    } else { // Parent process\n        printf(\"Parent process (PID: %d) waiting for child...\\n\", getpid());\n        wait(NULL); // Wait for child to finish\n\n        printf(\"Parent process (PID: %d) modifying data...\\n\", getpid());\n        // Parent modifies an element in the second page\n        arr[PAGE_SIZE / sizeof(int)] = 300;\n        printf(\"Parent: arr[PAGE_SIZE/sizeof(int)] = %d\\n\", arr[PAGE_SIZE / sizeof(int)]);\n        free(arr);\n        printf(\"Parent finished.\\n\");\n    }\n\n    return 0;\n}\n```\n\nענה על השאלות הבאות בהתייחס לקטע הקוד ולמנגנון CoW:\n\n1.  **לפני קריאת `fork()`:** כמה דפים פיזיים מוקצים לטובת המערך `arr` לאחר האתחול בלולאה? הסבר.\n2.  **מיד לאחר קריאת `fork()`:**\n    *   כמה דפים פיזיים *נוספים* מוקצים (אם בכלל) עבור המערך `arr` בתהליך הבן?\n    *   כמה דפים פיזיים *משותפים* קיימים כעת בין תהליך האב לתהליך הבן עבור המערך `arr`?\n    *   הסבר כיצד מנגנון ה-CoW מאפשר מצב זה.\n3.  **כאשר תהליך הבן מבצע את השורה `arr[0] = 100;`:**\n    *   תאר את רצף האירועים ברמת ניהול הזיכרון הוירטואלי והפיזי, תוך התמקדות בתפקיד מנגנון ה-CoW.\n    *   כמה דפים פיזיים חדשים נוצרו כתוצאה מכך? (התייחס גם לשורה השנייה של הבן)\n4.  **לאחר שהבן סיים את פעולתו, וכאשר תהליך האב מבצע את השורה `arr[PAGE_SIZE / sizeof(int)] = 300;`:**\n    *   תאר את רצף האירועים ברמת ניהול הזיכרון הוירטואלי והפיזי.\n    *   כמה דפים פיזיים חדשים נוצרו כתוצאה מכך?\n5.  מהם היתרונות העיקריים של שימוש במנגנון Copy-on-Write בתרחיש כזה?",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **לפני קריאת `fork()`:**\n    המערך `arr` בגודל `ARRAY_SIZE` (5 * 4096 בתים = 20KB). האתחול בלולאה גורם לנגיעה בכל תאי המערך, מה שמחייב הקצאה של כל הדפים הווירטואליים המתאימים לדפים פיזיים בזיכרון.\n    מכיוון שגודל דף הוא 4KB, ומערך בגודל 20KB מתפרס על פני 5 דפים (20KB / 4KB לדף = 5 דפים), יוקצו 5 דפים פיזיים למערך `arr`.\n\n2.  **מיד לאחר קריאת `fork()`:**\n    *   **דפים פיזיים נוספים:** 0 דפים פיזיים נוספים מוקצים עבור המערך `arr` בתהליך הבן.\n    *   **דפים פיזיים משותפים:** כל 5 הדפים הפיזיים שהוקצו למערך `arr` בתהליך האב, משותפים כעת בין תהליך האב לתהליך הבן.\n    *   **הסבר CoW:** מנגנון ה-Copy-on-Write (CoW) מאפשר לשני התהליכים (האב והבן) לשתף את אותם דפים פיזיים. במקום להעתיק את כל מרחב הכתובות של האב לבן מיד עם ה-`fork()`, מערכת ההפעלה מסמנת את הדפים המשותפים כ\"קריאה בלבד\" (read-only) או \"CoW\". כאשר אחד התהליכים (האב או הבן) מנסה לכתוב לדף כזה, מתרחשת הפרעת דף (page fault). מנהל הזיכרון קולט את ההפרעה, מעתיק את הדף הפיזי המשותף לדף פיזי חדש, מעדכן את טבלת הדפים של התהליך הכותב כך שתצביע לדף החדש, ומשנה את ההרשאות של הדף החדש ל\"קריאה וכתיבה\" (read-write). רק אז מתבצעת פעולת הכתיבה. גישה זו חוסכת זיכרון וזמן יקרים במקרה שבו תהליכי האב והבן אינם משנים את אותם דפים או שהבן מחליף את מרחב הכתובות שלו (למשל, בקריאה ל-`execve`).\n\n3.  **כאשר תהליך הבן מבצע את השורה `arr[0] = 100;`:**\n    *   **רצף האירועים:**\n        1.  תהליך הבן מנסה לכתוב לכתובת הווירטואלית של `arr[0]`. כתובת זו שייכת לדף הראשון של המערך.\n        2.  מנהל הזיכרון (MMU) מנסה לתרגם את הכתובת הווירטואלית לכתובת פיזית.\n        3.  ה-MMU מגלה שהדף (הדף הראשון של המערך) אליו שייכת הכתובת מסומן כ\"קריאה בלבד\" (או CoW), למרות שהתהליך מנסה לכתוב אליו.\n        4.  נוצרת הפרעת דף (page fault).\n        5.  מערכת ההפעלה (הקרנל) מקבלת את ההפרעה. היא מזהה שמדובר בדף CoW.\n        6.  מערכת ההפעלה מקצה דף פיזי חדש בזיכרון.\n        7.  תוכן הדף הפיזי המקורי (המשותף) מועתק לדף הפיזי החדש.\n        8.  טבלת הדפים של תהליך הבן מתעדכנת כך שהכניסה עבור הדף הווירטואלי הרלוונטי תצביע כעת לדף הפיזי *החדש*.\n        9.  ההרשאות של הדף החדש בטבלת הדפים של הבן משתנות ל\"קריאה וכתיבה\".\n        10. ההרשאות של הדף הפיזי המקורי (המשותף כעת רק לאב ולדפים אחרים אם קיימים) נשארות כפי שהיו.\n        11. פעולת הכתיבה (`arr[0] = 100;`) מתבצעת כעת לדף הפיזי החדש של הבן.\n        12. כאשר הבן מבצע את השורה `arr[ARRAY_SIZE / sizeof(int) / 2] = 200;`, מתרחש תהליך דומה עבור הדף השלישי של המערך (page 3). כלומר, דף פיזי חדש יוקצה גם עבור הדף השלישי.\n    *   **דפים פיזיים חדשים:** 2 דפים פיזיים חדשים נוצרו כתוצאה מכך (אחד לדף הראשון ואחד לדף השלישי של המערך).\n\n4.  **לאחר שהבן סיים את פעולתו, וכאשר תהליך האב מבצע את השורה `arr[PAGE_SIZE / sizeof(int)] = 300;`:**\n    *   **רצף האירועים:**\n        1.  תהליך האב מנסה לכתוב לכתובת הווירטואלית של `arr[PAGE_SIZE / sizeof(int)]`. כתובת זו שייכת לדף השני של המערך.\n        2.  הדף השני של המערך עדיין היה מסומן CoW ומשותף לאב (הבן כבר סיים את פעולתו, כך שהוא אינו שותף עוד לדפים אלו).\n        3.  כמו בסעיף הקודם, ה-MMU מגלה שהדף מסומן כ\"קריאה בלבד\" (או CoW).\n        4.  נוצרת הפרעת דף (page fault).\n        5.  מערכת ההפעלה מזהה שמדובר בדף CoW.\n        6.  מערכת ההפעלה מקצה דף פיזי חדש.\n        7.  תוכן הדף הפיזי המקורי (המשותף קודם לכן) מועתק לדף הפיזי החדש.\n        8.  טבלת הדפים של תהליך האב מתעדכנת כך שהכניסה עבור הדף הווירטואלי השני תצביע כעת לדף הפיזי *החדש*.\n        9.  ההרשאות של הדף החדש בטבלת הדפים של האב משתנות ל\"קריאה וכתיבה\".\n        10. הדף הפיזי המקורי (הדף השני) שאינו משותף יותר עם אף תהליך, עשוי כעת להיות מסומן כפנוי או להישאר בזיכרון עד שיוקצה מחדש.\n        11. פעולת הכתיבה (`arr[PAGE_SIZE / sizeof(int)] = 300;`) מתבצעת כעת לדף הפיזי החדש של האב.\n    *   **דפים פיזיים חדשים:** דף פיזי חדש אחד נוצר כתוצאה מכך (עבור הדף השני של המערך).\n\n5.  **יתרונות CoW:**\n    היתרונות העיקריים של שימוש במנגנון Copy-on-Write בתרחיש כזה הם:\n    *   **חיסכון בזיכרון:** במקום להעתיק את כל מרחב הכתובות של האב לבן מיד עם ה-`fork()`, מה שיכול להיות בזבזני מאוד עבור תהליכים גדולים, CoW מאפשר לשניהם לחלוק את אותם דפים פיזיים. רק כאשר אחד מהם מנסה לשנות דף, נוצר עותק. זה רלוונטי במיוחד כאשר תהליכים משתמשים ב-`fork()` ולאחר מכן ב-`execve()` (כמו במעטפת פקודה), מכיוון שאז מרחב הכתובות של הבן יוחלף לחלוטין בכל מקרה.\n    *   **חיסכון בזמן:** תהליך ה-`fork()` הופך למהיר יותר באופן משמעותי, שכן הוא לא דורש העתקה מיידית של כמויות גדולות של נתונים. רק העתקה של טבלאות דפים ושינוי הרשאות נדרשים. העתקה בפועל של דפים מתבצעת רק לפי הצורך (on-demand), ובכך מפחיתה את העומס על המערכת.\n    *   **שיפור ביצועים:** פחות פעולות I/O לזיכרון (כתוצאה מפחות העתקות) משפרות את הביצועים הכוללים של המערכת."
    },
    "difficulty_estimation": "Medium"
  }
}