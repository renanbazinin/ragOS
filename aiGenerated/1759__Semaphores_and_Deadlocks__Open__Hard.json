{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:35:27",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4395,
      "output_tokens": 4724,
      "total_tokens": 16962
    }
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Deadlocks",
      "Deadlock Prevention",
      "Concurrency"
    ],
    "content": {
      "text": "מערכת מורכבת מ-N חוטים עובדים (Worker Threads) ומ-M משאבי משימה (Task Resources), המסומנים Task_0 עד Task_{M-1}. כל משאב משימה מוגן על ידי סמפור בינארי משלו, המאפשר לחוט אחד בלבד להחזיק בו זמנית. כדי לבצע 'עבודה', חוט עובד זקוק לרכוש שני משאבי משימה *שונים* בו זמנית. לאחר השלמת העבודה, החוט משחרר את שני המשאבים. נניח ש-M ≥ 2 (יש לפחות שני משאבים).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "8.1",
        "text": "כתוב קוד C/C++ עבור פונקציית 'worker_thread' המממשת את הלוגיקה של חוט עובד בצורה נאיבית. הפונקציה תקבל כפרמטרים את מזהה החוט (thread_id), מערך של סמפורים (task_semaphores), ואת מספר המשאבים הכולל (num_tasks). בכל איטרציה, החוט יבחר שני משאבים אקראיים (שונים) וינסה לרכוש אותם, יבצע 'עבודה' כלשהי (למשל, sleep קצר), ולאחר מכן ישחרר אותם. \n\nלאחר מכן, הצג דוגמה ספציפית (עם מספרים קטנים של N ו-M, לדוגמה N=2, M=2) ותרחיש צעדים (sequence of events) שבו המימוש שלך עלול להוביל למצב של הקפאה (deadlock). הסבר מדוע זהו מצב הקפאה.",
        "code_snippet": "/* Headers and global variables for semaphores and thread IDs are provided in the main function context. */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep\n\n#define NUM_TASKS 2 // Example M\n#define NUM_WORKERS 2 // Example N\n\nsem_t task_semaphores[NUM_TASKS];\n\nvoid *worker_thread(void *arg) {\n    int thread_id = *(int *)arg;\n    int task1_idx, task2_idx;\n\n    while (1) {\n        // TODO: Implement naive worker logic here\n        // Acquire two distinct tasks, do work, release them.\n        // This implementation should be susceptible to deadlocks.\n\n        // Example of choosing random tasks (ensure they are distinct)\n        task1_idx = rand() % NUM_TASKS;\n        do {\n            task2_idx = rand() % NUM_TASKS;\n        } while (task1_idx == task2_idx);\n\n        // Simulate work by acquiring semaphores\n        // Add printf statements for tracing thread actions\n        // printf(\"Worker %d trying to acquire Task %d and Task %d\\n\", thread_id, task1_idx, task2_idx);\n    }\n    return NULL;\n}\n\n// Main function to initialize semaphores and create threads (for context)\nint main() {\n    srand(time(NULL)); // Seed random number generator\n    // Initialize semaphores\n    for (int i = 0; i < NUM_TASKS; ++i) {\n        sem_init(&task_semaphores[i], 0, 1); // Binary semaphore, initial value 1\n    }\n\n    // Create worker threads\n    pthread_t workers[NUM_WORKERS];\n    int thread_ids[NUM_WORKERS];\n\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        thread_ids[i] = i;\n        pthread_create(&workers[i], NULL, worker_thread, &thread_ids[i]);\n    }\n\n    // Join threads (for simplicity, not strictly necessary for deadlock demo)\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        pthread_join(workers[i], NULL);\n    }\n\n    // Destroy semaphores\n    for (int i = 0; i < NUM_TASKS; ++i) {\n        sem_destroy(&task_semaphores[i]);\n    }\n\n    return 0;\n}",
        "options": null
      },
      {
        "id": "8.2",
        "text": "שנה את המימוש של פונקציית 'worker_thread' כך שימנע הקפאה (deadlock) בכל מקרה, תוך שמירה על עקרון העבודה (רכישת שני משאבים שונים, ביצוע עבודה, שחרור). הסבר את השינוי וכיצד הוא מונע הקפאה.",
        "code_snippet": "/* Headers and global variables as in 8.1 */\n\nvoid *worker_thread(void *arg) {\n    int thread_id = *(int *)arg;\n    int task1_idx, task2_idx;\n\n    while (1) {\n        // TODO: Implement deadlock-free worker logic here\n        // Acquire two distinct tasks, do work, release them.\n\n        // Example of choosing random tasks (ensure they are distinct)\n        task1_idx = rand() % NUM_TASKS;\n        do {\n            task2_idx = rand() % NUM_TASKS;\n        } while (task1_idx == task2_idx);\n\n        // Simulate work by acquiring semaphores\n        // Add printf statements for tracing thread actions\n        // printf(\"Worker %d trying to acquire Task %d and Task %d\\n\", thread_id, task1_idx, task2_idx);\n    }\n    return NULL;\n}",
        "options": null
      }
    ],
    "points": 20,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### פתרון סעיף 8.1: מימוש נאיבי ותרחיש הקפאה\n\n**מימוש פונקציית `worker_thread` (נאיבי):**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep\n#include <time.h>   // For srand\n\n#define NUM_TASKS 2 // Example M\n#define NUM_WORKERS 2 // Example N\n\nsem_t task_semaphores[NUM_TASKS];\n\nvoid *worker_thread(void *arg) {\n    int thread_id = *(int *)arg;\n    int task1_idx, task2_idx;\n\n    while (1) {\n        // בחירת שני משאבים אקראיים ושונים\n        task1_idx = rand() % NUM_TASKS;\n        do {\n            task2_idx = rand() % NUM_TASKS;\n        } while (task1_idx == task2_idx);\n\n        printf(\"Worker %d trying to acquire Task %d and Task %d\\n\", thread_id, task1_idx, task2_idx);\n\n        // ניסיון לרכוש את המשאבים בסדר אקראי (הפגיע להקפאה)\n        sem_wait(&task_semaphores[task1_idx]);\n        printf(\"Worker %d acquired Task %d. Waiting for Task %d.\\n\", thread_id, task1_idx, task2_idx);\n        usleep(1000); // מעט השהיה להגברת הסיכוי להקפאה\n        sem_wait(&task_semaphores[task2_idx]);\n\n        printf(\"Worker %d acquired Task %d and Task %d. Doing work...\\n\", thread_id, task1_idx, task2_idx);\n        usleep(rand() % 500000); // מדמה עבודה\n\n        sem_post(&task_semaphores[task2_idx]);\n        sem_post(&task_semaphores[task1_idx]);\n        printf(\"Worker %d released Task %d and Task %d. Done.\\n\", thread_id, task1_idx, task2_idx);\n        usleep(rand() % 500000); // מדמה זמן לפני העבודה הבאה\n    }\n    return NULL;\n}\n\nint main() {\n    srand(time(NULL)); // Seed random number generator\n    for (int i = 0; i < NUM_TASKS; ++i) {\n        sem_init(&task_semaphores[i], 0, 1);\n    }\n    pthread_t workers[NUM_WORKERS];\n    int thread_ids[NUM_WORKERS];\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        thread_ids[i] = i;\n        pthread_create(&workers[i], NULL, worker_thread, &thread_ids[i]);\n    }\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        pthread_join(workers[i], NULL);\n    }\n    for (int i = 0; i < NUM_TASKS; ++i) {\n        sem_destroy(&task_semaphores[i]);\n    }\n    return 0;\n}\n```\n\n**תרחיש הקפאה (Deadlock Scenario) עבור N=2, M=2:**\nנניח שיש לנו שני חוטים עובדים (Worker 0, Worker 1) ושני משאבי משימה (Task 0, Task 1). הסמפורים המגנים עליהם הם `task_semaphores[0]` ו-`task_semaphores[1]`. כל חוט צריך לרכוש את שני המשאבים.\n\n1.  **Worker 0:** בוחר לרכוש את Task 0 ואז את Task 1.\n2.  **Worker 1:** בוחר לרכוש את Task 1 ואז את Task 0.\n\n**סדר אירועים אפשרי המוביל להקפאה:**\n*   **שלב 1:** Worker 0 מבצע `sem_wait(&task_semaphores[0])`. הוא רוכש בהצלחה את Task 0. (Worker 0 מחזיק ב-Task 0).\n*   **שלב 2:** Worker 1 מבצע `sem_wait(&task_semaphores[1])`. הוא רוכש בהצלחה את Task 1. (Worker 1 מחזיק ב-Task 1).\n*   **שלב 3:** Worker 0 מבצע `sem_wait(&task_semaphores[1])`. הוא מנסה לרכוש את Task 1, אך Task 1 מוחזק על ידי Worker 1. Worker 0 נכנס למצב המתנה (בלוק).\n*   **שלב 4:** Worker 1 מבצע `sem_wait(&task_semaphores[0])`. הוא מנסה לרכוש את Task 0, אך Task 0 מוחזק על ידי Worker 0. Worker 1 נכנס למצב המתנה (בלוק).\n\n**הסבר מדוע זהו מצב הקפאה:**\nשני החוטים נמצאים במצב חסימה הדדית: Worker 0 ממתין למשאב (Task 1) שמוחזק על ידי Worker 1, ו-Worker 1 ממתין למשאב (Task 0) שמוחזק על ידי Worker 0. אף אחד מהם לא יכול להמשיך, לשחרר את המשאב שהוא מחזיק, ובכך לאפשר לחוט השני להתקדם. זהו מצב של הקפאה (deadlock) מכיוון שמתקיימים כל ארבעת התנאים ההכרחיים להקפאה:\n1.  **מניעה הדדית (Mutual Exclusion):** כל משאב מוגן על ידי סמפור בינארי, כך שרק חוט אחד יכול להחזיק בו זמנית.\n2.  **החזקה והמתנה (Hold and Wait):** כל חוט מחזיק במשאב אחד (Worker 0 ב-Task 0, Worker 1 ב-Task 1) וממתין למשאב נוסף.\n3.  **אי-הפקעה (No Preemption):** לא ניתן להפקיע משאב מחוט שמחזיק בו; רק החוט עצמו יכול לשחרר אותו.\n4.  **המתנה מעגלית (Circular Wait):** ישנה שרשרת המתנה מעגלית: Worker 0 ממתין ל-Worker 1, ו-Worker 1 ממתין ל-Worker 0.\n\n### פתרון סעיף 8.2: מניעת הקפאה\n\nכדי למנוע הקפאה, נשנה את המימוש של פונקציית `worker_thread` כך שכל החוטים ירכשו את המשאבים תמיד באותו סדר. שיטה זו, הנקראת \"היררכיית משאבים\" (Resource Ordering), שוברת את תנאי ה\"המתנה המעגלית\" (Circular Wait).\n\n**מימוש פונקציית `worker_thread` (מונע הקפאה):**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep\n#include <time.h>   // For srand\n\n#define NUM_TASKS 2 // Example M\n#define NUM_WORKERS 2 // Example N\n\nsem_t task_semaphores[NUM_TASKS];\n\nvoid *worker_thread(void *arg) {\n    int thread_id = *(int *)arg;\n    int task1_idx, task2_idx;\n    int first_task, second_task;\n\n    while (1) {\n        // בחירת שני משאבים אקראיים ושונים\n        task1_idx = rand() % NUM_TASKS;\n        do {\n            task2_idx = rand() % NUM_TASKS;\n        } while (task1_idx == task2_idx);\n\n        // קביעת סדר רכישה: תמיד קודם את המשאב בעל האינדקס הקטן יותר\n        if (task1_idx < task2_idx) {\n            first_task = task1_idx;\n            second_task = task2_idx;\n        } else {\n            first_task = task2_idx;\n            second_task = task1_idx;\n        }\n\n        printf(\"Worker %d trying to acquire Task %d and Task %d (ordered: %d, %d)\\n\", \n               thread_id, task1_idx, task2_idx, first_task, second_task);\n\n        // רכישת המשאבים לפי הסדר הקבוע\n        sem_wait(&task_semaphores[first_task]);\n        printf(\"Worker %d acquired Task %d. Waiting for Task %d.\\n\", thread_id, first_task, second_task);\n        usleep(1000); \n        sem_wait(&task_semaphores[second_task]);\n\n        printf(\"Worker %d acquired Task %d and Task %d. Doing work...\\n\", thread_id, first_task, second_task);\n        usleep(rand() % 500000); // מדמה עבודה\n\n        sem_post(&task_semaphores[second_task]);\n        sem_post(&task_semaphores[first_task]);\n        printf(\"Worker %d released Task %d and Task %d. Done.\\n\", thread_id, first_task, second_task);\n        usleep(rand() % 500000); // מדמה זמן לפני העבודה הבאה\n    }\n    return NULL;\n}\n\nint main() {\n    srand(time(NULL)); // Seed random number generator\n    for (int i = 0; i < NUM_TASKS; ++i) {\n        sem_init(&task_semaphores[i], 0, 1);\n    }\n    pthread_t workers[NUM_WORKERS];\n    int thread_ids[NUM_WORKERS];\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        thread_ids[i] = i;\n        pthread_create(&workers[i], NULL, worker_thread, &thread_ids[i]);\n    }\n    for (int i = 0; i < NUM_WORKERS; ++i) {\n        pthread_join(workers[i], NULL);\n    }\n    for (int i = 0; i < NUM_TASKS; ++i) {\n        sem_destroy(&task_semaphores[i]);\n    }\n    return 0;\n}\n```\n\n**הסבר השינוי וכיצד הוא מונע הקפאה:**\nהשינוי המהותי הוא שבמקום לרכוש את המשאבים בסדר אקראי, אנו מבטיחים שכל חוט ירכוש את המשאבים תמיד לפי סדר קבוע, למשל, לפי האינדקס המספרי שלהם (תמיד קודם את המשאב עם האינדקס הקטן יותר, ואז את המשאב עם האינדקס הגדול יותר). כלומר, אם חוט זקוק למשאבים Task_i ו-Task_j, הוא תמיד ינסה לרכוש את `min(i, j)` קודם, ורק לאחר מכן את `max(i, j)`.\n\nשיטה זו מונעת הקפאה על ידי שבירת תנאי ה\"המתנה המעגלית\" (Circular Wait). אם כל החוטים רוכשים משאבים בסדר עולה (לפי האינדקסים שלהם), אז לא ייתכן מצב שבו חוט A ממתין למשאב שמוחזק על ידי חוט B, וחוט B ממתין למשאב שמוחזק על ידי חוט A. לדוגמה:\n*   אם חוט A מחזיק ב-Task_i וממתין ל-Task_j (כאשר j > i).\n*   אם חוט B מחזיק ב-Task_k וממתין ל-Task_l (כאשר l > k).\n\nלא ייתכן ש-A ימתין ל-Task_j (שמוחזק על ידי B) ו-B ימתין ל-Task_i (שמוחזק על ידי A) בו זמנית. מכיוון ש-B חייב לרכוש את Task_i לפני Task_j (אם הוא זקוק לשניהם), אם Task_i מוחזק על ידי A, אז B לא יצליח לרכוש אותו מלכתחילה וימתין. הוא לא יוכל להגיע למצב שבו הוא מחזיק ב-Task_j וממתין ל-Task_i. בכך, אנו מבטיחים שלא תיווצר שרשרת המתנה מעגלית, ובכך נמנעת הקפאה."
    },
    "difficulty_estimation": "Hard"
  }
}