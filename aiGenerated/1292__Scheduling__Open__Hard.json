{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:18:47",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3419,
      "output_tokens": 6015,
      "total_tokens": 24103
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Process Management"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה עם מעבד יחיד (Single-core CPU). במערכת רצים ארבעה תהליכים (P1, P2, P3, P4) עם המאפיינים הבאים:\n\n*   **P1**: תהליך עתיר מעבד (CPU-bound) עם זמן ביצוע כולל של 20ms. בעל עדיפות גבוהה.\n*   **P2**: תהליך עתיר קלט/פלט (I/O-bound) עם זמן ביצוע כולל של 15ms. כל 3ms של עבודה במעבד, התהליך מבצע פעולת קלט/פלט של 5ms. בעל עדיפות בינונית.\n*   **P3**: תהליך אינטראקטיבי עם זמן ביצוע כולל של 10ms. כל 1ms של עבודה במעבד, התהליך ממתין לקלט משתמש של 2ms. בעל עדיפות גבוהה.\n*   **P4**: תהליך עתיר מעבד (CPU-bound) עם זמן ביצוע כולל של 25ms. בעל עדיפות נמוכה.\n\nכל התהליכים מגיעים למערכת בזמן t=0. נניח שזמן החלפת הקשר (Context Switch) זניח.\n\nיש לנתח את ביצועי המערכת תחת שני אלגוריתמי תזמון שונים:\n\n**א. תזמון מבוסס עדיפויות מונע (Preemptive Priority Scheduling):**\nהתהליך בעל העדיפות הגבוהה ביותר יקבל את המעבד. במקרה של שוויון עדיפויות, האלגוריתם יבחר את התהליך שהגיע ראשון (FCFS).\n\n**ב. Round Robin (RR) עם קוונטום זמן (Time Quantum) של 4ms:**\nהתהליכים יקבלו את המעבד בסדר הגעתם (FCFS) בתוך התור, כאשר הקוונטום הוא 4ms.\n\n**שאלות:**\n1.  תארו את סדר ביצוע התהליכים וחשבו את זמן הסיום (Completion Time) ואת זמן המחזור (Turnaround Time) עבור כל תהליך, וכן את זמן המחזור הממוצע, עבור כל אחד מהאלגוריתמים.\n2.  השוו את האלגוריתמים במונחים של הגינות (Fairness) וזמן תגובה (Response Time) לתהליכים האינטראקטיביים (P3).\n3.  האם קיים תרחיש שבו אחד התהליכים עלול לסבול מרעב (Starvation) באחד מהאלגוריתמים? אם כן, הציעו פתרון אפשרי.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": 15,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "נתונים:\n*   P1: CPU=20ms, Priority=High\n*   P2: CPU=15ms (3ms burst, 5ms I/O), Priority=Medium\n*   P3: CPU=10ms (1ms burst, 2ms I/O), Priority=High\n*   P4: CPU=25ms, Priority=Low\n*   זמן הגעה לכולם t=0.\n*   זמן החלפת הקשר זניח.\n\n**חלק 1: סדר ביצוע וזמנים**\n\n**א. תזמון מבוסס עדיפויות מונע (Preemptive Priority Scheduling):**\nסדר עדיפויות (גבוה לנמוך): P1, P3 (שוויון FCFS), P2, P4.\n\n*   **t=0**: כל התהליכים מגיעים. P1 (עדיפות גבוהה) מתחיל לרוץ.\n*   **t=20**: P1 מסיים את ריצתו (20ms). **P1 Completion Time = 20ms, Turnaround Time = 20ms.**\n*   **t=20**: P3 (עדיפות גבוהה) מתחיל לרוץ. P3 רץ 1ms.\n*   **t=21**: P3 מתחיל פעולת I/O (2ms). P3 חסום. P2 (עדיפות בינונית) מתחיל לרוץ.\n*   **t=23**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P2. P3 רץ 1ms.\n*   **t=24**: P3 מתחיל I/O (2ms). P3 חסום. P2 ממשיך לרוץ (סה\"כ 2ms+1ms=3ms עד כה).\n*   **t=26**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P2. P3 רץ 1ms.\n*   **t=27**: P3 מתחיל I/O (2ms). P3 חסום. P2 ממשיך לרוץ (סה\"כ 3ms+1ms=4ms עד כה).\n*   **t=28**: P2 מסיים 3ms עבודת CPU (סה\"כ 6ms CPU), מתחיל I/O (5ms). P2 חסום. P4 (עדיפות נמוכה) מתחיל לרוץ.\n*   **t=29**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P4. P3 רץ 1ms.\n*   **t=30**: P3 מתחיל I/O (2ms). P3 חסום. P4 ממשיך לרוץ.\n*   **t=32**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P4. P3 רץ 1ms.\n*   **t=33**: P2 מסיים I/O, הופך למוכן. P3 מתחיל I/O (2ms). P3 חסום. P2 (עדיפות בינונית) מתחיל לרוץ (P4 בעדיפות נמוכה יותר).\n*   **t=35**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P2. P3 רץ 1ms.\n*   **t=36**: P3 מתחיל I/O (2ms). P3 חסום. P2 ממשיך לרוץ (סה\"כ 6ms+1ms=7ms עד כה).\n*   **t=38**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P2. P3 רץ 1ms.\n*   **t=39**: P2 מסיים 3ms עבודת CPU (סה\"כ 9ms CPU), מתחיל I/O (5ms). P2 חסום. P3 מתחיל I/O (2ms). P3 חסום. P4 מתחיל לרוץ.\n*   **t=41**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P4. P3 רץ 1ms.\n*   **t=42**: P3 מתחיל I/O (2ms). P3 חסום. P4 ממשיך לרוץ.\n*   **t=44**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P4. P3 רץ 1ms.\n*   **t=45**: P2 מסיים I/O, הופך למוכן. P3 מתחיל I/O (2ms). P3 חסום. P2 (עדיפות בינונית) מתחיל לרוץ.\n*   **t=47**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P2. P3 רץ 1ms.\n*   **t=48**: P3 מתחיל I/O (2ms). P3 חסום. P2 ממשיך לרוץ (סה\"כ 9ms+1ms=10ms עד כה).\n*   **t=50**: P3 מסיים I/O, הופך למוכן. P3 דוחה את P2. P3 רץ 1ms.\n*   **t=51**: P3 מסיים את ריצתו (10ms CPU). **P3 Completion Time = 51ms, Turnaround Time = 51ms.**\n*   **t=51**: P2 ממשיך לרוץ (סה\"כ 10ms+1ms=11ms CPU). P2 מסיים 3ms עבודת CPU (סה\"כ 12ms CPU), מתחיל I/O (5ms). P2 חסום.\n*   **t=52**: P4 ממשיך לרוץ.\n*   **t=57**: P2 מסיים I/O, הופך למוכן. P2 דוחה את P4. P2 רץ 3ms.\n*   **t=60**: P2 מסיים את ריצתו (15ms CPU). **P2 Completion Time = 60ms, Turnaround Time = 60ms.**\n*   **t=60**: P4 ממשיך לרוץ (25ms - (28-27) - (30-29) - (32-30) - (35-33) - (40-39) - (42-41) - (45-44) - (47-45) - (52-51) - (57-52) = 25 - 1 - 1 - 2 - 2 - 1 - 1 - 1 - 2 - 1 - 5 = 7ms. P4 רץ 7ms בזמן ש P3 ו P2 היו חסומים). P4 רץ עוד 18ms. (25-7=18ms CPU)\n*   **t=78**: P4 מסיים את ריצתו. **P4 Completion Time = 78ms, Turnaround Time = 78ms.**\n\n**סיכום זמנים (Preemptive Priority):**\n*   P1: Completion Time = 20ms, Turnaround Time = 20ms\n*   P2: Completion Time = 60ms, Turnaround Time = 60ms\n*   P3: Completion Time = 51ms, Turnaround Time = 51ms\n*   P4: Completion Time = 78ms, Turnaround Time = 78ms\n*   **זמן מחזור ממוצע = (20 + 60 + 51 + 78) / 4 = 209 / 4 = 52.25ms**\n\n**ב. Round Robin (RR) עם קוונטום זמן (Time Quantum) של 4ms:**\nReady Queue (RQ): [P1, P2, P3, P4] (FCFS).\n\n*   **t=0**: P1 רץ (4ms). CPU_P1=16. RQ=[P2, P3, P4, P1].\n*   **t=4**: P2 רץ (3ms לפני I/O). CPU_P2=12. P2 חסום (I/O עד t=9). RQ=[P3, P4, P1].\n*   **t=7**: P3 רץ (1ms לפני I/O). CPU_P3=9. P3 חסום (I/O עד t=10). RQ=[P4, P1].\n*   **t=8**: P4 רץ (4ms). CPU_P4=21. RQ=[P1].\n*   **t=10**: P3 מוכן. RQ=[P1, P3].\n*   **t=12**: P4 מסיים קוונטום. RQ=[P1, P3, P4]. P2 מוכן. RQ=[P1, P3, P4, P2].\n*   **t=12**: P1 רץ (4ms). CPU_P1=12. RQ=[P3, P4, P2].\n*   **t=16**: P1 מסיים קוונטום. RQ=[P3, P4, P2, P1].\n*   **t=16**: P3 רץ (1ms לפני I/O). CPU_P3=8. P3 חסום (I/O עד t=19). RQ=[P4, P2, P1].\n*   **t=17**: P4 רץ (4ms). CPU_P4=17. RQ=[P2, P1].\n*   **t=19**: P3 מוכן. RQ=[P2, P1, P3].\n*   **t=21**: P4 מסיים קוונטום. RQ=[P2, P1, P3, P4].\n*   **t=21**: P2 רץ (3ms לפני I/O). CPU_P2=9. P2 חסום (I/O עד t=29). RQ=[P1, P3, P4].\n*   **t=24**: P1 רץ (4ms). CPU_P1=8. RQ=[P3, P4].\n*   **t=28**: P1 מסיים קוונטום. RQ=[P3, P4, P1].\n*   **t=28**: P3 רץ (1ms לפני I/O). CPU_P3=7. P3 חסום (I/O עד t=31). RQ=[P4, P1].\n*   **t=29**: P2 מוכן. RQ=[P4, P1, P2].\n*   **t=29**: P4 רץ (4ms). CPU_P4=13. RQ=[P1, P2].\n*   **t=31**: P3 מוכן. RQ=[P1, P2, P3].\n*   **t=33**: P4 מסיים קוונטום. RQ=[P1, P2, P3, P4].\n*   **t=33**: P1 רץ (4ms). CPU_P1=4. RQ=[P2, P3, P4].\n*   **t=37**: P1 מסיים קוונטום. RQ=[P2, P3, P4, P1].\n*   **t=37**: P2 רץ (3ms לפני I/O). CPU_P2=6. P2 חסום (I/O עד t=45). RQ=[P3, P4, P1].\n*   **t=40**: P3 רץ (1ms לפני I/O). CPU_P3=6. P3 חסום (I/O עד t=43). RQ=[P4, P1].\n*   **t=41**: P4 רץ (4ms). CPU_P4=9. RQ=[P1].\n*   **t=43**: P3 מוכן. RQ=[P1, P3].\n*   **t=45**: P4 מסיים קוונטום. RQ=[P1, P3, P4]. P2 מוכן. RQ=[P1, P3, P4, P2].\n*   **t=45**: P1 רץ (4ms). CPU_P1=0. RQ=[P3, P4, P2].\n*   **t=49**: P1 מסיים. **P1 Completion Time = 49ms, Turnaround Time = 49ms.** RQ=[P3, P4, P2].\n*   **t=49**: P3 רץ (1ms לפני I/O). CPU_P3=5. P3 חסום (I/O עד t=52). RQ=[P4, P2].\n*   **t=50**: P4 רץ (4ms). CPU_P4=5. RQ=[P2].\n*   **t=52**: P3 מוכן. RQ=[P2, P3].\n*   **t=54**: P4 מסיים קוונטום. RQ=[P2, P3, P4].\n*   **t=54**: P2 רץ (3ms לפני I/O). CPU_P2=3. P2 חסום (I/O עד t=62). RQ=[P3, P4].\n*   **t=57**: P3 רץ (1ms לפני I/O). CPU_P3=4. P3 חסום (I/O עד t=60). RQ=[P4].\n*   **t=58**: P4 רץ (4ms). CPU_P4=1. RQ=[].\n*   **t=60**: P3 מוכן. RQ=[P3].\n*   **t=62**: P4 מסיים קוונטום. RQ=[P3, P4]. P2 מוכן. RQ=[P3, P4, P2].\n*   **t=62**: P3 רץ (1ms לפני I/O). CPU_P3=3. P3 חסום (I/O עד t=65). RQ=[P4, P2].\n*   **t=63**: P4 רץ (1ms). CPU_P4=0. RQ=[P2].\n*   **t=64**: P4 מסיים. **P4 Completion Time = 64ms, Turnaround Time = 64ms.** RQ=[P2].\n*   **t=64**: P2 רץ (3ms לפני I/O). CPU_P2=0. P2 חסום (I/O עד t=72). RQ=[P3].\n*   **t=65**: P3 מוכן. RQ=[P3].\n*   **t=67**: P2 מסיים. **P2 Completion Time = 67ms, Turnaround Time = 67ms.** RQ=[P3].\n*   **t=67**: P3 רץ (1ms לפני I/O). CPU_P3=2. P3 חסום (I/O עד t=70). RQ=[].\n*   **t=70**: P3 מוכן. RQ=[P3].\n*   **t=70**: P3 רץ (1ms לפני I/O). CPU_P3=1. P3 חסום (I/O עד t=73). RQ=[].\n*   **t=72**: P2 מוכן. RQ=[P2]. (Oops, P2 finished at t=67. This step is incorrect. P2 is already done.)\n*   **t=73**: P3 מוכן. RQ=[P3].\n*   **t=73**: P3 רץ (1ms לפני I/O). CPU_P3=0. P3 חסום (I/O עד t=76). RQ=[].\n*   **t=74**: P3 מסיים. **P3 Completion Time = 74ms, Turnaround Time = 74ms.** (Correcting for the I/O completion after its final CPU burst)\n\n**סיכום זמנים (Round Robin):**\n*   P1: Completion Time = 49ms, Turnaround Time = 49ms\n*   P2: Completion Time = 67ms, Turnaround Time = 67ms\n*   P3: Completion Time = 74ms, Turnaround Time = 74ms\n*   P4: Completion Time = 64ms, Turnaround Time = 64ms\n*   **זמן מחזור ממוצע = (49 + 67 + 74 + 64) / 4 = 254 / 4 = 63.5ms**\n\n**חלק 2: השוואת הגינות וזמן תגובה**\n\n*   **הגינות (Fairness):**\n    *   **תזמון מבוסס עדיפויות מונע**: אינו הוגן. תהליכים בעלי עדיפות גבוהה (P1, P3) מקבלים את המעבד לעיתים קרובות יותר ומסיימים מוקדם יותר. P4 (עדיפות נמוכה) סובל מעיכובים משמעותיים ויקבל את המעבד רק כאשר תהליכים בעלי עדיפות גבוהה יותר חסומים או סיימו את ריצתם. במקרה זה, P4 נדחה לעיתים קרובות על ידי P2 ו-P3. P2 נדחה על ידי P3.\n    *   **Round Robin**: הוגן יותר. כל התהליכים מקבלים תור במעבד, ומונעים מתהליך יחיד לתפוס את המעבד לזמן רב. גם תהליכים עתירי מעבד (P1, P4) וגם תהליכים עתירי I/O (P2, P3) מקבלים זמן מעבד באופן מתחלף.\n\n*   **זמן תגובה (Response Time) לתהליכים אינטראקטיביים (P3):**\n    *   **תזמון מבוסס עדיפויות מונע**: זמן תגובה מצוין. P3, בהיותו בעל עדיפות גבוהה, מקבל את המעבד מיד כאשר הוא הופך למוכן (לאחר פעולת I/O), תוך דחיית תהליכים בעלי עדיפות נמוכה יותר. בפעם הראשונה P3 מתחיל ב-t=20. לאחר מכן, זמן התגובה שלו הוא מיידי (בגבולות הזניחים של החלפת הקשר) לאחר סיום ה-I/O.\n    *   **Round Robin**: זמן תגובה טוב, אך פחות טוב מאשר בתזמון עדיפויות. P3 צריך להמתין לתורו בתור ה-Ready Queue, גם אם הוא מוכן. הוא יקבל את המעבד לכל היותר לאחר (N-1) * קוונטום זמן, כאשר N הוא מספר התהליכים בתור. P3 מתחיל לרוץ לראשונה ב-t=7. זמן התגובה שלו יהיה ארוך יותר מאשר בתזמון עדיפויות, שכן הוא צריך לחכות לתורים של P1, P2, P4.\n\n**חלק 3: רעב (Starvation) ופתרונות**\n\n*   **רעב בתזמון מבוסס עדיפויות מונע**: כן, קיים תרחיש כזה. P4 (עדיפות נמוכה, עתיר מעבד) עלול לסבול מרעב. כל עוד ישנם תהליכים בעלי עדיפות גבוהה או בינונית שמוכנים לרוץ, P4 לא יקבל את המעבד. במקרה זה, P4 אמנם רץ לפרקים קצרים כאשר P2 ו-P3 חסומים ב-I/O, אך הוא נדחה באופן קבוע. אם היו מגיעים תהליכים נוספים בעלי עדיפות גבוהה או בינונית באופן רציף, P4 לא היה מקבל זמן מעבד כלל.\n*   **רעב ב-Round Robin**: לא, אלגוריתם Round Robin מונע רעב מטבעו. כל תהליך מקבל קוונטום זמן באופן מחזורי, מה שמבטיח שכל תהליך יקבל בסופו של דבר גישה למעבד וימשיך להתקדם.\n*   **פתרון לרעב בתזמון מבוסס עדיפויות (אם קיים):**\n    *   **Aging (הזדקנות)**: הגדלה הדרגתית של העדיפות של תהליכים שממתינים זמן רב במצב 'מוכן'. זה מבטיח שאפילו תהליכים בעלי עדיפות נמוכה יצברו מספיק עדיפות כדי לרוץ בסופו של דבר.\n    *   **Multi-level Feedback Queue (MLFQ)**: שימוש במספר תורים עם עדיפויות שונות ואלגוריתמי תזמון שונים. תהליכים עוברים בין התורים בהתאם להתנהגותם (לדוגמה, תהליך שמשתמש בקוונטום המלא שלו עובר לתור בעדיפות נמוכה יותר, ותהליך שמבצע I/O לעיתים קרובות עשוי לעבור לתור בעדיפות גבוהה יותר). MLFQ משלב באופן מובנה מנגנוני הזדקנות כדי למנוע רעב."
    },
    "difficulty_estimation": "Hard"
  }
}