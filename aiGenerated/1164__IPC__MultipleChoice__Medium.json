{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 08:22:36",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1196,
      "output_tokens": 653,
      "total_tokens": 3763
    }
  },
  "question": {
    "id": 101,
    "type": "MultipleChoice",
    "topic": [
      "IPC",
      "Pipes",
      "Processes"
    ],
    "content": {
      "text": "נתבונן בתהליך אב שיוצר תהליך בן באמצעות `fork()`. לפני ה-`fork()`, האב יוצר צינור אנונימי (unnamed pipe). האב כותב נתונים לצינור, והבן קורא ממנו.\nמהי ההתנהגות הצפויה אם תהליך האב מנסה לכתוב 10KB של נתונים לצינור, אך תהליך הבן סוגר את קצה הקריאה שלו בצינור מיד לאחר יצירתו, וקיבולת הצינור היא 64KB (בהנחה שאין טיפול מיוחד באותות)?",
      "code_snippet": null,
      "options": [
        "א. תהליך האב יחסם ללא הגבלת זמן עד שתהליך הבן יקרא את הנתונים.",
        "ב. תהליך האב יקבל אות SIGPIPE ויסיים את פעולתו.",
        "ג. תהליך האב יכתוב בהצלחה 10KB של נתונים, והנתונים יישארו בחיץ הצינור עד שהצינור יושמד.",
        "ד. קריאת המערכת write() של תהליך האב תחזיר שגיאה עם errno שווה ל-EPIPE לאחר ניסיון הכתיבה.",
        "ה. כל התשובות האחרות אינן נכונות."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "כאשר תהליך כותב לצינור שקצה הקריאה שלו נסגר על ידי התהליך השני, מערכת ההפעלה שולחת אות SIGPIPE לתהליך הכותב. ברירת המחדל לטיפול באות SIGPIPE היא סיום התהליך (termination). לכן, בהנחה שאין טיפול מיוחד באותות, תהליך האב יקבל את האות ויסיים את פעולתו. אם האות היה מטופל (למשל, על ידי התעלמות ממנו), אז קריאת המערכת write() הייתה נכשלת ומחזירה -1, עם errno ששווה ל-EPIPE. קיבולת הצינור אינה רלוונטית במקרה זה, שכן הבעיה היא היעדר קורא פעיל, לא חוסר מקום בחיץ."
    },
    "difficulty_estimation": "Medium"
  }
}