{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores and Deadlocks",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:42:17",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4285,
      "output_tokens": 2046,
      "total_tokens": 11071
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Synchronization",
      "Semaphores",
      "Deadlocks",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה מערכת המורכבת משני סוגי תהליכונים (threads) ושני משאבים משותפים (R1, R2). כל משאב מוגן באמצעות סמפור בינארי משלו. תהליכונים מסוג A נדרשים לגשת למשאב R1 ולאחר מכן למשאב R2. תהליכונים מסוג B נדרשים לגשת למשאב R2 ולאחר מכן למשאב R1. הקוד הבא מממש את התנהגות התהליכונים. הניחו שכל הסמפורים מאותחלים ל-1.",
      "code_snippet": "sem_t S1, S2; // סמפורים למשאבים R1 ו- R2\n\nvoid *thread_A_func(void *arg) {\n    // תהליכון מסוג A: ניגש ל-R1 ואז ל-R2\n    sem_wait(&S1);\n    // ... מבצע עבודה עם R1 ...\n    sem_wait(&S2);\n    // ... מבצע עבודה עם R1 ו-R2 ...\n    sem_post(&S2);\n    sem_post(&S1);\n    return NULL;\n}\n\nvoid *thread_B_func(void *arg) {\n    // תהליכון מסוג B: ניגש ל-R2 ואז ל-R1\n    sem_wait(&S2);\n    // ... מבצע עבודה עם R2 ...\n    sem_wait(&S1);\n    // ... מבצע עבודה עם R1 ו-R2 ...\n    sem_post(&S1);\n    sem_post(&S2);\n    return NULL;\n}"
    },
    "sub_questions": [
      {
        "id": "8.1",
        "text": "האם קיים מצב של קיפאון (Deadlock) אפשרי במערכת זו? אם כן, תארו תרחיש ספציפי (למשל, באמצעות סדר פעולות) שמוביל לקיפאון.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "8.2",
        "text": "הסבירו בקצרה מדוע המצב המתואר בסעיף הקודם אכן מהווה קיפאון, תוך התייחסות לתנאים ההכרחיים לקיפאון.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "8.3",
        "text": "תקנו את הקוד על מנת למנוע קיפאון, תוך שמירה על הגישה ההדדית הבלעדית (mutual exclusion) לכל משאב. הציגו את הקוד המתוקן והסבירו בקצרה את עיקרון התיקון.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "8.1. כן, קיים מצב של קיפאון (Deadlock).\nתרחיש לדוגמה:\n1.  תהליכון A מבצע `sem_wait(&S1)` בהצלחה (תופס את R1).\n2.  תהליכון B מבצע `sem_wait(&S2)` בהצלחה (תופס את R2).\n3.  תהליכון A מנסה לבצע `sem_wait(&S2)` אך S2 כבר נתפס על ידי תהליכון B, ולכן A נחסם וממתין ל-S2.\n4.  תהליכון B מנסה לבצע `sem_wait(&S1)` אך S1 כבר נתפס על ידי תהליכון A, ולכן B נחסם וממתין ל-S1.\nבשלב זה, שני התהליכונים חסומים זה לזה, כל אחד מחזיק במשאב שהשני ממתין לו, ולא יוכלו להתקדם. זהו מצב של קיפאון.\n\n8.2. המצב המתואר מהווה קיפאון מכיוון שהוא מקיים את כל ארבעת התנאים ההכרחיים לקיפאון:\n*   **הדרה הדדית (Mutual Exclusion)**: כל משאב (S1, S2) יכול להיתפס על ידי תהליכון אחד בלבד בכל רגע נתון, מכיוון שהם סמפורים בינאריים. אם תהליכון תופס סמפור, אחרים נחסמים.\n*   **החזק והמתן (Hold and Wait)**: כל תהליכון מחזיק במשאב אחד (A מחזיק ב-R1, B מחזיק ב-R2) ובמקביל ממתין למשאב נוסף (A ממתין ל-R2, B ממתין ל-R1).\n*   **אין דריסה (No Preemption)**: המשאבים אינם ניתנים לדריסה. סמפור שנתפס חייב להשתחרר באופן יזום על ידי התהליכון שתפס אותו, ואי אפשר לקחת אותו בכוח מתהליכון אחר.\n*   **המתנה מעגלית (Circular Wait)**: קיימת שרשרת מעגלית של תהליכונים הממתינים זה לזה. תהליכון A ממתין למשאב שמוחזק על ידי תהליכון B, ותהליכון B ממתין למשאב שמוחזק על ידי תהליכון A.\n\n8.3. כדי למנוע קיפאון, ניתן לשבור את אחד התנאים ההכרחיים לקיפאון. הדרך הנפוצה והפשוטה ביותר במקרה זה היא לשבור את תנאי ההמתנה המעגלית על ידי אכיפת סדר עקבי לרכישת המשאבים. כלומר, כל התהליכונים ירכשו את המשאבים באותו סדר.\n\n**קוד מתוקן:**\n```c\nsem_t S1, S2; // סמפורים למשאבים R1 ו- R2\n\nvoid *thread_A_func_fixed(void *arg) {\n    // תהליכון מסוג A: ניגש ל-R1 ואז ל-R2 (הסדר נשמר)\n    sem_wait(&S1);\n    // ... מבצע עבודה עם R1 ...\n    sem_wait(&S2);\n    // ... מבצע עבודה עם R1 ו-R2 ...\n    sem_post(&S2);\n    sem_post(&S1);\n    return NULL;\n}\n\nvoid *thread_B_func_fixed(void *arg) {\n    // תהליכון מסוג B: ניגש ל-R1 ואז ל-R2 (הסדר שונה כדי למנוע קיפאון)\n    sem_wait(&S1); // שונה: קודם S1, אחר כך S2\n    // ... מבצע עבודה עם R1 ...\n    sem_wait(&S2);\n    // ... מבצע עבודה עם R1 ו-R2 ...\n    sem_post(&S2);\n    sem_post(&S1);\n    return NULL;\n}\n```\n**הסבר לתיקון:**\nהתיקון מבטיח ששני סוגי התהליכונים (A ו-B) מנסים לרכוש את המשאבים באותו סדר קבוע (לדוגמה, תמיד קודם S1 ואז S2). על ידי אכיפת סדר עקבי לרכישת משאבים, אנו מונעים את היווצרות שרשרת ההמתנה המעגלית. אם תהליכון A תופס את S1 ותהליכון B מנסה גם הוא לתפוס את S1, תהליכון B ימתין עד ש-A ישחרר את S1. כאשר A ישחרר את S1, הוא כבר יחזיק ב-S2 (או ישחרר אותו מיד). בדרך זו, לעולם לא ייווצר מצב שבו A ממתין ל-S2 בזמן ש-B ממתין ל-S1, מכיוון ששניהם תמיד ינסו לתפוס את S1 קודם."
    },
    "difficulty_estimation": "Hard"
  }
}