{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:48:32",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 5452,
      "total_tokens": 17843
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Process Management",
      "Synchronization"
    ],
    "content": {
      "text": "תכנן ויישם תוכנית ב-C/C++ המדמה מערכת של תהליך אב (Parent) המנהל מספר תהליכי בן (Children). המערכת צריכה לקיים את הדרישות הבאות:\n\n1.  **יצירת תהליכים:** תהליך האב ייצור `N` תהליכי בן (כאשר `N` הוא קבוע, לדוגמה 3). לכל תהליך בן יוקצה מזהה ייחודי (ID) מ-0 עד `N-1`.\n2.  **פעילות תהליכי הבן:** כל תהליך בן יבצע לולאה אינסופית המדמה עבודה: הוא יגדיל מונה פנימי משלו (counter) וישלח את ערכו הנוכחי, יחד עם מזהה הבן שלו (ID), לתהליך האב. לאחר מכן, הבן ימתין זמן קצר (לדוגמה, שנייה אחת).\n3.  **תקשורת בין תהליכים (IPC):** השתמשו ב-Pipe ללא שם (unnamed pipe) לצורך דיווח ההתקדמות מתהליכי הבן לתהליך האב. יש להגדיר פורמט ברור לדיווח.\n4.  **שליטה באמצעות אותות (Signals):**\n    *   תהליך האב יוכל לשלוח אות `SIGUSR1` לתהליך בן ספציפי כדי להשהות את עבודתו.\n    *   תהליך האב יוכל לשלוח אות `SIGUSR2` לאותו תהליך בן כדי לחדש את עבודתו.\n    *   תהליכי הבן צריכים לטפל באותות אלו בהתאם.\n5.  **טיפול בסיום תהליכים:** תהליך האב יצטרך לטפל בסיום תקין של תהליכי הבן באמצעות אות `SIGCHLD`, ולנקות את המשאבים המתאימים.\n6.  **מניעת תנאי מירוץ וקיפאון:** הקפידו על טיפול נכון באותות וב-IPC כדי למנוע תנאי מירוץ (race conditions) או מצבי קיפאון (deadlocks). יש להסביר בפתרון כיצד נמנעים ממצבים אלו.\n\n**דרישות לפתרון:**\n*   יש לספק את קוד המקור המלא של התוכנית ב-C/C++.\n*   יש לכלול הסבר מפורט על עיצוב התוכנית, בחירת מנגנוני ה-IPC והאותות, וכיצד נפתרו האתגרים השונים (כגון טיפול באותות בטוח, מניעת תנאי מירוץ, וקריאה מ-pipe מכמה תהליכים).\n*   ההסבר צריך לפרט גם את התנהגות התוכנית והפלט הצפוי.\n\n**הערה:** יש להניח שהאב יקבל קלט מהמשתמש (לדוגמה, דרך `stdin`) כדי לשלוח אותות ספציפיים לבנים ספציפיים, או שימתין לזמן מוגדר לפני שליחת אותות.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h> // For non-blocking pipe read\n#include <sys/select.h> // For select()\n\n#define NUM_CHILDREN 3\n#define BUFFER_SIZE 256\n\n// Global flags for signal handling in children\nvolatile sig_atomic_t is_paused = 0;\nvolatile sig_atomic_t child_id_global = -1; // To store child ID for logging\n\n// Signal handler for SIGUSR1 (pause)\nvoid sigusr1_handler(int signum) {\n    is_paused = 1;\n    // printf(\"Child %d: Received SIGUSR1 - PAUSING.\\n\", child_id_global);\n}\n\n// Signal handler for SIGUSR2 (resume)\nvoid sigusr2_handler(int signum) {\n    is_paused = 0;\n    // printf(\"Child %d: Received SIGUSR2 - RESUMING.\\n\", child_id_global);\n}\n\n// Signal handler for SIGCHLD (parent)\nvoid sigchld_handler(int signum) {\n    int status;\n    pid_t pid;\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        if (WIFEXITED(status)) {\n            printf(\"Parent: Child PID %d exited normally with status %d.\\n\", pid, WEXITSTATUS(status));\n        } else if (WIFSIGNALED(status)) {\n            printf(\"Parent: Child PID %d terminated by signal %d.\\n\", pid, WTERMSIG(status));\n        }\n    }\n}\n\n// Child process function\nvoid child_task(int child_id, int write_pipe_fd) {\n    child_id_global = child_id; // Set global ID for signal handler logging\n    int counter = 0;\n    char buffer[BUFFER_SIZE];\n\n    // Setup signal handlers for SIGUSR1 and SIGUSR2\n    struct sigaction sa_usr1, sa_usr2;\n    memset(&sa_usr1, 0, sizeof(sa_usr1));\n    sa_usr1.sa_handler = sigusr1_handler;\n    sa_usr1.sa_flags = SA_RESTART; // Restart interrupted system calls\n    sigemptyset(&sa_usr1.sa_mask); // No signals blocked inside handler\n    if (sigaction(SIGUSR1, &sa_usr1, NULL) == -1) {\n        perror(\"sigaction SIGUSR1\");\n        exit(EXIT_FAILURE);\n    }\n\n    memset(&sa_usr2, 0, sizeof(sa_usr2));\n    sa_usr2.sa_handler = sigusr2_handler;\n    sa_usr2.sa_flags = SA_RESTART;\n    sigemptyset(&sa_usr2.sa_mask);\n    if (sigaction(SIGUSR2, &sa_usr2, NULL) == -1) {\n        perror(\"sigaction SIGUSR2\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Close the read end of the pipe in child\n    close(0); // Close stdin for child\n\n    while (1) {\n        // Check if paused\n        while (is_paused) {\n            // Sleep to avoid busy-waiting while paused\n            sleep(1); \n        }\n\n        counter++;\n        snprintf(buffer, BUFFER_SIZE, \"Child %d: counter = %d\\n\", child_id, counter);\n        \n        // Write to pipe\n        if (write(write_pipe_fd, buffer, strlen(buffer)) == -1) {\n            if (errno == EPIPE) { // Parent closed read end\n                printf(\"Child %d: Pipe closed by parent. Exiting.\\n\", child_id);\n            } else {\n                perror(\"Child write to pipe\");\n            }\n            break; // Exit loop if pipe write fails\n        }\n\n        sleep(1); // Simulate work\n    }\n\n    close(write_pipe_fd);\n    printf(\"Child %d: Exiting.\\n\", child_id);\n    exit(EXIT_SUCCESS);\n}\n\nint main() {\n    pid_t children_pids[NUM_CHILDREN];\n    int pipe_fds[2]; // pipe_fds[0] for read, pipe_fds[1] for write\n\n    // Create the pipe\n    if (pipe(pipe_fds) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set the read end of the pipe to non-blocking\n    if (fcntl(pipe_fds[0], F_SETFL, O_NONBLOCK) == -1) {\n        perror(\"fcntl O_NONBLOCK\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Setup SIGCHLD handler in parent\n    struct sigaction sa_chld;\n    memset(&sa_chld, 0, sizeof(sa_chld));\n    sa_chld.sa_handler = sigchld_handler;\n    sa_chld.sa_flags = SA_RESTART | SA_NOCLDSTOP; // SA_NOCLDSTOP prevents SIGCHLD on child stop/continue\n    sigemptyset(&sa_chld.sa_mask);\n    if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Block SIGUSR1 and SIGUSR2 in parent to avoid unexpected behavior\n    // The parent only sends these, doesn't handle them for itself.\n    sigset_t block_mask;\n    sigemptyset(&block_mask);\n    sigaddset(&block_mask, SIGUSR1);\n    sigaddset(&block_mask, SIGUSR2);\n    if (sigprocmask(SIG_BLOCK, &block_mask, NULL) == -1) {\n        perror(\"sigprocmask block SIGUSR1/2\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Fork children\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        pid_t pid = fork();\n\n        if (pid == -1) {\n            perror(\"fork\");\n            // Clean up already forked children and exit\n            for (int j = 0; j < i; ++j) {\n                kill(children_pids[j], SIGTERM);\n            }\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) { // Child process\n            close(pipe_fds[0]); // Child closes read end of pipe\n            child_task(i, pipe_fds[1]);\n            // child_task will exit\n        } else { // Parent process\n            children_pids[i] = pid;\n            printf(\"Parent: Forked child %d with PID %d.\\n\", i, pid);\n        }\n    }\n\n    // Parent closes write end of the pipe\n    close(pipe_fds[1]);\n\n    printf(\"Parent: Enter command (e.g., 'p 0' to pause child 0, 'r 1' to resume child 1, 'q' to quit):\\n\");\n\n    char command[BUFFER_SIZE];\n    fd_set read_fds;\n    int max_fd = pipe_fds[0]; // Max file descriptor for select\n\n    while (1) {\n        FD_ZERO(&read_fds);\n        FD_SET(STDIN_FILENO, &read_fds);\n        FD_SET(pipe_fds[0], &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = 1; // Wait up to 1 second\n        tv.tv_usec = 0;\n\n        int retval = select(max_fd + 1, &read_fds, NULL, NULL, &tv);\n\n        if (retval == -1) {\n            if (errno == EINTR) continue; // Interrupted by signal, retry\n            perror(\"select\");\n            break;\n        } else if (retval == 0) {\n            // Timeout, no data to read, continue loop\n        } else {\n            // Data available\n            if (FD_ISSET(STDIN_FILENO, &read_fds)) {\n                // Command from user\n                if (fgets(command, BUFFER_SIZE, stdin) == NULL) {\n                    perror(\"fgets\");\n                    break;\n                }\n                char cmd_char;\n                int child_idx;\n                if (sscanf(command, \"%c %d\", &cmd_char, &child_idx) == 2) {\n                    if (child_idx >= 0 && child_idx < NUM_CHILDREN) {\n                        if (cmd_char == 'p') {\n                            kill(children_pids[child_idx], SIGUSR1);\n                            printf(\"Parent: Sent SIGUSR1 to child %d (PID %d).\\n\", child_idx, children_pids[child_idx]);\n                        } else if (cmd_char == 'r') {\n                            kill(children_pids[child_idx], SIGUSR2);\n                            printf(\"Parent: Sent SIGUSR2 to child %d (PID %d).\\n\", child_idx, children_pids[child_idx]);\n                        } else {\n                            printf(\"Unknown command: %s\", command);\n                        }\n                    } else {\n                        printf(\"Invalid child ID.\\n\");\n                    }\n                } else if (strcmp(command, \"q\\n\") == 0) {\n                    printf(\"Parent: Quitting. Terminating children.\\n\");\n                    for (int i = 0; i < NUM_CHILDREN; ++i) {\n                        if (children_pids[i] > 0) { // If child is still alive\n                            kill(children_pids[i], SIGTERM);\n                        }\n                    }\n                    break;\n                } else {\n                    printf(\"Invalid input format. Use 'p <child_id>', 'r <child_id>' or 'q'.\\n\");\n                }\n            }\n\n            if (FD_ISSET(pipe_fds[0], &read_fds)) {\n                // Data from pipe\n                ssize_t bytes_read;\n                while ((bytes_read = read(pipe_fds[0], buffer, BUFFER_SIZE - 1)) > 0) {\n                    buffer[bytes_read] = '\\0';\n                    printf(\"Parent (Pipe): %s\", buffer);\n                }\n                if (bytes_read == -1 && errno != EWOULDBLOCK) {\n                    perror(\"Parent read from pipe\");\n                    // Potentially break here, or handle specific errors\n                }\n            }\n        }\n    }\n\n    // Wait for all children to terminate (if not already handled by SIGCHLD and exit)\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (children_pids[i] > 0) { // Only wait for children that were successfully forked\n            waitpid(children_pids[i], NULL, 0);\n        }\n    }\n\n    close(pipe_fds[0]);\n    printf(\"Parent: All children terminated. Exiting.\\n\");\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**עיצוב כללי**\nהפתרון מורכב מתהליך אב ותהליכי בן. תהליך האב יוצר צינור ללא שם (unnamed pipe) לפני יצירת הבנים. לאחר מכן, הוא יוצר `NUM_CHILDREN` תהליכי בן באמצעות `fork()`. כל בן מקבל מזהה ייחודי (ID) ואת קצה הכתיבה של הצינור. האב שומר את ה-PIDs של הבנים כדי לשלוט בהם באמצעות אותות.\n\n**תקשורת בין תהליכים (IPC) - ה-Pipe**\n*   **יצירה וסגירה:** ה-pipe נוצר באב לפני ה-`fork()`. קצה הקריאה של ה-pipe (pipe_fds[0]) משמש את האב בלבד, וקצה הכתיבה (pipe_fds[1]) משמש את הבנים בלבד.\n*   **סגירת קצוות מיותרים:** לאחר ה-`fork()`, כל תהליך בן סוגר את קצה הקריאה של ה-pipe, ותהליך האב סוגר את קצה הכתיבה. זה קריטי כדי למנוע קיפאון ולאפשר ל-`select()` באב לזהות מתי כל הבנים סיימו וסגרו את קצה הכתיבה (ובכך יגיע EOF).\n*   **דיווח התקדמות:** כל בן כותב ל-pipe הודעת טקסט המכילה את מזהה הבן ואת ערך המונה הנוכחי שלו.\n*   **קריאה לא חוסמת:** קצה הקריאה של ה-pipe באב מוגדר כלא חוסם (non-blocking) באמצעות `fcntl(pipe_fds[0], F_SETFL, O_NONBLOCK)`. זה מאפשר לאב לקרוא נתונים מה-pipe מבלי לחכות אם אין נתונים זמינים, ובכך הוא יכול גם לבדוק קלט ממשתמש וגם לנהל את הבנים.\n\n**טיפול באותות (Signals)**\n\n1.  **טיפול באותות בבנים (`SIGUSR1`, `SIGUSR2`):**\n    *   כל תהליך בן מגדיר מטפלי אותות (signal handlers) עבור `SIGUSR1` ו-`SIGUSR2` באמצעות `sigaction()`.\n    *   `SIGUSR1` משמש להשהיית עבודת הבן: המטפל מגדיר דגל גלובלי מסוג `volatile sig_atomic_t` בשם `is_paused` ל-1.\n    *   `SIGUSR2` משמש לחידוש עבודת הבן: המטפל מגדיר את `is_paused` ל-0.\n    *   הדגל `is_paused` הוא `volatile sig_atomic_t` כדי להבטיח גישה אטומית ובטוחה מנקודת מבט של קומפיילר ושל גישה במקביל על ידי המטפל והלולאה הראשית של הבן.\n    *   בתוך לולאת העבודה של הבן, ישנה בדיקה של הדגל `is_paused`. אם הוא 1, הבן נכנס ללולאת המתנה שבה הוא קורא ל-`sleep(1)` כדי למנוע busy-waiting (במקום לבזבז משאבי CPU בלולאה ריקה). ברגע ש-`SIGUSR2` מתקבל, הדגל מתאפס והבן ממשיך בעבודתו.\n    *   הדגל `SA_RESTART` מוגדר ב-`sigaction` כדי שקריאות מערכת כמו `write()` או `sleep()` שהופרעו על ידי אות יופעלו מחדש באופן אוטומטי.\n\n2.  **טיפול באותות באב (`SIGCHLD`):**\n    *   תהליך האב מגדיר מטפל אותות עבור `SIGCHLD` באמצעות `sigaction()`.\n    *   מטפל ה-`SIGCHLD` משתמש ב-`waitpid(-1, &status, WNOHANG)` בלולאה כדי לקצור את כל תהליכי הבן שהסתיימו מבלי לחסום את האב. `WNOHANG` מבטיח שה-`waitpid` יחזור מיד אם אין בנים שסיימו.\n    *   הדגל `SA_NOCLDSTOP` מוגדר כדי למנוע קבלת `SIGCHLD` כאשר בן מושהה או מתחדש, ולקבל אותו רק עם סיום הבן.\n\n3.  **שליחת אותות מהאב:**\n    *   האב משתמש בפונקציה `kill()` כדי לשלוח `SIGUSR1` או `SIGUSR2` לבן ספציפי, על סמך קלט מהמשתמש. ה-PID של הבן הספציפי נשמר במערך `children_pids`.\n    *   האב חוסם את `SIGUSR1` ו-`SIGUSR2` עבור עצמו באמצעות `sigprocmask()` כדי למנוע קבלת אותות אלו, שנועדו לבנים.\n\n**מניעת תנאי מירוץ וקיפאון**\n*   **Pipe Cleanup:** סגירת קצוות ה-pipe הלא נחוצים בתהליכים השונים מונעת מצבי קיפאון פוטנציאליים ב-`read()` וב-`write()`.\n*   **Non-blocking I/O עם `select()`:** השימוש ב-`select()` עם קצה קריאה לא חוסם של ה-pipe ובדיקת `stdin` מאפשר לאב לנהל מספר ערוצי קלט בו זמנית מבלי לחסום את פעילותו. `select()` גם מאפשר לאב להגיב לאותות (דרך `EINTR`) או להמשיך בפעילות אחרת (במקרה של timeout).\n*   **`volatile sig_atomic_t`:** השימוש בדגל זה מבטיח שהגישה אליו מהלולאה הראשית של הבן ומהמטפל האות תהיה בטוחה ואטומית.\n*   **`sleep()` במצב מושהה:** מונע busy-waiting ומפנה את ה-CPU לשימוש תהליכים אחרים.\n*   **`SA_RESTART`:** מונע הפרעות לא צפויות לקריאות מערכת שיכולות לגרום לשגיאות `EINTR` ולמצבים לא עקביים.\n\n**התנהגות התוכנית והפלט הצפוי**\nהתוכנית תתחיל, האב ייצור 3 בנים וידפיס את ה-PIDs שלהם. הבנים יתחילו להדפיס הודעות התקדמות (מונה) ל-pipe, שהאב יקרא וידפיס למסך.\nהאב ימתין לקלט ממשתמש:\n*   `p <child_id>`: ישלח `SIGUSR1` לבן בעל ה-ID המתאים, והבן יושהה (יפסיק להגדיל מונה ולדווח).\n*   `r <child_id>`: ישלח `SIGUSR2` לאותו בן, והבן יתחדש.\n*   `q`: יסיים את האב ואת כל הבנים.\nכאשר בן מסיים (לדוגמה, על ידי `SIGTERM` מהאב בעת יציאה), מטפל ה-`SIGCHLD` באב יקצור אותו וידפיס הודעה מתאימה."
    },
    "difficulty_estimation": "Hard"
  }
}