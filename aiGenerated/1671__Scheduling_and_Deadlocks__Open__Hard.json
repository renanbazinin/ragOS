{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 19:57:39",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3383,
      "output_tokens": 1684,
      "total_tokens": 10137
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Deadlocks",
      "Concurrency",
      "Priority Scheduling"
    ],
    "content": {
      "text": "במערכת הפעלה נתונה, רצים שלושה תהליכים: P1, P2 ו-P3. המערכת משתמשת בשני מנעולים (mutexes) גלובליים, A ו-B, כאשר כל מנעול זמין במופע יחיד. כל התהליכים מנסים לבצע קטע קריטי הדורש את שני המנעולים. סדר רכישת המנעולים עבור כל תהליך מוגדר כדלקמן:\n\nP1: רוכש A, רוכש B, מבצע פעולה, משחרר B, משחרר A.\nP2: רוכש B, רוכש A, מבצע פעולה, משחרר A, משחרר B.\nP3: רוכש A, רוכש B, מבצע פעולה, משחרר B, משחרר A.\n\nהמערכת משתמשת באלגוריתם תזמון מבוסס עדיפויות, לא נדחה (non-preemptive priority scheduling). העדיפויות הן: P1 > P2 > P3 (כלומר P1 בעל העדיפות הגבוהה ביותר, P3 הנמוכה ביותר).\n\nא. האם במצב זה עלול להיווצר קיפאון (deadlock)? נמק בפירוט. אם כן, תאר תרחיש אפשרי להיווצרות הקיפאון.\nב. האם ייתכן מצב של רעב (starvation) עבור אחד או יותר מהתהליכים? נמק.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. כן, בהחלט עלול להיווצר קיפאון (deadlock). נסביר את התנאים והתרחיש:\n\nתנאי קיפאון:\n1.  **מניעה הדדית (Mutual Exclusion):** מתקיים, שכן המנעולים A ו-B הם mutexes, ורק תהליך אחד יכול להחזיק כל מנעול בכל רגע נתון.\n2.  **החזקה והמתנה (Hold and Wait):** מתקיים, שכן כל תהליך רוכש מנעול אחד וממתין למנעול השני (לדוגמה, P1 רוכש את A וממתין ל-B, ו-P2 רוכש את B וממתין ל-A).\n3.  **אי-דחיה (No Preemption):** מתקיים, שכן המנעולים אינם נדחים מתהליכים שמחזיקים אותם; רק התהליך המחזיק יכול לשחרר אותם.\n4.  **המתנה מעגלית (Circular Wait):** זהו התנאי המורכב ביותר בהקשר לתזמון. תזמון מבוסס עדיפויות לא נדחה אומר שאם תהליך בעל עדיפות גבוהה מתחיל לרוץ, הוא ימשיך לרוץ עד שיסיים או ייחסם (למשל, בהמתנה למנעול).\n\nתרחיש אפשרי לקיפאון:\n1.  תהליך P2 מתחיל לרוץ (לדוגמה, P1 אינו מוכן לרוץ בתחילה, או P1 בדיוק סיים פעולת קלט/פלט והוא עומד להפוך למוכן, אך P2 קיבל את המעבד). P2 רוכש את מנעול B.\n2.  P2 מנסה כעת לרכוש את מנעול A, אך בדיוק ברגע זה, תהליך P1 הופך למוכן לרוץ ומקבל את המעבד (בגלל עדיפותו הגבוהה יותר). P2 נחסם (ממתין ל-A) ומוסר את המעבד.\n3.  P1, בעל העדיפות הגבוהה ביותר, מתחיל לרוץ. P1 רוכש את מנעול A.\n4.  P1 מנסה כעת לרכוש את מנעול B. אך B מוחזק על ידי P2. לכן, P1 נחסם (ממתין ל-B).\n\nבמצב זה, נוצר קיפאון: P1 מחזיק את A וממתין ל-B (שמוחזק על ידי P2), בעוד P2 מחזיק את B וממתין ל-A (שמוחזק על ידי P1). תהליך P3 אינו יכול להתקדם כלל במצב זה, שכן הוא ממתין ל-A או B שמוחזקים. אף אחד מהתהליכים לא יכול להמשיך, והמערכת נמצאת בקיפאון.\n\nב. כן, בהחלט ייתכן מצב של רעב (starvation) עבור אחד או יותר מהתהליכים.\n\n**רעב עבור P3:**\nתהליך P3 הוא בעל העדיפות הנמוכה ביותר. במערכת תזמון מבוססת עדיפויות, אם תהליכים P1 ו-P2 (בעלי עדיפות גבוהה יותר) ממשיכים לרוץ, לסיים את הקטעים הקריטיים שלהם, ולהפוך שוב למוכנים לרוץ, P3 לעולם לא יקבל הזדמנות לקבל את המעבד. גם אם P1 ו-P2 נכנסים לקיפאון כפי שתואר בסעיף א', P3 עדיין לא יוכל לרוץ (שכן הוא ממתין למשאבים שמוחזקים על ידי P1 ו-P2). אם הקיפאון נפתר, ו-P1 ו-P2 ממשיכים לרוץ בלולאה אינסופית (או חוזרים להיות מוכנים לעיתים קרובות), P3 יכול להישאר בהמתנה אינסופית.\n\n**רעב עבור P2 (במצבים מסוימים):**\nלמרות ש-P2 בעל עדיפות בינונית, הוא עדיין יכול לסבול מרעב. אם P1 (בעל העדיפות הגבוהה ביותר) נמצא במצב שבו הוא כמעט תמיד מוכן לרוץ וצורש את המעבד, P2 יקבל זמן מעבד רק כאשר P1 חסום (למשל, ממתין לקלט/פלט) או מסיים. אם P1 מבצע עבודה רבה ונדיר שהוא נחסם, P2 יכול לסבול מרעב.\n\nלסיכום, במערכת תזמון מבוססת עדיפויות לא נדחה, תהליכים בעלי עדיפות נמוכה יותר חשופים מאוד לסכנת רעב אם תהליכים בעלי עדיפות גבוהה יותר תמיד מוכנים לרוץ.",
      "difficulty_estimation": "Hard"
    }
  }
}