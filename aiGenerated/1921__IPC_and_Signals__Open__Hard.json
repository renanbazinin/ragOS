{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "IPC and Signals",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:49:22",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4150,
      "output_tokens": 5253,
      "total_tokens": 16886
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "IPC",
      "Signals",
      "Shared Memory",
      "Semaphores",
      "Concurrency"
    ],
    "content": {
      "text": "תכנן ויישם ב-C/C++ תוכנית המדגימה תקשורת בין תהליכים (IPC) וטיפול באותות (Signals) באופן חזק ואמין. התוכנית תכלול תהליך אב ותהליך בן. תהליך האב ישמש כיצרן (Producer) ויכתוב מספרים שלמים לזיכרון משותף, ותהליך הבן ישמש כצרכן (Consumer) ויקרא מספרים אלו מהזיכרון המשותף.\n\nדרישות:\n1.  הזיכרון המשותף ישמש כבָּפֶר מעגלי (circular buffer) עבור מספרים שלמים.\n2.  הסנכרון בין האב לבן (הכנסה והוצאה מהבָּפֶר) יתבצע באמצעות סמפורים (semaphores) של System V.\n3.  יש לטפל באות `SIGINT` (לחיצה על Ctrl+C) בשני התהליכים (אב ובן) באופן אלגנטי, כך שכל המשאבים המשותפים (קטע זיכרון משותף, סמפורים) ישוחררו ויושמדו בצורה נכונה, ללא קשר לאיזה תהליך קיבל את האות ראשון או מתי הוא מסיים את פעולתו.\n4.  יש לכלול הסבר מפורט על אופן הפעולה של הקוד, המנגנונים שנבחרו (IPC ו-Signals), וההתמודדות עם האתגרים השונים (סנכרון, טיפול באותות וניקוי משאבים).\n\nציין והסבר במפורט את הצעדים הדרושים ליצירת, שימוש, וניקוי המשאבים המשותפים, ואת הדרך שבה הקוד מבטיח סיום עבודה נקי ובטוח.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "הפתרון כולל קוד C המממש את הדרישות באמצעות זיכרון משותף (Shared Memory) וסמפורים (System V Semaphores) לתקשורת וסנכרון בין תהליך אב לבן, וטיפול באות `SIGINT` לסיום עבודה אלגנטי וניקוי משאבים.\n\n**מבנה הזיכרון המשותף:**\nהזיכרון המשותף מוגדר כמבנה `shared_data_t` המכיל:\n*   מערך `buffer` המשמש כבָּפֶר מעגלי עבור מספרים שלמים.\n*   אינדקסים `in` ו-`out` למעקב אחר מיקום הכתיבה והקריאה בבָּפֶר.\n*   דגל `terminate_flag` מסוג `volatile sig_atomic_t`, המשמש לאיתות סיום עבודה לשני התהליכים בעקבות קבלת `SIGINT`. השימוש ב-`volatile` מבטיח שהקומפיילר לא יבצע אופטימיזציות שימנעו קריאה עדכנית של הדגל, ו-`sig_atomic_t` מבטיח שהגישה אליו אטומית ובטוחה מתוך Signal Handler.\n\n**הסמפורים:**\nנעשה שימוש בשלושה סמפורים של System V, המנוהלים כקבוצת סמפורים:\n1.  `empty`: סמפור מונה (counting semaphore) המציין את מספר המקומות הפנויים בבָּפֶר. מאותחל לגודל הבָּפֶר (`BUFFER_SIZE`). האב מבצע עליו `sem_wait` לפני כתיבה, והבן מבצע עליו `sem_post` לאחר קריאה.\n2.  `full`: סמפור מונה המציין את מספר הפריטים המלאים בבָּפֶר. מאותחל ל-0. הבן מבצע עליו `sem_wait` לפני קריאה, והאב מבצע עליו `sem_post` לאחר כתיבה.\n3.  `mutex`: סמפור בינארי (binary semaphore / mutex) להבטחת גישה הדדית בלעדית (mutual exclusion) לאינדקסים `in`, `out` ולמערך `buffer` עצמו. מאותחל ל-1. שני התהליכים מבצעים עליו `sem_wait` לפני גישה לאזור הקריטי ו-`sem_post` לאחר מכן.\n\n**תהליך העבודה:**\n1.  **יצירת משאבים:** תהליך האב יוצר את קטע הזיכרון המשותף ואת קבוצת הסמפורים באמצעות `shmget` ו-`semget` בהתאמה. הוא מאתחל את הסמפורים ואת מבנה הנתונים בזיכרון המשותף.\n2.  **יצירת תהליכים:** האב יוצר את תהליך הבן באמצעות `fork()`.\n3.  **הצמדת זיכרון משותף:** שני התהליכים מצמידים את קטע הזיכרון המשותף למרחב הכתובות שלהם באמצעות `shmat`.\n4.  **Signal Handling:** בשני התהליכים, מוגדר Signal Handler עבור `SIGINT` באמצעות `sigaction`. ה-handler פשוט מעדכן את `terminate_flag` בזיכרון המשותף ל-1. חשוב לציין שפעולות מורכבות (כמו ניקוי משאבים) אינן בטוחות לביצוע בתוך Signal Handler, ולכן רק דגל אטומי מעודכן.\n5.  **לולאות עבודה:**\n    *   **אב (Producer):** בלולאה אינסופית, האב ממתין לסמפור `empty`, מבצע `sem_wait` על `mutex`, כותב מספר לזיכרון המשותף, מעדכן את `in`, מבצע `sem_post` על `mutex`, ומבצע `sem_post` על `full`. הוא בודק את `terminate_flag` באופן מחזורי, ואם הוא מוגדר, הוא יוצא מהלולאה.\n    *   **בן (Consumer):** בלולאה אינסופית, הבן ממתין לסמפור `full`, מבצע `sem_wait` על `mutex`, קורא מספר מהזיכרון המשותף, מעדכן את `out`, מבצע `sem_post` על `mutex`, ומבצע `sem_post` על `empty`. הוא בודק את `terminate_flag` באופן מחזורי, ואם הוא מוגדר, הוא יוצא מהלולאה.\n    *   חשוב לציין כי קריאות `sem_wait` עשויות להיות מופסקות על ידי אותות (עם `errno == EINTR`). במקרה כזה, התוכנית בודקת את `terminate_flag` לפני ניסיון חוזר או יציאה. כמו כן, אם תהליך מסיים בזמן שהוא מחזיק בסמפור (למשל, `mutex` או `empty`/`full` לאחר ביצוע `sem_wait` עליהם), הוא משחרר אותם לפני היציאה מהלולאה כדי למנוע מצב של חסימת תהליכים אחרים.\n\n**סיום עבודה וניקוי משאבים:**\n1.  כאשר אחד התהליכים מקבל `SIGINT` (או שניהם), ה-handler מעדכן את `terminate_flag` בזיכרון המשותף. כתוצאה מכך, שני התהליכים יבחינו בדגל ויצאו מלולאות העבודה שלהם.\n2.  כל תהליך מנתק את קטע הזיכרון המשותף ממרחב הכתובות שלו באמצעות `shmdt()`.\n3.  תהליך האב ממתין לסיום תהליך הבן באמצעות `waitpid()`. זה מבטיח שהבן הספיק לנתק את הזיכרון המשותף לפני שהאב מנסה להשמיד אותו.\n4.  לאחר שהבן סיים, האב אחראי להשמיד את המשאבים המשותפים: הוא משתמש ב-`shmctl(..., IPC_RMID)` להשמדת קטע הזיכרון המשותף וב-`semctl(..., IPC_RMID)` להשמדת קבוצת הסמפורים. פעולות אלה מבטיחות שאין \"זבל\" של משאבים משותפים במערכת לאחר סיום התוכנית.\n\n**התמודדות עם אתגרים:**\n*   **סנכרון:** הסמפורים `empty`, `full`, `mutex` מטפלים באופן קלאסי בבעיית יצרן-צרכן, מונעים גישה במקביל לאזור קריטי ומבטיחים שהיצרן לא יכתוב לבָּפֶר מלא והצרכן לא יקרא מבָּפֶר ריק.\n*   **טיפול באותות:** שימוש בדגל אטומי בזיכרון משותף מאפשר תקשורת בטוחה של אות הסיום בין ה-Signal Handler ללולאות הראשיות של שני התהליכים, תוך הימנעות מפעולות לא בטוחות בתוך ה-Handler. דגל זה מאפשר גם לצאת מקריאות חוסמות של סמפורים במקרה של קבלת אות.\n*   **ניקוי משאבים:** הגישה לפיה האב ממתין לבן ורק אז משמיד את המשאבים, מבטיחה שכל התהליכים סיימו להשתמש במשאבים לפני שהם נמחקים. זה מונע שגיאות ודליפות זיכרון במערכת ההפעלה.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <sys/sem.h>\n#include <signal.h>\n#include <errno.h>\n#include <time.h> // For sleep/nanosleep, and random seed\n#include <sys/wait.h> // For waitpid\n\n#define SHM_KEY 1234\n#define SEM_KEY 5678\n#define BUFFER_SIZE 10 // Size of the circular buffer\n\n// Structure for shared memory\ntypedef struct {\n    int buffer[BUFFER_SIZE];\n    int in;  // Producer index\n    int out; // Consumer index\n    volatile sig_atomic_t terminate_flag; // Flag for graceful termination\n} shared_data_t;\n\n// Semaphore union for semctl (required by POSIX, but for System V IPC it's part of the standard usage)\nunion semun {\n    int              val;    /* Value for SETVAL */\n    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n    unsigned short  *array;  /* Array for GETALL, SETALL */\n    struct seminfo  *__buf;  /* Buffer for IPC_INFO (Linux specific) */\n};\n\n// Global variables for IPC IDs and shared memory pointer\nint shmid;\nint semid;\nshared_data_t *shm_ptr = NULL;\n\n// Signal handler function\nvoid signal_handler(int signum) {\n    if (signum == SIGINT) {\n        if (shm_ptr != NULL) {\n            shm_ptr->terminate_flag = 1;\n        }\n        fprintf(stderr, \"\\nProcess %d received SIGINT. Setting termination flag.\\n\", getpid());\n    }\n}\n\n// Function to perform a semaphore operation\n// Returns 0 on success, -1 on failure (e.g., interrupted by signal and terminate_flag is set)\nint sem_op(int sem_num, int op) {\n    struct sembuf sb;\n    sb.sem_num = sem_num;\n    sb.sem_op = op;\n    sb.sem_flg = 0; // No flags, blocking operation\n\n    // Loop to handle EINTR (interrupted system call)\n    while (semop(semid, &sb, 1) == -1) {\n        if (errno == EINTR) {\n            if (shm_ptr != NULL && shm_ptr->terminate_flag) {\n                // If termination flag is set, break the loop and exit\n                return -1;\n            }\n            // Otherwise, retry the semaphore operation\n            continue;\n        } else {\n            perror(\"semop failed\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    return 0;\n}\n\n// Function to initialize semaphores\nvoid init_semaphores() {\n    union semun arg;\n    unsigned short values[3];\n\n    // sem_num 0: empty slots (initially BUFFER_SIZE)\n    // sem_num 1: full slots (initially 0)\n    // sem_num 2: mutex for shared buffer access (initially 1)\n    values[0] = BUFFER_SIZE; // empty\n    values[1] = 0;           // full\n    values[2] = 1;           // mutex\n\n    arg.array = values;\n    if (semctl(semid, 0, SETALL, arg) == -1) {\n        perror(\"semctl SETALL failed\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Semaphores initialized: empty=%d, full=%d, mutex=%d\\n\", values[0], values[1], values[2]);\n}\n\n// Parent process (Producer)\nvoid producer_process() {\n    printf(\"Producer (PID %d) started.\\n\", getpid());\n    srand(time(NULL) ^ getpid()); // Seed random number generator\n\n    while (!shm_ptr->terminate_flag) {\n        int item = rand() % 100;\n\n        // P(empty)\n        if (sem_op(0, -1) == -1) break; // Decrement empty count\n\n        // P(mutex)\n        if (sem_op(2, -1) == -1) {\n            // If terminated while waiting for mutex, release empty and exit\n            sem_op(0, 1); // Increment empty count back\n            break;\n        }\n\n        // Critical section: write to shared buffer\n        shm_ptr->buffer[shm_ptr->in] = item;\n        printf(\"Producer (PID %d) produced item: %d at index %d\\n\", getpid(), item, shm_ptr->in);\n        shm_ptr->in = (shm_ptr->in + 1) % BUFFER_SIZE;\n\n        // V(mutex)\n        sem_op(2, 1); // Release mutex\n\n        // V(full)\n        sem_op(1, 1); // Increment full count\n\n        // Simulate some work\n        usleep(rand() % 500000 + 100000); // 100ms - 600ms\n    }\n    printf(\"Producer (PID %d) exiting loop.\\n\", getpid());\n}\n\n// Child process (Consumer)\nvoid consumer_process() {\n    printf(\"Consumer (PID %d) started.\\n\", getpid());\n    srand(time(NULL) ^ getpid()); // Seed random number generator\n\n    while (!shm_ptr->terminate_flag) {\n        // P(full)\n        if (sem_op(1, -1) == -1) break; // Decrement full count\n\n        // P(mutex)\n        if (sem_op(2, -1) == -1) {\n            // If terminated while waiting for mutex, release full and exit\n            sem_op(1, 1); // Increment full count back\n            break;\n        }\n\n        // Critical section: read from shared buffer\n        int item = shm_ptr->buffer[shm_ptr->out];\n        printf(\"Consumer (PID %d) consumed item: %d from index %d\\n\", getpid(), item, shm_ptr->out);\n        shm_ptr->out = (shm_ptr->out + 1) % BUFFER_SIZE;\n\n        // V(mutex)\n        sem_op(2, 1); // Release mutex\n\n        // V(empty)\n        sem_op(0, 1); // Increment empty count\n\n        // Simulate some work\n        usleep(rand() % 500000 + 100000); // 100ms - 600ms\n    }\n    printf(\"Consumer (PID %d) exiting loop.\\n\", getpid());\n}\n\n// Cleanup function\nvoid cleanup_resources(pid_t child_pid) { // Pass child_pid to cleanup\n    if (shm_ptr != (shared_data_t *)-1 && shm_ptr != NULL) { // Check for valid shm_ptr\n        if (shmdt(shm_ptr) == -1) {\n            perror(\"shmdt failed\");\n        } else {\n            printf(\"Process %d detached shared memory.\\n\", getpid());\n        }\n    }\n\n    // Only the parent process (the one that forked child_pid) should destroy IPC resources\n    if (child_pid > 0) { // This is the parent process\n        // Wait for child to ensure it has detached\n        int status;\n        if (waitpid(child_pid, &status, 0) == -1) { // Use waitpid to wait for specific child\n            perror(\"waitpid failed\");\n        }\n        printf(\"Parent (PID %d) waited for child (PID %d) to terminate.\\n\", getpid(), child_pid);\n\n        if (shmctl(shmid, IPC_RMID, NULL) == -1) {\n            perror(\"shmctl IPC_RMID failed\");\n        } else {\n            printf(\"Shared memory segment %d destroyed by parent.\\n\", shmid);\n        }\n\n        if (semctl(semid, 0, IPC_RMID) == -1) {\n            perror(\"semctl IPC_RMID failed\");\n        } else {\n            printf(\"Semaphore set %d destroyed by parent.\\n\", semid);\n        }\n    }\n}\n\n\nint main() {\n    struct sigaction sa;\n    // Set up the signal handler for SIGINT\n    sa.sa_handler = signal_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART; // Restart interrupted system calls by default, but our sem_op handles EINTR explicitly\n\n    if (sigaction(SIGINT, &sa, NULL) == -1) {\n        perror(\"sigaction failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 1. Create shared memory segment\n    shmid = shmget(SHM_KEY, sizeof(shared_data_t), IPC_CREAT | 0666);\n    if (shmid == -1) {\n        perror(\"shmget failed\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Shared memory segment %d created.\\n\", shmid);\n\n    // 2. Attach shared memory segment\n    shm_ptr = (shared_data_t *)shmat(shmid, NULL, 0);\n    if (shm_ptr == (shared_data_t *)-1) {\n        perror(\"shmat failed\");\n        // Attempt to remove shared memory if attachment failed\n        shmctl(shmid, IPC_RMID, NULL); \n        exit(EXIT_FAILURE);\n    }\n    printf(\"Shared memory attached at %p.\\n\", shm_ptr);\n\n    // 3. Initialize shared data\n    shm_ptr->in = 0;\n    shm_ptr->out = 0;\n    shm_ptr->terminate_flag = 0;\n\n    // 4. Create semaphore set\n    semid = semget(SEM_KEY, 3, IPC_CREAT | 0666); // 3 semaphores: empty, full, mutex\n    if (semid == -1) {\n        perror(\"semget failed\");\n        // Attempt to remove shared memory if semaphore creation failed\n        shmdt(shm_ptr);\n        shmctl(shmid, IPC_RMID, NULL);\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Semaphore set %d created.\\n\", semid);\n\n    // 5. Initialize semaphores\n    init_semaphores();\n\n    pid_t pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork failed\");\n        // Clean up everything if fork fails\n        shmdt(shm_ptr);\n        shmctl(shmid, IPC_RMID, NULL);\n        semctl(semid, 0, IPC_RMID);\n        exit(EXIT_FAILURE);\n    } else if (pid == 0) { // Child process\n        consumer_process();\n    } else { // Parent process\n        producer_process();\n    }\n\n    // Cleanup resources (both parent and child will call this)\n    cleanup_resources(pid);\n\n    return 0;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}