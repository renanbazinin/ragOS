{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory and Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:58:24",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2792,
      "output_tokens": 2633,
      "total_tokens": 10898
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Paging",
      "TLB",
      "Memory Hierarchy",
      "Performance"
    ],
    "content": {
      "text": "מערכת הפעלה מודרנית משתמשת בזיכרון וירטואלי ובמנגנון דפדוף (Paging) לניהול זיכרון. נתון מעבד בעל יחידת ניהול זיכרון (MMU) הכוללת Translation Lookaside Buffer (TLB) בגודל 64 כניסות. גודל עמוד (Page Size) במערכת הוא 4KB (4096 בתים). המעבד משתמש במדיניות החלפה LRU (Least Recently Used) עבור ה-TLB.\n\nלצורך השאלה, הניחו כי מערך ה-int הדו-ממדי `matrix` בגודל `1024x1024` (כאשר `sizeof(int) = 4` בתים) מאותחל על ידי שתי לולאות שונות, כפי שמוצג בקוד הבא. הניחו כי המערך מאוחסן באופן רציף בזיכרון הווירטואלי וכי כל המערך אינו נמצא ב-TLB או בזיכרון הפיזי בתחילת ביצוע כל פונקציה. כמו כן, הניחו כי הזיכרון הפיזי מספיק גדול כדי להכיל את כל המערך.\n\nבהינתן הקוד הבא, ובהתבסס על הפרטים לעיל לגבי המערכת:\n\n1.  **לולאה מס' 1 (init_row_major):** כמה אירועי TLB Miss לכל הפחות יתרחשו במהלך ביצוע הפונקציה `init_row_major`? נמקו בפירוט.\n2.  **לולאה מס' 2 (init_col_major):** כמה אירועי TLB Miss לכל הפחות יתרחשו במהלך ביצוע הפונקציה `init_col_major`? נמקו בפירוט.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ROWS 1024\n#define COLS 1024\n\nint matrix[ROWS][COLS]; // Global array\n\nvoid init_row_major() {\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            matrix[i][j] = i * j;\n        }\n    }\n}\n\nvoid init_col_major() {\n    for (int j = 0; j < COLS; j++) {\n        for (int i = 0; i < ROWS; i++) {\n            matrix[i][j] = i * j;\n        }\n    }\n}\n",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסבר ופתרון:\n\n**חישובים מקדימים:**\n*   **גודל המערך הכולל:** `1024 שורות * 1024 עמודות * 4 בתים/int = 4,194,304 בתים = 4MB`.\n*   **גודל עמוד (Page Size):** `4KB = 4096 בתים`.\n*   **מספר שלמים (int) בעמוד אחד:** `4096 בתים / 4 בתים/int = 1024 שלמים`.\n*   **גודל ה-TLB:** `64 כניסות`. כל כניסה ממפה עמוד וירטואלי אחד לעמוד פיזי.\n*   **מספר העמודים הכולל שהמערך תופס:** `4MB / 4KB = 1024 עמודים`.\n\n**ניתוח לולאה מס' 1 (init_row_major):**\n```c\nvoid init_row_major() {\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            matrix[i][j] = i * j; // גישה לפי שורה\n        }\n    }\n}\n```\n1.  **דפוס גישה:** הלולאה ניגשת לאלמנטים במערך באופן רציף (row-major), כלומר, `matrix[i][j]` ואחריו `matrix[i][j+1]` נמצאים בכתובות זיכרון עוקבות.\n2.  **גודל שורה ביחס לעמוד:** שורה שלמה במערך (`matrix[i]`) מכילה `COLS = 1024` שלמים. מכיוון שעמוד אחד מכיל `1024` שלמים, שורה שלמה אחת מתאימה בדיוק לעמוד זיכרון אחד.\n3.  **גישת עמודים:** כאשר הלולאה החיצונית מתקדמת ל-`i` הבא, אנו עוברים לשורה חדשה, ובהתאם לכך, לעמוד זיכרון חדש וייחודי (שטרם נגיש אליו בלולאה הנוכחית).\n4.  **TLB Misses:**\n    *   סה\"כ יש `ROWS = 1024` שורות, ולכן `1024` עמודים שונים נגישים לכל אורך הריצה של הפונקציה.\n    *   בכל פעם שניגשים לעמוד חדש בפעם הראשונה (כלומר, עבור `matrix[i][0]` כאשר `i` משתנה), תתרחש TLB Miss, מכיוון שהעמוד אינו נמצא ב-TLB. ה-TLB יטען את כניסת המיפוי עבור עמוד זה.\n    *   לאחר שהעמוד נטען ל-TLB, כל הגישות הבאות לאלמנטים באותה שורה (`matrix[i][j]` עבור אותו `i` ו-`j > 0`) יגרמו ל-TLB Hit, מכיוון שהכניסה כבר נמצאת ב-TLB.\n    *   מדיניות ה-LRU של ה-TLB לא תשפיע כאן על מספר ה-misses, מכיוון שאנו ניגשים ל-`1024` עמודים שונים, וכל עמוד נצרך במלואו לפני שעוברים לעמוד הבא. העמודים הקודמים אינם נגישים שוב, ולכן אין חשיבות אם הם פונו מה-TLB או לא.\n    *   לכן, מספר אירועי ה-TLB Miss הכולל יהיה שווה למספר העמודים הייחודיים שאליהם ניגשים, שהוא `1024`.\n\n**מספר אירועי TLB Miss ללולאה מס' 1: 1024.**\n\n**ניתוח לולאה מס' 2 (init_col_major):**\n```c\nvoid init_col_major() {\n    for (int j = 0; j < COLS; j++) {\n        for (int i = 0; i < ROWS; i++) {\n            matrix[i][j] = i * j; // גישה לפי עמודה\n        }\n    }\n}\n```\n1.  **דפוס גישה:** הלולאה ניגשת לאלמנטים במערך באופן לא רציף (column-major), כלומר, `matrix[i][j]` ואחריו `matrix[i+1][j]`.\n2.  **מרחק בזיכרון בין גישות:** המרחק בזיכרון בין `matrix[i][j]` לבין `matrix[i+1][j]` הוא בדיוק גודל שורה אחת, כלומר `COLS * sizeof(int) = 1024 * 4 = 4096 בתים`. זהו בדיוק גודל של עמוד זיכרון אחד. כלומר, `matrix[i][j]` ו-`matrix[i+1][j]` נמצאים בעמודים שונים לחלוטין.\n3.  **גישת עמודים עבור `j` קבוע:** עבור כל איטרציה של הלולאה החיצונית (עבור `j` קבוע), הלולאה הפנימית תעבור על `ROWS = 1024` אלמנטים: `matrix[0][j], matrix[1][j], ..., matrix[1023][j]`. כפי שצוין, כל אחד מ-`1024` האלמנטים הללו נמצא בעמוד זיכרון שונה.\n4.  **TLB Misses:**\n    *   ה-TLB יכול להכיל רק `64` כניסות.\n    *   עבור `j` קבוע, כאשר אנו ניגשים ל-`matrix[0][j]`, `matrix[1][j]`, ..., `matrix[63][j]`, כל גישה תגרום ל-TLB Miss (סה\"כ `64` misses), וה-TLB יתמלא בכניסות המיפוי עבור 64 העמודים הראשונים.\n    *   כאשר אנו ניגשים ל-`matrix[64][j]`, תתרחש TLB Miss. מכיוון שה-TLB מלא, כניסת המיפוי עבור `matrix[0][j]` (הישנה ביותר לפי LRU) תפונה כדי לפנות מקום לכניסה החדשה.\n    *   תהליך זה יימשך: כל גישה ל-`matrix[i][j]` (עבור `i >= 64`) תגרום ל-TLB Miss, מכיוון שהעמוד אליו ניגשים כבר פונה מה-TLB (או שעדיין לא נטען). למעשה, כל גישה לאלמנט בתוך הלולאה הפנימית תגרום ל-TLB Miss, כי אנו ניגשים ברצף ל-1024 עמודים שונים, בעוד ה-TLB יכול להכיל רק 64. כניסות תמיד יפונו לפני שנגיע אליהן שוב (אם בכלל).\n    *   לכן, עבור כל `j` קבוע (כלומר, עבור כל איטרציה של הלולאה החיצונית), יהיו `1024` אירועי TLB Miss.\n    *   הלולאה החיצונית רצה `COLS = 1024` פעמים.\n    *   סה\"כ אירועי TLB Miss: `1024 * 1024 = 1,048,576`.\n\n**מספר אירועי TLB Miss ללולאה מס' 2: 1,048,576.**"
    },
    "difficulty_estimation": "Hard"
  }
}