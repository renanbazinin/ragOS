{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Synchronization",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 19:46:30",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3826,
      "output_tokens": 3273,
      "total_tokens": 14693
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Threads",
      "Synchronization",
      "Deadlock Prevention",
      "Starvation Prevention",
      "Mutexes",
      "Condition Variables"
    ],
    "content": {
      "text": "נתונה מערכת מרובת חוטים המדמה N עובדים (Workers) ו-N כלים (Tools). כל עובד `i` (כאשר `i` בין 0 ל-1-N) זקוק לשני כלים ספציפיים כדי לבצע את משימתו: כלי `i` וכלי `(i+1)%N`. כל כלי הוא משאב בלעדי (אקסקלוסיבי) ויכול להיות בשימוש עובד אחד בלבד בכל רגע נתון.\nיש לכתוב מימוש לפונקציות `acquire_tools(int worker_id)` ו-`release_tools(int worker_id)` המבטיחות את התכונות הבאות:\n1.  **מניעה הדדית (Mutual Exclusion)**: בכל רגע נתון, כלי יכול להיות בשימוש עובד אחד בלבד.\n2.  **מניעת קיפאון (Deadlock Prevention)**: המערכת לא תגיע למצב קיפאון.\n3.  **מניעת הרעבה (Starvation Prevention)**: אף עובד לא ימתין ללא הגבלת זמן כדי להשיג את הכלים שלו.\n\nלצורך המימוש ניתן להשתמש במנעולים (mutexes) ומשתני תנאי (condition variables) בלבד. אין להשתמש בפקודות מכונה אטומיות או אובייקטי סנכרון אחרים (כמו סמפורים). יש להימנע מ-spinning על-ידי שימוש נכון במשתני תנאי.\n\nתיאור הפתרון:\nמשתנים גלובליים (יש לציין ערכי אתחול בהערה):",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For sleep\n#include <time.h>   // For srand\n\n#define N 5 // Number of workers and tools\n\n// Global variables for synchronization\n// TODO: Add your global variables here\n\nvoid acquire_tools(int worker_id) {\n    // TODO: Implement tool acquisition logic here\n}\n\nvoid release_tools(int worker_id) {\n    // TODO: Implement tool release logic here\n}\n\nvoid* worker_thread(void* arg) {\n    int worker_id = *(int*)arg;\n\n    while (1) {\n        printf(\"Worker %d is thinking...\\n\", worker_id);\n        sleep(rand() % 2 + 1); // Simulate thinking\n\n        printf(\"Worker %d wants tools %d and %d\\n\", worker_id, worker_id, (worker_id + 1) % N);\n        acquire_tools(worker_id);\n        printf(\"Worker %d HAS tools %d and %d, now working...\\n\", worker_id, worker_id, (worker_id + 1) % N);\n        sleep(rand() % 2 + 1); // Simulate working\n\n        release_tools(worker_id);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[N];\n    int worker_ids[N];\n\n    // TODO: Initialize global synchronization variables here\n\n    // Initialize random seed for sleep simulation\n    srand(time(NULL));\n\n    for (int i = 0; i < N; ++i) {\n        worker_ids[i] = i;\n        pthread_create(&threads[i], NULL, worker_thread, &worker_ids[i]);\n    }\n\n    // Let threads run for a while for demonstration\n    sleep(20);\n\n    // TODO: Destroy global synchronization variables here (if threads were joined or cancelled)\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": 30,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הבעיה המתוארת היא וריאציה של בעיית הפילוסופים הסועדים (Dining Philosophers Problem). הפתרון הקלאסי לבעיה זו, המונע קיפאון והרעבה באמצעות מנעולים ומשתני תנאי, כולל ניהול מצב עבור כל עובד ובדיקת תנאים לפני מתן הרשאה לאיסוף כלים. הפתרון המוצג משתמש במנעול גלובלי אחד (`mutex`) כדי להגן על הגישה למערך המצבים (`state`) ולמערך משתני התנאי (`cond`). לכל עובד יש משתנה תנאי משלו (`cond[worker_id]`) עליו הוא ממתין כאשר הכלים שלו אינם זמינים.\n\n**משתנים גלובליים (יש לציין ערכי אתחול בהערה):**\n- `pthread_mutex_t mutex;` // מנעול גלובלי להגנה על משאבים משותפים (מערך המצבים ומערך משתני התנאי). אתחול: `pthread_mutex_init(&mutex, NULL);`\n- `pthread_cond_t cond[N];` // מערך של משתני תנאי, אחד לכל עובד, עליו הוא ממתין אם אינו יכול לאסוף כלים. אתחול: `pthread_cond_init(&cond[i], NULL);` לכל `i`.\n- `enum { THINKING, HUNGRY, EATING } state[N];` // מערך המצבים של העובדים: THINKING (חושב), HUNGRY (רעב ורוצה כלים), EATING (אוכל/עובד עם הכלים). אתחול: `state[i] = THINKING;` לכל `i`.\n\n**פונקציית העזר `test(int i)`:**\nפונקציה זו, המופעלת תמיד תחת המנעול הגלובלי (`mutex`), בודקת אם עובד `i` יכול לעבור למצב EATING. עובד יכול לאכול רק אם הוא במצב HUNGRY ושני שכניו (משמאל ומימין) אינם במצב EATING. אם התנאים מתקיימים, העובד עובר למצב EATING, ומשתנה התנאי שלו מאותת לו (signal) שהוא יכול להמשיך.\n\n**פונקציית `acquire_tools(int worker_id)`:**\n1.  העובד נועל את המנעול הגלובלי (`mutex`).\n2.  מגדיר את מצבו ל-`HUNGRY` (הוא רוצה לאסוף כלים).\n3.  מפעיל את פונקציית העזר `test(worker_id)` כדי לבדוק אם הוא יכול לאכול מיד. אם כן, `test` ישנה את מצבו ל-`EATING` ויאותת לו.\n4.  כל עוד מצבו אינו `EATING` (כלומר, הכלים אינם זמינים או שאחד השכנים אוכל), העובד ממתין על משתנה התנאי שלו (`cond[worker_id]`). ההמתנה משחררת את המנעול הגלובלי באופן אוטומטי ומאפשרת לעובדים אחרים לגשת למשאבים המשותפים.\n5.  כאשר העובד מתעורר ומצבו הוא `EATING`, הוא משחרר את המנעול הגלובלי וממשיך בביצוע משימתו (עם הכלים).\n\n**פונקציית `release_tools(int worker_id)`:**\n1.  העובד נועל את המנעול הגלובלי (`mutex`).\n2.  מגדיר את מצבו ל-`THINKING` (שחרר את הכלים).\n3.  מפעיל את פונקציית העזר `test` עבור שני שכניו (משמאל ומימין). שחרור הכלים על ידי העובד הנוכחי עשוי לאפשר לאחד משכניו הרעבים לאסוף כלים.\n4.  משחרר את המנעול הגלובלי (`mutex`).\n\n**מניעת קיפאון:** הפתרון מונע קיפאון על ידי כך שעובד יכול לאסוף את הכלים רק אם שניהם זמינים ושני שכניו אינם אוכלים. אין מצב של המתנה מעגלית. הפונקציה `test` מבטיחה שאף עובד לא יקבל הרשאה לאכול אם הדבר יוביל לקיפאון.\n\n**מניעת הרעבה:** הפתרון מונע הרעבה מכיוון שכל עובד רעב יקבל בסופו של דבר את הכלים שלו. כאשר עובד מסיים לאכול, הוא בודק את שכניו הרעבים ומאפשר להם לאכול אם התנאים מתאימים. אין עדיפות קבועה או דפוס שיכול למנוע מעובד מסוים לאכול אי פעם.\n\n```c\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For sleep\n#include <time.h>   // For srand\n\n#define N 5 // Number of workers and tools\n\n// Global variables for synchronization\npthread_mutex_t mutex; // Global mutex for the table and state array\npthread_cond_t cond[N]; // One condition variable per worker\nenum { THINKING, HUNGRY, EATING } state[N]; // State of each worker\n\n// Helper macros for neighbors. Using a function-like macro to ensure correct evaluation.\n#define LEFT_NEIGHBOR(i) ((i + N - 1) % N)\n#define RIGHT_NEIGHBOR(i) ((i + 1) % N)\n\n// Forward declaration for helper function\nvoid test(int i);\n\nvoid acquire_tools(int worker_id) {\n    pthread_mutex_lock(&mutex);\n    state[worker_id] = HUNGRY;\n    printf(\"Worker %d is HUNGRY for tools %d and %d.\\n\", worker_id, worker_id, (worker_id + 1) % N);\n    test(worker_id);\n    while (state[worker_id] != EATING) {\n        pthread_cond_wait(&cond[worker_id], &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n}\n\nvoid release_tools(int worker_id) {\n    pthread_mutex_lock(&mutex);\n    state[worker_id] = THINKING;\n    printf(\"Worker %d finished working, released tools %d and %d.\\n\", worker_id, worker_id, (worker_id + 1) % N);\n    test(LEFT_NEIGHBOR(worker_id)); // Check if left neighbor can eat now\n    test(RIGHT_NEIGHBOR(worker_id)); // Check if right neighbor can eat now\n    pthread_mutex_unlock(&mutex);\n}\n\n// Helper function to check if a worker can eat\nvoid test(int i) {\n    // This function must be called with 'mutex' locked.\n    if (state[i] == HUNGRY && state[LEFT_NEIGHBOR(i)] != EATING && state[RIGHT_NEIGHBOR(i)] != EATING) {\n        state[i] = EATING;\n        pthread_cond_signal(&cond[i]); // Signal the worker that it can eat\n    }\n}\n\nvoid* worker_thread(void* arg) {\n    int worker_id = *(int*)arg;\n\n    while (1) {\n        printf(\"Worker %d is thinking...\\n\", worker_id);\n        sleep(rand() % 2 + 1); // Simulate thinking\n\n        acquire_tools(worker_id);\n        printf(\"Worker %d HAS tools %d and %d, now working...\\n\", worker_id, worker_id, (worker_id + 1) % N);\n        sleep(rand() % 2 + 1); // Simulate working\n\n        release_tools(worker_id);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[N];\n    int worker_ids[N];\n\n    // Initialize random seed for sleep simulation\n    srand(time(NULL));\n\n    // Initialize global synchronization variables\n    pthread_mutex_init(&mutex, NULL);\n    for (int i = 0; i < N; ++i) {\n        pthread_cond_init(&cond[i], NULL);\n        state[i] = THINKING; // All workers start thinking\n    }\n\n    for (int i = 0; i < N; ++i) {\n        worker_ids[i] = i;\n        pthread_create(&threads[i], NULL, worker_thread, &worker_ids[i]);\n    }\n\n    // Let threads run for a while for demonstration\n    sleep(20);\n\n    // Cleanup synchronization variables (assuming threads are cancelled or detached for a clean exit)\n    pthread_mutex_destroy(&mutex);\n    for (int i = 0; i < N; ++i) {\n        pthread_cond_destroy(&cond[i]);\n    }\n\n    return 0;\n}\n```",
      "difficulty_estimation": "Hard"
    }
  }
}