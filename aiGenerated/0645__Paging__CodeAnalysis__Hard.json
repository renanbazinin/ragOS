{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 23:22:17",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3971,
      "output_tokens": 2815,
      "total_tokens": 12379
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Paging",
      "TLB",
      "Memory Management",
      "Performance"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה ב-C המאתחלת מערך דו-ממדי גדול ומבצעת עליו שתי לולאות גישה שונות: אחת בסדר שורות ואחת בסדר עמודות. יש להתייחס למערכת בעלת המאפיינים הבאים:\n*   גודל עמוד (Page Size): 4KB\n*   גודל טיפוס `int`: 4 בתים\n*   TLB: מכיל 64 כניסות, אסוציאטיבי מלא (Fully Associative), ומשתמש במדיניות החלפה LRU.\n*   הניחו שה-TLB ריק בתחילה ושאף עמוד אינו טעון לזיכרון הפיזי לפני תחילת ביצוע הלולאות.\n*   הניחו שאין תהליכים אחרים רצים במערכת ושכל המערך מוקצה בזיכרון וירטואלי רציף.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define DIM 1024\n#define ARRAY_SIZE (DIM * DIM) // 1024 * 1024 integers\n\nint main() {\n    int* arr = (int*)malloc(ARRAY_SIZE * sizeof(int));\n    if (arr == NULL) {\n        perror(\"malloc failed\");\n        return 1;\n    }\n\n    // Access pattern 1: Row-major\n    printf(\"Accessing row-major...\\n\");\n    for (int i = 0; i < DIM; ++i) {\n        for (int j = 0; j < DIM; ++j) {\n            arr[i * DIM + j] = i + j; // Write access\n        }\n    }\n\n    // Access pattern 2: Column-major\n    printf(\"Accessing column-major...\\n\");\n    for (int j = 0; j < DIM; ++j) {\n        for (int i = 0; i < DIM; ++i) {\n            volatile int temp = arr[i * DIM + j]; // Read access, use volatile to prevent optimization\n            // Dummy use to ensure access is not optimized away\n            if (temp < 0) { /* do nothing, just to use temp */ }\n        }\n    }\n\n    free(arr);\n    return 0;\n}\n```\n\nחשבו והסבירו עבור כל אחת מתבניות הגישה (סדר שורות וסדר עמודות):\n1.  כמה כשלי עמודים (Page Faults) יתרחשו?\n2.  כמה החמצות TLB (TLB Misses) יתרחשו?\n\nהסבירו את חישוביכם ונימוקיכם באופן מפורט.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "ראשית, נחשב את גודל המערך הכולל ואת מספר העמודים הנדרשים:\n*   גודל המערך: `1024 * 1024 * sizeof(int) = 1024 * 1024 * 4 bytes = 4,194,304 bytes = 4MB`.\n*   גודל עמוד: `4KB = 4096 bytes`.\n*   מספר העמודים הנדרשים למערך כולו: `4MB / 4KB = 1024 עמודים`.\n*   מספר שלמים (int) בעמוד אחד: `4096 bytes / 4 bytes/int = 1024 שלמים`.\n*   מכיוון ש-`DIM = 1024`, כל שורה במערך מכילה `1024` שלמים, כלומר, כל שורה תופסת בדיוק עמוד אחד של זיכרון.\n\n**תבנית גישה 1: סדר שורות (Row-major)**\nהלולאה החיצונית עוברת על השורות (`i`), והפנימית על העמודות (`j`).\n`for (int i = 0; i < DIM; ++i)`\n  `for (int j = 0; j < DIM; ++j)`\n    `arr[i * DIM + j]`\n\n1.  **כשלי עמודים (Page Faults):**\n    *   בכל פעם שהלולאה החיצונית מתחילה איטרציה חדשה (עבור `i` חדש), היא ניגשת לשורה חדשה. מכיוון שכל שורה תופסת עמוד זיכרון שלם, ובהנחה שאף עמוד אינו טעון בתחילה, הגישה הראשונה לכל שורה (לדוגמה, `arr[i * DIM + 0]`) תגרום לכשל עמוד. העמוד כולו ייטען לזיכרון הפיזי.\n    *   הגישות הבאות באותה שורה (`arr[i * DIM + j]` עבור `j > 0`) יהיו כולן בתוך אותו עמוד שכבר נטען, ולכן לא יגרמו כשלי עמודים נוספים.\n    *   ישנן `DIM = 1024` שורות, ולכן יתרחשו `1024` כשלי עמודים בסך הכל (אחד לכל עמוד ייחודי במערך).\n\n2.  **החמצות TLB (TLB Misses):**\n    *   בדומה לכשלי העמודים, הגישה הראשונה לכל שורה חדשה (כלומר, לעמוד חדש) תגרום להחמצת TLB, שכן ה-TLB ריק בתחילה. לאחר מכן, הכתובת הווירטואלית של העמוד תתורגם, והכניסה המתאימה תתווסף ל-TLB.\n    *   כל הגישות הבאות בתוך אותה שורה (אותו עמוד) יהיו פגיעות TLB (TLB Hits), שכן הכניסה לעמוד זה כבר נמצאת ב-TLB.\n    *   ה-TLB מכיל 64 כניסות. אנו ניגשים ל-1024 עמודים ברצף, כאשר כל עמוד נגיש רק פעם אחת במהלך הגישה הראשונית. מכיוון שאנו לא חוזרים לעמודים קודמים לפני שנשלים את כל המערך, גודל ה-TLB לא משפיע על מספר ההחמצות הכולל במעבר יחיד זה. כל גישה לעמוד חדש תגרום להחמצה.\n    *   לכן, יתרחשו `1024` החמצות TLB בסך הכל (אחת לכל עמוד ייחודי במערך).\n\n**תבנית גישה 2: סדר עמודות (Column-major)**\nהלולאה החיצונית עוברת על העמודות (`j`), והפנימית על השורות (`i`).\n`for (int j = 0; j < DIM; ++j)`\n  `for (int i = 0; i < DIM; ++i)`\n    `arr[i * DIM + j]`\n\n1.  **כשלי עמודים (Page Faults):**\n    *   עבור `j` קבוע (כלומר, בעת מעבר על עמודה אחת), הלולאה הפנימית (`i`) ניגשת ל-`arr[0*DIM + j]`, `arr[1*DIM + j]`, `arr[2*DIM + j]`, וכן הלאה, עד `arr[1023*DIM + j]`.\n    *   ההבדל בין `arr[i*DIM + j]` לבין `arr[(i+1)*DIM + j]` הוא `DIM` שלמים, כלומר `1024 * 4 = 4096 bytes`. זהו בדיוק גודל של עמוד אחד.\n    *   משמעות הדבר היא שכל גישה בתוך הלולאה הפנימית (עבור `i` שונה) מתייחסת לעמוד זיכרון *שונה* לחלוטין. לדוגמה, `arr[0*DIM + j]` נמצא בעמוד 0 (בקיזוז `j`), `arr[1*DIM + j]` נמצא בעמוד 1 (בקיזוז `j`), וכן הלאה, עד `arr[1023*DIM + j]` שנמצא בעמוד 1023 (בקיזוז `j`).\n    *   במהלך הגישה לעמודה הראשונה (`j=0`), הלולאה הפנימית תגרום לגישה לכל 1024 העמודים (עמוד 0 עד עמוד 1023) בפעם הראשונה. כל אחת מ-1024 הגישות האלה תגרום לכשל עמוד, שכן העמודים אינם טעונים בתחילה. בסיום מעבר על העמודה הראשונה, כל 1024 העמודים של המערך יהיו טעונים בזיכרון הפיזי.\n    *   במהלך הגישות לעמודות הבאות (`j=1` עד `j=1023`), כל העמודים כבר נמצאים בזיכרון הפיזי. לכן, לא יתרחשו כשלי עמודים נוספים.\n    *   לכן, יתרחשו `1024` כשלי עמודים בסך הכל (אחד לכל עמוד ייחודי במערך, במהלך הגישה הראשונה אליו).\n\n2.  **החמצות TLB (TLB Misses):**\n    *   כאמור, עבור `j` קבוע, הלולאה הפנימית ניגשת ל-1024 עמודים *שונים* ברצף.\n    *   ה-TLB מכיל רק 64 כניסות. כאשר אנו ניגשים ל-64 העמודים הראשונים, ה-TLB מתמלא בהם (כל גישה היא החמצה ומוסיפה כניסה).\n    *   כאשר אנו מנסים לגשת לעמוד ה-65 (עבור `i=64`), ה-TLB כבר מלא. מדיניות ה-LRU תגרום לפינוי הכניסה של העמוד שהיה בשימוש הכי פחות לאחרונה (במקרה זה, העמוד הראשון שנגשנו אליו, עמוד 0). גישה זו תהיה החמצת TLB.\n    *   דפוס זה יחזור על עצמו עבור כל אחת מ-1024 הגישות בלולאה הפנימית: כל גישה לעמוד חדש תגרום להחמצת TLB, מכיוון שה-TLB קטן מכדי להכיל את כל 1024 העמודים שנגישים ברצף כה מהיר.\n    *   לכן, עבור כל איטרציה של הלולאה החיצונית (עבור כל עמודה `j`), יתרחשו `1024` החמצות TLB.\n    *   מכיוון שיש `DIM = 1024` עמודות, מספר ההחמצות הכולל יהיה: `1024 (עמודות) * 1024 (החמצות לעמודה) = 1,048,576 החמצות TLB`."
    },
    "difficulty_estimation": "Hard"
  }
}