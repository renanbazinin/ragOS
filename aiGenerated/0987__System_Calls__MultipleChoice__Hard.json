{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:15:52",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 969,
      "output_tokens": 1286,
      "total_tokens": 5794
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "System Calls",
      "Concurrency",
      "File Systems",
      "Race Conditions",
      "Atomicity"
    ],
    "content": {
      "text": "נתונה בעיה בה מספר תהליכים (או תהליכונים) מנסים ליצור קובץ נעילה (lock file) ייחודי. קובץ הנעילה אמור להיווצר רק על ידי תהליך אחד בלבד, וכל ניסיון נוסף ליצור אותו אמור להיכשל. איזה מקטע קוד, מבין הבאים, מבטיח בצורה נכונה ובטוחה (thread-safe/process-safe) את יצירת קובץ הנעילה הייחודי בסביבת ריבוי תהליכים/תהליכונים?",
      "code_snippet": null,
      "options": [
        "א. \n```c\nint fd = open(\"lockfile.lck\", O_CREAT | O_EXCL | O_WRONLY, 0666);\nif (fd == -1) {\n    // הקובץ כבר קיים או שגיאה אחרת אירעה.\n} else {\n    // הקובץ נוצר בהצלחה ובאופן בלעדי על ידי תהליך זה.\n}\n```",
        "ב. \n```c\nint fd = -1;\nif (access(\"lockfile.lck\", F_OK) == -1 && errno == ENOENT) {\n    fd = open(\"lockfile.lck\", O_CREAT | O_WRONLY, 0666);\n}\nif (fd == -1) {\n    // הקובץ כבר קיים או שגיאה אחרת.\n} else {\n    // הקובץ נוצר בהצלחה על ידי תהליך זה, אך ייתכן שגם תהליכים אחרים הצליחו ליצור אותו במקביל.\n}\n```",
        "ג. \n```c\nint fd = open(\"lockfile.lck\", O_CREAT | O_WRONLY, 0666);\nif (fd != -1) {\n    // הקובץ נוצר (או נפתח אם קיים).\n    // אין ערובה לייחודיות היצירה, שכן אם הקובץ כבר קיים הוא ייפתח ללא שגיאה.\n}\n```",
        "ד. \n```c\nint fd = open(\"lockfile.lck\", O_WRONLY, 0666); // ניסיון פתיחה ללא O_CREAT\nif (fd == -1 && errno == ENOENT) {\n    // קובץ לא קיים, ננסה ליצור\n    fd = open(\"lockfile.lck\", O_CREAT | O_WRONLY, 0666);\n}\nif (fd != -1) {\n    // הקובץ נוצר או נפתח.\n}\n```"
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. הדגל `O_EXCL` בשילוב עם `O_CREAT` מבטיח שהקובץ ייצור רק אם הוא אינו קיים כבר. אם הקובץ קיים, הקריאה ל-`open` תיכשל ותגדיר את `errno` ל-`EEXIST`. פעולה זו היא אטומית (atomic), כלומר, מערכת ההפעלה מבצעת את הבדיקה (האם הקובץ קיים?) ואת היצירה (אם אינו קיים) כפעולה יחידה ובלתי ניתנת להפרעה. זהו המנגנון המקובל והבטוח ליצירת קובץ נעילה ייחודי.\n\nאפשרות ב' לוקה בתנאי מירוץ (race condition). תהליך אחד יכול לבדוק עם `access` שקובץ הנעילה אינו קיים, ומיד לאחר מכן, לפני שהוא מספיק לקרוא ל-`open`, תהליך אחר יכול לבדוק גם הוא שקובץ הנעילה אינו קיים. שני התהליכים ימשיכו ליצור את הקובץ באמצעות `open` עם `O_CREAT` בלבד, אשר יצליח לשניהם, ובכך מפר את דרישת הייחודיות.\n\nאפשרות ג' פשוט יוצרת או פותחת את הקובץ אם הוא קיים, ואינה מבטיחה יצירה בלעדית. אם הקובץ כבר קיים, ה-`open` יצליח ותוכן הקובץ עשוי להידרס או להשתנות, מבלי שיתבצע סימון כלשהו לניסיון יצירה לא בלעדי.\n\nאפשרות ד' מנסה לפתוח קובץ שאינו קיים ללא דגל `O_CREAT` תחילה, מה שיגרום לכשלון אם הקובץ אינו קיים. לאחר מכן, היא מנסה ליצור אותו. גם כאן, אין שימוש ב-`O_EXCL`, ולכן היא חשופה לתנאי מירוץ בדומה לאפשרות ב' אם מספר תהליכים מגיעים לשלב יצירת הקובץ במקביל."
    },
    "difficulty_estimation": "Hard"
  }
}