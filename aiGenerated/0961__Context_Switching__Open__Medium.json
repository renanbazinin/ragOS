{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 07:08:14",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2388,
      "output_tokens": 1321,
      "total_tokens": 6184
    }
  },
  "question": {
    "id": 4,
    "type": "Open",
    "topic": [
      "Context Switching",
      "Processes",
      "Threads",
      "Performance",
      "Operating System Kernels"
    ],
    "content": {
      "text": "תאר את מנגנון החלפת ההקשר (Context Switching) במערכת הפעלה. איזה מידע נשמר ומשוחזר במהלך החלפת הקשר? דון בהשלכות הביצועים ובעלויות התקורה (overheads) הקשורות להחלפות הקשר תכופות, תוך הבחנה בין החלפת הקשר בין תהליכים (processes) להחלפת הקשר בין תהליכונים (threads) באותו תהליך.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "החלפת הקשר (Context Switching) היא התהליך שבו מערכת ההפעלה שומרת את מצבו (הקשרו) של תהליך או תהליכון אחד ומחזירה את מצבו של תהליך או תהליכון אחר, על מנת שה-CPU יוכל להמשיך לבצע את העבודה של הישות החדשה. זה מאפשר ל-CPU יחיד לתת אשליה של הרצת מספר רב של תהליכים/תהליכונים במקביל.\n\nהמידע שנשמר ומשוחזר במהלך החלפת הקשר כולל:\n1.  **אוגרי מעבד (CPU Registers)**: כולל Program Counter (PC), Stack Pointer (SP), ואוגרים כלליים אחרים. אלו חיוניים כדי שהתהליך/תהליכון יוכל להמשיך בדיוק מהנקודה שבה הופסק.\n2.  **מצב התהליך/תהליכון**: מצב הריצה (Running, Ready, Waiting).\n3.  **מידע ניהול זיכרון**: עבור תהליכים, זה כולל מצבי טבלאות דפים (Page Tables). עבור תהליכונים באותו תהליך, זה לא נשמר מכיוון שהם חולקים את אותו מרחב כתובות.\n4.  **מידע נוסף (בעיקר לתהליכים)**: קבצים פתוחים, אותות ממתינים, מצבי I/O, וכו'. מידע זה נשמר ב-Process Control Block (PCB) עבור תהליכים, וב-Thread Control Block (TCB) עבור תהליכונים.\n\n**השלכות ביצועים ועלויות תקורה (Overheads):**\nהחלפות הקשר כרוכות בעלויות תקורה משמעותיות שמשפיעות על ביצועי המערכת:\n1.  **זמן CPU מבוזבז**: במהלך החלפת ההקשר, ה-CPU אינו מבצע עבודה שימושית עבור יישומים. הוא עסוק בשמירה ושיחזור מצבים.\n2.  **זיהום מטמון (Cache Pollution)**: המידע של התהליך/תהליכון החדש שנטען ל-CPU כנראה שונה מהמידע של הישן. זה גורם ל-Cache Misses רבים, מה שמאט את הגישה לנתונים ופקודות.\n3.  **ריקון TLB (TLB Flush)**: כאשר מחליפים תהליכים, טבלאות הדפים משתנות. ה-Translation Lookaside Buffer (TLB) במעבד, שמכיל מיפויים של כתובות וירטואליות לפיזיות, צריך לרוב להתרוקן או להיות מסומן כלא תקף, מה שמצריך טעינה מחדש של מיפויים וגורם להאטה בגישה לזיכרון.\n\n**הבחנה בין החלפת הקשר של תהליכים להחלפת הקשר של תהליכונים:**\n1.  **החלפת הקשר בין תהליכים (Process Context Switch)**: זוהי הפעולה היקרה ביותר. היא דורשת שמירה ושיחזור של כל ה-Process Control Block (PCB), כולל מרחב כתובות שלם (טבלאות דפים), קבצים פתוחים, אוגרי מעבד, ועוד. לרוב זה כרוך גם בריקון ה-TLB, מה שתורם רבות לעלות.\n2.  **החלפת הקשר בין תהליכונים (Kernel-Level Thread Context Switch) באותו תהליך**: פעולה זו זולה יותר. מכיוון שתהליכונים באותו תהליך חולקים את אותו מרחב כתובות, קבצים פתוחים ומשאבי תהליך אחרים, אין צורך להחליף טבלאות דפים או לרוקן את ה-TLB. רק אוגרי המעבד, מצביע המחסנית (Stack Pointer) ומידע ספציפי לתהליכון (כמו TCB) צריכים להישמר ולשוחזר.\n3.  **החלפת הקשר בין תהליכונים (User-Level Thread Context Switch)**: זוהי הפעולה הזולה ביותר, כיוון שהיא מנוהלת כולה על ידי ספריית התהליכונים ברמת המשתמש, ללא מעורבות של הליבה (kernel). היא אינה דורשת מעבר למצב ליבה (kernel mode) וכוללת בעיקר שמירה ושיחזור של אוגרי מעבד ומצביע המחסנית."
    },
    "difficulty_estimation": "Medium"
  }
}