{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Synchronization",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 19:49:44",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3682,
      "output_tokens": 1352,
      "total_tokens": 8118
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Race Condition",
      "Mutex"
    ],
    "content": {
      "text": "נתון קטע קוד ב-C המציג פונקציה `increment_counter` המופעלת על ידי מספר תהליכונים במקביל. הפונקציה מגדילה מונה גלובלי משותף.",
      "code_snippet": "int global_counter = 0;\n\nvoid increment_counter() {\n    int temp = global_counter;\n    // Simulate some work\n    // usleep(1000);\n    global_counter = temp + 1;\n}"
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "הסבר מדוע קטע הקוד הזה עלול לגרום לבעיית מירוץ (Race Condition) כאשר מספר תהליכונים מפעילים את `increment_counter` במקביל.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "הצג קטע קוד מתוקן המשתמש במנעול (mutex) כדי למנוע את בעיית המירוץ ולהבטיח שהמונה הגלובלי יתעדכן בצורה נכונה. כלול את ההכרזה, האתחול והשחרור של המנעול.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "10.1: בעיית מירוץ (Race Condition) מתרחשת כאשר מספר תהליכונים ניגשים למשאב משותף (במקרה זה, `global_counter`) ומנסים לשנות אותו בו-זמנית, והתוצאה הסופית תלויה בסדר הלא-דטרמיניסטי שבו התהליכונים מבצעים את פעולותיהם. בקטע הקוד הנתון, פעולת ההגדלה (`global_counter = temp + 1;`) אינה אטומית. אם שני תהליכונים קוראים את `global_counter` (למשל, שניהם קוראים 0) כמעט באותו זמן, ואז שניהם מגדילים את הערך שקראו ל-1 וכותבים בחזרה, במקום שהמונה יהיה 2, הוא יהיה רק 1. זאת מכיוון שכל אחד מהם עבד על עותק משלו של הערך הישן, וכתב אותו בחזרה מבלי להתחשב בשינויים של תהליכונים אחרים. הוספת `usleep` מדמה עיכוב ומגדילה את הסיכוי לבעיה זו.\n\n10.2: כדי למנוע את בעיית המירוץ, יש להגן על הקטע הקריטי (Critical Section) שבו המשתנה המשותף `global_counter` נקרא ונכתב. נשתמש במנעול (mutex) כדי להבטיח שרק תהליכון אחד יוכל להיכנס לקטע קריטי זה בכל רגע נתון.\n```c\n#include <pthread.h>\n#include <stdio.h>\n// #include <unistd.h> // For usleep, if needed for testing\n\nint global_counter = 0;\npthread_mutex_t counter_mutex; // Declare a mutex\n\nvoid increment_counter() {\n    pthread_mutex_lock(&counter_mutex); // Acquire the lock\n    // Critical Section\n    int temp = global_counter;\n    // Simulate some work (should be minimal in critical section if performance is key)\n    // usleep(1000);\n    global_counter = temp + 1;\n    // End Critical Section\n    pthread_mutex_unlock(&counter_mutex); // Release the lock\n}\n\n// Example of how mutex would be initialized and destroyed in main:\n// int main() {\n//     pthread_mutex_init(&counter_mutex, NULL); // Initialize the mutex\n//     // ... create and join threads that call increment_counter()...\n//     pthread_mutex_destroy(&counter_mutex); // Destroy the mutex\n//     return 0;\n// }\n```\nהסבר:\n1.  **הכרזה ואתחול המנעול**: `pthread_mutex_t counter_mutex;` מכריז על משתנה מנעול. `pthread_mutex_init(&counter_mutex, NULL);` מאתחל אותו לפני השימוש (לרוב בפונקציית `main` או בפונקציית אתחול מערכת). יש לזכור גם לשחרר את המשאבים של המנעול באמצעות `pthread_mutex_destroy()` בסיום השימוש כדי למנוע דליפות זיכרון.\n2.  **נעילה (Lock)**: `pthread_mutex_lock(&counter_mutex);` מבוצעת לפני הכניסה לקטע הקריטי. אם המנעול כבר תפוס על ידי תהליכון אחר, התהליכון הנוכחי ייחסם (יעבור למצב המתנה) עד שהמנעול ישוחרר. זה מבטיח בלעדיות הדדית (mutual exclusion) לקטע הקריטי.\n3.  **שחרור (Unlock)**: `pthread_mutex_unlock(&counter_mutex);` מבוצעת לאחר היציאה מהקטע הקריטי, ומשחררת את המנעול, ובכך מאפשרת לתהליכונים אחרים שחסומים להיכנס לקטע הקריטי."
    },
    "difficulty_estimation": "Easy"
  }
}