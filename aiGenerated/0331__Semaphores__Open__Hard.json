{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:51:35",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4278,
      "output_tokens": 3724,
      "total_tokens": 19594
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Concurrency",
      "Resource Allocation",
      "Deadlock",
      "Starvation"
    ],
    "content": {
      "text": "מערכת הפעלה מנהלת N תאי זיכרון רציפים (בלוקים בגודל יחידה), הממוספרים מ-0 עד N-1. תהליכים שונים צריכים להקצות בלוק של k תאי זיכרון רציפים לשימושם. כלומר, אם תהליך מבקש k תאים, הוא חייב לקבל את התאים `i, i+1, ..., i+k-1` עבור איזה `i` מתאים. לאחר שימוש, הוא משחרר את הבלוק. נניח שכל תא זיכרון מיוצג על ידי סמפור בינארי `sem_t slot_sem[N]` המאופס ל-1 בתחילת הריצה. הקוד הבא מציג ניסיון לממש את פונקציית ההקצאה `acquire_contiguous_slots(int k)`:\n\n1.  זהו את כל הבעיות בקוד המוצג (כגון תנאי מירוץ, קיפאון, רעב, חוסר יעילות). נמקו את תשובתכם.\n2.  כתבו פתרון מתוקן ומלא באמצעות סמפורים (ובמידת הצורך, מנעולים) שימנע את הבעיות שזיהיתם, ימנע קיפאון ורעב, ויאפשר מקסום מקביליות. הציגו את הקוד המלא של הפונקציות `acquire_contiguous_slots(int k)` ו-`release_contiguous_slots(int start_idx, int k)`.\n",
      "code_snippet": "#define N_SLOTS 10 // מספר כולל של תאי זיכרון\nsem_t slot_sem[N_SLOTS]; // סמפור בינארי לכל תא, מאותחל ל-1\n\n// פונקציית אתחול (נקראת פעם אחת בתחילת הריצה)\nvoid init_resources() {\n    for (int i = 0; i < N_SLOTS; ++i) {\n        sem_init(&slot_sem[i], 0, 1);\n    }\n}\n\n// פונקציה להקצאת k תאי זיכרון רציפים\nint acquire_contiguous_slots(int k) {\n    int start_idx = -1;\n    while (start_idx == -1) { // לולאת busy-wait\n        for (int i = 0; i <= N_SLOTS - k; ++i) {\n            bool all_acquired = true;\n            for (int j = 0; j < k; ++j) {\n                if (sem_trywait(&slot_sem[i+j]) != 0) { // ניסיון לרכוש\n                    all_acquired = false;\n                    // שחרור סמפורים שכבר נרכשו בבלוק הנוכחי\n                    for (int l = 0; l < j; ++l) {\n                        sem_post(&slot_sem[i+l]);\n                    }\n                    break;\n                }\n            }\n            if (all_acquired) {\n                start_idx = i;\n                break; // נמצא בלוק וכולו נרכש\n            }\n        }\n    }\n    return start_idx; // מחזיר את אינדקס ההתחלה של הבלוק\n}\n\n// פונקציה לשחרור k תאי זיכרון רציפים\nvoid release_contiguous_slots(int start_idx, int k) {\n    for (int j = 0; j < k; ++j) {\n        sem_post(&slot_sem[start_idx + j]);\n    }\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\n**1. זיהוי בעיות בקוד המוצג:**\n\n*   **רעב (Starvation):** תהליך עשוי לסבול מרעב. אם תהליך מנסה לרכוש בלוק של k תאים, הוא עשוי שוב ושוב למצוא בלוקים פנויים חלקית, לרכוש אותם, לשחרר אותם (כאשר הוא מגלה שאינו יכול להשלים את הבלוק כולו), ולנסות שוב. בינתיים, תהליכים אחרים (אולי כאלה שמבקשים בלוקים קטנים יותר או בלוקים אחרים) עשויים להצליח לרכוש משאבים. אין מנגנון הוגנות שמבטיח שתהליך יקבל את המשאבים בסופו של דבר.\n*   **Busy-waiting (בזבוז משאבי מעבד):** לולאת ה-`while (start_idx == -1)` החיצונית היא busy-wait. אם אין בלוק זמין באופן מיידי, התהליך ממשיך לבדוק שוב ושוב את כל הבלוקים האפשריים בלולאה אינסופית, ובכך מבזבז משאבי מעבד יקרים במקום להיכנס למצב חסימה ולהמתין לאירוע כלשהו (כמו שחרור בלוק).\n*   **חוסר יעילות:** שחרור ורכישה חוזרים ונשנים של סמפורים בתוך הלולאה הפנימית (כאשר `sem_trywait` נכשל) הוא לא יעיל. בנוסף, כל תהליך מבצע סריקה מלאה של כל תאי הזיכרון בכל איטרציה, גם אם לא היה שינוי משמעותי במצב התאים.\n*   **תנאי מירוץ (Race Conditions) לוגיים:** למרות שפעולות `sem_trywait` ו-`sem_post` הן אטומיות, הלוגיקה הכוללת של איתור בלוק פנוי ורכישתו אינה מוגנת. שני תהליכים יכולים לזהות בו-זמנית את אותו בלוק פנוי או בלוקים חופפים, מה שיוביל לכך שאחד מהם ירכוש חלקית, ישחרר וינסה שוב, או ששניהם יחמיצו בלוק שהיה זמין אם היו מתואמים. זה יכול להחמיר את בעיית הרעב.\n*   **קיפאון (Deadlock):** במקרה זה, הקוד המוצג אינו מוביל ישירות לקיפאון במובן הקלאסי של מעגל המתנה. מכיוון שהוא משתמש ב-`sem_trywait` ומשחרר משאבים מיד עם כישלון, הוא נמנע ממצב של החזקה והמתנה מעגלית. עם זאת, הוא סובל מהבעיות החמורות של רעב ובזבוז משאבים כמפורט לעיל.\n\n**2. פתרון מתוקן:**\n\nהפתרון הנכון דורש מנגנון מרכזי שיגן על תהליך האיתור וההקצאה של הבלוק הרציף. נשתמש במנעול (mutex) כדי להבטיח שרק תהליך אחד יחפש ויקצה בלוק בכל רגע נתון. בנוסף, נשתמש במערך בוליאני כדי לעקוב אחר מצב התאים (פנוי/תפוס) לצורך חיפוש יעיל.\n\n```c\n#include <semaphore.h>\n#include <pthread.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n#define N_SLOTS 10 // מספר כולל של תאי זיכרון\n\nsem_t slot_sem[N_SLOTS]; // סמפור בינארי לכל תא, מאותחל ל-1\npthread_mutex_t allocation_mutex; // מנעול להגנה על לוגיקת ההקצאה/שחרור\nbool is_slot_free[N_SLOTS]; // עוקב אחר מצב פנוי/תפוס של כל תא\npthread_cond_t new_slots_available_cond; // משתנה תנאי להתראה על שחרור תאים\n\n// פונקציית אתחול (נקראת פעם אחת בתחילת הריצה)\nvoid init_resources() {\n    for (int i = 0; i < N_SLOTS; ++i) {\n        sem_init(&slot_sem[i], 0, 1); // כל סמפור מאותחל ל-1\n        is_slot_free[i] = true; // כל התאים פנויים בתחילה\n    }\n    pthread_mutex_init(&allocation_mutex, NULL); // אתחול מנעול\n    pthread_cond_init(&new_slots_available_cond, NULL); // אתחול משתנה תנאי\n}\n\n// פונקציה להקצאת k תאי זיכרון רציפים\nint acquire_contiguous_slots(int k) {\n    int start_idx = -1;\n\n    pthread_mutex_lock(&allocation_mutex); // נכנסים לאזור קריטי\n    while (start_idx == -1) {\n        // סורקים למצוא בלוק רציף פנוי\n        for (int i = 0; i <= N_SLOTS - k; ++i) {\n            bool possible = true;\n            for (int j = 0; j < k; ++j) {\n                if (!is_slot_free[i + j]) {\n                    possible = false;\n                    i = i + j; // מדלגים מעבר לבלוק תפוס\n                    break;\n                }\n            }\n            if (possible) {\n                start_idx = i;\n                // מסמנים את התאים כתפוסים במערך המעקב\n                for (int j = 0; j < k; ++j) {\n                    is_slot_free[i + j] = false;\n                }\n                break; // נמצא בלוק\n            }\n        }\n\n        if (start_idx == -1) {\n            // אם לא נמצא בלוק, ממתינים לשחרור תאים\n            pthread_cond_wait(&new_slots_available_cond, &allocation_mutex);\n        }\n    }\n    pthread_mutex_unlock(&allocation_mutex); // יוצאים מהאזור הקריטי\n\n    // כעת, כשהבלוק סומן כתפוס במערך is_slot_free, רוכשים את הסמפורים הספציפיים.\n    // אנו יודעים שהם פנויים כי ה-allocation_mutex הגן על הלוגיקה.\n    for (int j = 0; j < k; ++j) {\n        sem_wait(&slot_sem[start_idx + j]);\n    }\n\n    return start_idx;\n}\n\n// פונקציה לשחרור k תאי זיכרון רציפים\nvoid release_contiguous_slots(int start_idx, int k) {\n    if (start_idx < 0 || start_idx + k > N_SLOTS) {\n        fprintf(stderr, \"Error: Invalid release range.\\n\");\n        return;\n    }\n\n    // משחררים את הסמפורים הספציפיים\n    for (int j = 0; j < k; ++j) {\n        sem_post(&slot_sem[start_idx + j]);\n    }\n\n    pthread_mutex_lock(&allocation_mutex); // נכנסים לאזור קריטי\n    // מסמנים את התאים כפנויים במערך המעקב\n    for (int j = 0; j < k; ++j) {\n        is_slot_free[start_idx + j] = true;\n    }\n    // מודיעים לתהליכים ממתינים שאולי יש תאים פנויים כעת\n    pthread_cond_broadcast(&new_slots_available_cond); \n    pthread_mutex_unlock(&allocation_mutex); // יוצאים מהאזור הקריטי\n}\n```\n\n**הסבר לפתרון המתוקן:**\n\n1.  **מנעול `allocation_mutex`:** מנעול זה מגן על המצב המשותף של מערך `is_slot_free` ועל לוגיקת החיפוש וההקצאה. הוא מבטיח שרק תהליך אחד בכל פעם יבצע את פעולת החיפוש והסימון של הבלוקים כפנויים/תפוסים, ובכך מונע תנאי מירוץ לוגיים.\n2.  **מערך `is_slot_free`:** מערך בוליאני זה משמש למעקב מהיר ויעיל אחר מצב הפניות של כל תא זיכרון. החיפוש מתבצע על מערך זה תחת הגנת ה-`allocation_mutex`.\n3.  **משתנה תנאי `new_slots_available_cond`:** במקום busy-waiting, תהליכים שלא מוצאים בלוק פנוי נכנסים למצב חסימה באמצעות `pthread_cond_wait`. כאשר תהליך משחרר בלוק (בפונקציה `release_contiguous_slots`), הוא מאותת (באמצעות `pthread_cond_broadcast`) לכל התהליכים הממתינים שאולי יש כעת תאים פנויים, והם מתעוררים כדי לנסות שוב להקצות.\n4.  **רכישת סמפורים בודדים לאחר ההקצאה הלוגית:** לאחר שבלוק רציף זוהה וסומן כתפוס במערך `is_slot_free` (תחת הגנת ה-`allocation_mutex`), התהליך משחרר את ה-`allocation_mutex` ורק אז מבצע `sem_wait` על הסמפורים הספציפיים של התאים בבלוק. פעולה זו בטוחה מכיוון שה-`allocation_mutex` הבטיח שאף תהליך אחר לא יסמן את התאים הללו כתפוסים, ולכן הסמפורים יהיו זמינים לרכישה מיידית (או שהם כבר נרכשו על ידי תהליך זה עצמו, אם היה צורך בכך – אך במקרה זה הם תמיד יהיו זמינים כי ה-`is_slot_free` מגן על כך). גישה זו מונעת קיפאון ומאפשרת מקביליות מקסימלית על ידי כך שהיא משחררת את המנעול המרכזי בזמן השימוש בפועל במשאבים.\n5.  **מניעת רעב:** השימוש ב-`pthread_cond_wait` וב-`pthread_cond_broadcast` בשילוב עם מנעול מבטיח שכל תהליך שממתין יקבל הזדמנות לנסות להקצות בלוק כאשר משאבים משתחררים, ובכך מפחית משמעותית את הסיכון לרעב (בהתחשב בהוגנות של מתזמן התהליכים).\n6.  **יעילות:** נמנע בזבוז משאבי מעבד כתוצאה מ-busy-waiting. החיפוש הופך ליעיל יותר מכיוון שהוא מוגן ואינו מתנגש עם חיפושים של תהליכים אחרים."
    },
    "difficulty_estimation": "Hard"
  }
}