{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:56:08",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 3609,
      "total_tokens": 17209
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "Process Management",
      "Synchronization"
    ],
    "content": {
      "text": "נתונים קטעי הקוד הבאים עבור תהליך אב ותהליך בן. תהליך האב יוצר תהליך בן, ותהליך הבן מבצע פעולה כלשהי, שולח אות SIGUSR1 לאב, ולאחר מכן מסיים את פעולתו. תהליך האב צריך לטפל באות SIGUSR1 מהבן וגם להמתין לסיום הבן בצורה בטוחה.\n\nהשלימו את החלק החסר בקוד של תהליך האב כך שימתין לאות SIGUSR1 מהבן, ולאחר מכן ימתין לסיום הבן. יש להסביר את הבחירות במימוש, ובפרט להתייחס לבעיות תזמון פוטנציאליות (race conditions) וכיצד המימוש שלכם פותר אותן. הניחו שאין אותות נוספים פרט ל-SIGUSR1 ו-SIGCHLD שיפריעו לפעולה.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n\nvolatile sig_atomic_t sigusr1_received = 0;\n\nvoid handler(int signum) {\n    if (signum == SIGUSR1) {\n        sigusr1_received = 1;\n        printf(\"Parent: SIGUSR1 received!\\n\");\n    } else if (signum == SIGCHLD) {\n        printf(\"Parent: SIGCHLD received!\\n\");\n    }\n}\n\nint main() {\n    struct sigaction sa;\n    pid_t pid;\n    sigset_t block_mask, old_mask, suspend_mask;\n\n    // Block SIGUSR1 and SIGCHLD initially in parent to control delivery\n    sigemptyset(&block_mask);\n    sigaddset(&block_mask, SIGUSR1);\n    sigaddset(&block_mask, SIGCHLD);\n    if (sigprocmask(SIG_BLOCK, &block_mask, &old_mask) == -1) {\n        perror(\"sigprocmask block\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set up signal handler for SIGUSR1 and SIGCHLD\n    sa.sa_handler = handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0; // No SA_RESTART for sigsuspend or waitpid. We'll handle EINTR manually.\n\n    if (sigaction(SIGUSR1, &sa, NULL) == -1) {\n        perror(\"sigaction SIGUSR1\");\n        exit(EXIT_FAILURE);\n    }\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork\");\n        // Restore original mask before exiting on error\n        sigprocmask(SIG_SETMASK, &old_mask, NULL);\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        printf(\"Child: Starting work...\\n\");\n        sleep(2); // Simulate work\n        printf(\"Child: Sending SIGUSR1 to parent (%d)...\\n\", getppid());\n        if (kill(getppid(), SIGUSR1) == -1) {\n            perror(\"kill\");\n            exit(EXIT_FAILURE);\n        }\n        printf(\"Child: Exiting.\\n\");\n        exit(EXIT_SUCCESS);\n    } else { // Parent process\n        printf(\"Parent: Child created with PID %d.\\n\", pid);\n\n        // --- PART TO BE COMPLETED ---\n        // Implement the logic here to:\n        // 1. Wait for the SIGUSR1 signal from the child.\n        // 2. After SIGUSR1 is handled, wait for the child process to terminate.\n        // 3. Ensure both events are processed correctly, handling potential race conditions.\n        // --- END PART TO BE COMPLETED ---\n\n        // Restore original mask before exiting\n        if (sigprocmask(SIG_SETMASK, &old_mask, NULL) == -1) {\n            perror(\"sigprocmask restore\");\n            exit(EXIT_FAILURE);\n        }\n        printf(\"Parent: Exiting.\\n\");\n    }\n\n    return 0;\n}\n```",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון המלא לקטע הקוד החסר בתהליך האב, יחד עם הסבר מפורט:\n\n```c\n        // 1. Prepare mask for sigsuspend: we want to wait specifically for SIGUSR1.\n        // The `wait_for_sigusr1_mask` will be the set of signals that are *unblocked* by sigsuspend.\n        // So, it should be the current block_mask, but with SIGUSR1 removed (unblocked).\n        sigset_t wait_for_sigusr1_mask = block_mask;\n        sigdelset(&wait_for_sigusr1_mask, SIGUSR1); // Unblock SIGUSR1 for sigsuspend\n\n        printf(\"Parent: Waiting for SIGUSR1 from child...\\n\");\n        while (!sigusr1_received) {\n            // Atomically unblock SIGUSR1 (and keep others blocked) and wait for a signal.\n            // If SIGUSR1 arrives, the handler runs, sets sigusr1_received = 1, and sigsuspend returns EINTR.\n            // The loop then checks sigusr1_received and exits if it's set.\n            // If another signal (not SIGUSR1 or SIGCHLD) arrives and is unblocked, it might interrupt sigsuspend,\n            // but we explicitly blocked SIGCHLD and the problem assumes no other interfering signals.\n            sigsuspend(&wait_for_sigusr1_mask);\n            // After sigsuspend returns (due to SIGUSR1 or another unblocked signal),\n            // the original signal mask (block_mask) is restored.\n            if (errno == EINTR) {\n                // This is expected if a signal was delivered. The loop condition handles the check.\n            }\n        }\n        printf(\"Parent: SIGUSR1 handled. Now waiting for child termination...\\n\");\n\n        // 2. After SIGUSR1 is handled, wait for the child process to terminate.\n        // First, unblock SIGCHLD to allow waitpid to correctly reap the child.\n        // We set the mask to `block_mask` but with `SIGCHLD` removed.\n        sigset_t wait_for_child_reaping_mask = block_mask;\n        sigdelset(&wait_for_child_reaping_mask, SIGCHLD);\n        if (sigprocmask(SIG_SETMASK, &wait_for_child_reaping_mask, NULL) == -1) {\n            perror(\"sigprocmask unblock SIGCHLD\");\n            exit(EXIT_FAILURE);\n        }\n\n        int status;\n        while (waitpid(pid, &status, 0) == -1) {\n            if (errno == EINTR) {\n                printf(\"Parent: waitpid interrupted by signal, retrying...\\n\");\n                // SIGCHLD might have arrived and its handler executed (printing a message),\n                // but waitpid is still needed to reap the child and collect its status.\n                continue;\n            } else {\n                perror(\"waitpid\");\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        if (WIFEXITED(status)) {\n            printf(\"Parent: Child %d terminated normally with status %d.\\n\", pid, WEXITSTATUS(status));\n        } else {\n            printf(\"Parent: Child %d terminated abnormally.\\n\", pid);\n        }\n```\n\n**הסבר מפורט:**\n\n1.  **חסימה ראשונית של אותות (`sigprocmask`):**\n    *   בתחילת תהליך האב, האותות `SIGUSR1` ו-`SIGCHLD` נחסמים באמצעות `sigprocmask(SIG_BLOCK, &block_mask, &old_mask)`. פעולה זו מונעת את הספקתם האקראית של אותות אלו לתהליך האב לפני שהאב מוכן לטפל בהם. חסימה זו חיונית למניעת מצבי מרוץ (race conditions) שבהם אות עשוי להגיע ולהימסר לפני שהקוד בתהליך האב מגיע לנקודה שבה הוא מצפה לו, מה שעלול לגרום לאובדן מידע או להתנהגות בלתי צפויה.\n    *   `old_mask` נשמרת כדי שניתן יהיה לשחזר את מסכת האותות המקורית של התהליך לפני היציאה.\n\n2.  **הגדרת מטפלי אותות (`sigaction`):**\n    *   מטפלים עבור `SIGUSR1` ו-`SIGCHLD` מוגדרים באמצעות `sigaction`. המטפל `handler` פשוט מדפיס הודעה וקובע דגל `volatile sig_atomic_t` מתאים (`sigusr1_received`).\n    *   השימוש ב-`sig_atomic_t` מבטיח שהעדכון של הדגל אטומי ובטוח לשימוש מתוך מטפל אותות, ו-`volatile` מבטיח שהקומפיילר לא יבצע אופטימיזציות שימנעו קריאה חוזרת של הערך מהזיכרון בכל בדיקה.\n    *   `sa.sa_flags` מוגדר ל-0, מה שאומר שאנחנו מטפלים באופן ידני בהפרעות של קריאות מערכת כמו `waitpid` (באמצעות בדיקת `EINTR`) ולא מסתמכים על `SA_RESTART`.\n\n3.  **המתנה לאות `SIGUSR1` באמצעות `sigsuspend`:**\n    *   התהליך האב נכנס ללולאה `while (!sigusr1_received)`. בתוך הלולאה, הוא קורא ל-`sigsuspend(&wait_for_sigusr1_mask)`.\n    *   `wait_for_sigusr1_mask` נוצרה על ידי לקיחת `block_mask` והסרת `SIGUSR1` ממנה. משמעות הדבר היא ש-`SIGUSR1` הוא האות היחיד שאינו חסום באופן זמני בזמן ש-`sigsuspend` פועלת.\n    *   `sigsuspend` פועלת באופן אטומי: היא משנה את מסכת האותות של התהליך לזו שמועברת לה כארגומנט (`wait_for_sigusr1_mask`) ולאחר מכן משעה את התהליך. כאשר אות (כמו `SIGUSR1`) מגיע ואינו חסום במסכה החדשה, המטפל שלו מופעל, ולאחר מכן `sigsuspend` חוזרת עם `errno` שווה ל-`EINTR` (מכיוון שהיא הופרעה על ידי אות).\n    *   אם `SIGUSR1` כבר היה ממתין (pending) לפני הקריאה ל-`sigsuspend` (מצב מרוץ פוטנציאלי), הוא יימסר מיד כאשר `sigsuspend` משנה את המסכה, המטפל יופעל, הדגל `sigusr1_received` יוגדר ל-1, ו-`sigsuspend` תחזור. הלולאה `while (!sigusr1_received)` מבטיחה שהתהליך האב ימשיך להמתין עד ש-`SIGUSR1` יטופל בהצלחה.\n\n4.  **המתנה לסיום תהליך הבן (`waitpid`):**\n    *   לאחר ש-`SIGUSR1` טופל, תהליך האב משנה את מסכת האותות שלו שוב כדי לבטל את חסימת `SIGCHLD` באמצעות `sigprocmask`.\n    *   לאחר מכן, הוא קורא ל-`waitpid(pid, &status, 0)` בתוך לולאה. לולאה זו מטפלת במצב שבו `waitpid` מופרעת על ידי אות (לדוגמה, אם `SIGCHLD` הגיע אך לאחריו הגיע אות אחר שלא נחסם, או אם המטפל של `SIGCHLD` הופעל אך `waitpid` עדיין לא גבתה את הבן). במקרה של `EINTR`, הלולאה פשוט ממשיכה לנסות שוב עד ש-`waitpid` מצליחה לגבות את תהליך הבן.\n    *   לאחר ש-`waitpid` חוזרת בהצלחה, התהליך האב מדפיס את סטטוס היציאה של הבן.\n\n**התמודדות עם בעיות תזמון (Race Conditions):**\n*   **אות `SIGUSR1` מגיע לפני `sigsuspend`:** האות נשאר ממתין (pending) עקב החסימה הראשונית. כאשר `sigsuspend` נקראת והופכת את `SIGUSR1` לבלתי חסום באופן זמני, האות נמסר מיד, המטפל מופעל, והדגל `sigusr1_received` מוגדר. הלולאה יוצאת בצורה נכונה.\n*   **אות `SIGCHLD` מגיע לפני `waitpid`:** האות נשאר ממתין (pending) עקב החסימה הראשונית. כאשר `SIGCHLD` מבוטל חסימתו באמצעות `sigprocmask` לפני הקריאה ל-`waitpid`, האות נמסר, המטפל מופעל, ו-`waitpid` מוצאת מיד את הבן שסיים את פעולתו.\n*   **הפרעות לקריאות מערכת:** השימוש בלולאות סביב `sigsuspend` ו-`waitpid` ובדיקת `errno == EINTR` מבטיח שקריאות מערכת אלו יחזרו על עצמן אם הן מופרעות על ידי אות, ובכך מונע מצב של חסימה בלתי צפויה או אי-טיפול באירוע.\n\nבסך הכל, פתרון זה מספק סנכרון חזק בין תהליך האב והבן, ומבטיח שגם האות `SIGUSR1` וגם סיום תהליך הבן מטופלים בסדר ובאופן בטוח, ללא תלות בתזמון המדויק של האירועים."
    },
    "difficulty_estimation": "Hard"
  }
}