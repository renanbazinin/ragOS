{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:49:38",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3433,
      "output_tokens": 3454,
      "total_tokens": 13989
    }
  },
  "question": {
    "id": 11,
    "type": "Open",
    "topic": [
      "Producer-Consumer",
      "Synchronization",
      "Semaphores",
      "Concurrency",
      "Pipeline"
    ],
    "content": {
      "text": "במערכת עיבוד משימות מבוזרת, קיימים שלושה סוגי ישויות הפועלות במקביל: יצרנים, עובדים ומעבדים סופיים.\nהיצרנים (Producers) מייצרים 'משימות גולמיות' (raw tasks) ומכניסים אותן למאגר (חיץ) ראשון בגודל קבוע.\nהעובדים (Workers) לוקחים משימות גולמיות מהמאגר הראשון, מעבדים אותן ל'משימות מעובדות' (processed tasks), ומכניסים אותן למאגר שני בגודל קבוע.\nהמעבדים הסופיים (Finishers) לוקחים משימות מעובדות מהמאגר השני ומבצעים עליהן פעולת סיום.\nיש לממש את הפונקציות הראשיות של החוטים (Threads) עבור כל סוג ישות, תוך שימוש בסמפורים בלבד (כמו בדוגמה 1), כדי להבטיח סנכרון נכון ולמנוע תנאי מירוץ (Race Conditions) או קיפאון (Deadlock). יש להניח שהסמפורים הוגנים (fair).\nיש לתאר בקצרה ובבירור את הפתרון ולכתוב קוד ברור.\nשימו לב: אין צורך לממש את הפונקציות `produce_raw_task`, `process_task`, `finalize_task` – יש להניח שהן קיימות.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#define RAW_BUFFER_SIZE 5\n#define PROCESSED_BUFFER_SIZE 5\n\n// משתנים גלובליים (יש לכתוב ערכי אתחול בהערה):\n// task_t raw_buffer[RAW_BUFFER_SIZE];\n// int raw_in, raw_out;\n// task_t processed_buffer[PROCESSED_BUFFER_SIZE];\n// int processed_in, processed_out;\n// sem_t raw_mutex, raw_full, raw_empty;\n// sem_t processed_mutex, processed_full, processed_empty;\n\ntypedef struct {\n    int id;\n    // ... נתונים נוספים של המשימה\n} task_t;\n\n// פונקציות עזר (אין צורך לממש):\n// task_t produce_raw_task(int producer_id);\n// task_t process_task(task_t raw_task, int worker_id);\n// void finalize_task(task_t processed_task, int finisher_id);\n\nvoid* producer(void* arg) {\n    // מימוש חוט היצרן\n}\n\nvoid* worker(void* arg) {\n    // מימוש חוט העובד\n}\n\nvoid* finisher(void* arg) {\n    // מימוש חוט המעבד הסופי\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "תיאור הפתרון:\nהפתרון מבוסס על שתי בעיות יצרן-צרכן מדורגות (Pipeline):\n1.  **יצרנים ועובדים:** היצרנים הם יצרנים למאגר המשימות הגולמיות, והעובדים הם צרכנים למאגר זה.\n2.  **עובדים ומעבדים סופיים:** העובדים פועלים כצרכנים למאגר המשימות הגולמיות וכיוצרים למאגר המשימות המעובדות, והמעבדים הסופיים הם צרכנים למאגר המשימות המעובדות.\n\nלכל מאגר (מאגר משימות גולמיות ומאגר משימות מעובדות) נשתמש בשלושה סמפורים:\n*   `_mutex`: סמפור בינארי (מוטקס) לאבטחת גישה בלעדית למאגר בעת הכנסה או הוצאה של פריטים. מאותחל ל-1.\n*   `_full`: סמפור המונה את מספר הפריטים המלאים במאגר. מאותחל ל-0.\n*   `_empty`: סמפור המונה את מספר המקומות הפנויים במאגר. מאותחל לגודל המאגר (BUFFER_SIZE).\n\n**פעולת היצרן (Producer):**\n1.  ממתין למקום פנוי במאגר המשימות הגולמיות (`sem_wait(&raw_empty)`).\n2.  רוכש נעילה על המאגר הגולמי (`sem_wait(&raw_mutex)`).\n3.  מכניס משימה גולמית למאגר.\n4.  משחרר את הנעילה על המאגר הגולמי (`sem_post(&raw_mutex)`).\n5.  מאותת שיש פריט חדש במאגר הגולמי (`sem_post(&raw_full)`).\n\n**פעולת העובד (Worker):** (פועל כצרכן למאגר הגולמי וכיוצר למאגר המעובד)\n**חלק הצרכן (למאגר הגולמי):**\n1.  ממתין למשימה גולמית במאגר (`sem_wait(&raw_full)`).\n2.  רוכש נעילה על המאגר הגולמי (`sem_wait(&raw_mutex)`).\n3.  מוציא משימה גולמית מהמאגר.\n4.  משחרר את הנעילה על המאגר הגולמי (`sem_post(&raw_mutex)`).\n5.  מאותת שיש מקום פנוי במאגר הגולמי (`sem_post(&raw_empty)`).\n6.  מעבד את המשימה הגולמית למשימה מעובדת.\n\n**חלק היצרן (למאגר המעובד):**\n1.  ממתין למקום פנוי במאגר המשימות המעובדות (`sem_wait(&processed_empty)`).\n2.  רוכש נעילה על המאגר המעובד (`sem_wait(&processed_mutex)`).\n3.  מכניס את המשימה המעובדת למאגר.\n4.  משחרר את הנעילה על המאגר המעובד (`sem_post(&processed_mutex)`).\n5.  מאותת שיש פריט חדש במאגר המעובד (`sem_post(&processed_full)`).\n\n**פעולת המעבד הסופי (Finisher):**\n1.  ממתין למשימה מעובדת במאגר (`sem_wait(&processed_full)`).\n2.  רוכש נעילה על המאגר המעובד (`sem_wait(&processed_mutex)`).\n3.  מוציא משימה מעובדת מהמאגר.\n4.  משחרר את הנעילה על המאגר המעובד (`sem_post(&processed_mutex)`).\n5.  מאותת שיש מקום פנוי במאגר המעובד (`sem_post(&processed_empty)`).\n6.  מבצע פעולת סיום על המשימה המעובדת.\n\nהקוד המלא כולל את ההצהרות והאתחולים הנדרשים:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#define RAW_BUFFER_SIZE 5\n#define PROCESSED_BUFFER_SIZE 5\n\ntypedef struct {\n    int id;\n    // ... נתונים נוספים של המשימה\n} task_t;\n\n// משתנים גלובליים:\ntask_t raw_buffer[RAW_BUFFER_SIZE];\nint raw_in = 0, raw_out = 0; // אתחול ל-0\n\ntask_t processed_buffer[PROCESSED_BUFFER_SIZE];\nint processed_in = 0, processed_out = 0; // אתחול ל-0\n\n// סמפורים למאגר הגולמי:\nsem_t raw_mutex;    // אתחול ל-1 (mutex)\nsem_t raw_full;     // אתחול ל-0 (מספר פריטים זמינים)\nsem_t raw_empty;    // אתחול ל-RAW_BUFFER_SIZE (מקומות פנויים)\n\n// סמפורים למאגר המעובד:\nsem_t processed_mutex;    // אתחול ל-1 (mutex)\nsem_t processed_full;     // אתחול ל-0 (מספר פריטים זמינים)\nsem_t processed_empty;    // אתחול ל-PROCESSED_BUFFER_SIZE (מקומות פנויים)\n\n// פונקציות עזר (אין צורך לממש בפתרון המבחן):\n// task_t produce_raw_task(int producer_id);\n// task_t process_task(task_t raw_task, int worker_id);\n// void finalize_task(task_t processed_task, int finisher_id);\n\nvoid* producer(void* arg) {\n    // int producer_id = *(int*)arg; // אם נרצה להשתמש ב-ID\n    while (1) {\n        task_t new_raw_task; // = produce_raw_task(producer_id);\n        // סימולציה של יצירת משימה\n        new_raw_task.id = rand() % 1000;\n        printf(\"[Producer] Produced raw task %d\\n\", new_raw_task.id);\n        \n        sem_wait(&raw_empty); // ממתין למקום פנוי במאגר הגולמי\n        sem_wait(&raw_mutex); // רוכש נעילה על המאגר הגולמי\n        \n        raw_buffer[raw_in] = new_raw_task;\n        raw_in = (raw_in + 1) % RAW_BUFFER_SIZE;\n        \n        sem_post(&raw_mutex); // משחרר נעילה על המאגר הגולמי\n        sem_post(&raw_full); // מאותת שיש פריט חדש במאגר הגולמי\n        \n        // usleep(100000); // סימולציה של זמן עבודה\n    }\n    return NULL;\n}\n\nvoid* worker(void* arg) {\n    // int worker_id = *(int*)arg; // אם נרצה להשתמש ב-ID\n    while (1) {\n        task_t raw_task_to_process;\n        \n        // חלק הצרכן למאגר הגולמי\n        sem_wait(&raw_full); // ממתין למשימה גולמית\n        sem_wait(&raw_mutex); // רוכש נעילה על המאגר הגולמי\n        \n        raw_task_to_process = raw_buffer[raw_out];\n        raw_out = (raw_out + 1) % RAW_BUFFER_SIZE;\n        \n        sem_post(&raw_mutex); // משחרר נעילה על המאגר הגולמי\n        sem_post(&raw_empty); // מאותת שיש מקום פנוי במאגר הגולמי\n        \n        // task_t processed_task = process_task(raw_task_to_process, worker_id);\n        // סימולציה של עיבוד משימה\n        task_t processed_task = { .id = raw_task_to_process.id * 10 };\n        printf(\"  [Worker] Processed raw task %d into processed task %d\\n\", raw_task_to_process.id, processed_task.id);\n        \n        // חלק היצרן למאגר המעובד\n        sem_wait(&processed_empty); // ממתין למקום פנוי במאגר המעובד\n        sem_wait(&processed_mutex); // רוכש נעילה על המאגר המעובד\n        \n        processed_buffer[processed_in] = processed_task;\n        processed_in = (processed_in + 1) % PROCESSED_BUFFER_SIZE;\n        \n        sem_post(&processed_mutex); // משחרר נעילה על המאגר המעובד\n        sem_post(&processed_full); // מאותת שיש פריט חדש במאגר המעובד\n        \n        // usleep(100000); // סימולציה של זמן עבודה\n    }\n    return NULL;\n}\n\nvoid* finisher(void* arg) {\n    // int finisher_id = *(int*)arg; // אם נרצה להשתמש ב-ID\n    while (1) {\n        task_t task_to_finalize;\n        \n        sem_wait(&processed_full); // ממתין למשימה מעובדת\n        sem_wait(&processed_mutex); // רוכש נעילה על המאגר המעובד\n        \n        task_to_finalize = processed_buffer[processed_out];\n        processed_out = (processed_out + 1) % PROCESSED_BUFFER_SIZE;\n        \n        sem_post(&processed_mutex); // משחרר נעילה על המאגר המעובד\n        sem_post(&processed_empty); // מאותת שיש מקום פנוי במאגר המעובד\n        \n        // finalize_task(task_to_finalize, finisher_id);\n        // סימולציה של סיום משימה\n        printf(\"    [Finisher] Finalized task %d\\n\", task_to_finalize.id);\n        \n        // usleep(100000); // סימולציה של זמן עבודה\n    }\n    return NULL;\n}\n```",
      "difficulty_estimation": "Hard"
    }
  }
}