{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 22:06:00",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2670,
      "output_tokens": 1567,
      "total_tokens": 7854
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Memory Management",
      "Stack",
      "Pointers",
      "Undefined Behavior"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה בשפת C.\nהתוכנית מנסה להקצות מערך בתוך פונקציה ולהחזיר מצביע אליו.\n\nהסבירו מהו הפלט הצפוי של התוכנית. אם התוכנית עלולה לקרוס או להתנהג באופן בלתי צפוי, הסבירו מדוע ומה הסיבות לכך בהקשר לניהול זיכרון במערכת ההפעלה.",
      "code_snippet": "#include <stdio.h>\n\nint* createArray() {\n    int arr[5]; // מערך מקומי המוקצה על המחסנית (stack)\n    for (int i = 0; i < 5; ++i) {\n        arr[i] = i * 10;\n    }\n    printf(\"Inside createArray: arr[0] = %d, address = %p\\n\", arr[0], (void*)arr);\n    return arr; // החזרת כתובת של משתנה מקומי במחסנית\n}\n\nint main() {\n    int* ptr = createArray();\n    printf(\"Inside main: ptr = %p\\n\", (void*)ptr);\n    // ניסיון לגשת לזיכרון לאחר שהפונקציה createArray הסתיימה\n    printf(\"Inside main: *ptr = %d\\n\", *ptr);\n    printf(\"Inside main: ptr[1] = %d\\n\", ptr[1]);\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הבעיה המרכזית בתוכנית זו היא שהפונקציה `createArray` מחזירה מצביע למערך `arr` שהוקצה על המחסנית (stack). כאשר הפונקציה `createArray` מסיימת את ריצתה, מסגרת המחסנית (stack frame) שלה מוסרת (או מסומנת כזמינה לשימוש חוזר). המשמעות היא שהזיכרון שבו שכן המערך `arr` אינו מוקצה עוד באופן חוקי עבור `arr`.\n\n**פלט צפוי והסבר:**\n1.  **הפלט הראשון (מתוך `createArray`):** `Inside createArray: arr[0] = 0, address = <כתובת כלשהי>`\n    *   פלט זה יהיה תקין ומדויק. בתוך הפונקציה `createArray`, המערך `arr` נמצא עדיין בתחום החיים שלו על המחסנית, והגישה אליו תקינה.\n\n2.  **הפלט השני (מתוך `main`):** `Inside main: ptr = <אותה כתובת כמו בפלט הראשון>`\n    *   פלט זה גם יהיה תקין, שכן `ptr` פשוט מקבל ומחזיק את הכתובת שהוחזרה מ-`createArray`. הבעיה אינה בהחזקת הכתובת, אלא בשימוש בה.\n\n3.  **הפלט השלישי והרביעי (מתוך `main`):** `Inside main: *ptr = <ערך בלתי צפוי>`, `Inside main: ptr[1] = <ערך בלתי צפוי>`\n    *   כאן מתרחשת התנהגות בלתי מוגדרת (Undefined Behavior). לאחר ש-`createArray` סיימה, הזיכרון שאליו `ptr` מצביע אינו מוקצה עוד עבור המערך `arr`. הגישה לזיכרון זה היא למעשה גישה לזיכרון תלוי (dangling pointer).\n    *   **הסיבות והתוצאות האפשריות:**\n        *   **הדפסת הערכים המקוריים:** במקרים רבים, במיוחד בתוכניות פשוטות, ייתכן שהזיכרון במחסנית לא יידרס מיד על ידי קריאות פונקציות אחרות. במצב כזה, התוכנית עשויה להדפיס בטעות את הערכים המקוריים (0 ו-10), מה שעלול ליצור אשליה שהקוד תקין. זוהי סכנה גדולה, מכיוון שהתנהגות זו אינה מובטחת ועלולה להשתנות בין ריצות שונות, קומפיילרים שונים או סביבות הפעלה שונות.\n        *   **הדפסת ערכי זבל:** אם הזיכרון שבו שכן `arr` נדרס על ידי נתונים אחרים (לדוגמה, אם פונקציה אחרת נקראה מיד לאחר `createArray` והשתמשה באותו אזור זיכרון במחסנית), אז `*ptr` ו-`ptr[1]` יכילו ערכי זבל.\n        *   **קריסה (Segmentation Fault):** במקרים מסוימים, מערכת ההפעלה או רכיבי זמן ריצה עשויים לזהות ניסיון גישה לזיכרון לא חוקי ולגרום לקריסת התוכנית (לרוב עם שגיאת Segmentation Fault). זה קורה אם הזיכרון סומן כלא נגיש או אם הגישה חורגת מגבולות הזיכרון שהוקצה לתהליך.\n\n**בהקשר לניהול זיכרון במערכת ההפעלה:**\nמערכת ההפעלה מקצה לכל תהליך מרחב כתובות וירטואלי משלו, הכולל בין היתר את מקטע המחסנית (Stack). המחסנית משמשת לאחסון משתנים מקומיים וכתובות חזרה של פונקציות. כאשר פונקציה נקראת, מסגרת מחסנית חדשה נוצרת עבורה. כאשר היא מסיימת, המסגרת שלה 'נמחקת' (כלומר, ה-stack pointer מתעדכן, והזיכרון נחשב לזמין לשימוש עתידי). הגישה לזיכרון זה לאחר ה'מחיקה' היא לגיטימית מבחינת מרחב הכתובות הוירטואלי של התהליך, אך לא חוקית מבחינה לוגית של התוכנית, ועלולה להוביל לשגיאות קשות שקשה לאתר."
    },
    "difficulty_estimation": "Medium"
  }
}