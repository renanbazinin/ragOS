{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Concurrency",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 00:41:19",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4697,
      "output_tokens": 3521,
      "total_tokens": 13568
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Concurrency",
      "Synchronization",
      "Readers-Writers Problem",
      "Prioritization",
      "Starvation Prevention",
      "Threads"
    ],
    "content": {
      "text": "נתון משאב משותף אליו ניגשים שני סוגי חוטים: קוראים (Readers) וכותבים (Writers). יש לממש מנגנון סנכרון המאפשר גישה למשאב בהתאם לכללים הבאים:\n1.  מספר קוראים יכולים לגשת למשאב בו-זמנית.\n2.  רק כותב אחד יכול לגשת למשאב בכל רגע נתון.\n3.  כותבים אינם יכולים לגשת למשאב כאשר קוראים פעילים.\n4.  קוראים אינם יכולים לגשת למשאב כאשר כותב פעיל.\n\nבנוסף לכללים אלו, יש להבטיח את העדיפויות הבאות:\n5.  **עדיפות לכותבים**: אם ישנם כותבים הממתינים לגישה למשאב, אין לאפשר לקוראים חדשים להיכנס. קוראים קיימים יסיימו את עבודתם, ולאחר מכן הכותבים יקבלו גישה.\n6.  **מניעת הרעבה לכותבים**: כותבים יקבלו גישה למשאב בסדר הגעתם (FIFO).\n7.  **מניעת הרעבה לקוראים**: קוראים לא יורעבו באופן מוחלט (כלומר, הם יקבלו גישה בסופו של דבר, אם אין כותבים ממתינים או פעילים).\n\nיש לממש את הפונקציות הבאות באמצעות מוטקסים (mutexes) ומשתני תנאי (condition variables) מתוך ספריית pthreads:\n`void reader_acquire();`\n`void reader_release();`\n`void writer_acquire();`\n`void writer_release();`\n\nאין צורך לממש את הגישה בפועל למשאב, אלא רק את מנגנון הסנכרון. יש לכלול גם פונקציות אתחול וסיום למנגנון הסנכרון (לדוגמה: `init_rw_lock()`, `destroy_rw_lock()`).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון מבוסס על שימוש במנעול הדדי (mutex) אחד להגנה על משתני מצב משותפים, ושני משתני תנאי (condition variables) - אחד לקוראים ואחד לכותבים. בנוסף, אנו משתמשים במונים כדי לעקוב אחר מספר הקוראים הפעילים, הכותבים הפעילים, והכותבים הממתינים, ובמנגנון תור (FIFO) לכותבים באמצעות מזהי תור.\n\n**קוד מימוש:**\n```c\n#include <pthread.h>\n\n// Global state variables for synchronization\npthread_mutex_t rw_lock;\npthread_cond_t reader_cond;\npthread_cond_t writer_cond;\n\nint readers_active = 0;   // Number of readers currently in critical section\nint writers_active = 0;   // Number of writers currently in critical section (0 or 1)\nint writers_waiting = 0;  // Number of writers waiting to enter\n\n// For FIFO writer prioritization\nunsigned long next_writer_id = 0; // Next ID to be assigned to a waiting writer\nunsigned long current_writer_id = 0; // ID of the writer whose turn it is\n\nvoid init_rw_lock() {\n    pthread_mutex_init(&rw_lock, NULL);\n    pthread_cond_init(&reader_cond, NULL);\n    pthread_cond_init(&writer_cond, NULL);\n    readers_active = 0;\n    writers_active = 0;\n    writers_waiting = 0;\n    next_writer_id = 0;\n    current_writer_id = 0;\n}\n\nvoid destroy_rw_lock() {\n    pthread_mutex_destroy(&rw_lock);\n    pthread_cond_destroy(&reader_cond);\n    pthread_cond_destroy(&writer_cond);\n}\n\nvoid reader_acquire() {\n    pthread_mutex_lock(&rw_lock);\n    // Readers wait if there's an active writer OR if there are writers waiting (prioritization)\n    while (writers_active > 0 || writers_waiting > 0) {\n        pthread_cond_wait(&reader_cond, &rw_lock);\n    }\n    readers_active++;\n    pthread_mutex_unlock(&rw_lock);\n}\n\nvoid reader_release() {\n    pthread_mutex_lock(&rw_lock);\n    readers_active--;\n    // If this was the last reader and there are writers waiting, signal a writer\n    if (readers_active == 0 && writers_waiting > 0) {\n        pthread_cond_signal(&writer_cond); // Wake up the next writer in line\n    }\n    pthread_mutex_unlock(&rw_lock);\n}\n\nvoid writer_acquire() {\n    pthread_mutex_lock(&rw_lock);\n    writers_waiting++; // Increment count of waiting writers\n    unsigned long my_writer_id = next_writer_id++; // Assign unique ID for FIFO\n\n    // Writers wait if there are active readers, an active writer, OR if it's not their turn\n    while (readers_active > 0 || writers_active > 0 || my_writer_id != current_writer_id) {\n        pthread_cond_wait(&writer_cond, &rw_lock);\n    }\n    \n    writers_waiting--; // Decrement count of waiting writers\n    writers_active++;  // Enter critical section\n    pthread_mutex_unlock(&rw_lock);\n}\n\nvoid writer_release() {\n    pthread_mutex_lock(&rw_lock);\n    writers_active--; // Exit critical section\n    current_writer_id++; // Advance the turn to the next writer\n\n    // If there are writers still waiting, signal the next writer in line\n    if (writers_waiting > 0) {\n        pthread_cond_signal(&writer_cond);\n    } else {\n        // If no writers are waiting, allow readers to proceed\n        pthread_cond_broadcast(&reader_cond);\n    }\n    pthread_mutex_unlock(&rw_lock);\n}\n```\n\n**הסבר מפורט:**\n\n**משתני מצב גלובליים:**\n*   `rw_lock`: מוטקס המגן על כל המשתנים הגלובליים הללו כדי למנוע תנאי מירוץ בגישה אליהם.\n*   `reader_cond`: משתנה תנאי עליו ממתינים קוראים כאשר הם אינם יכולים להיכנס למקטע הקריטי.\n*   `writer_cond`: משתנה תנאי עליו ממתינים כותבים כאשר הם אינם יכולים להיכנס למקטע הקריטי.\n*   `readers_active`: מונה את מספר הקוראים שנמצאים כרגע במקטע הקריטי. כאשר ערכו אפס, אין קוראים פעילים.\n*   `writers_active`: מונה את מספר הכותבים שנמצאים כרגע במקטע הקריטי. ערכו יכול להיות 0 או 1, שכן רק כותב אחד יכול להיות פעיל בכל עת.\n*   `writers_waiting`: מונה את מספר הכותבים שממתינים בתור להיכנס למקטע הקריטי. מונה זה משמש לאכיפת עדיפות לכותבים.\n*   `next_writer_id`: מונה עולה שמשמש להקצאת מזהה ייחודי לכל כותב שמגיע ומבקש גישה. זהו למעשה מספר הסידורי של הכותב בתור הכותבים.\n*   `current_writer_id`: המזהה של הכותב שכרגע תורו להיכנס למקטע הכתיבה. כותבים ממתינים עד שמזהה זה ישתווה למזהה שלהם.\n\n**היגיון הפעולה של הפונקציות:**\n\n1.  **`writer_acquire()`**: \n    *   הכותב נועל את המוטקס (`rw_lock`) כדי לגשת בבטחה למשתני המצב הגלובליים.\n    *   הוא מגדיל את `writers_waiting` כדי לסמן שיש כותב ממתין (זה ימנע מקוראים חדשים להיכנס).\n    *   הוא מקבל מזהה תור ייחודי (`my_writer_id`) על ידי הגדלת `next_writer_id`. מזהה זה ישמש לאכיפת סדר FIFO.\n    *   הכותב נכנס ללולאת המתנה (באמצעות `pthread_cond_wait`) על `writer_cond` אם מתקיים אחד מהתנאים הבאים:\n        *   `readers_active > 0`: ישנם קוראים פעילים במשאב.\n        *   `writers_active > 0`: יש כותב אחר שכרגע פעיל במשאב.\n        *   `my_writer_id != current_writer_id`: זה לא תורו של הכותב הנוכחי להיכנס. תנאי זה, יחד עם קידום `current_writer_id` ב`writer_release`, מבטיח שכותבים ייכנסו בסדר הגעתם (FIFO).\n    *   לאחר שהתנאים מתקיימים (אין קוראים/כותבים פעילים וזה תורו של הכותב), הכותב מקטין את `writers_waiting` (כבר אינו ממתין) ומגדיל את `writers_active` (נכנס למקטע הכתיבה).\n    *   הוא משחרר את המוטקס.\n\n2.  **`writer_release()`**: \n    *   הכותב נועל את המוטקס.\n    *   הוא מקטין את `writers_active` כדי לסמן שיצא ממקטע הכתיבה.\n    *   הוא מקדם את `current_writer_id`. פעולה זו מסמנת שהכותב הבא בתור יכול כעת להיכנס (אם אין קוראים פעילים).\n    *   אם ישנם כותבים נוספים שממתינים (`writers_waiting > 0`), הוא מאותת לכותב הבא בתור על `writer_cond` (באמצעות `pthread_cond_signal`). `signal` ולא `broadcast` משמש כדי להעיר כותב יחיד, שהוא הכותב הבא בתור לפי `current_writer_id`.\n    *   אחרת (אין כותבים ממתינים), הוא מאותת לכל הקוראים הממתינים על `reader_cond` (באמצעות `pthread_cond_broadcast`) כדי לאפשר להם להיכנס, שכן אין יותר כותבים שממתינים או פעילים.\n    *   הוא משחרר את המוטקס.\n\n3.  **`reader_acquire()`**: \n    *   הקורא נועל את המוטקס.\n    *   הוא נכנס ללולאת המתנה על `reader_cond` אם מתקיים אחד מהתנאים הבאים:\n        *   `writers_active > 0`: יש כותב פעיל במשאב.\n        *   `writers_waiting > 0`: ישנם כותבים שממתינים לגישה למשאב. תנאי זה מבטיח את עדיפות הכותבים - קוראים חדשים לא ייכנסו אם יש כותבים שמחכים, גם אם אין כותב פעיל כרגע.\n    *   לאחר שהתנאים מתקיימים (אין כותבים פעילים או ממתינים), הקורא מגדיל את `readers_active` (נכנס למקטע הקריאה).\n    *   הוא משחרר את המוטקס.\n\n4.  **`reader_release()`**: \n    *   הקורא נועל את המוטקס.\n    *   הוא מקטין את `readers_active` כדי לסמן שיצא ממקטע הקריאה.\n    *   אם הוא הקורא האחרון שעזב את המקטע הקריטי (`readers_active == 0`) וישנם כותבים ממתינים (`writers_waiting > 0`), הוא מאותת לכותב הבא בתור על `writer_cond` (באמצעות `pthread_cond_signal`). פעולה זו חשובה כדי לשחרר כותבים כאשר כל הקוראים סיימו את עבודתם.\n    *   הוא משחרר את המוטקס.\n\n**הבטחת הדרישות:**\n*   **מספר קוראים בו-זמנית**: מושג מכיוון ש`readers_active` גדל ללא הגבלה כאשר אין כותבים פעילים או ממתינים. אין הגבלה על מספר הקוראים הפעילים.\n*   **כותב יחיד**: מושג על ידי התנאי `writers_active > 0` בלולאת ההמתנה של הכותבים, אשר מבטיח שרק כותב אחד יכול להיות פעיל בכל עת.\n*   **כותבים לא מפריעים לקוראים/קוראים לא מפריעים לכותבים**: מובטח על ידי תנאי ההמתנה בשני סוגי ה-acquire, המונעים גישה בו-זמנית של קוראים וכותבים.\n*   **עדיפות לכותבים**: התנאי `writers_waiting > 0` בלולאת ההמתנה של `reader_acquire()` מונע כניסת קוראים חדשים כאשר ישנם כותבים הממתינים, ובכך נותן עדיפות לכותבים.\n*   **FIFO לכותבים**: השימוש במזהי תור (`next_writer_id`, `current_writer_id`) ובתנאי `my_writer_id != current_writer_id` בלולאת ההמתנה של הכותבים, יחד עם שימוש ב-`pthread_cond_signal` עבור `writer_cond`, מבטיח שכותבים ייכנסו בסדר הגעתם.\n*   **מניעת הרעבה לקוראים**: קוראים יכולים להיכנס אם אין כותבים פעילים או ממתינים. כאשר כותב מסיים את עבודתו ואין כותבים נוספים בתור, הוא מאותת לכל הקוראים הממתינים באמצעות `pthread_cond_broadcast`, ובכך מונע את הרעבתם."
    },
    "difficulty_estimation": "Hard"
  }
}