{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Semaphores and Producer-Consumer",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 10:40:57",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1649,
      "output_tokens": 2884,
      "total_tokens": 10323
    }
  },
  "question": {
    "id": 5,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Producer-Consumer",
      "Synchronization"
    ],
    "content": {
      "text": "בעיית היצרן-צרכן הקלאסית כוללת יצרנים שמוסיפים פריטים וצרכנים שצורכים פריטים, תוך שימוש בחוצץ משותף בעל גודל קבוע. נניח שבמקום להוסיף או לצרוך פריט בודד בכל פעם, יצרנים וצרכנים יכולים לנסות לבצע פעולות 'אצווה' (batch operations) - יצרן מנסה להוסיף X פריטים בבת אחת, וצרכן מנסה לצרוך Y פריטים בבת אחת.\nנדרש שכל פעולת אצווה תהיה אטומית: או שכל X הפריטים מתווספים לחוצץ בהצלחה, או שאף אחד מהם לא מתווסף; ובאופן דומה עבור צרכן, או שכל Y הפריטים נצרכים בהצלחה, או שאף אחד מהם לא נצרך. אין אפשרות לפעולות חלקיות.\n\nכתבו קוד C/C++ עבור פונקציות ה-`producer` וה-`consumer` המשתמשות בסמפורים כדי לפתור בעיה זו. יש לכלול את הגדרות הסמפורים והחוצץ, ולהסביר בפירוט את ההיגיון מאחורי השימוש בסמפורים כדי להבטיח נכונות, אטומיות ולמנוע קיפאון (deadlock) או הרעבה (starvation) בתרחיש זה. הניחו ש-X ו-Y הם פרמטרים ידועים וקבועים עבור היצרנים והצרכנים בהתאמה (לדוגמה, X=3, Y=2).",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep, if simulation is part of the code\n\n#define BUFFER_SIZE 10\nint buffer[BUFFER_SIZE];\nint in = 0;\nint out = 0;\n\nsem_t mutex;    // Mutual exclusion for buffer access (binary semaphore)\nsem_t empty;    // Counts empty slots in buffer (counting semaphore)\nsem_t full;     // Counts full slots in buffer (counting semaphore)\n\n// Helper function to add multiple items to the buffer\n// Assumes mutex is held and enough empty slots are available\nvoid add_items_to_buffer(int *items, int count) {\n    for (int i = 0; i < count; i++) {\n        buffer[in] = items[i];\n        in = (in + 1) % BUFFER_SIZE;\n    }\n}\n\n// Helper function to remove multiple items from the buffer\n// Assumes mutex is held and enough full slots are available\nvoid remove_items_from_buffer(int *items_removed, int count) {\n    for (int i = 0; i < count; i++) {\n        items_removed[i] = buffer[out];\n        out = (out + 1) % BUFFER_SIZE;\n    }\n}\n\n// Producer thread function\nvoid *producer(void *arg) {\n    // int producer_id = *(int*)arg; // If distinguishing producers\n    int items_to_produce = 3; // Example: producer wants to add 3 items at a time\n    static int produced_value_counter = 0; // Static to generate unique values across calls\n\n    while (1) {\n        // Prepare items to add\n        int items[items_to_produce];\n        for (int i = 0; i < items_to_produce; i++) {\n            items[i] = produced_value_counter++;\n        }\n\n        // Wait for enough empty slots for all 'items_to_produce' items\n        for (int i = 0; i < items_to_produce; i++) {\n            sem_wait(&empty);\n        }\n\n        sem_wait(&mutex); // Acquire mutex for exclusive buffer access\n        \n        add_items_to_buffer(items, items_to_produce);\n        printf(\"Producer added %d items (from %d to %d).\\n\", items_to_produce, items[0], items[items_to_produce-1]);\n\n        sem_post(&mutex); // Release mutex\n\n        // Signal that 'items_to_produce' new full slots are available\n        for (int i = 0; i < items_to_produce; i++) {\n            sem_post(&full);\n        }\n\n        // sleep(1); // Simulate work, if part of the specific context\n    }\n    return NULL;\n}\n\n// Consumer thread function\nvoid *consumer(void *arg) {\n    // int consumer_id = *(int*)arg; // If distinguishing consumers\n    int items_to_consume = 2; // Example: consumer wants to remove 2 items at a time\n    int consumed_items[items_to_consume];\n\n    while (1) {\n        // Wait for enough full slots for all 'items_to_consume' items\n        for (int i = 0; i < items_to_consume; i++) {\n            sem_wait(&full);\n        }\n\n        sem_wait(&mutex); // Acquire mutex for exclusive buffer access\n\n        remove_items_from_buffer(consumed_items, items_to_consume);\n        printf(\"Consumer consumed %d items (from %d to %d).\\n\", items_to_consume, consumed_items[0], consumed_items[items_to_consume-1]);\n\n        sem_post(&mutex); // Release mutex\n\n        // Signal that 'items_to_consume' new empty slots are available\n        for (int i = 0; i < items_to_consume; i++) {\n            sem_post(&empty);\n        }\n\n        // sleep(2); // Simulate work, if part of the specific context\n    }\n    return NULL;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון לבעיית היצרן-צרכן עם פעולות אצווה דורש התאמה של השימוש בסמפורים `empty` ו-`full`. הסמפור `mutex` עדיין נשאר סמפור בינארי רגיל (מאותחל ל-1 באמצעות `sem_init(&mutex, 0, 1)`) כדי להבטיח בלעדיות הדדית בגישה לחוצץ המשותף.\nהסמפור `empty` (מאותחל לגודל החוצץ `BUFFER_SIZE` באמצעות `sem_init(&empty, 0, BUFFER_SIZE)`) סופר את מספר המקומות הריקים בחוצץ, והסמפור `full` (מאותחל ל-0 באמצעות `sem_init(&full, 0, 0)`) סופר את מספר המקומות המלאים.\n\n**היצרן (Producer):**\nכאשר יצרן רוצה להוסיף `X` פריטים בבת אחת, הוא חייב להבטיח שישנם `X` מקומות ריקים זמינים בחוצץ לפני שהוא מתחיל לכתוב. לשם כך, הוא יבצע `sem_wait(&empty)` `X` פעמים. קריאות אלו יחסמו את היצרן עד שיהיו מספיק מקומות ריקים.\nלאחר מכן, היצרן רוכש את ה-`mutex` (`sem_wait(&mutex)`) כדי לקבל גישה בלעדית לחוצץ. הוא מוסיף את כל `X` הפריטים לחוצץ באמצעות הפונקציה `add_items_to_buffer`.\nבסיום הכתיבה, היצרן משחרר את ה-`mutex` (`sem_post(&mutex)`).\nולבסוף, הוא מאותת על כך שנוספו `X` פריטים מלאים על ידי ביצוע `sem_post(&full)` `X` פעמים.\n\n**הצרכן (Consumer):**\nבאופן דומה, כאשר צרכן רוצה לצרוך `Y` פריטים בבת אחת, הוא חייב להבטיח שישנם `Y` פריטים זמינים בחוצץ לפני שהוא מתחיל לקרוא. לשם כך, הוא יבצע `sem_wait(&full)` `Y` פעמים. קריאות אלו יחסמו את הצרכן עד שיהיו מספיק פריטים מלאים.\nלאחר מכן, הצרכן רוכש את ה-`mutex` (`sem_wait(&mutex)`) כדי לקבל גישה בלעדית לחוצץ. הוא מסיר את כל `Y` הפריטים מהחוצץ באמצעות הפונקציה `remove_items_from_buffer`.\nבסיום הקריאה, הצרכן משחרר את ה-`mutex` (`sem_post(&mutex)`).\nולבסוף, הוא מאותת על כך שנוספו `Y` מקומות ריקים על ידי ביצוע `sem_post(&empty)` `Y` פעמים.\n\n**הסבר על נכונות, אטומיות ומניעת קיפאון/הרעבה:**\n1.  **אטומיות:** השימוש ב-`sem_wait(&empty)` `X` פעמים (או `sem_wait(&full)` `Y` פעמים) *לפני* רכישת ה-`mutex` מבטיח שאם התהליך מצליח לרכוש את ה-`mutex` ולגשת לחוצץ, יש לו מספיק משאבים (מקומות ריקים/מלאים) כדי להשלים את כל פעולת האצווה. ה-`mutex` מבטיח שרק יצרן/צרכן אחד ניגש לחוצץ בכל רגע נתון, ובכך הוספת/הסרת `X`/`Y` פריטים מתבצעת כיחידה אטומית אחת מבחינת גישה לחוצץ.\n2.  **מניעת קיפאון (Deadlock):** סדר הפעולות קריטי. היצרן מבצע `sem_wait(&empty)` ואז `sem_wait(&mutex)`. הצרכן מבצע `sem_wait(&full)` ואז `sem_wait(&mutex)`. סדר זה מונע קיפאון. במקרה זה, היצרן מחכה למשאבים (`empty`) לפני שהוא תופס את המשאב הבלעדי (`mutex`). ה-`mutex` נתפס רק כאשר הובטח שיש מספיק מקום/פריטים. סדר זה מבטיח שכל תהליך שמחזיק ב-`mutex` כבר הבטיח לעצמו את כל המשאבים הנוספים הנדרשים לו, ולכן לא יחסום תהליך אחר שזקוק ל-`mutex` כדי לשחרר משאבים שהוא עצמו זקוק להם.\n3.  **מניעת הרעבה (Starvation):** הסמפורים מאפשרים גישה הוגנת יחסית (בהתאם למדיניות התזמון של מערכת ההפעלה). כל תהליך שממתין על סמפור יקבל הזדמנות להיכנס כאשר הסמפור ישוחרר. אין מנגנון שמבטיח שחוט מסוים לא יורעב באופן מוחלט, אך השימוש הסטנדרטי בסמפורים אינו יוצר הרעבה אינהרנטית בתרחיש זה. הפתרון המוצג מבטיח שפעולות האצווה מתבצעות בשלמותן, ושמצב החוצץ נשאר עקבי גם תחת גישה מקבילית."
    },
    "difficulty_estimation": "Medium"
  }
}