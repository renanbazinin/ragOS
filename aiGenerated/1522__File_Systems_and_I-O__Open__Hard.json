{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems and I/O",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 11:05:36",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4088,
      "output_tokens": 2798,
      "total_tokens": 10740
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "File Systems",
      "I/O"
    ],
    "content": {
      "text": "נתונה מערכת קבצים חדשה בשם InDirFS עם המאפיינים הבאים:\n*   רשומת תיקייה (directory entry) אינה מכילה מספר inode, אלא את שם הקובץ, גודלו, ומצביע ישיר לבלוק הדיסק שבו נמצא ה-inode של הקובץ.\n*   ה-inodes מאוחסנים ישירות בתוך בלוקי נתונים (data blocks). בלוק נתונים יכול להכיל מספר inodes.\n*   אין טבלת inodes גלובלית או bitmap ייעודי ל-inodes. במקום זאת, בלוקי הנתונים (שמכילים גם inodes) מנוהלים באמצעות bitmap של בלוקים חופשיים, הנמצא ב-superblock.\n*   כאשר inode משתחרר (למשל במחיקת קובץ), המקום שלו בתוך הבלוק מסומן כפנוי. הבלוק כולו מסומן כפנוי ב-bitmap רק אם כל ה-inodes בתוכו פנויים.\n*   המערכת תומכת ב-hard links.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "במערכת InDirFS, איך משפיעה העובדה שרשומת תיקייה מכילה מצביע ישיר לבלוק ה-inode על יצירה או מחיקה של hard link? פרטו את ההשלכות מבחינת עקביות הנתונים (consistency) ומהם היתרונות/חסרונות של גישה זו לעומת מערכת המבוססת על מספרי inode.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "תארו את רצף פעולות הדיסק (קריאה/כתיבה) המינימלי הנדרש למחיקת קובץ f מתיקייה D, כאשר ידוע שלקובץ f יש hard link אחד בלבד (כלומר, link_count = 1 לפני המחיקה). זהו נקודה קריטית ברצף הפעולות שבה קריסה עלולה להוביל למצב לא עקבי שקשה לשחזר ממנו, והסבירו מדוע. (הניחו שאין journaling).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "דנו בהשלכות הביצועים (performance implications) של אחסון inodes ישירות בתוך בלוקי נתונים במקום בטבלת inodes ייעודית. כיצד הדבר משפיע על דפוסי ה-I/O בדיסק בעת יצירת קבצים, מחיקתם, ובעת מעבר על תיקיות?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון לשאלה 1:\n\n**1.1 השלכות על יצירה/מחיקת hard link:**\n*   **יצירת hard link**: כאשר נוצר hard link חדש לקובץ קיים, נוצרת רשומה חדשה בתיקיית היעד. רשומה זו תכיל את שם ה-hard link, גודל הקובץ, ואותו \"מצביע ישיר לבלוק ה-inode\" כמו הרשומה המקורית. בנוסף, יש לעדכן את שדה `link_count` ב-inode עצמו (להגדיל אותו ב-1). היתרון הוא גישה ישירה ל-inode ללא צורך בחיפוש בטבלת inodes גלובלית. החיסרון המרכזי הוא עקביות: אם ה-inode משנה את מיקומו הפיזי בדיסק (למשל, ה-inode עובר לבלוק אחר עקב אופטימיזציה פנימית, או שהבלוק כולו נכתב מחדש מסיבה כלשהי), כל רשומות התיקיות המצביעות אליו חייבות להתעדכן. אם לא כולן מתעדכנות בהצלחה (למשל, עקב קריסה), חלק מהקישורים יצביעו למיקום שגוי, מה שיוביל לחוסר עקביות חמור. במערכת קבצים רגילה המבוססת על מספרי inode, מספר ה-inode נשאר קבוע, ורק ה-inode עצמו (שמציין את מיקום הנתונים) צריך להתעדכן במידת הצורך, ללא השפעה על רשומות התיקיות.\n*   **מחיקת hard link**: כאשר hard link נמחק, יש להסיר את הרשומה המתאימה מבלוק הנתונים של התיקייה. בנוסף, יש להקטין את שדה `link_count` ב-inode ב-1. אם `link_count` מגיע ל-0, יש לסמן את ה-inode כפנוי ולשחרר את בלוקי הנתונים שלו. במערכת כזו, מחיקת hard link לא אמורה להשפיע על המצביע הישיר ברשומות התיקיות האחרות, אלא רק על ה-`link_count` ועל רשומת התיקייה שנמחקה.\n\n**1.2 רצף פעולות דיסק ונקודת קריסה קריטית:**\n**רצף פעולות מינימלי למחיקת קובץ `f` מתיקייה `D` (`link_count = 1`):**\n1.  **קריאת בלוק הנתונים של תיקייה `D` (R_Dir_D_Data)**: כדי למצוא את רשומת הקובץ `f` ולהסירו מהתוכן בזיכרון.\n2.  **קריאת בלוק ה-inode של `f` (R_Inode_f_Block)**: כדי לעדכן את `link_count` (להקטין ל-0) ולקבל את המידע על בלוקי הנתונים של הקובץ כדי לשחררם.\n3.  **כתיבת בלוק הנתונים של תיקייה `D` (W_Dir_D_Data)**: לאחר הסרת רשומת `f` מהבלוק בזיכרון, כתיבתו לדיסק.\n4.  **כתיבת בלוק ה-inode של `f` (W_Inode_f_Block)**: לאחר עדכון `link_count` ל-0 וסימון ה-inode כפנוי בתוך הבלוק בזיכרון, כתיבתו לדיסק.\n5.  **שחרור בלוקי הנתונים של `f` (W_Superblock_Bitmap)**: כתיבה ל-free block bitmap ב-superblock כדי לסמן את בלוקי הנתונים של הקובץ כפנויים. (ייתכן שיש יותר מבלוק נתונים אחד, ויותר מכתיבה אחת ל-bitmap, אך נניח לצורך המינימליזם שזה מתבצע כפעולה אחת ל-bitmap).\n\n**נקודה קריטית לקריסה:**\nקריסה בין שלב 3 לשלב 4 (או 5).\n*   **הסבר**: אם המערכת קורסת לאחר כתיבת בלוק הנתונים של תיקייה `D` (שלב 3), אך לפני עדכון ה-inode של `f` (שלב 4) ולפני שחרור בלוקי הנתונים שלו (שלב 5), התיקייה `D` כבר לא מכילה רשומה עבור `f`. עם זאת, ה-inode של `f` עדיין מציין `link_count = 1`, והבלוקים של `f` עדיין מסומנים כתפוסים ב-bitmap. התוצאה היא \"קובץ רפאים\" (ghost file) או \"זליגת בלוקים\" (disk space leak): הקובץ אינו נגיש דרך אף תיקייה, אך בלוקי הנתונים שלו וכן ה-inode שלו עדיין תפוסים. מכיוון שאין טבלת inodes גלובלית או bitmap ייעודי ל-inodes, קשה לזהות את ה-inode הזה כיתום (orphan) על ידי סריקת המערכת, כי אין רשימה מרכזית של inodes קיימים. מערכת `fsck` רגילה תתקשה לזהות ש-inode זה אינו מקושר לאף תיקייה, מכיוון שהיא אינה יכולה לסרוק את כל ה-inodes הפוטנציאליים המפוזרים בבלוקי נתונים מבלי לדעת אילו בלוקים מכילים inodes ואילו לא.\n\n**1.3 השלכות ביצועים של אחסון Inodes בבלוקי נתונים:**\n*   **יתרונות (פוטנציאליים):**\n    *   **Località (Locality) משופרת**: כאשר קובץ נוצר בתיקייה, ה-inode שלו עשוי להיות מוקצה באותו בלוק נתונים או בבלוק סמוך לבלוק הנתונים של התיקייה. זה יכול לשפר את ה-locality של גישה, במיוחד עבור קבצים קטנים הנמצאים בתיקיות שנגישות יחד, מכיוון שייתכן שקריאת בלוק התיקייה תביא גם את בלוק ה-inode לזיכרון המטמון (cache).\n    *   **אין צורך בטבלת inodes נפרדת**: חוסך מקום אחסון וגישות נפרדות לטבלה זו, ומפשט את מבנה מערכת הקבצים.\n*   **חסרונות ובעיות ביצועים:**\n    *   **Fragmentציה של Inodes**: מכיוון ש-inodes מפוזרים בתוך בלוקי נתונים, הם עלולים להיות מפוזרים באופן לא רציף על הדיסק. בעת מעבר על תיקייה גדולה (שמכילה הרבה קבצים) או בעת ביצוע פעולות שדורשות גישה ל-inodes רבים (למשל, `ls -lR`), ייתכן שיהיה צורך לקרוא בלוקי נתונים רבים ושונים, מה שיגרום ל-seek times גבוהים ולביצועים ירודים, בניגוד לטבלת inodes רציפה יחסית.\n    *   **הקצאת/שחרור Inodes מורכבת ופחות יעילה**: כאשר inode משתחרר, הבלוק שלו לא מתפנה אלא אם כן כל ה-inodes בתוכו פנויים. זה יכול להוביל לבלוקים עם מקום פנוי חלקי שקשה לנצל מחדש ביעילות. תהליך הקצאת inode חדש עלול לדרוש סריקה של בלוקים רבים ב-bitmap כדי למצוא בלוק עם מקום פנוי ל-inode, או בלוק ריק לחלוטין, מה שיכול להיות איטי.\n    *   **גודל רשומת תיקייה**: רשומת תיקייה גדולה יותר (בגלל מצביע 4 בתים) מגבילה את מספר הרשומות שיכולות להיכנס לבלוק נתונים של תיקייה, מה שעלול להגדיל את מספר הבלוקים שתיקייה דורשת עבור הנתונים שלה, וכתוצאה מכך להגדיל את זמן הגישה לתיקיות גדולות."
    },
    "difficulty_estimation": "Hard"
  }
}