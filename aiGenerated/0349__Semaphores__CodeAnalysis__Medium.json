{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:59:47",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2864,
      "output_tokens": 1262,
      "total_tokens": 7519
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Semaphores",
      "Concurrency",
      "Threads",
      "Mutual Exclusion"
    ],
    "content": {
      "text": "נתונה תוכנית C++ המשתמשת בסמפורים (POSIX semaphores) לסנכרון גישה למשתנה משותף. התוכנית יוצרת מספר תהליכונים (threads) שכל אחד מהם מגדיל מונה גלובלי מספר פעמים. נתחו את הקוד וענו: מהו הערך הסופי של המשתנה `shared_counter` לאחר שכל התהליכונים סיימו את ריצתם? נמקו את תשובתכם והסבירו כיצד הסמפור מבטיח את הערך הנכון.",
      "code_snippet": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <semaphore.h> // For POSIX semaphores\n\n// Global shared counter\nint shared_counter = 0;\n\n// Semaphore for mutual exclusion\nsem_t mutex;\n\n// Number of increments per thread\nconst int INCREMENTS_PER_THREAD = 100000;\n// Number of threads\nconst int NUM_THREADS = 5;\n\nvoid thread_function() {\n    for (int i = 0; i < INCREMENTS_PER_THREAD; ++i) {\n        // Acquire the semaphore (P operation)\n        sem_wait(&mutex);\n\n        // Critical section\n        shared_counter++;\n\n        // Release the semaphore (V operation)\n        sem_post(&mutex);\n    }\n}\n\nint main() {\n    // Initialize the semaphore for mutual exclusion (initial value 1)\n    // 0 means semaphore is shared between threads of a process\n    sem_init(&mutex, 0, 1);\n\n    std::vector<std::thread> threads;\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        threads.emplace_back(thread_function);\n    }\n\n    for (std::thread& t : threads) {\n        t.join();\n    }\n\n    // Destroy the semaphore\n    sem_destroy(&mutex);\n\n    std::cout << \"Final value of shared_counter: \" << shared_counter << std::endl;\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הערך הסופי של המשתנה `shared_counter` יהיה 500,000.\n\nהסבר:\n1.  המשתנה `shared_counter` הוא משאב משותף אליו ניגשים מספר תהליכונים בו-זמנית. ללא סנכרון, פעולת ההגדלה (`shared_counter++`) אינה אטומית ויכולה להוביל למצב מרוץ (race condition), שבו מספר תהליכונים קוראים את אותו ערך, מגדילים אותו, וכותבים בחזרה, וכתוצאה מכך חלק מההגדלות עלולות ללכת לאיבוד והערך הסופי יהיה שגוי.\n2.  התוכנית משתמשת בסמפור בינארי (`mutex`) שמאותחל לערך 1 (`sem_init(&mutex, 0, 1);`). סמפור בינארי עם ערך התחלתי 1 משמש כמעין מנעול (lock) להבטחת הדרה הדדית (mutual exclusion).\n3.  כל תהליכון מבצע קריאה ל-`sem_wait(&mutex)` לפני הכניסה לקטע הקריטי (השורה `shared_counter++;`) וקריאה ל-`sem_post(&mutex)` לאחר היציאה ממנו.\n4.  קריאה ל-`sem_wait` (פעולת P) מקטינה את ערך הסמפור. אם הערך הופך לשלילי, התהליכון נחסם עד שתהליכון אחר יבצע `sem_post`. זה מבטיח שרק תהליכון אחד יכול להחזיק בסמפור (ובכך להיות בקטע הקריטי) בכל רגע נתון.\n5.  קריאה ל-`sem_post` (פעולת V) מגדילה את ערך הסמפור, ומשחררת תהליכון ממתין אם יש כזה.\n6.  בזכות מנגנון ההדרה ההדדית הזה, כל פעולת הגדלה של `shared_counter` מתבצעת באופן אטומי ביחס לתהליכונים האחרים. אין שני תהליכונים שיכולים להגדיל את המונה בו-זמנית.\n7.  לכן, הערך הסופי של `shared_counter` יהיה סכום מדויק של כל ההגדלות שבוצעו על ידי כל התהליכונים.\n8.  החישוב הוא: `NUM_THREADS` (5) * `INCREMENTS_PER_THREAD` (100,000) = 500,000."
    },
    "difficulty_estimation": "Medium"
  }
}