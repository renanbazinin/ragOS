{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Processes and Memory Management",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:17:54",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3064,
      "output_tokens": 3673,
      "total_tokens": 17565
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Processes",
      "Memory Management",
      "Copy-on-Write",
      "System Calls",
      "Virtual Memory"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה בשם prog_A. בנוסף, קיימת תוכנית נוספת בשם prog_B (שאינה מופיעה כאן). ידוע כי prog_B אינה מבצעת קריאות fork/exec נוספות ואינה מקצה זיכרון heap בעצמה.\n\nיש להניח את ההנחות הבאות:\n1. גודל דף זיכרון הוא 4KB.\n2. כל קריאות המערכת מצליחות.\n3. לא נוצרים תהליכים או מוקצה זיכרון בקטעי קוד אחרים במערכת.\n4. מערכת ההפעלה משתמשת במנגנון Copy-On-Write (COW) עבור זיכרון של תהליכים שנוצרו באמצעות fork.\n5. קטע הקוד של תוכנית (text segment) הוא read-only ומשותף בין תהליכים המריצים את אותה תוכנית.\n6. קטע ה-BSS (זיכרון לא מאותחל) מאופס על ידי מערכת ההפעלה בדף הראשון שנגשים אליו, ולאחר מכן מתנהג כ-COW. אם לא מתבצעת כתיבה לדפי ה-BSS, הם נשארים משותפים.\n\nנתוני זיכרון:\n**עבור prog_A (התוכנית הנתונה):**\n*   קטע קוד (Text Segment): 12 KB\n*   קטע נתונים מאותחלים (Data Segment, כולל משתנים סטטיים): 4 KB\n*   קטע נתונים לא מאותחלים (BSS Segment, עבור `large_bss_array`): 512 KB\n*   מחסנית (Stack): כל תהליך מתחיל עם דף מחסנית אחד (4KB) וגדל לפי הצורך. הקריאות לפונקציות בתוכנית זו אינן דורשות יותר מדף בודד למחסנית.\n*   Heap: הקצאת `malloc(1024 * 10)` דורשת 10KB.\n\n**עבור prog_B (התוכנית שמופעלת באמצעות execvp):**\n*   קטע קוד (Text Segment): 8 KB\n*   קטע נתונים ו-BSS (משולב): 4 KB\n*   מחסנית (Stack): דף אחד (4KB).\n*   Heap: 0 KB (אין הקצאת heap ב-prog_B).\n\nכעת, התבוננו במערכת בנקודת זמן **לאחר שכל קריאות ה-fork וכל קריאות ה-execvp הסתיימו בהצלחה**, אך **לפני שכל תהליך ביצע קריאת wait או exit**. כלומר, כל התהליכים שנוצרו עדיין קיימים ופעילים. תהליכים שביצעו execvp כבר החליפו את תמונת הזיכרון שלהם ל-prog_B וסיימו את הפונקציה `main` של `prog_A` (או את הקטע שהוביל ל-execvp), והחלו בריצת `prog_B` (אך לא ביצעו פעולות משמעותיות שמשנות את הזיכרון מעבר לנדרש להפעלת התוכנית).\n\nכמה מסגרות זיכרון פיזיות (physical frames) בסך הכל תפוסות במערכת עבור מרחב המשתמש (user space) בנקודת זמן זו? יש להסביר את החישוב המפורט לכל קטע זיכרון ולכל תהליך.\n",
      "code_snippet": "1 #include <stdio.h>\n2 #include <stdlib.h>\n3 #include <unistd.h>\n4 #include <sys/wait.h>\n\n5 int global_data_var = 1; // Initialized data segment\n6 char large_bss_array[1024 * 512]; // 512 KB BSS segment (uninitialized data)\n\n7 void do_work_and_modify_memory(const char* process_name) {\n8     int local_stack_var = 100; // Stack variable\n9     static int static_data_var = 50; // Initialized data segment (resides in data section)\n\n10    printf(\"[%s] PID: %d, PPID: %d\\n\", process_name, getpid(), getppid());\n\n11    // Modify a global variable to trigger COW for the data segment\n12    global_data_var++;\n13    printf(\"[%s] global_data_var after modification: %d\\n\", process_name, global_data_var);\n\n14    // Modify a static variable to trigger COW for the data segment\n15    static_data_var++;\n16    printf(\"[%s] static_data_var after modification: %d\\n\", process_name, static_data_var);\n\n17    // Allocate some heap memory\n18    int* heap_ptr = (int*)malloc(1024 * 10); // 10 KB on heap\n19    if (heap_ptr) {\n20        heap_ptr[0] = getpid();\n21        printf(\"[%s] Heap allocated, first value: %d\\n\", process_name, heap_ptr[0]);\n22        // Don't free for the purpose of the question, assume it's used.\n23    }\n24    sleep(1); // Simulate some work before exec or exit\n25 }\n\n26 int main() {\n27    pid_t original_pid = getpid();\n28    printf(\"[Main] Original PID: %d\\n\", original_pid);\n\n29    pid_t p1 = fork(); // Fork 1\n30    if (p1 == 0) { // Child A\n31        do_work_and_modify_memory(\"Child A\");\n32        pid_t p2 = fork(); // Fork 2 (from Child A)\n33        if (p2 == 0) { // Grandchild A\n34            do_work_and_modify_memory(\"Grandchild A\");\n35            // Grandchild A will exec prog_B\n36            char* args[] = { \"./prog_B\", NULL };\n37            printf(\"[Grandchild A] Executing prog_B...\\n\");\n38            execvp(args[0], args);\n39            perror(\"execvp failed in Grandchild A\");\n40            exit(1);\n41        } else if (p2 > 0) { // Child A continues\n42            // wait(NULL); // Commented out for the specific point in time\n43            printf(\"[Child A] Grandchild A is running prog_B.\\n\");\n44        }\n45        // exit(0); // Commented out for the specific point in time\n46    } else if (p1 > 0) { // Original Parent continues\n47        pid_t p3 = fork(); // Fork 3 (from Original Parent)\n48        if (p3 == 0) { // Child B\n49            do_work_and_modify_memory(\"Child B\");\n50            // Child B will exec prog_B\n51            char* args[] = { \"./prog_B\", NULL };\n52            printf(\"[Child B] Executing prog_B...\\n\");\n53            execvp(args[0], args);\n54            perror(\"execvp failed in Child B\");\n55            exit(1);\n56        } else if (p3 > 0) { // Original Parent continues\n57            // wait(NULL); // Commented out for the specific point in time\n58            // wait(NULL); // Commented out for the specific point in time\n59            printf(\"[Main] Children are running or finished exec.\\n\");\n60        }\n61    }\n62    sleep(5); // Ensure all processes are in their state for measurement\n63    return 0;\n}\n",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "לצורך החישוב, ננתח את עץ התהליכים ואת מצב הזיכרון של כל תהליך בנקודת הזמן הנתונה:\n\n**עץ התהליכים:**\n*   **P (תהליך ראשי):** מריץ את `prog_A`.\n    *   **C_A (בן א'):** נוצר על ידי P. מריץ את `prog_A`. קרא ל-`do_work_and_modify_memory`.\n        *   **GC_A (נכד א'):** נוצר על ידי C_A. קרא ל-`do_work_and_modify_memory`, ואז ביצע `execvp` והחליף את תוכניתו ל-`prog_B`.\n    *   **C_B (בן ב'):** נוצר על ידי P. קרא ל-`do_work_and_modify_memory`, ואז ביצע `execvp` והחליף את תוכניתו ל-`prog_B`.\n\n**מצב הזיכרון בנקודת הזמן הנתונה (לאחר כל ה-fork וה-exec, לפני waits/exits):**\n\n**1. קטעי זיכרון של `prog_A` (עבור P ו-C_A):**\n    *   **Text Segment (קוד):** 12KB = 3 דפים.\n        *   זהו קטע read-only. P ו-C_A מריצים את `prog_A` ולכן חולקים את אותם 3 דפים פיזיים.\n        *   *סה\"כ דפים פיזיים לקוד prog_A: 3 דפים.*\n    *   **Data Segment (מאותחל):** 4KB = 1 דף.\n        *   P: לא ביצע `do_work_and_modify_memory` (רק יצר ילדים), לכן הנתונים שלו נשארים במצב המקורי, בדף משלו.\n        *   C_A: ביצע `do_work_and_modify_memory`, ששינתה את `global_data_var` ו-`static_data_var`. כתוצאה מכך, מנגנון COW יצר עבורו עותק פרטי של דף ה-Data Segment.\n        *   *סה\"כ דפים פיזיים ל-Data prog_A: 2 דפים (1 עבור P, 1 עבור C_A).*\n    *   **BSS Segment (לא מאותחל):** 512KB = 128 דפים.\n        *   P ו-C_A: אף אחד מהם לא כתב ל-`large_bss_array`. דפי BSS הם COW, וכיוון שלא היה שינוי, הם נשארים משותפים.\n        *   *סה\"כ דפים פיזיים ל-BSS prog_A: 128 דפים (משותפים ל-P ו-C_A).*\n    *   **Stack (מחסנית):** 4KB = 1 דף לכל תהליך.\n        *   P: דף מחסנית ייחודי (1 דף).\n        *   C_A: דף מחסנית ייחודי (1 דף).\n        *   *סה\"כ דפים פיזיים ל-Stack prog_A: 2 דפים.*\n    *   **Heap (ערימה):**\n        *   P: לא ביצע הקצאה. (0 דפים).\n        *   C_A: ביצע `malloc(1024 * 10)` = 10KB. זה דורש 3 דפים ייחודיים עבורו.\n        *   *סה\"כ דפים פיזיים ל-Heap prog_A: 3 דפים (ייחודיים ל-C_A).*\n\n**2. קטעי זיכרון של `prog_B` (עבור GC_A ו-C_B):**\n    *   **Text Segment (קוד):** 8KB = 2 דפים.\n        *   GC_A ו-C_B מריצים את `prog_B` ולכן חולקים את אותם 2 דפים פיזיים (כי קוד הוא read-only).\n        *   *סה\"כ דפים פיזיים לקוד prog_B: 2 דפים.*\n    *   **Data/BSS Segment (משולב):** 4KB = 1 דף.\n        *   GC_A ו-C_B מריצים את `prog_B`. קטע זה הוא COW. ההנחה היא שאין פעולות משמעותיות שמשנות את הזיכרון מעבר לנדרש להפעלת התוכנית, כלומר אין כתיבה לדפי Data/BSS של prog_B. לכן, הם חולקים את אותו דף.\n        *   *סה\"כ דפים פיזיים ל-Data/BSS prog_B: 1 דף (משותף ל-GC_A ו-C_B).*\n    *   **Stack (מחסנית):** 4KB = 1 דף לכל תהליך.\n        *   GC_A: דף מחסנית ייחודי (1 דף).\n        *   C_B: דף מחסנית ייחודי (1 דף).\n        *   *סה\"כ דפים פיזיים ל-Stack prog_B: 2 דפים.*\n    *   **Heap (ערימה):** 0 KB. (0 דפים).\n\n**סיכום כולל של דפים פיזיים:**\n*   `prog_A` Text: 3 דפים (משותפים ל-P, C_A)\n*   `prog_A` Data: 2 דפים (1 ל-P, 1 ל-C_A)\n*   `prog_A` BSS: 128 דפים (משותפים ל-P, C_A)\n*   `prog_A` Stack: 2 דפים (1 ל-P, 1 ל-C_A)\n*   `prog_A` Heap: 3 דפים (ייחודיים ל-C_A)\n*   `prog_B` Text: 2 דפים (משותפים ל-GC_A, C_B)\n*   `prog_B` Data/BSS: 1 דף (משותף ל-GC_A, C_B)\n*   `prog_B` Stack: 2 דפים (1 ל-GC_A, 1 ל-C_B)\n\n**סה\"כ דפים פיזיים = 3 + 2 + 128 + 2 + 3 + 2 + 1 + 2 = 143 דפים.**"
    },
    "difficulty_estimation": "Hard"
  }
}