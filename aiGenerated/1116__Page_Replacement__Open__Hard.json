{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Page Replacement",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:06:26",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4205,
      "output_tokens": 3281,
      "total_tokens": 11436
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Page Replacement",
      "Memory Management",
      "Thrashing",
      "Frame Allocation"
    ],
    "content": {
      "text": "נתונה מערכת מרובת משימות (multiprogrammed system) המשתמשת ב-M מסגרות פיזיות ובאלגוריתם החלפת דפים LRU גלובלי. במערכת רצים שני תהליכים, P1 ו-P2, המתחרים על אותן מסגרות זיכרון פיזי.\nתהליך P1 מאופיין בסט עבודה קטן מאוד (למשל, 3-4 דפים) אליו הוא ניגש שוב ושוב באופן מחזורי ומהיר.\nתהליך P2 מאופיין בסט עבודה גדול בהרבה (למשל, 20-30 דפים) אליו הוא ניגש באופן סדרתי, כלומר הוא עובר בין דפים רבים בזה אחר זה.\n\nיש לפרט ולנמק את כל החישובים/הסברים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "תאר/י את ההתנהגות הצפויה של אלגוריתם ה-LRU הגלובלי במערכת זו, בהתחשב במאפייני הגישה לזיכרון של P1 ו-P2. איזה תהליך צפוי לחוות יותר כשלי דף (page faults), ומדוע? האם קיים סיכון לריבוי כשלים (thrashing) עבור אחד מהתהליכים או שניהם? נמק/י.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "הצע/י מנגנון לשינוי מדיניות החלפת הדפים או הקצאת המסגרות במערכת, במטרה למנוע או למתן את תופעת ה-thrashing עבור שני התהליכים, תוך שמירה על יעילות המערכת. הסבר/י כיצד המנגנון המוצע פועל, ומהם היתרונות והחסרונות שלו בהשוואה ל-LRU הגלובלי הטהור.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "אם המערכת הייתה משתמשת באלגוריתם LRU *מקומי* (local LRU), כאשר לכל תהליך מוקצה מספר קבוע של מסגרות (לדוגמה, 5 מסגרות ל-P1 ו-25 מסגרות ל-P2, כאשר סך המסגרות שווה ל-M), כיצד הייתה משתנה ביצועי המערכת בהשוואה למצב של LRU גלובלי? דון/י ביתרונות ובחסרונות של גישה זו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1: בהינתן מאפייני הגישה לזיכרון של P1 ו-P2 ואלגוריתם LRU גלובלי, ההתנהגות הצפויה היא כדלהלן:\n*   **תהליך P1**: מכיוון של-P1 סט עבודה קטן ונגישות מהירה ומחזורית לדפים אלה, הדפים שלו ייחשבו לרוב כ\"בשימוש לאחרונה\" במערכת הגלובלית. לכן, סביר להניח שדפיו של P1 יישארו בזיכרון הפיזי ולא יוחלפו בקלות. P1 צפוי לחוות מעט כשלי דף, אלא אם כן המערכת סובלת מ-thrashing חמור מאוד.\n*   **תהליך P2**: ל-P2 סט עבודה גדול והוא ניגש לדפים באופן סדרתי. באלגוריתם LRU גלובלי, כאשר P2 ניגש לדף חדש, הוא גורם לדף אחר (שהיה בשימוש הכי פחות לאחרונה מכלל הדפים במערכת) להיות מוחלף. עקב גודל סט העבודה של P2 והגישה הסדרתית, דפיו של P2 עצמו יהיו לרוב המועמדים העיקריים להחלפה (כי דפי P1 נגישים לעיתים קרובות יותר). P2 יחווה כשלי דף רבים מאוד, מכיוון שהוא כל הזמן מביא דפים חדשים ודוחף החוצה דפים קיימים, כולל דפים שהוא עצמו יזדקק להם שוב בקרוב.\n*   **סיכון ל-Thrashing**: קיים סיכון גבוה ל-thrashing עבור P2. מכיוון ש-P2 דוחף החוצה את דפיו שלו, הוא יבלה זמן רב בביצוע פעולות קלט/פלט להבאת דפים מהדיסק, במקום לבצע עבודה שימושית. ה-thrashing של P2 עלול להשפיע על המערכת כולה, להאט את ביצועיה ולהעלות את זמני ההמתנה גם עבור P1, למרות ש-P1 עצמו אינו סובל ישירות מ-thrashing באותה מידה. הסיבה היא ש-LRU גלובלי אינו מבחין בין דפים של תהליכים שונים כאשר הוא בוחר דף להחלפה, מה שמוביל לכך שתהליך עם סט עבודה גדול וגישה סדרתית כמו P2 \"גונב\" מסגרות מעצמו ומתהליכים אחרים באופן לא יעיל.\n\n1.2: כדי למנוע או למתן את תופעת ה-thrashing עבור שני התהליכים תוך שמירה על יעילות המערכת, ניתן להציע מנגנון המבוסס על מודל סט העבודה (Working Set Model) או תדירות כשלי הדף (Page Fault Frequency - PFF).\n**מנגנון מוצע: הקצאת מסגרות דינמית מבוססת PFF**\n*   **כיצד פועל המנגנון**: המערכת תנטר באופן רציף את תדירות כשלי הדף (PFF) של כל תהליך. יוגדרו שני ספים: סף עליון (PFF_upper) וסף תחתון (PFF_lower).\n    *   אם ה-PFF של תהליך עולה מעל PFF_upper (למשל, עבור P2), זה מעיד על כך שהתהליך סובל מ-thrashing או שהוא זקוק ליותר מסגרות. המערכת תנסה להקצות לו מסגרות נוספות (עד למגבלה מסוימת), על ידי לקיחתן ממאגר מסגרות פנויות או ממאגר מסגרות של תהליכים אחרים ש-PFF שלהם נמוך מ-PFF_lower.\n    *   אם ה-PFF של תהליך יורד מתחת ל-PFF_lower, זה מצביע על כך שהתהליך מחזיק יותר מסגרות ממה שהוא באמת צריך. המערכת יכולה לשחרר חלק מהמסגרות שלו למאגר הכללי, כדי שיהיו זמינות לתהליכים אחרים.\n    *   החלפת דפים בתוך התהליך עצמו תתבצע באמצעות LRU מקומי בין המסגרות שהוקצו לו.\n*   **יתרונות**: \n    *   **מניעת Thrashing**: המנגנון מזהה ומגיב ל-thrashing על ידי הגדלת הקצאת המסגרות לתהליך הסובל, ובכך מאפשר לו להחזיק את סט העבודה שלו בזיכרון. זה יועיל במיוחד ל-P2, ויפחית משמעותית את כשלי הדף שלו.\n    *   **יעילות ניצול זיכרון**: המערכת מנסה להתאים את הקצאת המסגרות לצרכים האמיתיים של התהליכים, ובכך מונעת בזבוז זיכרון על ידי תהליכים המחזיקים יותר מדי מסגרות, ומבטיחה שתהליכים עם צרכים גבוהים יקבלו את מבוקשם.\n    *   **הסתגלות דינמית**: המנגנון מסתגל לשינויים בסט העבודה של תהליכים לאורך זמן.\n*   **חסרונות**: \n    *   **תקורה (Overhead)**: נדרש ניטור מתמיד של ה-PFF וניהול דינמי של הקצאת המסגרות, מה שמוסיף תקורה למערכת ההפעלה.\n    *   **בחירת ספים**: קביעת הספים האופטימליים (PFF_upper, PFF_lower) היא משימה מורכבת וקריטית לביצועי המערכת.\n    *   **תגובה איטית**: למנגנון לוקח זמן לזהות שינויים ב-PFF ולהגיב אליהם, מה שעלול לגרום לתקופה קצרה של ביצועים ירודים לפני שהמערכת מתייצבת.\n\n1.3: אם המערכת הייתה משתמשת באלגוריתם LRU *מקומי* (local LRU), כאשר לכל תהליך מוקצה מספר קבוע של מסגרות (לדוגמה, 5 מסגרות ל-P1 ו-25 מסגרות ל-P2, כאשר סך המסגרות שווה ל-M), ביצועי המערכת היו משתנים באופן משמעותי:\n*   **P1**: עם הקצאה של 5 מסגרות (יותר מסט העבודה הקטן שלו), P1 יחווה מעט מאוד כשלי דף. סט העבודה שלו יישאר תמיד בזיכרון הפיזי, וביצועיו יהיו מצוינים ויציבים, ללא תלות בפעילות של P2. כל כשלי הדף יהיו רק בעת טעינה ראשונית של דפים או שינוי נדיר בסט העבודה.\n*   **P2**: עם הקצאה של 25 מסגרות, P2 עדיין יחווה כשלי דף רבים יחסית בגלל הגישה הסדרתית וסט העבודה הגדול שלו (20-30 דפים). עם זאת, מספר כשלי הדף יהיה צפוי ויציב יותר מאשר ב-LRU גלובלי, והוא לא יושפע מכך ש-P1 ניגש לדפיו בתדירות גבוהה. P2 יחליף רק דפים מתוך 25 המסגרות שהוקצו לו, מה שימנע ממנו לדחוק החוצה דפים של P1 או להידחק על ידי דפי P1.\n\n**יתרונות של LRU מקומי (בהשוואה ל-LRU גלובלי):**\n*   **הוגנות ובידוד**: כל תהליך מקבל את חלקו המובטח בזיכרון ואינו מושפע ישירות מהתנהגות זיכרון של תהליכים אחרים. P1 לא יגרום ל-P2 לסבול, ו-P2 לא יגרור את P1 ל-thrashing.\n*   **מניעת Thrashing רוחבי**: כשלי דף רבים בתהליך אחד (כמו P2) לא יגרמו באופן אוטומטי ל-thrashing במערכת כולה, מכיוון שהם מוגבלים למסגרות של אותו תהליך.\n*   **קלות ניתוח וחיזוי**: קל יותר לחזות ולנתח את ביצועי הזיכרון של כל תהליך בנפרד, מכיוון שהוא פועל באופן עצמאי במסגרותיו.\n*   **פשטות יחסית**: המימוש של LRU מקומי הוא פשוט יותר מבחינת ניהול זיכרון מאשר מנגנונים דינמיים מורכבים כמו PFF.\n\n**חסרונות של LRU מקומי (בהשוואה ל-LRU גלובלי):**\n*   **ניצול זיכרון לא יעיל**: אם תהליך מסוים אינו מנצל את כל המסגרות שהוקצו לו (לדוגמה, P1 זקוק ל-3 מסגרות אך הוקצו לו 5), המסגרות העודפות נשארות בלתי מנוצלות, גם אם תהליכים אחרים (כמו P2) זקוקים להן בדחיפות. זה עלול להוביל לניצול נמוך של הזיכרון הפיזי הכולל.\n*   **קשיחות בהקצאה**: הקצאת מסגרות קבועה אינה גמישה מספיק כדי להתמודד עם שינויים דינמיים בסט העבודה של תהליכים. תהליך שסט העבודה שלו גדל באופן פתאומי עלול לסבול מ-thrashing בתוך המסגרות שהוקצו לו, ללא יכולת לקבל מסגרות נוספות.\n*   **בחירת הקצאה**: קביעת מספר המסגרות האופטימלי לכל תהליך מראש היא משימה קשה, וקביעה שגויה עלולה לפגוע בביצועים.\n\nלסיכום, LRU מקומי מספק הוגנות ובידוד טובים יותר, אך עלול לסבול מניצול זיכרון פחות יעיל וחוסר גמישות בהשוואה למנגנונים גלובליים או דינמיים מתוחכמים יותר."
    },
    "difficulty_estimation": "Hard"
  }
}