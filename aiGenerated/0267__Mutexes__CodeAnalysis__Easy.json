{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:23:59",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4189,
      "output_tokens": 1954,
      "total_tokens": 10778
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Mutexes",
      "Concurrency",
      "Race Conditions"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בשני תהליכונים (threads) כדי להגדיל מונה משותף. עיין בקוד הנתון וענה על השאלות הבאות:",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\nint shared_counter = 0;\n\nvoid* increment_thread(void* arg) {\n    for (int i = 0; i < 100000; ++i) {\n        shared_counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2;\n\n    pthread_create(&tid1, NULL, increment_thread, NULL);\n    pthread_create(&tid2, NULL, increment_thread, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    printf(\"Final counter value: %d\\n\", shared_counter);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "101.1",
        "text": "מהו הפלט הצפוי של התוכנית? האם הוא יהיה תמיד זהה? נמק.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.2",
        "text": "תאר את הבעיה העיקרית בקוד הנתון וכיצד היא יכולה להתרחש.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.3",
        "text": "תקן את הקוד הנתון באמצעות mutex כדי להבטיח שהמונה המשותף יגיע לערכו הנכון. כלול את כל השינויים הנדרשים (הצהרה, אתחול, שימוש וסיום) בקוד המתוקן.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון לשאלה 101:\n\n**101.1 פלט צפוי וקביעות:**\nהפלט הצפוי של התוכנית לא יהיה 200000. לרוב, הפלט יהיה ערך נמוך יותר מ-200000, והוא לא יהיה תמיד זהה בין הרצות שונות של התוכנית. הסיבה לכך היא תנאי מרוץ (Race Condition).\n\n**101.2 תיאור הבעיה:**\nהבעיה העיקרית בקוד היא תנאי מרוץ על המשתנה הגלובלי המשותף `shared_counter`. הפעולה `shared_counter++` נראית אטומית, אך בפועל היא מורכבת משלוש פעולות בסיסיות ברמת המעבד (CPU):\n1. קריאת הערך הנוכחי של `shared_counter` מהזיכרון לרג'יסטר.\n2. הגדלת הערך ברג'יסטר באחד.\n3. כתיבת הערך המעודכן מהרג'יסטר בחזרה לזיכרון.\n\nכאשר שני תהליכונים (או יותר) מנסים לבצע את הפעולה הזו בו-זמנית, ייתכן ששניהם יקראו את אותו ערך ישן של `shared_counter` לפני שאחד מהם הספיק לכתוב בחזרה את הערך המעודכן. לדוגמה, אם `shared_counter` הוא 0:\n- תהליכון A קורא 0.\n- תהליכון B קורא 0.\n- תהליכון A מגדיל ל-1 וכותב בחזרה 1.\n- תהליכון B מגדיל ל-1 (מ-0 שקרא) וכותב בחזרה 1.\nבמקרה זה, בוצעו שתי הגדלות, אך המונה הגיע ל-1 במקום ל-2, ואחת ההגדלות 'אבדה'. כתוצאה מכך, הערך הסופי של `shared_counter` יהיה נמוך מהצפוי (200000) ולא יהיה דטרמיניסטי.\n\n**101.3 תיקון הקוד באמצעות mutex:**\nכדי לתקן את הבעיה ולהבטיח שהמונה יגיע לערכו הנכון (200000), יש להשתמש ב-mutex כדי להגן על הגישה לאזור הקריטי (השורה `shared_counter++`). הנה הקוד המתוקן:\n\n```c\n#include <stdio.h>\n#include <pthread.h>\n\nint shared_counter = 0;\npthread_mutex_t counter_mutex; // 1. הצהרה על mutex גלובלי\n\nvoid* increment_thread(void* arg) {\n    for (int i = 0; i < 100000; ++i) {\n        pthread_mutex_lock(&counter_mutex);   // 3. נעילת mutex לפני גישה לאזור הקריטי\n        shared_counter++;                     // האזור הקריטי\n        pthread_mutex_unlock(&counter_mutex); // 3. שחרור mutex לאחר סיום הגישה\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2;\n\n    pthread_mutex_init(&counter_mutex, NULL); // 2. אתחול ה-mutex לפני יצירת התהליכונים\n\n    pthread_create(&tid1, NULL, increment_thread, NULL);\n    pthread_create(&tid2, NULL, increment_thread, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    printf(\"Final counter value: %d\\n\", shared_counter);\n\n    pthread_mutex_destroy(&counter_mutex); // 4. השמדת ה-mutex בסיום השימוש בו\n    return 0;\n}\n```\n\n**הסבר לתיקון:**\n1.  **הצהרה על mutex**: הוספנו משתנה גלובלי מסוג `pthread_mutex_t` בשם `counter_mutex`. זהו אובייקט הסנכרון שישמש להגנה על המונה.\n2.  **אתחול mutex**: בתוך פונקציית `main`, לפני יצירת התהליכונים, אתחלנו את ה-mutex באמצעות `pthread_mutex_init(&counter_mutex, NULL)`. אתחול זה מכין את ה-mutex לשימוש.\n3.  **נעילה ושחרור mutex**: בתוך פונקציית `increment_thread`, עטפנו את הפעולה `shared_counter++;` בקריאות ל-`pthread_mutex_lock(&counter_mutex)` ו-`pthread_mutex_unlock(&counter_mutex)`. קריאה ל-`lock` מנסה לנעול את ה-mutex; אם הוא כבר נעול על ידי תהליכון אחר, התהליכון הנוכחי ימתין עד שה-mutex ישוחרר. קריאה ל-`unlock` משחררת את ה-mutex. זה מבטיח שרק תהליכון אחד יוכל להיכנס לאזור הקריטי (להגדיל את `shared_counter`) בכל רגע נתון, ובכך מונע את תנאי המרוץ.\n4.  **השמדת mutex**: לאחר שכל התהליכונים סיימו את ריצתם ואין יותר צורך ב-mutex, השמדנו אותו באמצעות `pthread_mutex_destroy(&counter_mutex)` בתוך פונקציית `main`. פעולה זו משחררת את המשאבים שהוקצו ל-mutex."
    },
    "difficulty_estimation": "Easy"
  }
}