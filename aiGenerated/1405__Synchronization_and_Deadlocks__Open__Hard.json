{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Synchronization and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 20:38:58",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3054,
      "output_tokens": 2810,
      "total_tokens": 11649
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Deadlocks",
      "Mutexes",
      "Resource Ordering"
    ],
    "content": {
      "text": "במערכת הפעלה נתונה, קיימים N חוטי עובד (Worker Threads) וחוט מנהל יחיד (Manager Thread).\nהמערכת משתמשת בשני משאבים משותפים, `ResourceA` ו-`ResourceB`, המוגנים באמצעות מנעולי `pthread_mutex_t`.\nחוטי העובד מבצעים משימות הדורשות גישה לשני המשאבים: הם תופסים את `ResourceA`, לאחר מכן את `ResourceB`, מבצעים עבודה, ומשחררים את שניהם.\nחוט המנהל מבצע פעולות תחזוקה תקופתיות הדורשות גם כן גישה לשני המשאבים, אך בסדר הפוך: הוא תופס את `ResourceB`, לאחר מכן את `ResourceA`, מבצע תחזוקה, ומשחרר את שניהם.\n\nלהלן מימוש ראשוני (אך לקוי) של הלוגיקה עבור החוטים:\n",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For sleep\n\npthread_mutex_t mutexA = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t mutexB = PTHREAD_MUTEX_INITIALIZER;\n\nvoid *worker_thread(void *arg) {\n    long id = (long)arg;\n    while (1) {\n        printf(\"Worker %ld: Trying to acquire ResourceA...\\n\", id);\n        pthread_mutex_lock(&mutexA);\n        printf(\"Worker %ld: Acquired ResourceA. Trying to acquire ResourceB...\\n\", id);\n        pthread_mutex_lock(&mutexB);\n        printf(\"Worker %ld: Acquired both resources. Performing work...\\n\", id);\n        // Simulate work\n        sleep(1);\n        pthread_mutex_unlock(&mutexB);\n        printf(\"Worker %ld: Released ResourceB.\\n\", id);\n        pthread_mutex_unlock(&mutexA);\n        printf(\"Worker %ld: Released ResourceA. Done with work.\\n\", id);\n        // Simulate non-critical work\n        sleep(2);\n    }\n    return NULL;\n}\n\nvoid *manager_thread(void *arg) {\n    while (1) {\n        printf(\"Manager: Trying to acquire ResourceB...\\n\");\n        pthread_mutex_lock(&mutexB);\n        printf(\"Manager: Acquired ResourceB. Trying to acquire ResourceA...\\n\");\n        pthread_mutex_lock(&mutexA);\n        printf(\"Manager: Acquired both resources. Performing maintenance...\\n\");\n        // Simulate maintenance\n        sleep(2);\n        pthread_mutex_unlock(&mutexA);\n        printf(\"Manager: Released ResourceA.\\n\");\n        pthread_mutex_unlock(&mutexB);\n        printf(\"Manager: Released ResourceB. Done with maintenance.\\n\");\n        // Simulate non-critical work\n        sleep(3);\n    }\n    return NULL;\n}\n",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**1. זיהוי קיפאון:**\n\nהמימוש הנתון אכן עלול להוביל למצב של קיפאון (deadlock) בשל סדר רכישת המשאבים השונה בין חוטי העובד לחוט המנהל. ננתח זאת באמצעות ארבעת התנאים ההכרחיים לקיפאון:\n\n*   **מניעה הדדית (Mutual Exclusion):** מתקיים. כל משאב (mutexA ו-mutexB) מוגן על ידי מנעול, ורק חוט אחד יכול להחזיק בו זמנית. אם חוט אחד מחזיק במנעול, חוט אחר המנסה לתפוס אותו ייחסם.\n*   **החזק והמתן (Hold and Wait):** מתקיים. חוט עובד עשוי לתפוס את `mutexA` ולהמתין ל-`mutexB`. באופן דומה, חוט המנהל עשוי לתפוס את `mutexB` ולהמתין ל-`mutexA`. כלומר, חוטים מחזיקים במשאב אחד לפחות בזמן שהם ממתינים למשאב נוסף.\n*   **אי-הפקעה (No Preemption):** מתקיים. המנעולים (`pthread_mutex_t`) אינם ניתנים להפקעה. ברגע שחוט תופס מנעול, הוא ישחרר אותו רק מרצונו החופשי (באמצעות `pthread_mutex_unlock`). מערכת ההפעלה לא יכולה לקחת מנעול מחוט שמחזיק בו.\n*   **המתנה מעגלית (Circular Wait):** מתקיים. זהו התנאי המרכזי שמוביל לקיפאון במקרה זה. ייתכן התרחיש הבא:\n    1.  חוט עובד (Worker X) תופס את `mutexA`.\n    2.  חוט המנהל (Manager) תופס את `mutexB`.\n    3.  כעת, חוט עובד X מנסה לתפוס את `mutexB` אך נחסם מכיוון שחוט המנהל מחזיק בו.\n    4.  חוט המנהל מנסה לתפוס את `mutexA` אך נחסם מכיוון שחוט עובד X מחזיק בו.\n    נוצרה כאן שרשרת המתנה מעגלית: Worker X מחכה ל-Manager, ו-Manager מחכה ל-Worker X. אף אחד מהם לא יכול להמשיך, והמערכת נכנסת לקיפאון.\n\n**2. פתרון למניעת קיפאון:**\n\nהדרך הנפוצה והיעילה ביותר למנוע קיפאון בתרחיש זה היא על ידי אכיפת סדר רכישת משאבים עקבי (Resource Ordering). כלומר, כל החוטים במערכת ירכשו את המשאבים באותו סדר מוגדר מראש. במקרה זה, נחליט שכל החוטים, הן העובדים והן המנהל, ירכשו תמיד את `ResourceA` ואז את `ResourceB`.\n\n**מימוש מתוקן:**\n\n```c\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For sleep\n\npthread_mutex_t mutexA = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t mutexB = PTHREAD_MUTEX_INITIALIZER;\n\nvoid *worker_thread(void *arg) {\n    long id = (long)arg;\n    while (1) {\n        printf(\"Worker %ld: Trying to acquire ResourceA...\\n\", id);\n        pthread_mutex_lock(&mutexA);\n        printf(\"Worker %ld: Acquired ResourceA. Trying to acquire ResourceB...\\n\", id);\n        pthread_mutex_lock(&mutexB);\n        printf(\"Worker %ld: Acquired both resources. Performing work...\\n\", id);\n        // Simulate work\n        sleep(1);\n        pthread_mutex_unlock(&mutexB);\n        printf(\"Worker %ld: Released ResourceB.\\n\", id);\n        pthread_mutex_unlock(&mutexA);\n        printf(\"Worker %ld: Released ResourceA. Done with work.\\n\", id);\n        // Simulate non-critical work\n        sleep(2);\n    }\n    return NULL;\n}\n\nvoid *manager_thread(void *arg) {\n    while (1) {\n        printf(\"Manager: Trying to acquire ResourceA... (Changed order)\\n\"); // Changed order\n        pthread_mutex_lock(&mutexA); // Changed order\n        printf(\"Manager: Acquired ResourceA. Trying to acquire ResourceB...\\n\");\n        pthread_mutex_lock(&mutexB);\n        printf(\"Manager: Acquired both resources. Performing maintenance...\\n\");\n        // Simulate maintenance\n        sleep(2);\n        pthread_mutex_unlock(&mutexB); // Changed order\n        printf(\"Manager: Released ResourceB.\\n\");\n        pthread_mutex_unlock(&mutexA); // Changed order\n        printf(\"Manager: Released ResourceA. Done with maintenance.\\n\");\n        // Simulate non-critical work\n        sleep(3);\n    }\n    return NULL;\n}\n```\n\n**הסבר כיצד הפתרון מונע קיפאון:**\n\nפתרון זה מונע את תנאי ה**המתנה המעגלית**. כאשר כל החוטים רוכשים את המשאבים באותו סדר (לדוגמה, תמיד A ואז B), לא ייתכן מצב שבו חוט X מחכה למשאב שחוט Y מחזיק, בעוד שחוט Y מחכה למשאב שחוט X מחזיק.\nאם חוט X תפס את A ומחכה ל-B, וחוט Y תפס את B ומחכה ל-A – זהו קיפאון.\nאבל אם כל החוטים תמיד מנסים לתפוס קודם את A ואז את B:\n*   אם חוט X מחזיק ב-A, הוא ממתין ל-B.\n*   אם חוט Y רוצה גם את A ואז את B, הוא יחסם מיד בניסיון לתפוס את A. הוא לא יגיע למצב בו הוא מחזיק ב-B ומחכה ל-A, מכיוון שהוא לא יכול לתפוס את B לפני שיתפוס את A.\nבכך, נשברת השרשרת המעגלית.\n\n**פשרות (Trade-offs):**\n\n*   **הוגנות (Fairness):** במקרה זה, אכיפת סדר רכישת המשאבים לאו דווקא פוגעת בהוגנות באופן מהותי, אלא אם כן ישנם דפוסים ספציפיים של שימוש שגורמים לחוטים מסוימים להמתין זמן רב יותר. עם זאת, אין זה פתרון שבהכרח מבטיח הוגנות חזקה (למשל, אין הבטחה שחוט שממתין זמן רב יקבל את המשאבים הבאים בתור). ייתכן מצב של רעב (starvation) אם יש זרם קבוע של חוטים מטיפוס אחד שתמיד מצליחים לתפוס את המשאבים לפני חוט מטיפוס אחר.\n*   **רמת מקביליות (Concurrency):** במקרה זה, הפתרון אינו מפחית משמעותית את רמת המקביליות לעומת המימוש המקורי (שגם בו נדרש שכל חוט יחזיק בשני המשאבים). כל עוד אין קיפאון, רמת המקביליות היא שהחוטים מתחרים על אותם מנעולים. אם היינו משתמשים במנעול יחיד לכל שני המשאבים, זה היה מפחית את המקביליות באופן דרסטי, אך שינוי הסדר בלבד שומר על רמת המקביליות הפוטנציאלית. הפשרה העיקרית היא הגמישות – חוטים אינם יכולים לרכוש משאבים בסדר שנוח להם ביותר מבחינה לוגית או ביצועית, אלא חייבים לציית לסדר הגלובלי."
    },
    "difficulty_estimation": "Hard"
  }
}