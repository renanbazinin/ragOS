{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:41:46",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 970,
      "output_tokens": 1370,
      "total_tokens": 6637
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Concurrency",
      "Critical Section"
    ],
    "content": {
      "text": "נתונים N תהליכים (threads) זהים, שכל אחד מהם מבצע את קטע הקוד הבא. במערכת קיימים שני סמפורים: `mutex` מאותחל ל-1, ו-`sync_point` מאותחל ל-0. בנוסף, קיים משתנה גלובלי `counter` המאותחל ל-0.\n\n```c\nvoid thread_func() {\n    // שלב 1\n    wait(mutex);\n    counter++;\n    if (counter == N) {\n        signal(sync_point);\n    }\n    signal(mutex);\n\n    // שלב 2\n    wait(sync_point);\n    // קטע קריטי לאחר מחסום (Critical Section after barrier)\n    // ...\n    signal(sync_point);\n}\n```\n\nבהנחה שכל N התהליכים מופעלים בו-זמנית ורצים עד לסיום. איזו מהטענות הבאות נכונה לגבי ההתנהגות של המערכת?",
      "code_snippet": "void thread_func() {\n    // שלב 1\n    wait(mutex);\n    counter++;\n    if (counter == N) {\n        signal(sync_point);\n    }\n    signal(mutex);\n\n    // שלב 2\n    wait(sync_point);\n    // קטע קריטי לאחר מחסום (Critical Section after barrier)\n    // ...\n    signal(sync_point);\n}",
      "options": [
        "א. רק תהליך אחד יצליח לעבור את הקריאה ל-`wait(sync_point)` ושאר התהליכים ייתקעו לנצח.",
        "ב. כל N התהליכים יצליחו לעבור את הקריאה ל-`wait(sync_point)` ויבצעו את \"הקטע הקריטי לאחר המחסום\" באופן סדרתי (אחד אחרי השני).",
        "ג. כל N התהליכים יצליחו לעבור את הקריאה ל-`wait(sync_point)` ויבצעו את \"הקטע הקריטי לאחר המחסום\" באופן מקבילי (בו-זמנית).",
        "ד. קיימת סכנת קיפאון (deadlock) שבה אף תהליך לא יצליח לעבור את הקריאה ל-`wait(sync_point)`.",
        "ה. כל התשובות האחרות אינן נכונות."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "הסבר:\n1.  **שלב 1 (הכנת המחסום):** כל N התהליכים מתחרים על גישה ל-`mutex` כדי להגדיל את המונה `counter`. המונה `counter` מוגן על ידי `mutex` ומבטיח שכל תהליך יגדיל אותו פעם אחת בדיוק.\n2.  **שחרור המחסום הראשוני:** התהליך ה-N שמגדיל את `counter` יגרום לתנאי `if (counter == N)` להיות אמיתי. תהליך זה יבצע קריאה ל-`signal(sync_point)`, מה שיגדיל את ערך `sync_point` ל-1 (מ-0). כל שאר התהליכים יבצעו `signal(mutex)` וישחררו אותו.\n3.  **שלב 2 (מעבר המחסום):** לאחר מכן, כל N התהליכים מגיעים לקריאה `wait(sync_point)`.\n    *   **התהליך הראשון:** התהליך הראשון שיגיע ל-`wait(sync_point)` וימצא את `sync_point` בערך 1 (שסומן על ידי התהליך ה-N) יצליח לעבור. ערך `sync_point` יירד ל-0. תהליך זה ייכנס ל\"קטע קריטי לאחר מחסום\".\n    *   **התהליכים הנותרים:** כל N-1 התהליכים האחרים יגיעו ל-`wait(sync_point)` וימצאו שערכו 0, ולכן ייתקעו בהמתנה.\n4.  **שחרור סדרתי:** התהליך היחיד שנמצא ב\"קטע קריטי לאחר מחסום\" יסיים את עבודתו ויבצע `signal(sync_point)`. קריאה זו תגדיל את ערך `sync_point` בחזרה ל-1, ותשחרר אחד מהתהליכים הממתינים. תהליך זה ישחרר שוב את `sync_point`, וכך הלאה.\n5.  **מסקנה:** כתוצאה מכך, כל N התהליכים אכן יעברו את המחסום `wait(sync_point)`, אך לא בו-זמנית. הם יעברו אחד אחרי השני, בסדרתיות, מכיוון שכל `signal(sync_point)` מאפשר רק לתהליך אחד נוסף לעבור. זהו אינו מחסום אמיתי (barrier) שמשחרר את כל התהליכים בבת אחת, אלא יותר מנגנון \"טורניקט\" או \"שער\" שמאפשר מעבר סדרתי לאחר שהאירוע הראשוני (כל התהליכים הגיעו לנקודה מסוימת) התרחש. לכן, טענה ב' נכונה."
    },
    "difficulty_estimation": "Hard"
  }
}