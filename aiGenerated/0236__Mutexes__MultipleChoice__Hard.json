{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:11:01",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 970,
      "output_tokens": 1033,
      "total_tokens": 3874
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "Synchronization",
      "Mutexes",
      "Deadlock",
      "Concurrency"
    ],
    "content": {
      "text": "נתון קטע הקוד הבא המשתמש בשני מנעולים (mutexes) ובשני תהליכונים (threads). איזה מהטענות הבאות נכונה לגבי הרצת קוד זה?",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // For sleep\n\npthread_mutex_t mutex_A;\npthread_mutex_t mutex_B;\n\nvoid* thread_func1(void* arg) {\n    printf(\"Thread 1: Trying to lock mutex_A...\\n\");\n    pthread_mutex_lock(&mutex_A);\n    printf(\"Thread 1: Locked mutex_A. Trying to lock mutex_B...\\n\");\n    sleep(1); // Simulate some work/context switch\n    pthread_mutex_lock(&mutex_B);\n    printf(\"Thread 1: Locked mutex_B. Doing work...\\n\");\n    // Do some work\n    pthread_mutex_unlock(&mutex_B);\n    pthread_mutex_unlock(&mutex_A);\n    printf(\"Thread 1: Unlocked both mutexes.\\n\");\n    return NULL;\n}\n\nvoid* thread_func2(void* arg) {\n    printf(\"Thread 2: Trying to lock mutex_B...\\n\");\n    pthread_mutex_lock(&mutex_B);\n    printf(\"Thread 2: Locked mutex_B. Trying to lock mutex_A...\\n\");\n    sleep(1); // Simulate some work/context switch\n    pthread_mutex_lock(&mutex_A);\n    printf(\"Thread 2: Locked mutex_A. Doing work...\\n\");\n    // Do some work\n    pthread_mutex_unlock(&mutex_A);\n    pthread_mutex_unlock(&mutex_B);\n    printf(\"Thread 2: Unlocked both mutexes.\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n\n    pthread_mutex_init(&mutex_A, NULL);\n    pthread_mutex_init(&mutex_B, NULL);\n\n    pthread_create(&t1, NULL, thread_func1, NULL);\n    pthread_create(&t2, NULL, thread_func2, NULL);\n\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n\n    pthread_mutex_destroy(&mutex_A);\n    pthread_mutex_destroy(&mutex_B);\n\n    return 0;\n}",
      "options": [
        "א. הקוד ירוץ תמיד בהצלחה וידפיס את כל ההודעות ללא בעיות.",
        "ב. הקוד עלול להיכנס למצב של קיפאון (deadlock).",
        "ג. הקוד יגרום לשגיאת זמן ריצה (runtime error) מכיוון שמנעול ננעל פעמיים.",
        "ד. הקוד ירוץ אבל תוצאות העבודה המוגנת עלולות להיות שגויות עקב תנאי מירוץ (race condition).",
        "ה. כל התשובות האחרות אינן נכונות."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "ההסבר: מצב של קיפאון (deadlock) עלול להתרחש. תהליכון 1 תופס את mutex_A ומנסה לתפוס את mutex_B. במקביל, תהליכון 2 תופס את mutex_B ומנסה לתפוס את mutex_A. אם שני התהליכונים תופסים את המנעול הראשון שלהם (כל אחד מנעול אחר) לפני שהשני משחרר אותו, שניהם ימתינו זה לזה באופן אינסופי, מה שיוביל לקיפאון. הוספת sleep(1) מגבירה את הסיכוי להתרחשות תרחיש זה."
    },
    "difficulty_estimation": "Hard"
  }
}