{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 23:16:44",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3180,
      "output_tokens": 2048,
      "total_tokens": 8755
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Paging",
      "Virtual Memory",
      "Memory Management",
      "Locality of Reference"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המנהלת זיכרון וירטואלי עם גודל דף של 4KB. גודל משתנה מסוג `int` הוא 4 בתים. נתונה תוכנית C המשתמשת במערך דו-ממדי סטטי גדול:\n\nהניחו שהמערך `arr` נמצא כולו באזור זיכרון המשתמש (user space) ואינו טעון לזיכרון הפיזי בתחילת ביצוע הפונקציות (כלומר, כל הדפים המכילים את המערך מסומנים כ-invalid בטבלת הדפים).",
      "code_snippet": "#define ROWS 1024\n#define COLS 1024\nstatic int arr[ROWS][COLS]; // ~4MB total size\n\n// פונקציה 1: גישה בסדר שורות\nvoid access_row_major() {\n    for (int i = 0; i < ROWS; ++i) {\n        for (int j = 0; j < COLS; ++j) {\n            arr[i][j] = i * j;\n        }\n    }\n}\n\n// פונקציה 2: גישה בסדר עמודות\nvoid access_col_major() {\n    for (int j = 0; j < COLS; ++j) {\n        for (int i = 0; i < ROWS; ++i) {\n            arr[i][j] = i * j;\n        }\n    }\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "כמה Page Faults (כשל דף) יתרחשו בסך הכל בעת קריאה לפונקציה `access_row_major()`? נמקו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "כמה Page Faults (כשל דף) יתרחשו בסך הכל בעת קריאה לפונקציה `access_col_major()`? נמקו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "הסבירו מדוע יש הבדל (או אין הבדל) במספר ה-Page Faults בין שתי הפונקציות.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "נתונים:\nגודל דף = 4KB = 4096 בתים.\nגודל `int` = 4 בתים.\nמספר `int`ים לדף = 4096 / 4 = 1024 `int`ים.\nגודל המערך `arr` הוא `1024 * 1024 * 4` בתים = `4,194,304` בתים = 4MB.\nמספר הדפים הכולל הנדרש למערך = 4MB / 4KB = 1024 דפים.\n\n**1. ניתוח `access_row_major()`:**\nמערכי C מאוחסנים בזיכרון בסדר שורות (row-major order). כלומר, האלמנטים `arr[i][0]`, `arr[i][1]`, ..., `arr[i][COLS-1]` מאוחסנים בזיכרון באופן רציף. \nבמקרה זה, `COLS = 1024`. מכיוון שדף אחד יכול להכיל 1024 `int`ים, כל שורה במערך `arr` (שגודלה `1024 * 4` בתים = 4KB) תתאים בדיוק לדף אחד בזיכרון. \nכאשר הפונקציה ניגשת לאלמנט הראשון בשורה (`arr[i][0]`), יתרחש Page Fault, והדף המכיל את כל השורה `i` ייטען לזיכרון הפיזי. לאחר מכן, כל הגישות הבאות לאלמנטים באותה שורה (`arr[i][1]` עד `arr[i][1023]`) ימצאו את הנתונים כבר בזיכרון הפיזי ולא יגרמו ל-Page Fault נוסף. \nמכיוון שיש `ROWS = 1024` שורות, וכל שורה גורמת ל-Page Fault אחד (ברגע הגישה הראשונה אליה), המספר הכולל של Page Faults יהיה **1024**. \n\n**2. ניתוח `access_col_major()`:**\nבפונקציה זו, הלולאה הפנימית עוברת על האינדקס `i` (שורות) בעוד האינדקס `j` (עמודות) קבוע. כלומר, סדר הגישה לזיכרון הוא `arr[0][j]`, `arr[1][j]`, `arr[2][j]`, וכן הלאה. \nהאלמנט `arr[i][j]` והאלמנט `arr[i+1][j]` אינם סמוכים בזיכרון. ההפרש בכתובות ביניהם הוא `COLS * sizeof(int)` בתים. במקרה זה, `1024 * 4` בתים = 4096 בתים, שזהו בדיוק גודל של דף אחד. \nמשמעות הדבר היא שכל גישה לאלמנט `arr[i][j]` (עבור `i` שונה) תהיה בדף זיכרון שונה לגמרי. לדוגמה, `arr[0][j]` יהיה בדף P, `arr[1][j]` יהיה בדף P+1, `arr[2][j]` בדף P+2, וכן הלאה. \nלכן, עבור כל עמודה `j`, כאשר הלולאה הפנימית עוברת על `i` מ-0 עד `ROWS-1`, כל גישה ל-`arr[i][j]` תגרום ל-Page Fault חדש, מכיוון שהיא ניגשת לדף שונה שעדיין לא נטען. \nיש `ROWS = 1024` גישות כאלה עבור כל עמודה, וקיימות `COLS = 1024` עמודות. \nלכן, המספר הכולל של Page Faults יהיה `ROWS * COLS = 1024 * 1024 = 1,048,576`. \n\n**3. הסבר ההבדל:**\nההבדל הדרמטי במספר ה-Page Faults נובע מעקרון 'מקומיוּת ההתייחסות' (Locality of Reference), ובפרט 'מקומיוּת מרחבית' (Spatial Locality). \n*   **`access_row_major()`** מפגינה מקומיוּת מרחבית גבוהה: היא ניגשת לזיכרון באופן רציף (אלמנטים סמוכים בזיכרון). כאשר דף נטען לזיכרון הפיזי בעקבות Page Fault, הוא מכיל את כל האלמנטים הבאים שהפונקציה תצטרך באותה שורה. לכן, רוב הגישות ימצאו את הנתונים כבר בזיכרון הפיזי, מה שמפחית משמעותית את מספר ה-Page Faults. \n*   **`access_col_major()`** מפגינה מקומיוּת מרחבית נמוכה מאוד: כל גישה בתוך הלולאה הפנימית (שינוי `i`) קופצת לכתובת זיכרון המרוחקת בדיוק דף אחד מהכתובת הקודמת. משמעות הדבר היא שכל גישה כמעט תמיד תגרום ל-Page Fault חדש, מכיוון שהיא דורשת דף זיכרון שונה שאינו טעון. זה מוביל לטעינה של דפים רבים ושונים שוב ושוב, ובכך מגדיל מאוד את מספר ה-Page Faults.",
      "code_snippet": null
    },
    "difficulty_estimation": "Medium"
  }
}