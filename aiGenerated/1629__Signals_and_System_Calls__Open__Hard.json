{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 11:57:23",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 3488,
      "total_tokens": 16007
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "Process Management",
      "Concurrency",
      "Synchronization"
    ],
    "content": {
      "text": "הורה צריך להריץ N תהליכי ילד. כל תהליך ילד יריץ תוכנית חיצונית (לדוגמה, `/bin/sleep <seconds>`). ההורה רוצה לשלוט על מועד התחלת הריצה של הילדים. \n\nדרישות:\n1. ההורה ייצור N תהליכי ילד באמצעות `fork()`.\n2. מיד לאחר ה-`fork()`, כל ילד ימתין לאות `SIGUSR1` מההורה לפני שיבצע `exec()` לתוכנית החיצונית.\n3. ההורה, לאחר יצירת כל הילדים, ישלח אות `SIGUSR1` לכל ילד בנפרד, עם השהייה קצרה (לדוגמה, שנייה אחת) בין שליחה לשליחה.\n4. ההורה ימתין לסיום כל הילדים באמצעות `waitpid()` וידפיס את סטטוס היציאה של כל אחד מהם.\n5. יש לממש מטפל לאות `SIGCHLD` בהורה כדי למנוע תהליכי זומבי ולאסוף את סטטוס היציאה בצורה נכונה. המטפל צריך להיות עמיד בפני מצבים בהם ילד מסיים את ריצתו לפני שההורה הספיק לשלוח לו `SIGUSR1` או לפני שההורה התחיל את לולאת ה-`waitpid` הראשית.\n6. יש להציג דוגמת קוד מלאה ב-C/C++ המממשת את הדרישות.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון זה מממש את הדרישות באמצעות שימוש ב-`fork()`, `exec()`, `kill()`, `waitpid()` ובמנגנוני טיפול באותות כמו `sigaction()` ו-`sigsuspend()`.\n\n**הסבר מפורט:**\n\n1.  **טיפול באות `SIGCHLD` בהורה (`sigchld_handler`):**\n    *   ההורה משתמש ב-`sigaction()` כדי להגדיר מטפל אמין לאות `SIGCHLD`. `sigaction` עדיף על `signal()` מכיוון שהוא מספק שליטה טובה יותר על התנהגות האות (למשל, `SA_RESTART` ו-`SA_NOCLDSTOP`).\n    *   בתוך המטפל, לולאת `while ((pid = waitpid(-1, &status, WNOHANG)) > 0)` חיונית. היא מבטיחה שכל תהליכי הילד שהסתיימו (גם אם מספר אותות `SIGCHLD` התמזגו לאחד) ייאספו (reaped) באופן מיידי. `WNOHANG` מונע מהמטפל להיחסם אם אין ילדים נוספים לאיסוף באותו רגע, ומאפשר לו לחזור במהירות. המונה `children_remaining` משמש למעקב אחר מספר הילדים הפעילים.\n\n2.  **המתנה לאות `SIGUSR1` בילד (`sigusr1_handler` ו-`sigsuspend`):**\n    *   הילד מגדיר מטפל לאות `SIGUSR1` (שבמקרה זה יכול להיות ריק, שכן מטרתו העיקרית היא לאפשר ל-`sigsuspend` לחזור). ה-`sigaction` עבור `SIGUSR1` מוגדר בהורה לפני ה-`fork`, והילד יורש את הגדרות המטפלים.\n    *   לפני הקריאה ל-`sigsuspend()`, הילד חוסם באופן זמני את `SIGUSR1` באמצעות `sigprocmask(SIG_BLOCK, ...)`. זה מבטיח שהאות לא יגיע ויימסר לפני שהילד מוכן להמתין לו באופן אטומי.\n    *   `sigsuspend(&suspend_mask)` הוא המפתח לסנכרון. הוא מבצע שתי פעולות באופן אטומי: משנה את מסכת האותות של התהליך למסכה שחוסמת את כל האותות למעט `SIGUSR1`, ולאחר מכן עוצר את התהליך. התהליך מתחדש רק כאשר אות לא חסום (כמו `SIGUSR1`) מגיע ומטופל. לאחר מכן, מסכת האותות המקורית משוחזרת. זה מבטיח שהילד יבצע `exec()` רק לאחר קבלת `SIGUSR1` מההורה.\n\n3.  **יצירת ילדים ושליחת אותות בהורה:**\n    *   ההורה יוצר `NUM_CHILDREN` תהליכי ילד באמצעות `fork()`, ושומר את ה-PIDs שלהם במערך.\n    *   לאחר יצירת כל הילדים, ההורה עובר בלולאה ושולח `SIGUSR1` לכל ילד באמצעות `kill(pid, SIGUSR1)`, עם השהייה קצרה של שנייה אחת בין שליחה לשליחה באמצעות `sleep(1)`.\n\n4.  **המתנה לסיום כל הילדים בהורה:**\n    *   לאחר שליחת כל אותות ה-`SIGUSR1`, ההורה נכנס ללולאה שבה הוא קורא ל-`pause()` כל עוד המונה `children_remaining` גדול מ-0. `pause()` גורם להורה להמתין עד שכל אות מגיע (לדוגמה, `SIGCHLD` כאשר ילד מסיים). המטפל `sigchld_handler` יטפל בילדים המסתיימים, ויקטין את המונה. כאשר המונה מגיע ל-0, כל הילדים סיימו את ריצתם, וההורה יכול לצאת.\n\n**עמידות בפני תרחישי מרוץ:**\n*   אם ילד מסיים את ריצתו (לדוגמה, `exec` נכשל מיד או `/bin/sleep` מקבל ערך 0) לפני שההורה שולח לו `SIGUSR1`, או לפני שההורה התחיל את לולאת ה-`waitpid` הראשית, ה-`SIGCHLD` יימסר להורה. המטפל `sigchld_handler` יאסוף את הילד הזה באופן מיידי בזכות לולאת `waitpid(-1, &status, WNOHANG)` ויעדכן את `children_remaining`. כך, לא נוצרים תהליכי זומבי, וההורה מעודכן במצב.\n*   השימוש ב-`sigsuspend` בילד מבטיח שהילד לא יפספס את `SIGUSR1` גם אם הוא נשלח בדיוק כשהילד מבצע הגדרה פנימית, ושהוא ימתין אך ורק לאות זה לפני המשך הריצה.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <errno.h>\n\n#define NUM_CHILDREN 3\n#define SLEEP_SECONDS 2 // משך השינה הבסיסי עבור /bin/sleep\n\npid_t child_pids[NUM_CHILDREN];\nvolatile int children_remaining = NUM_CHILDREN; // משתנה נדיף עבור בטיחות באותות\n\nvoid sigchld_handler(int signum) {\n    int status;\n    pid_t pid;\n    // לולאה לאיסוף כל הילדים שהסתיימו\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        printf(\"[Parent] SIGCHLD handler: Child %d terminated with status %d\\n\", pid, WEXITSTATUS(status));\n        children_remaining--;\n    }\n    // טיפול בשגיאות אפשריות מ-waitpid, אם כי WNOHANG מפחית את חשיבותן בתרחיש זה\n    if (pid == -1 && errno != ECHILD) {\n        perror(\"[Parent] SIGCHLD handler: waitpid error\");\n    }\n}\n\nvoid sigusr1_handler(int signum) {\n    // מטפל זה יכול להיות ריק, מטרתו היא רק לבטל את חסימת sigsuspend\n    printf(\"[Child %d] Received SIGUSR1. Proceeding with exec.\\n\", getpid());\n}\n\nint main() {\n    struct sigaction sa_chld, sa_usr1;\n    int i;\n\n    // --- הגדרת מטפל SIGCHLD בהורה ---\n    sa_chld.sa_handler = sigchld_handler;\n    sigemptyset(&sa_chld.sa_mask);\n    sa_chld.sa_flags = SA_RESTART | SA_NOCLDSTOP; // SA_RESTART עבור קריאות מערכת, SA_NOCLDSTOP לא לקבל אותות עבור ילדים שעצרו\n    if (sigaction(SIGCHLD, &sa_chld, NULL) == -1) {\n        perror(\"sigaction SIGCHLD\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"[Parent] SIGCHLD handler set up.\\n\");\n\n    // --- הגדרת מטפל SIGUSR1 (עבור הילדים) ---\n    sa_usr1.sa_handler = sigusr1_handler;\n    sigemptyset(&sa_usr1.sa_mask);\n    sa_usr1.sa_flags = 0; // אין צורך בדגלים מיוחדים עבור SIGUSR1\n    if (sigaction(SIGUSR1, &sa_usr1, NULL) == -1) {\n        perror(\"sigaction SIGUSR1\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"[Parent] SIGUSR1 handler prepared (for children).\\n\");\n\n    // --- יצירת תהליכי ילד ---\n    for (i = 0; i < NUM_CHILDREN; i++) {\n        pid_t pid = fork();\n\n        if (pid == -1) {\n            perror(\"fork\");\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) { // תהליך ילד\n            char sleep_duration_str[16];\n            // כל ילד ישן קצת יותר זמן כדי להדגים סדר\n            snprintf(sleep_duration_str, sizeof(sleep_duration_str), \"%d\", SLEEP_SECONDS + i);\n\n            // חסימת SIGUSR1 באופן זמני כדי להבטיח ש-sigsuspend מוכן\n            sigset_t block_mask, old_mask;\n            sigemptyset(&block_mask);\n            sigaddset(&block_mask, SIGUSR1);\n            if (sigprocmask(SIG_BLOCK, &block_mask, &old_mask) == -1) {\n                perror(\"[Child] sigprocmask BLOCK SIGUSR1\");\n                _exit(EXIT_FAILURE);\n            }\n            printf(\"[Child %d] Waiting for SIGUSR1...\\n\", getpid());\n\n            // הכנת מסכה עבור sigsuspend: חוסמת את כל האותות למעט SIGUSR1\n            sigset_t suspend_mask;\n            sigfillset(&suspend_mask); // חוסם את כל האותות\n            sigdelset(&suspend_mask, SIGUSR1); // מבטל חסימה של SIGUSR1\n\n            // מבטל חסימה של SIGUSR1 באופן אטומי וממתין לכל אות (רצוי SIGUSR1)\n            // sigsuspend יחזור כאשר SIGUSR1 יתקבל ויטופל\n            sigsuspend(&suspend_mask);\n\n            // שחזור מסכת האותות המקורית (אופציונלי, אך מומלץ)\n            if (sigprocmask(SIG_SETMASK, &old_mask, NULL) == -1) {\n                perror(\"[Child] sigprocmask SETMASK original\");\n                _exit(EXIT_FAILURE);\n            }\n\n            printf(\"[Child %d] SIGUSR1 received. Executing /bin/sleep %s\\n\", getpid(), sleep_duration_str);\n            execl(\"/bin/sleep\", \"sleep\", sleep_duration_str, (char *)NULL);\n            perror(\"[Child] execl failed\"); // execl חוזר רק במקרה של שגיאה\n            _exit(EXIT_FAILURE); // השתמש ב-_exit בילד לאחר שגיאות fork/exec\n        } else { // תהליך הורה\n            child_pids[i] = pid;\n            printf(\"[Parent] Forked child %d (PID: %d)\\n\", i + 1, pid);\n        }\n    }\n\n    // --- ההורה שולח SIGUSR1 לילדים ---\n    printf(\"[Parent] All children forked. Sending SIGUSR1 to them sequentially.\\n\");\n    for (i = 0; i < NUM_CHILDREN; i++) {\n        printf(\"[Parent] Sending SIGUSR1 to child %d (PID: %d)...\\n\", i + 1, child_pids[i]);\n        if (kill(child_pids[i], SIGUSR1) == -1) {\n            perror(\"kill SIGUSR1\");\n            // אם הילד כבר יצא, kill עלול להיכשל עם ESRCH. יש לטפל או להתעלם לפי הדרישות.\n        }\n        sleep(1); // השהייה קצרה בין שליחת אותות\n    }\n\n    // --- ההורה ממתין לכל הילדים שיסתיימו ---\n    printf(\"[Parent] All SIGUSR1 signals sent. Waiting for remaining children to terminate...\\n\");\n    // המטפל SIGCHLD מקטין את children_remaining. ההורה יכול פשוט להמתין שהמונה יגיע ל-0.\n    while (children_remaining > 0) {\n        pause(); // המתן לכל אות, כולל SIGCHLD\n    }\n\n    printf(\"[Parent] All children have terminated. Exiting.\\n\");\n\n    return 0;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}