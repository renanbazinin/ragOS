{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-08 07:18:30",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4164,
      "output_tokens": 1443,
      "total_tokens": 8050
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "System Calls",
      "Process Management"
    ],
    "content": {
      "text": "שיחת המערכת `fork()` היא אחת משיחות המערכת הבסיסיות והחשובות ביותר במערכות הפעלה דמויות יוניקס. ענה על השאלות הבאות:",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מהי מטרתה העיקרית של שיחת המערכת `fork()`?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "מהו ערך ההחזרה של `fork()` בתהליך האב ובתהליך הבן?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "כתוב תוכנית C קצרה המדגימה את השימוש ב-`fork()` והסבר מה יהיה הפלט שלה.",
        "code_snippet": "#include <stdio.h>\n#include <unistd.h> // For fork(), getpid(), getppid()\n\nint main() {\n    pid_t pid;\n\n    printf(\"תהליך ראשי לפני fork(). PID: %d\\n\", getpid());\n\n    pid = fork();\n\n    if (pid < 0) {\n        // Error\n        fprintf(stderr, \"Fork נכשל!\\n\");\n        return 1;\n    } else if (pid == 0) {\n        // Child process\n        printf(\"אני התהליך הבן. PID שלי: %d, PID של האב שלי: %d\\n\", getpid(), getppid());\n    } else {\n        // Parent process\n        printf(\"אני התהליך האב. PID שלי: %d, PID של הבן שלי: %d\\n\", getpid(), pid);\n    }\n\n    printf(\"שני התהליכים ממשיכים כאן. PID: %d\\n\", getpid());\n\n    return 0;\n}",
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1. מטרתה העיקרית של שיחת המערכת `fork()` היא ליצור תהליך חדש (תהליך בן) שהוא עותק כמעט זהה של התהליך הקורא (תהליך אב). התהליך הבן מקבל עותק של מרחב הכתובות של האב (לרוב בשיטת Copy-on-Write), בין היתר. לאחר הקריאה ל-`fork()`, קיימים שני תהליכים נפרדים המבצעים את הקוד מאותה נקודה.\n\n1.2. ערך ההחזרה של `fork()`:\n*   **בתהליך האב:** `fork()` מחזירה את ה-PID (מזהה התהליך) של התהליך הבן שנוצר.\n*   **בתהליך הבן:** `fork()` מחזירה 0.\n*   **במקרה של כשל:** `fork()` מחזירה 1- (או כל ערך שלילי אחר) בתהליך האב, ולא נוצר תהליך בן.\n\n1.3. הפלט של התוכנית יהיה כדלקמן (סדר השורות הספציפי בין תהליכים עשוי להשתנות, אך שורות בתוך אותו תהליך ישמרו על סדרן):\n\n```\nתהליך ראשי לפני fork(). PID: [PID של התהליך המקורי]\n```\nלאחר מכן, ייווצרו שני תהליכים. כל אחד מהם ידפיס את ההודעות המתאימות לו:\n```\nאני התהליך האב. PID שלי: [PID של התהליך המקורי], PID של הבן שלי: [PID של התהליך הבן]\nאני התהליך הבן. PID שלי: [PID של התהליך הבן], PID של האב שלי: [PID של התהליך המקורי]\n```\nולאחר מכן, שניהם ימשיכו לביצוע השורה האחרונה:\n```\nשני התהליכים ממשיכים כאן. PID: [PID של התהליך האב]\nשני התהליכים ממשיכים כאן. PID: [PID של התהליך הבן]\n```\n\nההסבר:\nהתוכנית מתחילה כתהליך יחיד. היא מדפיסה הודעה ראשונה המציגה את ה-PID שלה.\nכאשר `fork()` נקראת, נוצר תהליך בן. כעת יש שני תהליכים שרצים במקביל, שניהם ממשיכים את ביצוע הקוד מהשורה שלאחר קריאת ה-`fork()`.\nהתהליך האב מקבל את ה-PID של הבן (ערך חיובי) ולכן נכנס לבלוק ה-`else`.\nהתהליך הבן מקבל 0 ולכן נכנס לבלוק ה-`else if (pid == 0)`.\nשני התהליכים מדפיסים את ההודעה הרלוונטית לזהותם (האב מציג את ה-PID שלו ואת ה-PID של הבן שנוצר, והבן מציג את ה-PID שלו ואת ה-PID של האב שלו).\nלאחר מכן, שניהם ממשיכים לבצע את הקוד שאחרי בלוק ה-`if/else`, ומדפיסים את ההודעה האחרונה. סדר ההדפסה של שורות אלו בין התהליכים אינו מובטח, והוא תלוי בתזמון מערכת ההפעלה."
    },
    "difficulty_estimation": "Easy"
  }
}