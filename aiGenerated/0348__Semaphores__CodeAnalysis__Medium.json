{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:59:28",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2864,
      "output_tokens": 1646,
      "total_tokens": 8867
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Semaphores",
      "Concurrency",
      "Threads"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בסמפור סופר (counting semaphore) כדי לווסת גישה למקטע קריטי (critical section) בין מספר תהליכונים (threads). עיין בקוד והשב על השאלות הבאות:\n\n1. מהו המספר המקסימלי של תהליכונים שיכולים להימצא במקטע הקריטי בו-זמנית, וכיצד נקבע מספר זה בקוד?\n2. תארו את רצף האירועים הצפוי בריצת התוכנית, ובפרט את סדר ההדפסות של כניסה ויציאה מהמקטע הקריטי, בהנחה שהמתזמן (scheduler) מעדיף תהליכונים בעלי ID נמוך יותר כאשר מספר תהליכונים מוכנים לריצה. הסבירו מדוע ייתכן שסדר היציאה לא יהיה זהה לסדר הכניסה.\n3. מה יקרה אם נשנה את ערך האתחול של הסמפור `MAX_CONCURRENT_ACCESS` ל-0? תארו את השפעת השינוי על התנהגות התוכנית.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep\n\n#define NUM_THREADS 10\n#define MAX_CONCURRENT_ACCESS 3 // K\n\nsem_t resource_sem;\n\nvoid *worker_thread(void *arg) {\n    long thread_id = (long)arg;\n\n    printf(\"Thread %ld: Waiting to enter critical section...\\n\", thread_id);\n    sem_wait(&resource_sem); // Acquire access\n\n    printf(\"Thread %ld: !!! Entering critical section !!!\\n\", thread_id);\n    sleep(1); // Simulate work in critical section\n    printf(\"Thread %ld: Exiting critical section.\\n\", thread_id);\n\n    sem_post(&resource_sem); // Release access\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    int i;\n\n    // Initialize the semaphore to allow MAX_CONCURRENT_ACCESS threads\n    if (sem_init(&resource_sem, 0, MAX_CONCURRENT_ACCESS) != 0) {\n        perror(\"sem_init failed\");\n        return 1;\n    }\n\n    for (i = 0; i < NUM_THREADS; i++) {\n        if (pthread_create(&threads[i], NULL, worker_thread, (void *)(long)i) != 0) {\n            perror(\"pthread_create failed\");\n            return 1;\n        }\n    }\n\n    for (i = 0; i < NUM_THREADS; i++) {\n        pthread_join(threads[i], NULL);\n    }\n\n    sem_destroy(&resource_sem); // Clean up semaphore\n    printf(\"All threads finished. Main exiting.\\n\");\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1. המספר המקסימלי של תהליכונים שיכולים להימצא במקטע הקריטי בו-זמנית הוא 3. מספר זה נקבע על ידי הקבוע `MAX_CONCURRENT_ACCESS` אשר משמש כערך האתחול של הסמפור `resource_sem` בשורה `sem_init(&resource_sem, 0, MAX_CONCURRENT_ACCESS);`. סמפור סופר מאפשר למספר `MAX_CONCURRENT_ACCESS` של תהליכונים לבצע פעולת `sem_wait` בהצלחה לפני שהוא יחסום תהליכונים נוספים.\n\n2. בהנחה שהמתזמן מעדיף תהליכונים בעלי ID נמוך יותר, סדר הכניסה למקטע הקריטי יהיה בדרך כלל: Thread 0, Thread 1, Thread 2. לאחר מכן, תהליכונים אלו יתחילו לבצע את ה-\"עבודה\" שלהם (שינה למשך שנייה). בזמן זה, Thread 3 ימתין בתור לכניסה. כאשר אחד מהתהליכונים הראשונים (לדוגמה Thread 0) יסיים את עבודתו ויבצע `sem_post`, הוא ישחרר מקום במקטע הקריטי, ו-Thread 3 (או הבא בתור בעל ה-ID הנמוך ביותר) ייכנס. כתוצאה מכך, סדר הכניסה הצפוי למקטע הקריטי יהיה 0, 1, 2, ואז 3, 4, 5 וכן הלאה, בקבוצות של 3. סדר היציאה מהמקטע הקריטי אינו בהכרח זהה לסדר הכניסה. הסיבה לכך היא שכל תהליכון מבצע `sleep(1)` בתוך המקטע הקריטי, אך אין ערובה שכל התהליכונים יתחילו את ה-sleep באותו המיקרו-שנייה או שיסיימו אותו באותו סדר. יתכן ש-Thread 0 יסיים את ה-sleep ויצא לפני Thread 1 או Thread 2, גם אם הוא נכנס ראשון. לכן, סדר ההדפסות של 'Exiting critical section' יכול להיות שונה מסדר ה-'Entering critical section'.\n\n3. אם נשנה את ערך האתחול של הסמפור `MAX_CONCURRENT_ACCESS` ל-0, התוכנית תתנהג באופן שונה מהותית. כאשר הסמפור מאותחל ל-0, כל קריאה ראשונה ל-`sem_wait(&resource_sem)` תחסום את התהליכון הקורא, מכיוון שאין היתרים זמינים (הערך של הסמפור הוא 0). כתוצאה מכך, אף תהליכון לא יוכל להיכנס למקטע הקריטי. כל עשרת התהליכונים יבצעו `sem_wait` ויחסמו מיד, והם ימתינו באופן אינסופי (deadlock) מכיוון שאף אחד מהם לא יגיע ל-`sem_post` כדי לשחרר היתר ולאפשר לתהליכונים אחרים להמשיך. התוכנית תיתקע ולא תדפיס אף הודעת כניסה או יציאה מהמקטע הקריטי, למעט הודעות ההתחלה של התהליכונים."
    },
    "difficulty_estimation": "Medium"
  }
}