{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:48:15",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3433,
      "output_tokens": 3320,
      "total_tokens": 10953
    }
  },
  "question": {
    "id": 11,
    "type": "Open",
    "topic": [
      "Producer-Consumer",
      "Synchronization",
      "Semaphores",
      "Concurrency",
      "Pipeline"
    ],
    "content": {
      "text": "במערכת עיבוד נתונים מורכבת, ישנו צינור עיבוד (pipeline) המורכב משלושה שלבים:\n1.  **שלב יצרן הנתונים (Data Producer)**: מייצר נתונים גולמיים ומכניס אותם לחוצץ הראשון.\n2.  **שלב מעבד ביניים (Intermediate Processor)**: מוציא נתונים גולמיים מהחוצץ הראשון, מעבד אותם, ומכניס את הנתונים המעובדים (שלב א') לחוצץ השני.\n3.  **שלב צרכן סופי (Final Consumer)**: מוציא נתונים מעובדים (שלב א') מהחוצץ השני ומסיים את הטיפול בהם.\n\nהמערכת ממומשת באמצעות חוטים (threads), כאשר ייתכנו מספר חוטים מכל סוג. קיימים שני חוצצים מעגליים בגודל קבוע (BUFFER_SIZE) לכל אחד: `buffer1` בין היצרן למעבד הביניים, ו-`buffer2` בין מעבד הביניים לצרכן הסופי. יש להניח כי פעולות הכנסה והוצאה לחוצצים (למשל, `enqueue_buffer1`, `dequeue_buffer1` וכו') בטוחות לשימוש במקביל (thread-safe) ואינן דורשות סנכרון נוסף **מעבר לניהול הקיבולת והנגישות של החוצצים עצמם**. כלומר, אתם נדרשים לדאוג רק למתי מותר לקרוא לפונקציות אלו, ולא למימוש הפנימי שלהן.\n\nיש לממש את הפונקציות הראשיות של החוטים (`producer_thread`, `intermediate_processor_thread`, `consumer_thread`) ואת משתני הסנכרון הגלובליים הנדרשים (סמפורים בלבד) כדי להבטיח:\n*   אין גלישה או חמיקה מהחוצצים (buffer overflow/underflow).\n*   אין תנאי מירוץ (race conditions) בגישה לחוצצים.\n*   התהליך פועל ללא קיפאון (deadlock).\n\nהשתמשו בסמפורים בלבד (לא ניתן להשתמש בפעולות מעבד אטומיות או באובייקטי סנכרון אחרים מלבד סמפורים). הניחו שהסמפורים הוגנים. יש לתאר בקצרה ובבירור את הפתרון ולכתוב קוד ברור.\n\nתיאור הפתרון:\nמשתנים גלובליים (יש לכתוב ערכי אתחול בהערה):",
      "code_snippet": "sem_t empty1;   // init to BUFFER_SIZE\nsem_t full1;    // init to 0\nsem_t mutex1;   // init to 1\n\nsem_t empty2;   // init to BUFFER_SIZE\nsem_t full2;    // init to 0\nsem_t mutex2;   // init to 1\n\nvoid* producer_thread(void* arg) {\n}\n\nvoid* intermediate_processor_thread(void* arg) {\n}\n\nvoid* consumer_thread(void* arg) {\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הפתרון משתמש בשני סטים של סמפורים, אחד לכל חוצץ (buffer1 ו-buffer2), על מנת לנהל את הגישה והקיבולת של כל חוצץ בנפרד. לכל חוצץ ישנם שלושה סמפורים:\n1.  `emptyX`: סמפור המציין את מספר המקומות הפנויים בחוצץ X. מאותחל ל-BUFFER_SIZE.\n2.  `fullX`: סמפור המציין את מספר המקומות המלאים בחוצץ X. מאותחל ל-0.\n3.  `mutexX`: סמפור בינארי (mutex) המבטיח גישה הדדית בלעדית (mutual exclusion) לחוצץ X. מאותחל ל-1.\n\n**עבור `producer_thread` (יצרן):**\nהיצרן ממתין למקום פנוי ב-`buffer1` על ידי קריאה ל-`sem_wait(&empty1)`. לאחר מכן, הוא רוכש נעילה על `buffer1` באמצעות `sem_wait(&mutex1)` כדי למנוע גישת חוטים אחרים (כמו מעבדי ביניים אחרים אם היו, או יצרנים אחרים) לחוצץ בזמן ההכנסה. לאחר הכנסת הפריט, הוא משחרר את הנעילה עם `sem_post(&mutex1)` ומסמן שיש פריט מלא חדש בחוצץ על ידי קריאה ל-`sem_post(&full1)`.\n\n**עבור `intermediate_processor_thread` (מעבד ביניים):**\nחוט זה מתפקד גם כצרכן וגם כיצרן. כצרכן של `buffer1`, הוא ממתין לפריט מלא ב-`buffer1` על ידי `sem_wait(&full1)`, רוכש נעילה על `buffer1` עם `sem_wait(&mutex1)`, מוציא את הפריט, משחרר את הנעילה עם `sem_post(&mutex1)` ומסמן מקום פנוי חדש ב-`buffer1` עם `sem_post(&empty1)`.\nלאחר עיבוד הפריט, הוא מתפקד כיצרן עבור `buffer2`. הוא ממתין למקום פנוי ב-`buffer2` על ידי `sem_wait(&empty2)`, רוכש נעילה על `buffer2` עם `sem_wait(&mutex2)`, מכניס את הפריט המעובד, משחרר את הנעילה עם `sem_post(&mutex2)` ומסמן פריט מלא חדש ב-`buffer2` עם `sem_post(&full2)`.\n\n**עבור `consumer_thread` (צרכן סופי):**\nהצרכן ממתין לפריט מלא ב-`buffer2` על ידי `sem_wait(&full2)`. לאחר מכן, הוא רוכש נעילה על `buffer2` באמצעות `sem_wait(&mutex2)`, מוציא את הפריט, משחרר את הנעילה עם `sem_post(&mutex2)` ומסמן מקום פנוי חדש ב-`buffer2` על ידי קריאה ל-`sem_post(&empty2)`.\n\nהשימוש ב-`mutex` נפרד לכל חוצץ מאפשר מקביליות גבוהה יותר, מכיוון שחוטים יכולים לגשת לחוצצים שונים בו-זמנית (לדוגמה, יצרן מכניס ל-`buffer1` וצרכן מוציא מ-`buffer2` בו-זמנית). הסדר של `sem_wait(&emptyX)` / `sem_wait(&fullX)` לפני `sem_wait(&mutexX)` חיוני למניעת קיפאון (deadlock), ומבטיח שהחוט לא ינסה לנעול משאב תפוס בזמן שהוא כבר מחזיק במשאב אחר וממתין למשאב שלישי.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For usleep\n\n#define BUFFER_SIZE 5 // Example buffer size\n\n// Assume these are defined elsewhere for simplicity,\n// and are thread-safe for their internal operations,\n// but external synchronization is needed for buffer capacity.\ntypedef int data_item_t;\n\ndata_item_t buffer1[BUFFER_SIZE];\nint in1 = 0, out1 = 0;\n\ndata_item_t buffer2[BUFFER_SIZE];\nint in2 = 0, out2 = 0;\n\n// Helper functions for buffer operations (assume thread-safe internally)\n// In a real scenario, these would likely be part of a thread-safe data structure\nvoid enqueue_buffer1(data_item_t item) {\n    buffer1[in1] = item;\n    in1 = (in1 + 1) % BUFFER_SIZE;\n}\n\ndata_item_t dequeue_buffer1() {\n    data_item_t item = buffer1[out1];\n    out1 = (out1 + 1) % BUFFER_SIZE;\n    return item;\n}\n\nvoid enqueue_buffer2(data_item_t item) {\n    buffer2[in2] = item;\n    in2 = (in2 + 1) % BUFFER_SIZE;\n}\n\ndata_item_t dequeue_buffer2() {\n    data_item_t item = buffer2[out2];\n    out2 = (out2 + 1) % BUFFER_SIZE;\n    return item;\n}\n\n// Global Semaphores (declaration and initialization for a complete runnable example)\nsem_t empty1;   // init to BUFFER_SIZE\nsem_t full1;    // init to 0\nsem_t mutex1;   // init to 1\n\nsem_t empty2;   // init to BUFFER_SIZE\nsem_t full2;    // init to 0\nsem_t mutex2;   // init to 1\n\nvoid* producer_thread(void* arg) {\n    int produced_count = 0;\n    while (1) {\n        data_item_t item = produced_count++; // Simulate producing data\n\n        sem_wait(&empty1);  // Wait for an empty slot in buffer1\n        sem_wait(&mutex1);  // Lock buffer1 for access\n\n        enqueue_buffer1(item);\n        printf(\"Producer produced: %d\\n\", item);\n\n        sem_post(&mutex1);  // Unlock buffer1\n        sem_post(&full1);   // Signal that buffer1 has a full slot\n        usleep(100000); // Simulate work\n    }\n    return NULL;\n}\n\nvoid* intermediate_processor_thread(void* arg) {\n    while (1) {\n        // Consume from buffer1\n        sem_wait(&full1);   // Wait for a full slot in buffer1\n        sem_wait(&mutex1);  // Lock buffer1 for access\n\n        data_item_t raw_item = dequeue_buffer1();\n        printf(\"Intermediate Processor consumed raw: %d\\n\", raw_item);\n\n        sem_post(&mutex1);  // Unlock buffer1\n        sem_post(&empty1);  // Signal that buffer1 has an empty slot\n\n        // Process item (simulate some work)\n        data_item_t processed_item = raw_item * 2; // Simple processing\n        usleep(150000); // Simulate processing time\n\n        // Produce to buffer2\n        sem_wait(&empty2);  // Wait for an empty slot in buffer2\n        sem_wait(&mutex2);  // Lock buffer2 for access\n\n        enqueue_buffer2(processed_item);\n        printf(\"Intermediate Processor produced processed: %d\\n\", processed_item);\n\n        sem_post(&mutex2);  // Unlock buffer2\n        sem_post(&full2);   // Signal that buffer2 has a full slot\n        usleep(100000); // Simulate work\n    }\n    return NULL;\n}\n\nvoid* consumer_thread(void* arg) {\n    while (1) {\n        sem_wait(&full2);   // Wait for a full slot in buffer2\n        sem_wait(&mutex2);  // Lock buffer2 for access\n\n        data_item_t final_item = dequeue_buffer2();\n        printf(\"Consumer consumed final: %d\\n\", final_item);\n\n        sem_post(&mutex2);  // Unlock buffer2\n        sem_post(&empty2);  // Signal that buffer2 has an empty slot\n        usleep(200000); // Simulate work\n    }\n    return NULL;\n}\n\n// Main function to demonstrate (not part of the required solution for the exam question)\nint main() {\n    // Initialize semaphores\n    sem_init(&empty1, 0, BUFFER_SIZE);\n    sem_init(&full1, 0, 0);\n    sem_init(&mutex1, 0, 1);\n\n    sem_init(&empty2, 0, BUFFER_SIZE);\n    sem_init(&full2, 0, 0);\n    sem_init(&mutex2, 0, 1);\n\n    pthread_t p_tid, ip_tid, c_tid;\n\n    pthread_create(&p_tid, NULL, producer_thread, NULL);\n    pthread_create(&ip_tid, NULL, intermediate_processor_thread, NULL);\n    pthread_create(&c_tid, NULL, consumer_thread, NULL);\n\n    pthread_join(p_tid, NULL);\n    pthread_join(ip_tid, NULL);\n    pthread_join(c_tid, NULL);\n\n    // Destroy semaphores\n    sem_destroy(&empty1);\n    sem_destroy(&full1);\n    sem_destroy(&mutex1);\n    sem_destroy(&empty2);\n    sem_destroy(&full2);\n    sem_destroy(&mutex2);\n\n    return 0;\n}\n```"
    },
    "difficulty_estimation": "Hard"
  }
}