{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:24:33",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3498,
      "output_tokens": 2974,
      "total_tokens": 13306
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "System Calls",
      "Process Management",
      "File I/O",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה תוכנית C המבצעת פעולות יצירת תהליכים (fork) וביצוע תוכנית חדשה (execve) תוך שימוש במערכת קבצים. התוכנית פותחת קובץ, יוצרת תהליך בן, ולאחר מכן:\n- תהליך הבן מפנה את הפלט הסטנדרטי שלו לקובץ שנפתח על ידי האב, ואז מריץ תוכנית חיצונית (echo).\n- תהליך האב כותב הודעה ישירות לאותו קובץ.\n\nעיין בקטע הקוד המצורף וענה על השאלות הבאות:",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/wait.h>\n\nint main() {\n    int fd;\n    pid_t pid;\n    char *args[] = {\"/bin/echo\", \"Hello from child!\\n\", NULL};\n\n    // Open a file for writing, create if not exists, truncate if exists\n    fd = open(\"output.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (fd == -1) {\n        perror(\"open failed\");\n        return 1;\n    }\n\n    printf(\"Parent: File opened with fd = %d\\n\", fd);\n\n    pid = fork();\n\n    if (pid == -1) {\n        perror(\"fork failed\");\n        close(fd);\n        return 1;\n    }\n\n    if (pid == 0) { // Child process\n        printf(\"Child: PID = %d, Parent PID = %d\\n\", getpid(), getppid());\n        // Redirect stdout to the opened file\n        if (dup2(fd, STDOUT_FILENO) == -1) {\n            perror(\"dup2 failed in child\");\n            close(fd);\n            exit(1);\n        }\n        close(fd); // Close the original fd, stdout now points to the file\n\n        // Execute a new program\n        execve(args[0], args, NULL);\n        perror(\"execve failed\"); // Should not reach here if execve succeeds\n        exit(1);\n    } else { // Parent process\n        printf(\"Parent: PID = %d, Child PID = %d\\n\", getpid(), pid);\n        // Write directly to the file using the original file descriptor\n        char *parent_msg = \"Hello from parent!\\n\";\n        if (write(fd, parent_msg, strlen(parent_msg)) == -1) {\n            perror(\"parent write failed\");\n        }\n        close(fd); // Parent closes its copy of the file descriptor\n\n        wait(NULL); // Wait for child to terminate\n        printf(\"Parent: Child finished.\\n\");\n    }\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "7.1",
        "text": "לאחר הרצת הקוד, מהו התוכן הסופי של הקובץ `output.txt`? הסבר מדוע ייתכן שהתוצאה אינה דטרמיניסטית וכיצד פעולות ה-I/O של האב והבן משפיעות זו על זו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.2",
        "text": "תהליך הבן משתמש ב-`dup2` כדי להפנות את `STDOUT_FILENO` לקובץ. כיצד פעולה זו משפיעה על טבלת מנהלי הקבצים (file descriptor table) של הבן, וכיצד היא קשורה לעובדה ש-`execve` משמר מנהלי קבצים פתוחים?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "7.3",
        "text": "זהה לפחות שתי בעיות פוטנציאליות (לרבות תנאי מירוץ) העלולות להתעורר עקב גישה מקבילה של האב והבן לאותו קובץ, והצע פתרון קונקרטי לכל אחת מהן תוך ציון שם קריאת המערכת (system call) או מנגנון הסנכרון הרלוונטי.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "7.1: התוכן הסופי של הקובץ `output.txt` יכיל את שתי ההודעות:\n\"Hello from parent!\\n\"\n\"Hello from child!\\n\"\nאך סדר הופעתן בקובץ אינו דטרמיניסטי. הסיבה לכך היא שלאחר קריאת המערכת `fork()`, הן תהליך האב והן תהליך הבן מקבלים עותק של מזהה הקובץ (file descriptor) `fd`. שני העותקים מצביעים על אותו תיאור קובץ פתוח (open file description) בקרנל. משמעות הדבר היא שהם חולקים את אותו מצביע קובץ (file offset).\nתהליך האב קורא ל-`write()` עם ה-`fd` המקורי. תהליך הבן, לאחר ביצוע `dup2(fd, STDOUT_FILENO)`, מפנה את פלטו הסטנדרטי (fd 1) לאותו תיאור קובץ. לאחר מכן, `execve()` מחליף את תמונת התהליך של הבן בתוכנית `/bin/echo`, אך משמר את מנהלי הקבצים הפתוחים, כולל `STDOUT_FILENO` המופנה לקובץ. לכן, `echo` יכתוב את \"Hello from child!\\n\" לקובץ.\nמכיוון שגם האב וגם הבן כותבים לאותו תיאור קובץ משותף, פעולות הכתיבה שלהם מתחרות על המצביע הקובץ. סדר הביצוע נקבע על ידי המתזמן של מערכת ההפעלה, ולכן סדר ההודעות בקובץ אינו ודאי. במקרים מסוימים, ייתכן אף שחלקים מהודעות יתערבבו (interleave), אם כי עבור כתיבת שורות שלמות באמצעות `write` ו-`echo` זה פחות שכיח בשל אטומיות יחסית של כתיבות קטנות.\n\n7.2: פעולת `dup2(fd, STDOUT_FILENO)` משפיעה על טבלת מנהלי הקבצים של תהליך הבן באופן הבא:\n1.  אם `STDOUT_FILENO` (מזהה קובץ 1) היה פתוח קודם לכן, הוא נסגר.\n2.  לאחר מכן, `STDOUT_FILENO` מועתק כך שיצביע על אותו תיאור קובץ פתוח בקרנל שאליו מצביע ה-`fd` המקורי. כלומר, כעת גם `fd` וגם `STDOUT_FILENO` בטבלת מנהלי הקבצים של הבן מצביעים על אותו קובץ `output.txt` ואותו מצביע קובץ משותף בקרנל.\nלאחר `dup2`, תהליך הבן סוגר את `fd` המקורי (`close(fd)`) כדי למנוע מצב שבו שני מזהי קבצים מצביעים על אותו תיאור קובץ בתוך תהליך בודד, מה שעלול להיות מקור לשגיאות או בלבול.\nקריאת המערכת `execve()` מחליפה את תמונת הזיכרון של התהליך הנוכחי בתמונה של תוכנית חדשה, אך היא *משמרת* את כל מנהלי הקבצים הפתוחים כפי שהם. לכן, לאחר `execve(\"/bin/echo\", ...)`, תוכנית ה-`echo` החדשה תירש את טבלת מנהלי הקבצים של הבן, ו-`STDOUT_FILENO` (מזהה קובץ 1) ימשיך להצביע על הקובץ `output.txt`. כך, הפלט של `echo` (שהוא \"Hello from child!\\n\") נכתב ישירות לקובץ זה.\n\n7.3: להלן שתי בעיות פוטנציאליות ופתרונותיהן:\n1.  **בעיה: סדר כתיבה לא דטרמיניסטי ותנאי מירוץ (Race Condition on Write Order)**\n    *   **הסבר**: כפי שהוסבר בסעיף 7.1, מכיוון שהאב והבן חולקים את אותו תיאור קובץ וכותבים באופן עצמאי, סדר ההודעות בקובץ אינו מובטח. זה יכול להוביל לקובץ פלט לא צפוי או שגוי מבחינת הסדר הלוגי של המידע.\n    *   **פתרון**: שימוש במנגנוני נעילת קבצים (file locking) כדי להבטיח גישה בלעדית לקובץ בזמן כתיבה.\n        *   **קריאת מערכת / מנגנון**: `flock()` או `fcntl()`.\n        *   **יישום**: לפני כל פעולת כתיבה, התהליך (האב או הבן) ירכוש נעילה בלעדית (exclusive lock) על הקובץ באמצעות `flock(fd, LOCK_EX)`. אם הקובץ כבר נעול, התהליך ימתין עד שהנעילה תשתחרר. לאחר סיום הכתיבה, התהליך ישחרר את הנעילה באמצעות `flock(fd, LOCK_UN)`. זה יבטיח שרק תהליך אחד כותב לקובץ בכל רגע נתון, ויקבע סדר כתיבה סדרתי (אם כי לא בהכרח את הסדר שבו התוכנית קראה ל-`write` או `echo` לראשונה).\n\n2.  **בעיה: שיבוש נתונים (Data Corruption) או כתיבת יתר (Overwriting) במקרה של כתיבות לא אטומיות או שימוש ב-`lseek` (שאינו קיים בדוגמה אך רלוונטי).**\n    *   **הסבר**: אף על פי שפעולות `write` קטנות הן לרוב אטומיות, פעולות כתיבה גדולות יותר או שימוש ב-`lseek()` (כדי לשנות את המצביע הקובץ) עלולות להוביל לשיבוש נתונים. אם תהליך אחד מתחיל לכתוב, מועבר מהמעבד לפני שסיים, ותהליך אחר כותב, ואז הראשון ממשיך, עלולים להתערבב ביטים או שהנתונים ייכתבו אחד על גבי השני. במקרה של קוד זה, אם `echo` היה כותב פלט גדול יותר, ייתכן שהפלט של האב היה נכתב באמצע פלט הבן.\n    *   **פתרון**: הגדרת תהליך אחד ככותב בלעדי לקובץ באמצעות מנגנוני תקשורת בין תהליכים (IPC).\n        *   **קריאת מערכת / מנגנון**: `pipe()` (צינור), `message queues` (תורי הודעות).\n        *   **יישום**: האב יכול ליצור צינור (pipe) לפני ה-`fork()`. הבן יכתוב את הפלט שלו לקצה הכתיבה של הצינור, והאב יקרא מקצה הקריאה של הצינור. לאחר מכן, האב יכתוב את ההודעה של עצמו ושל הבן (שקרא מהצינור) לקובץ `output.txt` בסדר מבוקר. זה מבטיח שהאב הוא הכותב היחיד לקובץ, ומאפשר לו לשלוט באופן מלא על סדר ושלמות הנתונים בקובץ."
    },
    "difficulty_estimation": "Hard"
  }
}