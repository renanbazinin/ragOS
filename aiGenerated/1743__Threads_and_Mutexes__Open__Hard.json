{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-09 21:00:20",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4527,
      "output_tokens": 2983,
      "total_tokens": 19028
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Threads",
      "Mutexes",
      "Deadlock",
      "Synchronization"
    ],
    "content": {
      "text": "נתונה תוכנית C++ המדמה מערכת יצרן-צרכן פשוטה. מספר תהליכי יצרן (Producer) מוסיפים ערכים למאגר משותף (`std::vector<int>`) ומעדכנים סכום כולל (`long long`). מספר תהליכי צרכן (Consumer) מסירים ערכים מהמאגר ומעדכנים את הסכום הכולל. המטרה היא שהמשתנה `total_sum` תמיד ישקף את סכום כל הערכים הנמצאים במאגר `shared_buffer`. לצורך סנכרון, קיימים שני מנעולים (mutexes): `buffer_mutex` להגנה על המאגר ו-`sum_mutex` להגנה על המשתנה `total_sum`.\n\nלמרות השימוש במנעולים, התוכנית סובלת מבעיות סנכרון חמורות. נתח את הקוד הבא:\n```cpp\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <numeric>\n#include <random>\n#include <chrono>\n\nconst int NUM_PRODUCERS = 2;\nconst int NUM_CONSUMERS = 2;\nconst int ITERATIONS_PER_THREAD = 5;\n\nstd::vector<int> shared_buffer;\nlong long total_sum = 0;\n\nstd::mutex buffer_mutex;\nstd::mutex sum_mutex;\n\nvoid producer_thread(int id) {\n    std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count() + id);\n    std::uniform_int_distribution<> distrib(1, 100);\n\n    for (int i = 0; i < ITERATIONS_PER_THREAD; ++i) {\n        int value = distrib(gen);\n\n        sum_mutex.lock();\n        buffer_mutex.lock();\n\n        shared_buffer.push_back(value);\n        total_sum += value;\n        std::cout << \"Producer \" << id << \" added \" << value << \". Sum: \" << total_sum << \". Buffer size: \" << shared_buffer.size() << std::endl;\n\n        buffer_mutex.unlock();\n        sum_mutex.unlock();\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n\nvoid consumer_thread(int id) {\n    for (int i = 0; i < ITERATIONS_PER_THREAD; ++i) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(15));\n\n        int value = 0;\n        bool item_removed = false;\n\n        buffer_mutex.lock();\n        sum_mutex.lock();\n\n        if (!shared_buffer.empty()) {\n            value = shared_buffer.back();\n            shared_buffer.pop_back();\n            total_sum -= value;\n            item_removed = true;\n            std::cout << \"Consumer \" << id << \" removed \" << value << \". Sum: \" << total_sum << \". Buffer size: \" << shared_buffer.size() << std::endl;\n        } else {\n            std::cout << \"Consumer \" << id << \" found buffer empty, waiting...\" << std::endl;\n        }\n\n        sum_mutex.unlock();\n        buffer_mutex.unlock();\n    }\n}\n\nint main() {\n    std::vector<std::thread> producers;\n    std::vector<std::thread> consumers;\n\n    for (int i = 0; i < NUM_PRODUCERS; ++i) {\n        producers.emplace_back(producer_thread, i);\n    }\n    for (int i = 0; i < NUM_CONSUMERS; ++i) {\n        consumers.emplace_back(consumer_thread, i);\n    }\n\n    for (auto& t : producers) {\n        t.join();\n    }\n    for (auto& t : consumers) {\n        t.join();\n    }\n\n    long long final_buffer_sum = 0;\n    buffer_mutex.lock();\n    for (int val : shared_buffer) {\n        final_buffer_sum += val;\n    }\n    buffer_mutex.unlock();\n\n    std::cout << \"\\n--- Final State ---\" << std::endl;\n    std::cout << \"Final total_sum variable: \" << total_sum << std::endl;\n    std::cout << \"Sum of elements in buffer: \" << final_buffer_sum << std::endl;\n    std::cout << \"Buffer size: \" << shared_buffer.size() << std::endl;\n\n    if (total_sum == final_buffer_sum) {\n        std::cout << \"Consistency check PASSED.\" << std::endl;\n    } else {\n        std::cout << \"Consistency check FAILED! total_sum (\" << total_sum << \") != buffer_sum (\" << final_buffer_sum << \")\" << std::endl;\n    }\n\n    return 0;\n}\n```\nא. זהה והסבר את בעיית הסנכרון העיקרית אליה התוכנית עלולה להיקלע.\nב. הצע פתרון לבעיה שזיהית בסעיף א'. הצג את קטע הקוד המתוקן עבור שתי הפונקציות `producer_thread` ו-`consumer_thread`.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. **זיהוי והסבר הבעיה:**\nהבעיה העיקרית אליה התוכנית עלולה להיקלע היא **קיפאון (Deadlock)**. קיפאון מתרחש כאשר שני תהליכים או יותר מחזיקים במשאבים מסוימים וממתינים למשאבים אחרים המוחזקים על ידי תהליכים אחרים, ונוצר מעגל המתנה הדדי.\nבתוכנית הנתונה, תהליכי היצרן והצרכן רוכשים את המנעולים `sum_mutex` ו-`buffer_mutex` בסדר שונה:\n*   **תהליך יצרן (Producer)**: רוכש קודם את `sum_mutex` ולאחר מכן את `buffer_mutex`.\n*   **תהליך צרכן (Consumer)**: רוכש קודם את `buffer_mutex` ולאחר מכן את `sum_mutex`.\nתרחיש קיפאון אפשרי:\n1.  תהליך יצרן (לדוגמה, Producer 0) מצליח לרכוש את `sum_mutex`.\n2.  במקביל, תהליך צרכן (לדוגמה, Consumer 0) מצליח לרכוש את `buffer_mutex`.\n3.  כעת, Producer 0 מנסה לרכוש את `buffer_mutex` אך הוא מוחזק על ידי Consumer 0, ולכן הוא נכנס למצב המתנה.\n4.  ובמקביל, Consumer 0 מנסה לרכוש את `sum_mutex` אך הוא מוחזק על ידי Producer 0, ולכן הוא נכנס גם הוא למצב המתנה.\nשני התהליכים ממתינים זה לזה באופן בלתי הפיך, והתוכנית תיתקע בקיפאון ולא תתקדם.\nבנוסף, גם ללא קיפאון, סדר הנעילה השונה עלול לגרום לאי-עקביות זמנית בין `total_sum` לבין סכום ה-`shared_buffer` אם תהליך יקרא את אחד המשתנים כאשר השני כבר נעול אך עדיין לא שונו שניהם. אך הקיפאון הוא הבעיה הקריטית והחמורה יותר כאן.\n\nב. **פתרון וקוד מתוקן:**\nכדי למנוע קיפאון, יש להבטיח שכל התהליכים ירכשו את המנעולים באותו סדר עקבי. נבחר שכל התהליכים ירכשו תמיד קודם את `buffer_mutex` ולאחר מכן את `sum_mutex`.\nכמו כן, מומלץ להשתמש ב-`std::lock_guard` (או `std::unique_lock`) ב-C++ אשר מבטיח שהמנעולים ישוחררו אוטומטית כאשר האובייקט יוצא מהסקופ, ובכך מונע שכחה של שחרור מנעולים במקרה של חריגה או נתיבי יציאה מרובים.\nלהלן קטעי הקוד המתוקנים:\n\n```cpp\n// קוד מתוקן עבור פונקציית היצרן\nvoid producer_thread_fixed(int id) {\n    std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count() + id);\n    std::uniform_int_distribution<> distrib(1, 100);\n\n    for (int i = 0; i < ITERATIONS_PER_THREAD; ++i) {\n        int value = distrib(gen);\n\n        // סדר נעילה עקבי: קודם buffer_mutex, אחר כך sum_mutex\n        std::lock_guard<std::mutex> lock_buffer(buffer_mutex);\n        std::lock_guard<std::mutex> lock_sum(sum_mutex);\n\n        shared_buffer.push_back(value);\n        total_sum += value;\n        std::cout << \"Producer \" << id << \" added \" << value << \". Sum: \" << total_sum << \". Buffer size: \" << shared_buffer.size() << std::endl;\n\n        // המנעולים משוחררים אוטומטית בסיום הבלוק\n        std::this_thread::sleep_for(std::chrono::milliseconds(10)); // הדמיית עבודה\n    }\n}\n\n// קוד מתוקן עבור פונקציית הצרכן\nvoid consumer_thread_fixed(int id) {\n    for (int i = 0; i < ITERATIONS_PER_THREAD; ++i) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(15)); // הדמיית עבודה\n\n        int value = 0;\n        bool item_removed = false;\n\n        // סדר נעילה עקבי: קודם buffer_mutex, אחר כך sum_mutex\n        std::lock_guard<std::mutex> lock_buffer(buffer_mutex);\n        std::lock_guard<std::mutex> lock_sum(sum_mutex);\n\n        if (!shared_buffer.empty()) {\n            value = shared_buffer.back();\n            shared_buffer.pop_back();\n            total_sum -= value;\n            item_removed = true;\n            std::cout << \"Consumer \" << id << \" removed \" << value << \". Sum: \" << total_sum << \". Buffer size: \" << shared_buffer.size() << std::endl;\n        } else {\n            // במערכת יצרן-צרכן אמיתית, כאן היינו משתמשים ב-condition_variable\n            // כדי להמתין לפריטים במקום להדפיס הודעה ולהמשיך.\n            std::cout << \"Consumer \" << id << \" found buffer empty, waiting...\" << std::endl;\n        }\n\n        // המנעולים משוחררים אוטומטית בסיום הבלוק\n    }\n}\n```\nפתרון חלופי (מומלץ ל-C++17 ואילך): ניתן להשתמש ב-`std::scoped_lock` אשר נועד לנעול מספר מנעולים באופן בטוח מפני קיפאון, ללא צורך לדאוג לסדר הנעילה:\n```cpp\n// דוגמה לשימוש ב-std::scoped_lock בתוך הפונקציות:\n// std::scoped_lock locks(buffer_mutex, sum_mutex);\n// (המנעולים ישוחררו אוטומטית בסיום הבלוק)\n```"
    },
    "difficulty_estimation": "Hard"
  }
}