{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 07:19:25",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3372,
      "output_tokens": 1907,
      "total_tokens": 7364
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "System Calls",
      "I/O",
      "Performance"
    ],
    "content": {
      "text": "תוכנית ב-C קוראת קובץ טקסט גדול תו אחר-תו (character by character) ומבצעת עליו עיבוד כלשהו. נתייחס לפעולות הקריאה מהקובץ.\n\nא. הסבר/י כיצד קריאת תו בודד מהקובץ מערבת קריאות מערכת (system calls) ברמת מערכת ההפעלה.\nב. השווה/י בין ביצוע קריאת תו בודד באמצעות פונקציית הספרייה הסטנדרטית `fgetc()` לבין קריאת תו בודד באמצעות קריאת המערכת הישירה `read()`. התייחס/י להבדלים בביצועים ולמקרים בהם עשויה להיות עדיפות לאחת השיטות על פני השנייה.\nג. הצע/י דרך לשיפור ביצועי הקריאה מהקובץ במקרה זה, תוך התחשבות במנגנוני מערכת ההפעלה והספרייה הסטנדרטית.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. קריאת תו בודד מהקובץ מערבת קריאות מערכת בדרכים שונות, תלוי אם משתמשים בפונקציות ספרייה או בקריאות מערכת ישירות:\n   *   **באופן כללי:** כל גישה לדיסק (או למשאב I/O אחר) דורשת מעורבות של מערכת ההפעלה, מכיוון שהיא אחראית על ניהול החומרה, הבטחת אבטחה ושיתוף משאבים. כאשר תהליך משתמש רוצה לקרוא נתונים מקובץ, הוא לא יכול לגשת ישירות לדיסק. במקום זאת, הוא מבצע קריאת מערכת (system call).\n   *   **תהליך קריאת מערכת:** כאשר מבוצעת קריאת מערכת (כמו `read()`), התהליך עובר ממצב משתמש (user mode) למצב ליבה (kernel mode). בליבה, מערכת ההפעלה מאמתת את הבקשה, מנהלת את הגישה לדיסק (למשל, באמצעות מנהל התקן), קוראת את הנתונים מהדיסק (אם הם לא נמצאים ב-cache של מערכת ההפעלה), מעתיקה אותם לחוצץ בזיכרון המשתמש ומחזירה את השליטה לתהליך במצב משתמש. מעבר זה בין מצבי פעולה (user/kernel mode) כרוך בעלות ביצועים.\n\nב. השוואה בין `fgetc()` ל-`read()` לקריאת תו בודד:\n   *   **`fgetc()` (פונקציית ספרייה מבופרת):**\n      *   **מנגנון:** `fgetc()` היא חלק מהספרייה הסטנדרטית של C (stdio.h). היא משתמשת בחוצץ (buffer) פנימי. בפעם הראשונה שקוראים מהקובץ, או כאשר החוצץ מתרוקן, `fgetc()` תבצע קריאת מערכת `read()` אחת גדולה (למשל, לקרוא בלוק של 4KB או יותר) כדי למלא את החוצץ. לאחר מכן, `fgetc()` תחזיר תווים מהחוצץ בזיכרון המשתמש עד שיתרוקן, ורק אז תבצע קריאת מערכת נוספת.\n      *   **ביצועים:** בדרך כלל, ביצועים טובים בהרבה עבור קריאה תו-אחר-תו של קבצים גדולים. הסיבה היא שהיא מפחיתה באופן דרמטי את מספר קריאות המערכת. במקום קריאת מערכת לכל תו, יש קריאת מערכת אחת לכל בלוק גדול, והשאר מטופל במהירות בזיכרון המשתמש.\n      *   **עדיפות:** ברוב המקרים של קריאת קבצים גדולים תו-אחר-תו, `fgetc()` עדיפה מבחינת ביצועים בזכות מנגנון ה-buffering שלה.\n\n   *   **`read()` (קריאת מערכת ישירה):**\n      *   **מנגנון:** `read()` היא קריאת מערכת (system call) ישירה. כאשר קוראים תו בודד עם `read(fd, &c, 1)`, המערכת עוברת למצב ליבה עבור כל תו. אם הנתונים אינם ב-cache של מערכת ההפעלה, היא מבצעת פעולת I/O פיזית מהדיסק, מעתיקה תו בודד לזיכרון התהליך, וחוזרת למצב משתמש.\n      *   **ביצועים:** ביצועים ירודים מאוד עבור קריאה תו-אחר-תו. כל קריאת תו בודד כרוכה בעלות הגבוהה של מעבר הקשר (context switch) בין מצב משתמש למצב ליבה, מה שהופך את הפעולה לאיטית מאוד.\n      *   **עדיפות:** במקרים שבהם יש צורך בשליטה מדויקת יותר על ה-I/O (למשל, שימוש ב-non-blocking I/O), או כאשר קוראים כמות גדולה של נתונים בבת אחת (בלוקים גדולים), `read()` מתאימה יותר. עם זאת, לקריאת תו-אחר-תו, היא פחות יעילה.\n\nג. דרך לשיפור ביצועי הקריאה מהקובץ במקרה זה:\n   הדרך היעילה ביותר לשיפור ביצועים עבור קריאת קובץ גדול תו-אחר-תו היא למזער את מספר קריאות המערכת על ידי שימוש יעיל ב-buffering:\n   1.  **שימוש בפונקציות ספרייה מבופרות:** הבטחת שימוש ב-`fgetc()` או `fread()` (לקריאת בלוקים של תווים). פונקציות אלו משתמשות בחוצץ פנימי ומבצעות קריאות מערכת גדולות יותר (למשל, 4KB או 8KB) בפעם אחת, ומספקות את התווים מהחוצץ בזיכרון המשתמש. זה מפחית באופן דרמטי את תדירות קריאות המערכת.\n   2.  **הגדלת גודל החוצץ של הזרם:** ניתן להשתמש בפונקציה כמו `setvbuf()` כדי להגדיר חוצץ גדול יותר עבור הזרם (stream) שנוצר באמצעות `fopen()`. לדוגמה, הגדרת חוצץ בגודל של כמה עשרות קילובייט או מגהבייט (בהתאם לזיכרון הזמין ולדפוס הגישה), תפחית עוד יותר את תדירות קריאות המערכת ותשפר את הביצועים.\n   3.  **קריאה בבלוקים גדולים ועיבוד מקומי (ידני):** אם חייבים להשתמש ב-`read()` ישירה, הגישה הטובה ביותר היא לקרוא בלוקים גדולים של נתונים (למשל, 4KB, 8KB או יותר) לתוך חוצץ משלנו באמצעות `read()`, ולאחר מכן לעבד את התווים מתוך החוצץ הזה בזיכרון המשתמש. רק כאשר החוצץ מתרוקן, לבצע קריאת מערכת נוספת. זו בעצם הדרך שבה פונקציות כמו `fgetc()` עובדות פנימית, אך ביישום ידני. גישה זו ממזערת את עלות מעברי הקשר."
    },
    "difficulty_estimation": "Medium"
  }
}