{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 09:13:06",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1598,
      "output_tokens": 1537,
      "total_tokens": 6670
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Scheduling",
      "CPU Scheduling",
      "Throughput",
      "Response Time"
    ],
    "content": {
      "text": "אלגוריתמי תזמון נדרשים לאזן בין מטרות שונות, כגון מיקסום ניצול המעבד (throughput) ומזעור זמן התגובה (response time). הסבירו את הקונפליקט המובנה בין שתי מטרות אלו. לאחר מכן, הציעו שינוי לאלגוריתם תזמון בסיסי (כגון Round Robin או FCFS) שמנסה לאזן בין מטרות אלו. פרטו כיצד השינוי עובד, ומהם היתרונות והחסרונות הפוטנציאליים שלו.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסבר על הקונפליקט:\nמיקסום ניצול המעבד (throughput) מתמקד בהשלמת כמה שיותר עבודה בזמן נתון. לעיתים קרובות, הדבר מושג על ידי מתן עדיפות לתהליכים ארוכים או CPU-bound, והפחתת החלפות הקשר (context switches) שגוזלות זמן. לדוגמה, אלגוריתם FCFS יכול להשיג throughput גבוה עבור עומס עבודה מסוים על ידי ריצת תהליכים עד לסיומם ללא הפרעה.\nמנגד, מזעור זמן התגובה (response time) מתמקד בהבטחת שזמן ההמתנה של תהליכים קצרים ואינטראקטיביים יהיה מינימלי. הדבר מושג לרוב על ידי תזמון תכוף של תהליכים, גם במחיר של החלפות קשר רבות. לדוגמה, Round Robin עם קוונטום קטן משרת מטרה זו היטב.\nהקונפליקט נובע מכך שגישה אחת (מעט החלפות קשר, ריצת תהליכים ארוכים) פוגעת בזמן התגובה של תהליכים קצרים, בעוד שהגישה השנייה (החלפות קשר רבות, פיזור זמן מעבד) עלולה להפחית את ה-throughput הכולל עקב תקורה של החלפות קשר.\n\nהצעה לשינוי באלגוריתם Round Robin (Round Robin אדפטיבי):\nנציע שינוי לאלגוריתם Round Robin (RR) שינסה לאזן בין המטרות. הרעיון הוא להקצות קוונטום זמן דינמי לכל תהליך בהתבסס על התנהגותו ההיסטורית.\n\nכיצד השינוי עובד:\n1.  **ניטור התנהגות**: המתוזמן ינטר את התנהגות כל תהליך. אם תהליך מסיים את פרץ ה-CPU שלו (מבצע I/O) לפני תום הקוונטום שלו באופן עקבי, הוא יסווג כ\"אינטראקטיבי\". אם תהליך משתמש באופן עקבי בכל הקוונטום שלו (או כמעט כולו), הוא יסווג כ\"תלוי-מעבד\" (CPU-bound).\n2.  **קוונטום דינמי**: \n    *   לתהליכים אינטראקטיביים יוקצה קוונטום זמן קצר יותר (לדוגמה, חצי מהקוונטום הרגיל) כדי להבטיח זמן תגובה מהיר.\n    *   לתהליכים תלויי-מעבד יוקצה קוונטום זמן ארוך יותר (לדוגמה, פי שניים מהקוונטום הרגיל) כדי להפחית את תקורת החלפות הקשר ולשפר את ה-throughput.\n3.  **התאמה ואיזון**: המערכת תכלול מנגנון \"הזדקנות\" (aging) או \"העלאת עדיפות\" (priority boost) תקופתית, שבו תהליכים תלויי-מעבד שלא קיבלו מספיק זמן מעבד (או תהליכים שסיווגם השתנה) יקבלו קוונטום קצר יותר או עדיפות גבוהה יותר באופן זמני, כדי למנוע הרעבה (starvation) ולהתאים את עצמה לשינויים בהתנהגות התהליכים.\n\nיתרונות פוטנציאליים:\n*   **שיפור זמן התגובה**: תהליכים אינטראקטיביים יקבלו זמן מעבד מהר יותר ובמנות קטנות, מה שמשפר את חווית המשתמש.\n*   **שיפור ה-Throughput**: תהליכים תלויי-מעבד ירוצו למשך זמן ארוך יותר ללא הפרעה, מה שמפחית את תקורת החלפות הקשר ומגדיל את כמות העבודה הכוללת המבוצעת.\n*   **אדפטיביות**: האלגוריתם מסוגל להסתגל להתנהגות המשתנה של התהליכים במערכת.\n\nחסרונות פוטנציאליים:\n*   **מורכבות**: האלגוריתם מורכב יותר ליישום מאשר RR רגיל, דורש מנגנוני ניטור וקבלת החלטות נוספים.\n*   **תקורה נוספת**: ניטור התנהגות התהליכים והתאמת הקוונטום מוסיפים תקורה למערכת.\n*   **כיוונון (Tuning)**: דורש כיוונון זהיר של הסף לסיווג תהליכים ושל גדלי הקוונטום השונים כדי להשיג את האיזון האופטימלי.\n*   **פוטנציאל להרעבה/חוסר הוגנות**: ללא מנגנון הזדקנות או העלאת עדיפות מתאים, תהליכים תלויי-מעבד עלולים לסבול אם תהליכים אינטראקטיביים רבים מגיעים ברציפות."
    },
    "difficulty_estimation": "Medium"
  }
}