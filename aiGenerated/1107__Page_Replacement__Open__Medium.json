{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Page Replacement",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 07:59:10",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3033,
      "output_tokens": 3373,
      "total_tokens": 16827
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Page Replacement",
      "Memory Management",
      "Virtual Memory"
    ],
    "content": {
      "text": "נתונה מערכת זיכרון וירטואלי עם 3 מסגרות פיזיות זמינות לתהליך בודד. גודל הדף הוא 4KB. נתונה סדרת גישות לדפים הבאה:\n`7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "כמה כשלים (page faults) יתרחשו עבור סדרת הגישות הנתונה אם המערכת משתמשת באלגוריתם החלפת הדפים FIFO?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "כמה כשלים (page faults) יתרחשו עבור סדרת הגישות הנתונה אם המערכת משתמשת באלגוריתם החלפת הדפים LRU (Least Recently Used)?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "כמה כשלים (page faults) יתרחשו עבור סדרת הגישות הנתונה אם המערכת משתמשת באלגוריתם החלפת הדפים Second Chance (Clock)?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.4",
        "text": "הסבר את ההבדלים במספר כשלי הדף בין האלגוריתמים השונים שניתחת בסעיפים הקודמים. מהם היתרונות והחסרונות העיקריים של כל אלגוריתם בהקשר זה?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון מלא:\n\nנתונים: 3 מסגרות פיזיות. סדרת גישות: `7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`\n\n**10.1: אלגוריתם FIFO**\nמספר כשלי דף: 16\nמעקב:\n[ _, _, _ ] (Initial Empty Frames)\n1. 7: [7, _, _] PF\n2. 0: [7, 0, _] PF\n3. 1: [7, 0, 1] PF\n4. 2: [0, 1, 2] PF (7 replaced)\n5. 0: [0, 1, 2] Hit\n6. 3: [1, 2, 3] PF (0 replaced)\n7. 0: [2, 3, 0] PF (1 replaced)\n8. 4: [3, 0, 4] PF (2 replaced)\n9. 2: [0, 4, 2] PF (3 replaced)\n10. 3: [4, 2, 3] PF (0 replaced)\n11. 0: [2, 3, 0] PF (4 replaced)\n12. 3: [2, 3, 0] Hit\n13. 2: [2, 3, 0] Hit\n14. 1: [3, 0, 1] PF (2 replaced)\n15. 2: [0, 1, 2] PF (3 replaced)\n16. 0: [0, 1, 2] Hit\n17. 1: [0, 1, 2] Hit\n18. 7: [1, 2, 7] PF (0 replaced)\n19. 0: [2, 7, 0] PF (1 replaced)\n20. 1: [7, 0, 1] PF (2 replaced)\n\n**10.2: אלגוריתם LRU**\nמספר כשלי דף: 12\nמעקב:\n[ _, _, _ ] (Initial Empty Frames)\n1. 7: [7, _, _] PF\n2. 0: [7, 0, _] PF\n3. 1: [7, 0, 1] PF\n4. 2: [0, 1, 2] PF (7 replaced - LRU)\n5. 0: [1, 2, 0] Hit (0 becomes MRU)\n6. 3: [2, 0, 3] PF (1 replaced - LRU)\n7. 0: [2, 3, 0] Hit (0 becomes MRU)\n8. 4: [3, 0, 4] PF (2 replaced - LRU)\n9. 2: [0, 4, 2] PF (3 replaced - LRU)\n10. 3: [4, 2, 3] PF (0 replaced - LRU)\n11. 0: [2, 3, 0] PF (4 replaced - LRU)\n12. 3: [2, 0, 3] Hit (3 becomes MRU)\n13. 2: [0, 3, 2] Hit (2 becomes MRU)\n14. 1: [3, 2, 1] PF (0 replaced - LRU)\n15. 2: [3, 1, 2] Hit (2 becomes MRU)\n16. 0: [1, 2, 0] PF (3 replaced - LRU)\n17. 1: [2, 0, 1] Hit (1 becomes MRU)\n18. 7: [0, 1, 7] PF (2 replaced - LRU)\n19. 0: [1, 7, 0] Hit (0 becomes MRU)\n20. 1: [7, 0, 1] Hit (1 becomes MRU)\n\n**10.3: אלגוריתם Second Chance (Clock)**\nמספר כשלי דף: 15\nמעקב (הצבען מצביע על הפריים הבא לבדיקה. (P,R) = (Page, Reference Bit)):\n[(-,-), (-,-), (-,-)], P=0\n1. 7: [(7,1), (-,-), (-,-)], PF, P=0\n2. 0: [(7,1), (0,1), (-,-)], PF, P=0\n3. 1: [(7,1), (0,1), (1,1)], PF, P=0\n4. 2: PF. P=0 (7,1)->(7,0), P=1. P=1 (0,1)->(0,0), P=2. P=2 (1,1)->(1,0), P=0. P=0 (7,0)->replace. [(2,1), (0,0), (1,0)], P=0\n5. 0: Hit. Access 0. [(2,1), (0,1), (1,0)], P=0\n6. 3: PF. P=0 (2,1)->(2,0), P=1. P=1 (0,1)->(0,0), P=2. P=2 (1,0)->replace. [(2,0), (0,0), (3,1)], P=2\n7. 0: Hit. Access 0. [(2,0), (0,1), (3,1)], P=2\n8. 4: PF. P=2 (3,1)->(3,0), P=0. P=0 (2,0)->replace. [(4,1), (0,1), (3,0)], P=0\n9. 2: PF. P=0 (4,1)->(4,0), P=1. P=1 (0,1)->(0,0), P=2. P=2 (3,0)->replace. [(4,0), (0,0), (2,1)], P=2\n10. 3: PF. P=2 (2,1)->(2,0), P=0. P=0 (4,0)->replace. [(3,1), (0,0), (2,0)], P=0\n11. 0: Hit. Access 0. [(3,1), (0,1), (2,0)], P=0\n12. 3: Hit. Access 3. [(3,1), (0,1), (2,0)], P=0\n13. 2: Hit. Access 2. [(3,1), (0,1), (2,1)], P=0\n14. 1: PF. P=0 (3,1)->(3,0), P=1. P=1 (0,1)->(0,0), P=2. P=2 (2,1)->(2,0), P=0. P=0 (3,0)->replace. [(1,1), (0,0), (2,0)], P=0\n15. 2: Hit. Access 2. [(1,1), (0,0), (2,1)], P=0\n16. 0: Hit. Access 0. [(1,1), (0,1), (2,1)], P=0\n17. 1: Hit. Access 1. [(1,1), (0,1), (2,1)], P=0\n18. 7: PF. P=0 (1,1)->(1,0), P=1. P=1 (0,1)->(0,0), P=2. P=2 (2,1)->(2,0), P=0. P=0 (1,0)->replace. [(7,1), (0,0), (2,0)], P=0\n19. 0: Hit. Access 0. [(7,1), (0,1), (2,0)], P=0\n20. 1: PF. P=0 (7,1)->(7,0), P=1. P=1 (0,1)->(0,0), P=2. P=2 (2,0)->replace. [(7,0), (0,0), (1,1)], P=2\n\n**10.4: הסבר ההבדלים**\n\n*   **LRU (Least Recently Used)**: אלגוריתם LRU השיג את מספר כשלי הדף הנמוך ביותר (12). הוא נחשב לאלגוריתם אופטימלי (או קרוב לאופטימלי) ברוב המקרים מכיוון שהוא מנצל את עקרון לוקליות ההתייחסות (locality of reference) – דפים שנעשה בהם שימוש לאחרונה צפויים להיות בשימוש שוב בקרוב. החיסרון העיקרי שלו הוא עלות היישום הגבוהה, שכן הוא דורש מעקב מתמיד אחר זמן הגישה האחרון לכל דף, מה שעלול להיות יקר במונחי חומרה או תוכנה (למשל, באמצעות חותמות זמן או רשימות מקושרות). במקרה זה, הוא מצליח לשמור בזיכרון את הדפים 0, 1, 2, 3, 7 אשר חוזרים על עצמם לעיתים קרובות יחסית.\n\n*   **Second Chance (Clock)**: אלגוריתם זה השיג 15 כשלי דף, שזהו שיפור לעומת FIFO אך פחות טוב מ-LRU. הוא מהווה קירוב יעיל וזול יותר ליישום של LRU. האלגוריתם משתמש בביט התייחסות (reference bit) לכל דף. כאשר דף מועמד לפינוי, אם ביט ההתייחסות שלו הוא 1, הדף מקבל 'הזדמנות שנייה' – ביט ההתייחסות מאופס, והאלגוריתם עובר לדף הבא. רק דף עם ביט התייחסות 0 יוחלף. זה מאפשר לדפים בשימוש תכוף יותר להישאר בזיכרון, גם אם הם 'ישנים' יחסית כמו ב-FIFO. היתרון הוא פשטות היישום והביצועים הטובים יותר מ-FIFO, בעוד החיסרון הוא שאינו מדויק כמו LRU בזיהוי הדף שהיה הכי פחות בשימוש בפועל.\n\n*   **FIFO (First-In, First-Out)**: אלגוריתם FIFO השיג את מספר כשלי הדף הגבוה ביותר (16). אלגוריתם זה מחליף את הדף שהיה בזיכרון הפיזי במשך הזמן הארוך ביותר, ללא קשר לשאלה אם הוא בשימוש פעיל או לא. חסרונו העיקרי הוא חוסר ההתחשבות בדפוסי גישה בפועל, ולעיתים קרובות הוא מפנה דפים שיידרשו שוב בקרוב. הוא פשוט מאוד ליישום, אך ביצועיו נמוכים לעיתים קרובות. במקרים מסוימים, FIFO אף יכול לסבול מאנומליה של בלאדי (Belady's Anomaly), שבה הגדלת מספר המסגרות הפיזיות דווקא מגדילה את מספר כשלי הדף, אם כי תופעה זו לא התרחשה בתרחיש זה."
    },
    "difficulty_estimation": "Medium"
  }
}