{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Page Replacement",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 08:00:22",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3033,
      "output_tokens": 2617,
      "total_tokens": 9079
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Page Replacement",
      "Virtual Memory",
      "Memory Management"
    ],
    "content": {
      "text": "נתונה מערכת זיכרון וירטואלי עם 3 מסגרות פיזיות פנויות עבור תהליך יחיד. גודל דף הוא 4KB. נתונה סדרת גישות לדפים הבאה:\n`7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "כמה כשלים (Page Faults) יתרחשו אם המערכת משתמשת באלגוריתם FIFO (First-In, First-Out)? הצג את מצב המסגרות בכל שלב.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "כמה כשלים (Page Faults) יתרחשו אם המערכת משתמשת באלגוריתם LRU (Least Recently Used)? הצג את מצב המסגרות בכל שלב.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "נתח והשווה את ביצועי שני האלגוריתמים עבור סדרת הגישות הנתונה. הסבר מדוע אלגוריתם אחד השיג תוצאות טובות יותר (או פחות טובות) מהשני במקרה זה. בנוסף, דון במצבים כלליים בהם כל אחד מהאלגוריתמים עשוי להיות עדיף, תוך התחשבות בעלות המימוש והתחזוקה שלהם.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "סדרת הגישות לדפים: `7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`\nמספר המסגרות: 3\n\n**10.1. חישוב כשלים עבור אלגוריתם FIFO:**\n\n| גישה | מצב מסגרות (FIFO) | כשל דף? |\n|---|---|---|\n| 7 | [7, _, _] | PF=1 |\n| 0 | [7, 0, _] | PF=2 |\n| 1 | [7, 0, 1] | PF=3 |\n| 2 | [0, 1, 2] (הוצא 7) | PF=4 |\n| 0 | [0, 1, 2] | Hit |\n| 3 | [1, 2, 3] (הוצא 0) | PF=5 |\n| 0 | [2, 3, 0] (הוצא 1) | PF=6 |\n| 4 | [3, 0, 4] (הוצא 2) | PF=7 |\n| 2 | [0, 4, 2] (הוצא 3) | PF=8 |\n| 3 | [4, 2, 3] (הוצא 0) | PF=9 |\n| 0 | [2, 3, 0] (הוצא 4) | PF=10 |\n| 3 | [2, 3, 0] | Hit |\n| 2 | [2, 3, 0] | Hit |\n| 1 | [3, 0, 1] (הוצא 2) | PF=11 |\n| 2 | [0, 1, 2] (הוצא 3) | PF=12 |\n| 0 | [0, 1, 2] | Hit |\n| 1 | [0, 1, 2] | Hit |\n| 7 | [1, 2, 7] (הוצא 0) | PF=13 |\n| 0 | [2, 7, 0] (הוצא 1) | PF=14 |\n| 1 | [7, 0, 1] (הוצא 2) | PF=15 |\n\n**סה\"כ כשלים ב-FIFO: 15**\n\n**10.2. חישוב כשלים עבור אלגוריתם LRU:**\n\n| גישה | מצב מסגרות (LRU) | כשל דף? | דף להחלפה (LRU) |\n|---|---|---|---|\n| 7 | [7, _, _] | PF=1 | - |\n| 0 | [7, 0, _] | PF=2 | 7 |\n| 1 | [7, 0, 1] | PF=3 | 7 |\n| 2 | [0, 1, 2] | PF=4 | 7 |\n| 0 | [1, 2, 0] | Hit | 1 |\n| 3 | [2, 0, 3] | PF=5 | 1 |\n| 0 | [2, 3, 0] | Hit | 2 |\n| 4 | [3, 0, 4] | PF=6 | 2 |\n| 2 | [0, 4, 2] | PF=7 | 3 |\n| 3 | [4, 2, 3] | PF=8 | 0 |\n| 0 | [2, 3, 0] | PF=9 | 4 |\n| 3 | [2, 0, 3] | Hit | 2 |\n| 2 | [0, 3, 2] | Hit | 0 |\n| 1 | [3, 2, 1] | PF=10 | 0 |\n| 2 | [3, 1, 2] | Hit | 3 |\n| 0 | [1, 2, 0] | PF=11 | 3 |\n| 1 | [2, 0, 1] | Hit | 2 |\n| 7 | [0, 1, 7] | PF=12 | 2 |\n| 0 | [1, 7, 0] | Hit | 1 |\n| 1 | [7, 0, 1] | Hit | 7 |\n\n**סה\"כ כשלים ב-LRU: 12**\n\n**10.3. ניתוח והשוואת ביצועים:**\n\nעבור סדרת הגישות הנתונה, אלגוריתם LRU השיג ביצועים טובים יותר עם 12 כשלי דף, לעומת 15 כשלי דף באלגוריתם FIFO. ההבדל נובע מהאופן שבו כל אלגוריתם מחליט איזה דף לפנות:\n\n*   **FIFO (First-In, First-Out):** מפנה את הדף שהיה בזיכרון הפיזי במשך הזמן הארוך ביותר, ללא קשר לתדירות השימוש בו. במקרה זה, דפים כמו '0' ו-'2' ששימשו בתחילת הרצף ופונו על ידי FIFO, נדרשו שוב מאוחר יותר, מה שהוביל לכשלי דף נוספים. FIFO לא מנצל את עקרון המקומיות (locality of reference).\n*   **LRU (Least Recently Used):** מפנה את הדף שלא נעשה בו שימוש במשך הזמן הארוך ביותר. אלגוריתם זה מנסה לנצל את עקרון המקומיות, מתוך הנחה שדף שנעשה בו שימוש לאחרונה, סביר שיידרש שוב בקרוב. ברצף הנתון, דפים כמו '0', '2' ו-'3' נגישים מספר פעמים בהפרשי זמן קצרים יחסית. LRU מצליח לשמור אותם בזיכרון זמן רב יותר, ובכך מקטין את מספר כשלי הדף.\n\n**מצבים כלליים בהם כל אלגוריתם עשוי להיות עדיף:**\n\n*   **FIFO:**\n    *   **יתרונות:** פשוט מאוד ליישום (באמצעות תור), בעל תקורה נמוכה (אין צורך לעקוב אחר זמני גישה). \n    *   **חסרונות:** עלול לסבול מ\"אנומליית בילדי\" (Belady's Anomaly), כלומר, הגדלת מספר המסגרות עלולה להוביל ליותר כשלי דף. אינו יעיל כאשר קיימת מקומיות חזקה בגישות לדפים, כיוון שהוא מפנה דפים על בסיס זמן הגעתם בלבד ולא על בסיס שימושם. \n    *   **עדיפות:** במערכות פשוטות מאוד, או במקרים בהם דפוסי הגישה לדפים הם רציפים או אקראיים לחלוטין, כך שניצול מקומיות אינו רלוונטי או אינו אפשרי.\n\n*   **LRU:**\n    *   **יתרונות:** בדרך כלל משיג ביצועים טובים יותר מ-FIFO במערכות אמיתיות, במיוחד כאשר קיימת מקומיות חזקה בגישות לדפים. הוא מונע פינוי של דפים פעילים. \n    *   **חסרונות:** בעל תקורה גבוהה יותר ליישום. דורש מעקב אחר זמן הגישה האחרון לכל דף (לדוגמה, באמצעות רשימה מקושרת, מחסנית, או ביטים מיוחדים בחומרת ה-MMU), מה שמצריך משאבי חומרה או תוכנה נוספים. יישום מדויק של LRU דורש עדכון מתמיד של מבנה הנתונים שלו בכל גישת זיכרון. \n    *   **עדיפות:** במערכות בהן ביצועים (מספר כשלי דף נמוך) קריטיים וקיימת מקומיות ברורה בגישות לדפים, ועלות המימוש והתחזוקה הנוספת מקובלת. בפועל, לעיתים קרובות מיישמים קירובים ל-LRU (כמו אלגוריתם השעון או Second Chance) כדי להפחית את התקורה תוך שמירה על ביצועים טובים יחסית."
    },
    "difficulty_estimation": "Medium"
  }
}