{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Page Replacement",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 08:02:18",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4205,
      "output_tokens": 4196,
      "total_tokens": 26793
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Paging",
      "Page Replacement",
      "Clock Algorithm"
    ],
    "content": {
      "text": "נתונה מערכת זיכרון וירטואלי המשתמשת באלגוריתם החלפת דפים Clock (Second Chance). גודל דף הוא 4KB. למערכת יש 3 מסגרות פיזיות זמינות לתהליך בודד (כלומר, גודל הזיכרון הפיזי עבור התהליך הוא 12KB).\nכל כניסה בטבלת הדפים (PTE) כוללת Present bit (P), Reference bit (R) ו-Dirty bit (D).\nכאשר דף נטען לזיכרון, ביט ה-R שלו מוגדר ל-1 וביט ה-D שלו מוגדר ל-0 (אלא אם כן הגישה הראשונה היא כתיבה, אז D=1). גישת קריאה מגדירה את ביט ה-R ל-1. גישת כתיבה מגדירה את ביט ה-R ל-1 ואת ביט ה-D ל-1.\nכאשר מתרחש Page Fault, אלגוריתם ה-Clock פועל כדלקמן:\n- המצביע (clock hand) מתקדם.\n- אם ביט ה-R של הדף הנוכחי הוא 1, הוא מאופס ל-0, והמצביע ממשיך לדף הבא.\n- אם ביט ה-R הוא 0, הדף נבחר להחלפה. אם הדף שנבחר להחלפה הוא Dirty (D=1), יש לכתוב אותו לדיסק לפני פינויו. פעולה זו נחשבת לכתיבת דיסק.\n- הדף החדש נטען למסגרת שהתפנתה, עם R=1 ו-D מתאים (0 לקריאה, 1 לכתיבה).\n\nנתון קטע הקוד הבא בשפת C:\n",
      "code_snippet": "```c\n#include <stdio.h>\n\nint main() {\n    int arr[1024 * 5]; // מערך בגודל 5 דפים, כאשר כל דף הוא 4KB (1024 אינטים)\n    for (int k = 0; k < 3; k++) { // חזור על התבנית 3 פעמים\n        for (int i = 0; i < 5; i++) { // גש לדפים 0-4\n            int page_num = i;\n            int index = page_num * 1024;\n            if (i % 2 == 0) { // גש לדפים זוגיים בכתיבה\n                arr[index] = k; // גישת כתיבה\n            } else {\n                int x = arr[index]; // גישת קריאה\n            }\n        }\n    }\n    return 0;\n}\n```\n\nהנח כי:\n1.  גודל `int` הוא 4 בתים.\n2.  הגישה ל-`arr[index]` מתורגמת לגישה לדף הווירטואלי המתאים.\n3.  המסגרות הפיזיות ממוספרות מ-0 עד 2.\n4.  המצביע של Clock מתחיל ממסגרת 0.\n5.  בתחילה, כל המסגרות ריקות (לא מכילות דפים)."
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "מהי רצף הגישות לדפים הווירטואליים (מספרי דפים בלבד, עם ציון סוג הגישה – קריאה/כתיבה) שנוצר על ידי קטע הקוד?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "עקוב אחר פעולת אלגוריתם ה-Clock עבור רצף הגישות שחישבת. הצג את מצב המסגרות הפיזיות (מספר דף וביטים R, D) ואת מיקום המצביע לאחר כל Page Fault (עד שהמסגרות מתמלאות, ולאחר מכן רק כאשר מתרחש Page Fault והחלפה).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "כמה Page Faults התרחשו בסך הכל? כמה פעמים נדרשה כתיבה לדיסק (dirty page write back)?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.4",
        "text": "מהו המצב הסופי של המסגרות הפיזיות והביטים שלהן (R, D) בסיום ריצת הקוד?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1: חישוב רצף הגישות לדפים:\nגודל המערך `arr` הוא `1024 * 5` אינטים. גודל `int` הוא 4 בתים. לכן גודל המערך הכולל הוא `1024 * 5 * 4 = 20KB`.\nגודל דף הוא 4KB. לכן המערך תופס `20KB / 4KB = 5` דפים וירטואליים: דף 0, דף 1, דף 2, דף 3, דף 4.\nהלולאה החיצונית רצה 3 פעמים (`k=0, 1, 2`).\nהלולאה הפנימית רצה 5 פעמים (`i=0, 1, 2, 3, 4`), כאשר `page_num = i`.\nגישה לדף זוגי (`i % 2 == 0`) היא כתיבה (`W`), גישה לדף אי-זוגי היא קריאה (`R`).\n\nרצף הגישות לדפים (Page, Type):\nעבור `k=0`: (0,W), (1,R), (2,W), (3,R), (4,W)\nעבור `k=1`: (0,W), (1,R), (2,W), (3,R), (4,W)\nעבור `k=2`: (0,W), (1,R), (2,W), (3,R), (4,W)\n\nרצף הגישות המלא הוא: P0(W), P1(R), P2(W), P3(R), P4(W), P0(W), P1(R), P2(W), P3(R), P4(W), P0(W), P1(R), P2(W), P3(R), P4(W).\n\n1.2 ו-1.3: מעקב אחר אלגוריתם ה-Clock:\nמספר כולל של Page Faults = 0, מספר כולל של כתיבות לדיסק = 0. מצב המסגרות: F0: (-,-,-), F1: (-,-,-), F2: (-,-,-). מצביע (CH) ב-F0.\n\n1.  **גישה P0(W):** Page Fault. F0 פנויה. טען P0 ל-F0. מצב F0: (0,1,1). CH עובר ל-F1.\n    *מצב:* F0:(0,1,1), F1:(-,-,-), F2:(-,-,-). CH:F1. PF:1, Writes:0.\n2.  **גישה P1(R):** Page Fault. F1 פנויה. טען P1 ל-F1. מצב F1: (1,1,0). CH עובר ל-F2.\n    *מצב:* F0:(0,1,1), F1:(1,1,0), F2:(-,-,-). CH:F2. PF:2, Writes:0.\n3.  **גישה P2(W):** Page Fault. F2 פנויה. טען P2 ל-F2. מצב F2: (2,1,1). CH עובר ל-F0. כל המסגרות מלאות.\n    *מצב:* F0:(0,1,1), F1:(1,1,0), F2:(2,1,1). CH:F0. PF:3, Writes:0.\n4.  **גישה P3(R):** Page Fault. CH ב-F0. דף P0(R=1,D=1). אפס R ל-0 (P0(0,1)). CH ל-F1. דף P1(R=1,D=0). אפס R ל-0 (P1(0,0)). CH ל-F2. דף P2(R=1,D=1). אפס R ל-0 (P2(0,1)). CH ל-F0. דף P0(R=0,D=1) נבחר להחלפה. D=1, לכן יש לבצע כתיבה לדיסק עבור P0. טען P3 ל-F0. מצב F0: (3,1,0). CH עובר ל-F1.\n    *מצב:* F0:(3,1,0), F1:(1,0,0), F2:(2,0,1). CH:F1. PF:4, Writes:1.\n5.  **גישה P4(W):** Page Fault. CH ב-F1. דף P1(R=0,D=0) נבחר להחלפה. D=0, אין כתיבה לדיסק. טען P4 ל-F1. מצב F1: (4,1,1). CH עובר ל-F2.\n    *מצב:* F0:(3,1,0), F1:(4,1,1), F2:(2,0,1). CH:F2. PF:5, Writes:1.\n6.  **גישה P0(W):** Page Fault. CH ב-F2. דף P2(R=0,D=1) נבחר להחלפה. D=1, לכן יש לבצע כתיבה לדיסק עבור P2. טען P0 ל-F2. מצב F2: (0,1,1). CH עובר ל-F0.\n    *מצב:* F0:(3,1,0), F1:(4,1,1), F2:(0,1,1). CH:F0. PF:6, Writes:2.\n7.  **גישה P1(R):** Page Fault. CH ב-F0. דף P3(R=1,D=0). אפס R ל-0 (P3(0,0)). CH ל-F1. דף P4(R=1,D=1). אפס R ל-0 (P4(0,1)). CH ל-F2. דף P0(R=1,D=1). אפס R ל-0 (P0(0,1)). CH ל-F0. דף P3(R=0,D=0) נבחר להחלפה. D=0, אין כתיבה לדיסק. טען P1 ל-F0. מצב F0: (1,1,0). CH עובר ל-F1.\n    *מצב:* F0:(1,1,0), F1:(4,0,1), F2:(0,0,1). CH:F1. PF:7, Writes:2.\n8.  **גישה P2(W):** Page Fault. CH ב-F1. דף P4(R=0,D=1) נבחר להחלפה. D=1, לכן יש לבצע כתיבה לדיסק עבור P4. טען P2 ל-F1. מצב F1: (2,1,1). CH עובר ל-F2.\n    *מצב:* F0:(1,1,0), F1:(2,1,1), F2:(0,0,1). CH:F2. PF:8, Writes:3.\n9.  **גישה P3(R):** Page Fault. CH ב-F2. דף P0(R=0,D=1) נבחר להחלפה. D=1, לכן יש לבצע כתיבה לדיסק עבור P0. טען P3 ל-F2. מצב F2: (3,1,0). CH עובר ל-F0.\n    *מצב:* F0:(1,1,0), F1:(2,1,1), F2:(3,1,0). CH:F0. PF:9, Writes:4.\n10. **גישה P4(W):** Page Fault. CH ב-F0. דף P1(R=1,D=0). אפס R ל-0 (P1(0,0)). CH ל-F1. דף P2(R=1,D=1). אפס R ל-0 (P2(0,1)). CH ל-F2. דף P3(R=1,D=0). אפס R ל-0 (P3(0,0)). CH ל-F0. דף P1(R=0,D=0) נבחר להחלפה. D=0, אין כתיבה לדיסק. טען P4 ל-F0. מצב F0: (4,1,1). CH עובר ל-F1.\n    *מצב:* F0:(4,1,1), F1:(2,0,1), F2:(3,0,0). CH:F1. PF:10, Writes:4.\n11. **גישה P0(W):** Page Fault. CH ב-F1. דף P2(R=0,D=1) נבחר להחלפה. D=1, לכן יש לבצע כתיבה לדיסק עבור P2. טען P0 ל-F1. מצב F1: (0,1,1). CH עובר ל-F2.\n    *מצב:* F0:(4,1,1), F1:(0,1,1), F2:(3,0,0). CH:F2. PF:11, Writes:5.\n12. **גישה P1(R):** Page Fault. CH ב-F2. דף P3(R=0,D=0) נבחר להחלפה. D=0, אין כתיבה לדיסק. טען P1 ל-F2. מצב F2: (1,1,0). CH עובר ל-F0.\n    *מצב:* F0:(4,1,1), F1:(0,1,1), F2:(1,1,0). CH:F0. PF:12, Writes:5.\n13. **גישה P2(W):** Page Fault. CH ב-F0. דף P4(R=1,D=1). אפס R ל-0 (P4(0,1)). CH ל-F1. דף P0(R=1,D=1). אפס R ל-0 (P0(0,1)). CH ל-F2. דף P1(R=1,D=0). אפס R ל-0 (P1(0,0)). CH ל-F0. דף P4(R=0,D=1) נבחר להחלפה. D=1, לכן יש לבצע כתיבה לדיסק עבור P4. טען P2 ל-F0. מצב F0: (2,1,1). CH עובר ל-F1.\n    *מצב:* F0:(2,1,1), F1:(0,0,1), F2:(1,0,0). CH:F1. PF:13, Writes:6.\n14. **גישה P3(R):** Page Fault. CH ב-F1. דף P0(R=0,D=1) נבחר להחלפה. D=1, לכן יש לבצע כתיבה לדיסק עבור P0. טען P3 ל-F1. מצב F1: (3,1,0). CH עובר ל-F2.\n    *מצב:* F0:(2,1,1), F1:(3,1,0), F2:(1,0,0). CH:F2. PF:14, Writes:7.\n15. **גישה P4(W):** Page Fault. CH ב-F2. דף P1(R=0,D=0) נבחר להחלפה. D=0, אין כתיבה לדיסק. טען P4 ל-F2. מצב F2: (4,1,1). CH עובר ל-F0.\n    *מצב:* F0:(2,1,1), F1:(3,1,0), F2:(4,1,1). CH:F0. PF:15, Writes:7.\n\nסה\"כ Page Faults: 15\nסה\"כ כתיבות לדיסק: 7\n\n1.4: מצב סופי של המסגרות הפיזיות:\nF0: (Page 2, R=1, D=1)\nF1: (Page 3, R=1, D=0)\nF2: (Page 4, R=1, D=1)\nהמצביע של Clock נמצא במסגרת 0."
    },
    "difficulty_estimation": "Hard"
  }
}