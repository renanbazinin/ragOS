{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:01:06",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3383,
      "output_tokens": 2664,
      "total_tokens": 13058
    }
  },
  "question": {
    "id": 9,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Deadlocks",
      "Resource Management"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המנהלת שלושה תהליכים: P1, P2, P3, ושני סוגי משאבים: R1 ו-R2.\nלמשאב R1 יש 2 מופעים, ולמשאב R2 יש 2 מופעים.\nהתהליכים מבצעים בקשות למשאבים בסדר הבא:\n*   P1: מבקש מופע אחד מ-R1, ולאחר מכן מופע אחד מ-R2.\n*   P2: מבקש מופע אחד מ-R2, ולאחר מכן מופע אחד מ-R1.\n*   P3: מבקש מופע אחד מ-R1, ולאחר מכן מופע אחד מ-R2.\n\nהתהליכים רצים תחת אלגוריתם תזמון עדיפויות דורסני (Preemptive Priority Scheduling), כאשר P1 בעל העדיפות הגבוהה ביותר, P2 בינונית, ו-P3 נמוכה (P1 > P2 > P3).\nכל בקשה למשאב היא יחידה ואטומית. אם תהליך מבקש משאב ואינו יכול לקבלו, הוא נחסם.\n\nא. תאר סדר אירועים אפשרי (בקשות והקצאות משאבים) אשר יוביל למצב של קיפאון (Deadlock) במערכת זו. הסבר כיצד אלגוריתם התזמון של עדיפויות דורסניות משפיע על היווצרות הקיפאון במקרה זה.\nב. הצע שינוי יחיד במדיניות ניהול המשאבים או באלגוריתם התזמון אשר ימנע את הקיפאון המתואר בסעיף א', תוך נימוק ההצעה והסבר כיצד היא פותרת את הבעיה מבלי לפגוע באופן משמעותי בניצול המשאבים או בתפוקת המערכת.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. תיאור סדר אירועים אפשרי המוביל לקיפאון:\nמצב התחלתי: R1 זמין = 2, R2 זמין = 2. סדר עדיפויות: P1 > P2 > P3.\n\n1.  **P1 מתחיל** (תהליך בעל העדיפות הגבוהה ביותר). P1 מבקש מופע אחד מ-R1. R1 זמין = 2, לכן P1 מקבל את R1.\n    (P1 מחזיק R1(1). נותרו R1 זמין=1, R2 זמין=2).\n2.  **P2 מתחיל** (P1 עדיין רץ או עובר מצב חוסם אחר שמאפשר ל-P2 לרוץ). P2 מבקש מופע אחד מ-R2. R2 זמין = 2, לכן P2 מקבל את R2.\n    (P2 מחזיק R2(1). P1 מחזיק R1(1). נותרו R1 זמין=1, R2 זמין=1).\n3.  **P3 מתחיל**. P3 מבקש מופע אחד מ-R1. R1 זמין = 1, לכן P3 מקבל את R1.\n    (P3 מחזיק R1(1). P2 מחזיק R2(1). P1 מחזיק R1(1). נותרו R1 זמין=0, R2 זמין=1).\n    *בשלב זה, כל מופעי R1 מוקצים (אחד ל-P1 ואחד ל-P3).\n4.  **P1** (בעל העדיפות הגבוהה ביותר) מבקש מופע אחד מ-R2. R2 מוחזק כעת על ידי P2. P1 אינו יכול לקבל את R2 ולכן **נחסם**.\n    *כאשר P1 נחסם, P2 הופך לתהליך בעל העדיפות הגבוהה ביותר מבין התהליכים הניתנים להרצה.\n5.  **P2** (כעת בעל העדיפות הגבוהה ביותר מבין הרצים) מבקש מופע אחד מ-R1. R1 מוחזק כעת על ידי P1 ו-P3. P2 אינו יכול לקבל את R1 ולכן **נחסם**.\n    *כאשר P2 נחסם, P3 הופך לתהליך בעל העדיפות הגבוהה ביותר מבין התהליכים הניתנים להרצה.\n6.  **P3** (כעת בעל העדיפות הגבוהה ביותר מבין הרצים) מבקש מופע אחד מ-R2. R2 מוחזק כעת על ידי P2. P3 אינו יכול לקבל את R2 ולכן **נחסם**.\n\nבשלב זה, כל שלושת התהליכים חסומים ויוצרים מעגל המתנה:\n*   P1 מחזיק R1 וממתין ל-R2 (המוחזק על ידי P2).\n*   P2 מחזיק R2 וממתין ל-R1 (המוחזק על ידי P3).\n*   P3 מחזיק R1 וממתין ל-R2 (המוחזק על ידי P2).\n\nזהו מצב של קיפאון.\n\n**השפעת אלגוריתם תזמון עדיפויות דורסניות:**\nאלגוריתם תזמון עדיפויות דורסניות מאפשר לתהליכים בעלי עדיפות נמוכה יותר (P2 ו-P3) לרוץ ולרכוש משאבים (R2 על ידי P2, R1 על ידי P3) בעוד תהליך בעל עדיפות גבוהה יותר (P1) טרם סיים את כל בקשות המשאבים שלו או נחסם. כאשר P1 נחסם בהמתנה למשאב, המעבד מוקצה לתהליך הפעיל הבא בעדיפות (P2, ולאחר מכן P3). הדבר מאפשר לתהליכים אלו להמשיך לרכוש משאבים ולהיכנס למצב חסום בעצמם, ובכך להשלים את מעגל ההמתנה שיוביל לקיפאון. במערכת ללא דריסה, ייתכן ש-P1 היה ממשיך לרוץ עד שסיים את כל בקשותיו (אם היה יכול לקבל אותם) ובכך מונע את היווצרות המעגל. הדריסה מאפשרת שילוב של רכישת משאבים על ידי תהליכים שונים, מה שיכול להקל על היווצרות תנאי המתנה מעגלית.\n\nב. הצעת פתרון למניעת קיפאון:\nכדי למנוע קיפאון, יש לשבור אחד מארבעת התנאים ההכרחיים לקיפאון (מניעה הדדית, החזקה והמתנה, אי-דריסה, המתנה מעגלית). הצעת שינוי יחיד במדיניות ניהול המשאבים היא **ליישם את שיטת מניעת הקיפאון \"בקש את כל המשאבים בבת אחת\" (Request All Resources at Once)**, שמטרתה לשבור את תנאי ה\"החזקה והמתנה\" (Hold and Wait).\n\n**הסבר ונימוק:**\nבמדיניות זו, תהליך חייב לבקש את כל המשאבים שהוא עשוי להזדקק להם במהלך ביצועו (או לפחות את כל המשאבים הנדרשים עבור שלב קריטי מסוים) **בבת אחת**. אם כל המשאבים המבוקשים זמינים, הם מוקצים לתהליך. אחרת, התהליך נחסם ואינו מקבל אף משאב עד שכל המשאבים יהיו זמינים.\n\n**יישום בתרחיש הנתון:**\n*   P1 יבקש (R1(1), R2(1)) בבת אחת.\n*   P2 יבקש (R2(1), R1(1)) בבת אחת.\n*   P3 יבקש (R1(1), R2(1)) בבת אחת.\n\nמכיוון שסה\"כ המופעים הנדרשים הם R1(3) ו-R2(3) (לכל תהליך דרוש מופע אחד מכל סוג), בעוד שסה\"כ המופעים הזמינים במערכת הם R1(2) ו-R2(2), רק שני תהליכים יוכלו לקבל את כל משאביהם בבת אחת.\nלדוגמה:\n1.  P1, בעל העדיפות הגבוהה ביותר, מבקש (R1(1), R2(1)) ומקבל אותם. (R1 זמין=1, R2 זמין=1).\n2.  P2 מבקש (R1(1), R2(1)). מכיוון שאין מספיק מופעים של R1 (נותר רק 1), P2 **לא מקבל אף משאב** ונחסם.\n3.  P3 מבקש (R1(1), R2(1)). גם הוא לא יקבל אף משאב ונחסם.\n\nכאשר P1 יסיים את ביצועו וישחרר את R1(1) ו-R2(1), המשאבים יהפכו לזמינים (R1 זמין=2, R2 זמין=2). כעת, P2 (או P3, לפי עדיפות או FCFS מבין החסומים) יוכל לקבל את כל משאביו ולהתחיל לרוץ.\nבשיטה זו, אף תהליך לעולם לא יחזיק במשאבים מסוימים תוך כדי המתנה למשאבים אחרים, ובכך נשבר תנאי \"החזקה והמתנה\", והמתנה מעגלית נמנעת.\n\n**השפעה על ניצול משאבים ותפוקה:**\nשיטה זו עשויה להפחית מעט את ניצול המשאבים והתפוקה הכוללת של המערכת, מכיוון שתהליכים עשויים להחזיק משאבים לפרקי זמן ארוכים יותר (אף אם אינם משתמשים בהם באופן פעיל) או להמתין זמן רב יותר עד שכל המשאבים הנדרשים יהיו זמינים. עם זאת, היא מונעת קיפאון באופן מוחלט, ובתרחישים רבים, הפגיעה בתפוקה נחשבת סבירה ביחס ליתרון של מניעת קיפאון. זהו פתרון סטנדרטי ויעיל למניעת קיפאון."
    },
    "difficulty_estimation": "Hard"
  }
}