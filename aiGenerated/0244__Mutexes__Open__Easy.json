{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:13:24",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2084,
      "output_tokens": 663,
      "total_tokens": 3699
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Mutexes",
      "Synchronization",
      "Concurrency"
    ],
    "content": {
      "text": "מהו Mutex (מנעול הדדי) בהקשר של מערכות הפעלה ותכנות מקבילי? הסבר את מטרתו העיקרית ואת שתי הפעולות הבסיסיות הקשורות אליו. מדוע הוא חיוני בתוכניות מרובות חוטים?",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "Mutex (מנעול הדדי) הוא אובייקט סנכרון המשמש בתכנות מקבילי כדי לאכוף בלעדיות הדדית (mutual exclusion) על משאב משותף או קטע קוד קריטי. מטרתו העיקרית היא למנוע תנאי מרוץ (race conditions) ולהבטיח שרק חוט אחד (thread) יוכל לגשת למשאב המוגן בכל רגע נתון.\n\nשתי הפעולות הבסיסיות הקשורות ל-Mutex הן:\n1.  **lock()** (או `acquire()` / `wait()`): כאשר חוט מעוניין לגשת לקטע קוד קריטי או למשאב משותף המוגן על ידי Mutex, הוא מנסה לרכוש את המנעול באמצעות פעולה זו. אם המנעול פנוי, החוט רוכש אותו וממשיך בביצוע. אם המנעול כבר מוחזק על ידי חוט אחר, החוט הנוכחי נחסם (מושהה) וממתין עד שהמנעול ישוחרר.\n2.  **unlock()** (או `release()` / `signal()`): לאחר שחוט סיים את עבודתו עם המשאב המוגן, הוא משחרר את המנעול באמצעות פעולה זו. שחרור המנעול מאפשר לחוטים אחרים הממתינים לרכוש אותו ולהמשיך בביצוע.\n\nMutexים חיוניים בתוכניות מרובות חוטים מכיוון שללא מנגנון סנכרון כזה, גישה בו-זמנית של מספר חוטים לנתונים משותפים עלולה להוביל לחוסר עקביות בנתונים, לתוצאות שגויות ולבאגים קשים לאיתור (תנאי מרוץ). Mutex מבטיח שהנתונים יישארו עקביים ובמצב תקין על ידי מתן גישה מבוקרת ובלעדית לנתונים אלו."
    },
    "difficulty_estimation": "Easy"
  }
}