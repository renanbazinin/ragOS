{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 21:17:04",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3559,
      "output_tokens": 1789,
      "total_tokens": 8031
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Deadlocks",
      "Deadlock Prevention",
      "Concurrency"
    ],
    "content": {
      "text": "במערכת הפעלה, קיפאון (deadlock) יכול להתרחש כאשר קבוצת תהליכים נחסמת באופן קבוע, כאשר כל תהליך בקבוצה ממתין למשאב שמוחזק על ידי תהליך אחר בקבוצה.\nנתונה מערכת עם שני סוגי משאבים, R1 ו-R2, כאשר מכל סוג קיים מופע יחיד. במערכת רצים שני תהליכים, P1 ו-P2, אשר מבצעים את הקוד הבא:\n\n```c\n// Process P1\nvoid process_P1() {\n    lock(&R1);\n    lock(&R2);\n    // קטע קריטי\n    unlock(&R2);\n    unlock(&R1);\n}\n\n// Process P2\nvoid process_P2() {\n    lock(&R2);\n    lock(&R1);\n    // קטע קריטי\n    unlock(&R1);\n    unlock(&R2);\n}\n```\n\nא) הסבירו כיצד קיפאון יכול להתרחש במערכת זו. תארו רצף אירועים ספציפי שמוביל לקיפאון.\nב) הציעו מנגנון פשוט למניעת קיפאון במערכת זו, תוך התייחסות לאחד מארבעת התנאים למניעת קיפאון. הסבירו את המנגנון שבחרתם והדגימו כיצד הוא מונע את הקיפאון בתרחיש הספציפי הזה.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "חלק א': הסבר על קיפאון\n\nקיפאון יכול להתרחש במערכת זו עקב קיום כל ארבעת התנאים לקיפאון:\n1.  מניעה הדדית (Mutual Exclusion): המשאבים R1 ו-R2 הם משאבים בלעדיים, כלומר רק תהליך אחד יכול להחזיק בכל משאב נתון בזמן מסוים (ה-lock מבטיח זאת).\n2.  החזק והמתן (Hold-and-Wait): תהליך יכול להחזיק במשאב אחד (לדוגמה, P1 מחזיק ב-R1) ובמקביל לבקש משאב נוסף (P1 ממתין ל-R2).\n3.  אי-נשללות (No Preemption): לא ניתן לקחת משאב מתהליך שמחזיק בו בכוח. תהליך משחרר משאב רק מרצונו החופשי (באמצעות unlock).\n4.  המתנה מעגלית (Circular Wait): קיים מעגל של תהליכים, כאשר כל תהליך ממתין למשאב שמוחזק על ידי התהליך הבא במעגל.\n\nרצף אירועים המוביל לקיפאון:\n1.  P1 מבצע lock(&R1): P1 תופס את R1.\n2.  P2 מבצע lock(&R2): P2 תופס את R2.\n3.  P1 מבצע lock(&R2): P1 מנסה לתפוס את R2 אך נחסם, מכיוון ש-R2 מוחזק על ידי P2. P1 ממתין ל-R2.\n4.  P2 מבצע lock(&R1): P2 מנסה לתפוס את R1 אך נחסם, מכיוון ש-R1 מוחזק על ידי P1. P2 ממתין ל-R1.\n\nבשלב זה, P1 מחזיק ב-R1 וממתין ל-R2, בעוד P2 מחזיק ב-R2 וממתין ל-R1. נוצרה המתנה מעגלית, ושני התהליכים חסומים באופן קבוע – קיפאון.\n\nחלק ב': מנגנון למניעת קיפאון\n\nניתן למנוע את הקיפאון על ידי שבירת תנאי ה\"המתנה מעגלית\" (Circular Wait), באמצעות הקפדה על סדר קבוע לרכישת משאבים.\n\nמנגנון: הקצאת סדר גלובלי לכל סוגי המשאבים במערכת. לדוגמה, נקבע ש-R1 יבוא לפני R2 (כלומר, R1 < R2). כל התהליכים במערכת חייבים לבקש משאבים לפי סדר זה. אם תהליך זקוק למשאבים R1 ו-R2, הוא חייב לבקש קודם את R1 ורק אחר כך את R2.\n\nיישום בתרחיש זה:\nנשנה את קוד התהליכים כך ששניהם יבקשו את המשאבים בסדר קבוע (לדוגמה, R1 ואז R2):\n\n```c\n// Process P1 (ללא שינוי)\nvoid process_P1() {\n    lock(&R1);\n    lock(&R2);\n    // קטע קריטי\n    unlock(&R2);\n    unlock(&R1);\n}\n\n// Process P2 (לאחר שינוי)\nvoid process_P2_modified() {\n    lock(&R1); // שינוי: קודם מבקש R1\n    lock(&R2); // ואז מבקש R2\n    // קטע קריטי\n    unlock(&R2);\n    unlock(&R1);\n}\n```\n\nכיצד זה מונע קיפאון:\nננתח שוב את רצף האירועים האפשרי:\n1.  P1 מבצע lock(&R1): P1 תופס את R1.\n2.  P2 מנסה לבצע lock(&R1): P2 נחסם מכיוון ש-R1 מוחזק על ידי P1. P2 ממתין ל-R1.\n3.  P1 מבצע lock(&R2): P1 תופס את R2 (מכיוון ש-P2 חסום על R1, הוא לא יכול לתפוס את R2).\n4.  P1 מסיים את הקטע הקריטי ומשחרר את R2 ואז את R1.\n5.  כאשר R1 משוחרר, P2 (שממתין ל-R1) מקבל את R1.\n6.  P2 ממשיך ומבצע lock(&R2).\n7.  P2 מסיים את הקטע הקריטי ומשחרר את R2 ואז את R1.\n\nבכל תרחיש אפשרי, אחד מהתהליכים יתפוס את R1 ראשון. התהליך השני ייחסם וימתין. התהליך הראשון ימשיך, יתפוס את R2, יסיים את עבודתו וישחרר את שני המשאבים. רק אז התהליך השני יוכל להמשיך. תמיד יהיה תהליך שיסיים את עבודתו וישחרר משאבים, ובכך לא תיווצר המתנה מעגלית ולכן לא יהיה קיפאון."
    },
    "difficulty_estimation": "Medium"
  }
}