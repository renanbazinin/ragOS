{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 00:26:19",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4397,
      "output_tokens": 5666,
      "total_tokens": 27706
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "CPU Scheduling",
      "Processes",
      "Concurrency",
      "System Calls"
    ],
    "content": {
      "text": "נתונה התוכנית הבאה, המדמה עומס עבודה של תהליכים:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n\n#define N_CHILDREN 3     // מספר תהליכי הבן\n#define WORK_ITERATIONS_FACTOR 10000000 // פקטור עבודה CPU\n#define SLEEP_MICROSECONDS 100000 // 100 מיקרושניות שינה (I/O)\n#define REPEAT_COUNT 2   // מספר חזרות לכל תהליך בן\n\nvoid child_task(int child_idx) {\n    pid_t my_pid = getpid();\n    for (int i = 0; i < REPEAT_COUNT; ++i) {\n        printf(\"Child %d (PID %d) starting work iteration %d\\n\", child_idx, my_pid, i + 1);\n        // Simulate CPU-bound work\n        for (long long j = 0; j < WORK_ITERATIONS_FACTOR * 5; ++j) {\n            // Do nothing, just consume CPU\n        }\n        printf(\"Child %d (PID %d) finished work iteration %d, now sleeping\\n\", child_idx, my_pid, i + 1);\n        usleep(SLEEP_MICROSECONDS); // Simulate I/O or waiting\n    }\n    printf(\"Child %d (PID %d) finished all tasks.\\n\", child_idx, my_pid);\n    exit(0);\n}\n\nint main() {\n    printf(\"Parent (PID %d) starting.\\n\", getpid());\n\n    for (int i = 0; i < N_CHILDREN; ++i) {\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process\n            child_task(i + 1);\n        }\n    }\n\n    // Parent waits for all children\n    for (int i = 0; i < N_CHILDREN; ++i) {\n        wait(NULL);\n    }\n\n    printf(\"Parent (PID %d) finished, all children done.\\n\", getpid());\n    return 0;\n}\n```\n\n**הנחות:**\n*   המערכת כוללת מעבד יחיד.\n*   אלגוריתם התזמון הוא Round Robin (RR) עם קוונטום (quantum) של `Q = 20ms`.\n*   זמן העבודה של לולאת ה-CPU הפנימית: `for (long long j = 0; j < WORK_ITERATIONS_FACTOR * 5; ++j)` צורך בדיוק `50ms` של זמן מעבד בכל פעם שהיא מבוצעת (לפני קריאה ל-`usleep`).\n*   קריאה ל-`usleep(X)` גורמת לתהליך להיחסם (blocked) בדיוק למשך `X` מיקרושניות.\n*   זמן החלפת הקשר (context switch overhead) הוא `CS_OVERHEAD_MS = 1ms`. זמן זה נכלל בחישוב הזמן הכולל ומתרחש בכל פעם שהמעבד עובר מתהליך אחד לאחר (כולל בין תהליך האב לתהליכי הבן, ובין תהליכי הבן לבין עצמם, וגם כאשר המעבד עובר ממצב סרק לתהליך או מתהליך למצב סרק).\n*   התהליכים מוכנים לריצה מיד לאחר קריאת ה-`fork`.\n*   קריאות `printf` הן מיידיות ואינן צורכות זמן מעבד משמעותי או גורמות לחסימה.\n*   תהליכי הבן נוצרים בסדר עוקב, כך ש-Child 1 נוצר ראשון, Child 2 שני, ו-Child 3 שלישי. כתוצאה מכך, הם גם יכנסו לתור ה-ready בסדר זה.\n\n**שאלה:**\nחשבו את זמן הריצה הכולל המינימלי של התוכנית מרגע תחילת ריצתה ועד להדפסת ההודעה \"Parent (PID X) finished, all children done.\", תוך פירוט שלבי התזמון, עבודת המעבד והמתנות I/O. ציינו את כל הדפסות הפלט האפשריות ואת סדר הופעתן. יש להחליף את ה-PIDs האמיתיים בתווים X, Y1, Y2, Y3 כפי שמופיע בדוגמאות הפלט.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**ניתוח וחישוב זמן הריצה הכולל:**\n\n**הגדרות וקבועים:**\n*   `N_CHILDREN = 3` (מספר תהליכי הבן)\n*   `CPU_WORK_TIME_MS = 50ms` (זמן עבודת מעבד לכל איטרציה של לולאה פנימית)\n*   `IO_WAIT_TIME_MS = 100ms` (זמן המתנת I/O בקריאה ל-`usleep`)\n*   `REPEAT_COUNT = 2` (מספר איטרציות עבודה+שינה לכל תהליך בן)\n*   `Q = 20ms` (קוונטום Round Robin)\n*   `CS_OVERHEAD_MS = 1ms` (זמן החלפת הקשר)\n\n**סה\"כ עבודת מעבד לכל תהליך בן:** `REPEAT_COUNT * CPU_WORK_TIME_MS = 2 * 50ms = 100ms`\n**סה\"כ המתנת I/O לכל תהליך בן:** `REPEAT_COUNT * IO_WAIT_TIME_MS = 2 * 100ms = 200ms`\n\n**שלבי התזמון המפורטים (ציר זמן):**\n\n*   **t=0ms:** תהליך האב (P) מתחיל, מדפיס \"Parent (PID X) starting.\".\n    *   P יוצר את C1, C2, C3. סדר יצירה: C1, C2, C3.\n    *   P נכנס ללולאת `wait` ונחסם.\n    *   תור מוכנים (Ready Queue - RQ): `[C1, C2, C3]`.\n    *   **החלפת קשר:** P -> C1 (`1ms`).\n*   **t=1ms:** C1 מתחיל לרוץ (איטרציה 1). מדפיס \"Child 1 (PID Y1) starting work iteration 1\".\n*   **t=1ms + 20ms = 21ms:** קוונטום של C1 נגמר. נותרו ל-C1 `30ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C2, C3, C1]`.\n    *   **החלפת קשר:** C1 -> C2 (`1ms`).\n*   **t=22ms:** C2 מתחיל לרוץ (איטרציה 1). מדפיס \"Child 2 (PID Y2) starting work iteration 1\".\n*   **t=22ms + 20ms = 42ms:** קוונטום של C2 נגמר. נותרו ל-C2 `30ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C3, C1, C2]`.\n    *   **החלפת קשר:** C2 -> C3 (`1ms`).\n*   **t=43ms:** C3 מתחיל לרוץ (איטרציה 1). מדפיס \"Child 3 (PID Y3) starting work iteration 1\".\n*   **t=43ms + 20ms = 63ms:** קוונטום של C3 נגמר. נותרו ל-C3 `30ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C1, C2, C3]`.\n    *   **החלפת קשר:** C3 -> C1 (`1ms`).\n*   **t=64ms:** C1 ממשיך לרוץ.\n*   **t=64ms + 20ms = 84ms:** קוונטום של C1 נגמר. נותרו ל-C1 `10ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C2, C3, C1]`.\n    *   **החלפת קשר:** C1 -> C2 (`1ms`).\n*   **t=85ms:** C2 ממשיך לרוץ.\n*   **t=85ms + 20ms = 105ms:** קוונטום של C2 נגמר. נותרו ל-C2 `10ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C3, C1, C2]`.\n    *   **החלפת קשר:** C2 -> C3 (`1ms`).\n*   **t=106ms:** C3 ממשיך לרוץ.\n*   **t=106ms + 20ms = 126ms:** קוונטום של C3 נגמר. נותרו ל-C3 `10ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C1, C2, C3]`.\n    *   **החלפת קשר:** C3 -> C1 (`1ms`).\n*   **t=127ms:** C1 ממשיך לרוץ. מסיים את `10ms` הנותרים של עבודת המעבד.\n*   **t=127ms + 10ms = 137ms:** C1 מסיים עבודת מעבד לאיטרציה 1. מדפיס \"Child 1 (PID Y1) finished work iteration 1, now sleeping\".\n    *   C1 נחסם (blocked) למשך `100ms`. יתעורר ב-`137ms + 100ms = 237ms`.\n    *   RQ: `[C2, C3]`.\n    *   **החלפת קשר:** C1 -> C2 (`1ms`).\n*   **t=138ms:** C2 ממשיך לרוץ. מסיים את `10ms` הנותרים של עבודת המעבד.\n*   **t=138ms + 10ms = 148ms:** C2 מסיים עבודת מעבד לאיטרציה 1. מדפיס \"Child 2 (PID Y2) finished work iteration 1, now sleeping\".\n    *   C2 נחסם למשך `100ms`. יתעורר ב-`148ms + 100ms = 248ms`.\n    *   RQ: `[C3]`.\n    *   **החלפת קשר:** C2 -> C3 (`1ms`).\n*   **t=149ms:** C3 ממשיך לרוץ. מסיים את `10ms` הנותרים של עבודת המעבד.\n*   **t=149ms + 10ms = 159ms:** C3 מסיים עבודת מעבד לאיטרציה 1. מדפיס \"Child 3 (PID Y3) finished work iteration 1, now sleeping\".\n    *   C3 נחסם למשך `100ms`. יתעורר ב-`159ms + 100ms = 259ms`.\n    *   RQ: `[]` (המעבד עובר למצב סרק).\n    *   **החלפת קשר:** C3 -> Idle (`1ms`).\n*   **t=160ms - t=237ms:** המעבד במצב סרק.\n\n*   **t=237ms:** C1 מתעורר ומוכן לריצה. RQ: `[C1]`.\n    *   **החלפת קשר:** Idle -> C1 (`1ms`).\n*   **t=238ms:** C1 מתחיל לרוץ (איטרציה 2). מדפיס \"Child 1 (PID Y1) starting work iteration 2\".\n*   **t=248ms:** C2 מתעורר ומוכן לריצה. RQ: `[C1, C2]`.\n*   **t=238ms + 20ms = 258ms:** קוונטום של C1 נגמר. נותרו ל-C1 `30ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C2, C1]`.\n    *   **החלפת קשר:** C1 -> C2 (`1ms`).\n*   **t=259ms:** C2 מתחיל לרוץ (איטרציה 2). מדפיס \"Child 2 (PID Y2) starting work iteration 2\".\n*   **t=259ms:** C3 מתעורר ומוכן לריצה. RQ: `[C1, C3]` (C2 רץ).\n*   **t=259ms + 20ms = 279ms:** קוונטום של C2 נגמר. נותרו ל-C2 `30ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C1, C3, C2]`.\n    *   **החלפת קשר:** C2 -> C1 (`1ms`).\n*   **t=280ms:** C1 ממשיך לרוץ.\n*   **t=280ms + 20ms = 300ms:** קוונטום של C1 נגמר. נותרו ל-C1 `10ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C3, C2, C1]`.\n    *   **החלפת קשר:** C1 -> C3 (`1ms`).\n*   **t=301ms:** C3 מתחיל לרוץ (איטרציה 2). מדפיס \"Child 3 (PID Y3) starting work iteration 2\".\n*   **t=301ms + 20ms = 321ms:** קוונטום של C3 נגמר. נותרו ל-C3 `30ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C2, C1, C3]`.\n    *   **החלפת קשר:** C3 -> C2 (`1ms`).\n*   **t=322ms:** C2 ממשיך לרוץ.\n*   **t=322ms + 20ms = 342ms:** קוונטום של C2 נגמר. נותרו ל-C2 `10ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C1, C3, C2]`.\n    *   **החלפת קשר:** C2 -> C1 (`1ms`).\n*   **t=343ms:** C1 ממשיך לרוץ. מסיים את `10ms` הנותרים של עבודת המעבד.\n*   **t=343ms + 10ms = 353ms:** C1 מסיים עבודת מעבד לאיטרציה 2. מדפיס \"Child 1 (PID Y1) finished work iteration 2, now sleeping\".\n    *   C1 נחסם למשך `100ms`. יתעורר ב-`353ms + 100ms = 453ms`.\n    *   RQ: `[C3, C2]`.\n    *   **החלפת קשר:** C1 -> C3 (`1ms`).\n*   **t=354ms:** C3 ממשיך לרוץ.\n*   **t=354ms + 20ms = 374ms:** קוונטום של C3 נגמר. נותרו ל-C3 `10ms` עבודת מעבד לאיטרציה זו.\n    *   RQ: `[C2, C3]`.\n    *   **החלפת קשר:** C3 -> C2 (`1ms`).\n*   **t=375ms:** C2 ממשיך לרוץ. מסיים את `10ms` הנותרים של עבודת המעבד.\n*   **t=375ms + 10ms = 385ms:** C2 מסיים עבודת מעבד לאיטרציה 2. מדפיס \"Child 2 (PID Y2) finished work iteration 2, now sleeping\".\n    *   C2 נחסם למשך `100ms`. יתעורר ב-`385ms + 100ms = 485ms`.\n    *   RQ: `[C3]`.\n    *   **החלפת קשר:** C2 -> C3 (`1ms`).\n*   **t=386ms:** C3 ממשיך לרוץ. מסיים את `10ms` הנותרים של עבודת המעבד.\n*   **t=386ms + 10ms = 396ms:** C3 מסיים עבודת מעבד לאיטרציה 2. מדפיס \"Child 3 (PID Y3) finished work iteration 2, now sleeping\".\n    *   C3 נחסם למשך `100ms`. יתעורר ב-`396ms + 100ms = 496ms`.\n    *   RQ: `[]` (המעבד עובר למצב סרק).\n    *   **החלפת קשר:** C3 -> Idle (`1ms`).\n*   **t=397ms - t=453ms:** המעבד במצב סרק.\n\n*   **t=453ms:** C1 מתעורר ומוכן לריצה. RQ: `[C1]`.\n    *   **החלפת קשר:** Idle -> C1 (`1ms`).\n*   **t=454ms:** C1 רץ. מדפיס \"Child 1 (PID Y1) finished all tasks.\". C1 מסיים ויוצא.\n    *   P מקבל הודעה על יציאת C1, אך עדיין ממתין ל-C2 ו-C3.\n    *   RQ: `[]` (המעבד עובר למצב סרק).\n    *   **החלפת קשר:** C1 -> Idle (`1ms`).\n*   **t=455ms - t=485ms:** המעבד במצב סרק.\n\n*   **t=485ms:** C2 מתעורר ומוכן לריצה. RQ: `[C2]`.\n    *   **החלפת קשר:** Idle -> C2 (`1ms`).\n*   **t=486ms:** C2 רץ. מדפיס \"Child 2 (PID Y2) finished all tasks.\". C2 מסיים ויוצא.\n    *   P מקבל הודעה על יציאת C2, אך עדיין ממתין ל-C3.\n    *   RQ: `[]` (המעבד עובר למצב סרק).\n    *   **החלפת קשר:** C2 -> Idle (`1ms`).\n*   **t=487ms - t=496ms:** המעבד במצב סרק.\n\n*   **t=496ms:** C3 מתעורר ומוכן לריצה. RQ: `[C3]`.\n    *   **החלפת קשר:** Idle -> C3 (`1ms`).\n*   **t=497ms:** C3 רץ. מדפיס \"Child 3 (PID Y3) finished all tasks.\". C3 מסיים ויוצא.\n    *   P מקבל הודעה על יציאת C3. P סיים להמתין ומוכן לריצה. RQ: `[P]`.\n    *   **החלפת קשר:** C3 -> P (`1ms`).\n*   **t=498ms:** P רץ. מדפיס \"Parent (PID X) finished, all children done.\". P מסיים ויוצא.\n\n**זמן הריצה הכולל המינימלי של התוכנית:** `498ms`.\n\n**סה\"כ החלפות קשר:** 24 החלפות קשר (כולל החלפות מ/אל מצב סרק). `24 * 1ms = 24ms` זמן תקורה.\n\n**סדר הדפסות הפלט האפשרי (כולל זמנים משוערים):**\n\n1.  `t=0ms: Parent (PID X) starting.`\n2.  `t=1ms: Child 1 (PID Y1) starting work iteration 1`\n3.  `t=22ms: Child 2 (PID Y2) starting work iteration 1`\n4.  `t=43ms: Child 3 (PID Y3) starting work iteration 1`\n5.  `t=137ms: Child 1 (PID Y1) finished work iteration 1, now sleeping`\n6.  `t=148ms: Child 2 (PID Y2) finished work iteration 1, now sleeping`\n7.  `t=159ms: Child 3 (PID Y3) finished work iteration 1, now sleeping`\n8.  `t=238ms: Child 1 (PID Y1) starting work iteration 2`\n9.  `t=259ms: Child 2 (PID Y2) starting work iteration 2`\n10. `t=301ms: Child 3 (PID Y3) starting work iteration 2`\n11. `t=353ms: Child 1 (PID Y1) finished work iteration 2, now sleeping`\n12. `t=385ms: Child 2 (PID Y2) finished work iteration 2, now sleeping`\n13. `t=396ms: Child 3 (PID Y3) finished work iteration 2, now sleeping`\n14. `t=454ms: Child 1 (PID Y1) finished all tasks.`\n15. `t=486ms: Child 2 (PID Y2) finished all tasks.`\n16. `t=497ms: Child 3 (PID Y3) finished all tasks.`\n17. `t=498ms: Parent (PID X) finished, all children done.`\n"
    },
    "difficulty_estimation": "Hard"
  }
}