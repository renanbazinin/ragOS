{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 23:38:35",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4084,
      "output_tokens": 4106,
      "total_tokens": 25476
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "File Systems",
      "I/O",
      "Journaling",
      "Crash Consistency"
    ],
    "content": {
      "text": "נתונה מערכת קבצים VSFS משופרת המשתמשת ב-metadata journaling (בדומה למצב Ordered ב-ext3), ובהתאם לכך, נתוני קבצים נכתבים למיקומם הסופי בדיסק לפני כתיבת ה-metadata המעודכן ל-journal.\nנתונים נוספים על מערכת הקבצים:\n- גודל בלוק: 4KB (4096 בתים).\n- גודל inode: 256 בתים.\n- כל inode מכיל 64 בתים עבור נתוני קבצים קטנים (in-inode data).\n- כל inode מכיל 10 מצביעים ישירים, מצביע עקיף יחיד אחד, ומצביע עקיף כפול אחד. גודל מצביע הוא 4 בתים.\n- רשומות תיקייה: כל רשומה מכילה את שם הקובץ (עד 255 תווים) ומספר ה-inode של הקובץ, המיוצג על ידי 2 בתים בלבד.\n- תיקיות מאורגנות כרשימה מקושרת של בלוקי נתונים, כאשר כל בלוק מכיל מספר רשומות תיקייה. ה-inode של התיקייה מצביע על הבלוק הראשון ברשימה וכן מכיל מצביע לבלוק האחרון.\n\nנתוני דיסק:\n- מהירות סיבוב: 7200 RPM.\n- זמן Seek ממוצע: 10ms.\n- קצב העברה מקסימלי: 2 MB/s.\n\nיש לפרט ולנמק את כל החישובים בכל סעיף.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "משתמש יוצר קובץ חדש וריק בשם `new_file.txt` בתיקייה `home/user/documents/`. ידוע כי התיקייה `documents` מלאה ודורשת הקצאת בלוק נתונים חדש עבור רשומת הקובץ החדש. הקובץ `new_file.txt` הוא קטן ולכן נתוניו נשמרים בתוך ה-inode שלו (in-inode data).\nתארו את רצף הפעולות הקריטיות על הדיסק (כתיבות ועדכונים, כולל ל-journal) הנדרשות לפעולה זו, ובאיזה שלב קריסה עלולה לגרום לחוסר עקביות במערכת הקבצים (File System Corruption), למרות השימוש ב-metadata journaling. הסבירו מדוע, והציעו פתרון לבעיה זו.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "משתמש מבצע פעולת קריאה של 100KB מתוך קובץ גדול (מעל 1MB) שמתחילה ב-offset 0. הקובץ נמצא בנתיב `home/user/big_data/very_important_file.bin`.\nנתון כי כל ה-inodes ובלוקי הנתונים של התיקיות בנתיב (home, user, big_data) נמצאים ב-cache. ה-inode של `very_important_file.bin` אינו ב-cache, ובלוקי הנתונים של הקובץ אינם ב-cache. ניתן להניח כי בלוקי הנתונים של הקובץ מפוזרים באופן אקראי על הדיסק.\nמהו הזמן המינימלי והמקסימלי שתיקח פעולת קריאה זו? יש לפרט את כל החישובים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "מהו המספר המקסימלי של קבצים שתיקייה בודדת יכולה להכיל במערכת קבצים זו? יש לפרט את כל החישובים וההנחות.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון שאלה 1:\n\nחישובים כלליים:\nזמן סיבוב מלא: 1 / (7200 RPM / 60) = 1 / 120 = 8.333ms.\nזמן סיבוב ממוצע (חצי סיבוב): 8.333ms / 2 = 4.167ms.\nזמן העברת בלוק 4KB: (4KB / 2MB/s) = (4KB / 2048KB/s) = 1/512 s = 1.953ms.\n\n1.1. יצירת קובץ חדש וריק בתיקייה הדורשת בלוק נתונים חדש:\nרצף הפעולות הקריטיות על הדיסק (במצב Ordered journaling, שבו נתוני קבצים נכתבים לדיסק לפני ה-metadata המעודכן ל-journal, ובלוקי תיקייה נחשבים כנתונים):\n1.  הקצאת inode חדש (עדכון inode bitmap בזיכרון).\n2.  הקצאת בלוק נתונים חדש (בלוק תיקייה) (עדכון data bitmap בזיכרון).\n3.  **כתיבת בלוק הנתונים החדש של התיקייה למיקומו הסופי בדיסק.** בלוק זה יכיל את רשומת הקובץ `new_file.txt` ואת המצביע לבלוק הבא ברשימה המקושרת של התיקייה (אם יש).\n4.  כתיבת ה-inode החדש של `new_file.txt` למיקומו הסופי בדיסק (מכיל את נתוני הקובץ הקטנים).\n5.  עדכון בלוק הנתונים ה'אחרון' הקודם של התיקייה בזיכרון, כך שיצביע על בלוק הנתונים החדש שהוקצה (כדי לחבר אותו לרשימה המקושרת).\n6.  עדכון ה-inode של התיקייה `documents` בזיכרון (גודל, זמן שינוי).\n7.  **שלב ה-Journaling (כתיבת טרנזקציה ללוג):**\n    א.  כתיבת `TxB` (Transaction Begin) ל-journal.\n    ב.  כתיבת עדכון ל-`inode bitmap` ל-journal.\n    ג.  כתיבת עדכון ל-`data bitmap` ל-journal.\n    ד.  כתיבת תוכן ה-`new_inode` של `new_file.txt` ל-journal.\n    ה.  כתיבת תוכן בלוק הנתונים ה'אחרון' הקודם (לאחר עדכון המצביע) ל-journal.\n    ו.  כתיבת תוכן ה-`inode` של התיקייה `documents` (לאחר העדכונים) ל-journal.\n    ז.  כתיבת `TxE` (Transaction End) ל-journal.\n8.  ביצוע `fsync` על ה-journal (לוודא שהטרנזקציה כולה נכתבה לדיסק).\n9.  כתיבת ה-metadata המעודכן (ביטמאפים, inode חדש, inode תיקייה, בלוק קודם של תיקייה) למיקומם הסופי בדיסק.\n10. עדכון ה-superblock של ה-journal לציון שהטרנזקציה בוצעה בהצלחה (Commit).\n\n**שלב קריטי ובעיה:**\nקריסה עלולה לגרום לחוסר עקביות במערכת הקבצים אם היא מתרחשת **לאחר שלב 3 (כתיבת בלוק הנתונים החדש של התיקייה למיקומו הסופי בדיסק) אך לפני שלב 8 (סיום כתיבת הטרנזקציה המלאה ל-journal וביצוע fsync)**. במצב זה:\n-   בלוק הנתונים החדש של התיקייה, המכיל את רשומת `new_file.txt`, נכתב לדיסק.\n-   אך הטרנזקציה ב-journal אינה שלמה (או שעדיין לא בוצע לה `fsync`), ולכן מערכת הקבצים לא תדע על הבלוק הזה כחלק מהתיקייה על שחזור המערכת.\n-   על שחזור המערכת, ה-journal יתעלם מהפעולה הלא גמורה (או יחזיר את ה-metadata למצב הקודם). כתוצאה מכך, בלוק הנתונים החדש של התיקייה יהפוך לבלוק יתום (orphaned block) שאינו מקושר לשום תיקייה, ורשומת הקובץ החדש תאבד. זהו חוסר עקביות במערכת הקבצים (File System Corruption) מכיוון שיש בלוק מסומן כתפוס אך לא נגיש.\n\n**פתרון מוצע:**\nכדי למנוע בעיה זו במצב metadata journaling (Ordered mode), יש להבטיח שבלוקי הנתונים של התיקייה (שנחשבים כנתונים במצב זה, אך מכילים metadata-like entries) ייכתבו למיקומם הסופי בדיסק רק *לאחר* שהטרנזקציה המלאה שמתארת את השינויים בתיקייה (כולל קישור לבלוק החדש) נכתבה ל-journal ובוצעה לה `fsync`. כלומר, יש לשנות את סדר הכתיבה לדיסק כך ששלב 3 יתבצע רק *לאחר* שלב 8. לחילופין, ניתן להשתמש במצב journaling מלא (data journaling) שבו גם בלוקי הנתונים נכתבים ל-journal, אך זה פוגע בביצועים.\n\n1.2. זמן קריאת 100KB מקובץ גדול:\n\nנתונים:\nקריאת 100KB = 25 בלוקים (100KB / 4KB/בלוק).\n\n**זמן מינימלי:**\nבתרחיש המינימלי, ה-inode של הקובץ וכל 25 בלוקי הנתונים נמצאים ברצף על הדיסק.\n1.  **קריאת inode הקובץ:**\n    *   זמן Seek: 10ms.\n    *   זמן Rotational Latency ממוצע: 4.167ms.\n    *   זמן העברת בלוק (4KB): 1.953ms.\n    *   סה\"כ לקריאת inode: 10 + 4.167 + 1.953 = 16.120ms.\n2.  **קריאת 25 בלוקי נתונים רציפים:**\n    *   מכיוון שהבלוקים רציפים, נניח Seek ו-Rotational Latency יחידים עבור כלל 25 הבלוקים (הם מיד אחרי ה-inode או במיקום רציף אחר).\n    *   זמן Seek: 10ms.\n    *   זמן Rotational Latency ממוצע: 4.167ms.\n    *   זמן העברת 100KB (25 בלוקים): 100KB / (2MB/s) = 48.828ms.\n    *   סה\"כ לקריאת נתונים: 10 + 4.167 + 48.828 = 62.995ms.\n**סה\"כ זמן מינימלי:** 16.120ms (inode) + 62.995ms (נתונים) = **79.115ms**.\n\n**זמן מקסימלי:**\nבתרחיש המקסימלי, ה-inode של הקובץ וכל 25 בלוקי הנתונים מפוזרים באופן אקראי על הדיסק, כך שכל גישה לבלוק דורשת Seek ו-Rotational Latency ממוצעים חדשים.\n1.  **קריאת inode הקובץ:**\n    *   זמן Seek: 10ms.\n    *   זמן Rotational Latency ממוצע: 4.167ms.\n    *   זמן העברת בלוק (4KB): 1.953ms.\n    *   סה\"כ לקריאת inode: 10 + 4.167 + 1.953 = 16.120ms.\n2.  **קריאת 25 בלוקי נתונים מפוזרים:**\n    *   כל בלוק דורש: Seek + Rotational Latency + זמן העברת בלוק.\n    *   זמן לבלוק יחיד: 10 + 4.167 + 1.953 = 16.120ms.\n    *   סה\"כ ל-25 בלוקים: 25 * 16.120ms = 403.000ms.\n**סה\"כ זמן מקסימלי:** 16.120ms (inode) + 403.000ms (נתונים) = **419.120ms**.\n\n1.3. מספר קבצים מקסימלי בתיקייה בודדת:\n\n**הגבלה על ידי מספר ה-inodes הכולל במערכת:**\nרשומת תיקייה מכילה מספר inode המיוצג על ידי 2 בתים בלבד. משמעות הדבר היא שמספר ה-inodes הכולל שניתן לייצג במערכת הקבצים מוגבל ל-2^16 = 65,536 inodes. לכן, תיקייה בודדת לא יכולה להכיל יותר מ-65,536 קבצים, גם אם מבנה התיקייה מאפשר אחסון של יותר רשומות.\n\n**הגבלה על ידי מבנה התיקייה (רשימה מקושרת של בלוקים):**\n*   **גודל רשומת תיקייה:** שם קובץ (עד 255 בתים) + מספר inode (2 בתים) = 257 בתים לרשומה (בהנחה של שם קובץ מקסימלי).\n*   **מספר רשומות לבלוק נתונים:** גודל בלוק (4096 בתים) / גודל רשומה (257 בתים) = 15.93, כלומר 15 רשומות לבלוק (יש לעגל למטה).\n*   **מספר בלוקי נתונים ש-inode של תיקייה יכול להצביע עליהם:**\n    *   מספר מצביעים בבלוק מצביעים: 4096 בתים / 4 בתים/מצביע = 1024 מצביעים.\n    *   מצביעים ישירים: 10 בלוקים.\n    *   מצביע עקיף יחיד: 1 בלוק מצביעים, שיכול להצביע על 1024 בלוקי נתונים.\n    *   מצביע עקיף כפול: 1 בלוק מצביעים, שיכול להצביע על 1024 בלוקי מצביעים, שכל אחד מהם מצביע על 1024 בלוקי נתונים. סה\"כ 1024 * 1024 = 1,048,576 בלוקי נתונים.\n    *   סה\"כ בלוקי נתונים מקסימליים לתיקייה: 10 (ישיר) + 1024 (עקיף יחיד) + 1,048,576 (עקיף כפול) = 1,049,610 בלוקים.\n*   **מספר קבצים מקסימלי לפי מבנה התיקייה:** 1,049,610 בלוקים * 15 רשומות/בלוק = 15,744,150 קבצים.\n\n**סיכום:**\nהמספר המקסימלי של קבצים שתיקייה בודדת יכולה להכיל במערכת קבצים זו הוא **65,536 קבצים**. הגבלה זו נובעת ממספר ה-inodes הכולל המוגבל על ידי גודל שדה ה-inode number ברשומות התיקייה (2 בתים), שהוא קטן יותר מהמספר המקסימלי של קבצים שמבנה התיקייה יכול להכיל.\n"
    },
    "difficulty_estimation": "Hard"
  }
}