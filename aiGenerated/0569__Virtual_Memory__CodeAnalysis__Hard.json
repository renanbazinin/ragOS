{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:46:55",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3618,
      "output_tokens": 3265,
      "total_tokens": 14387
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Paging",
      "TLB",
      "Cache Locality"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשתמשת בזיכרון וירטואלי עם גודל עמוד של 4KB. יחידת הניהול זיכרון (MMU) כוללת TLB בגודל 64 כניסות, בעל אסוציאטיביות של 4-way (כלומר, 16 סטים, כל סט מכיל 4 כניסות). נניח שהמערכת משתמשת באלגוריתם החלפת עמודים LRU. המערך הגלובלי מאותחל לאפסים לפני הפעלת הפונקציות.\n\nנתונה תוכנית C המגדירה מערך דו-ממדי גדול מאוד בגודל `SIZE x SIZE` של מספרים שלמים (int). שתי פונקציות, `funcA` ו-`funcB`, מתוכננות לעבד את המערך:\n",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n\n#define SIZE 2048 // 2048x2048 matrix\n\nint matrix[SIZE][SIZE]; // Global array, initialized to zeros\n\nvoid funcA() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            matrix[i][j] = i + j; // Row-major access\n        }\n    }\n}\n\nvoid funcB() {\n    for (int j = 0; j < SIZE; j++) {\n        for (int i = 0; i < SIZE; i++) {\n            matrix[i][j] = i + j; // Column-major access\n        }\n    }\n}\n\nint main() {\n    // Example usage:\n    // funcA();\n    // funcB();\n    return 0;\n}\n",
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "השוו בין `funcA` ל-`funcB` מבחינת מספר ה-Page Faults הצפוי בעת גישה למערך. נמקו את תשובתכם בהתבסס על גודל העמוד הנתון (4KB).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "השוו בין `funcA` ל-`funcB` מבחינת ביצועי ה-TLB (Translation Lookaside Buffer). איזו פונקציה תסבול מפחות TLB misses? נמקו את תשובתכם בהתבסס על גודל ה-TLB הנתון (64 כניסות, 4-way associative).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "כיצד שינוי בגודל העמוד ל-16KB (במקום 4KB) ישפיע על ביצועי שתי הפונקציות ביחס ל-Page Faults? נמקו את תשובתכם.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": 25,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "נתונים: \nגודל המערך: `SIZE x SIZE` = `2048 x 2048` אינטגרים.\nגודל `int`: 4 בתים.\nגודל כולל של המערך: `2048 * 2048 * 4` בתים = `16,777,216` בתים = `16 MB`.\nגודל עמוד: `4 KB` = `4096` בתים.\nמספר אינטגרים בעמוד: `4096 / 4 = 1024` אינטגרים.\nגודל שורה במערך: `2048 * 4` בתים = `8192` בתים = `8 KB`.\nTLB: 64 כניסות, 4-way associative.\n\n**1.1 השוואה בין `funcA` ל-`funcB` מבחינת Page Faults (גודל עמוד 4KB):**\n\n*   **`funcA` (גישה לפי שורות - row-major):**\n    הלולאה הפנימית (`for j`) סורקת את כל האיברים בשורה מסוימת (`matrix[i][0]` עד `matrix[i][SIZE-1]`). שורה אחת היא בגודל `8 KB`. מכיוון שגודל העמוד הוא `4 KB`, כל שורה מתפרסת על פני `8KB / 4KB = 2` עמודים. כאשר `funcA` ניגשת לשורה חדשה `i`, יש צורך לטעון את 2 העמודים המכילים את השורה לזיכרון הפיזי (אם אינם כבר שם). לאחר טעינת העמודים, כל הגישות הבאות לאיברים באותה שורה יהיו Page Hits. \n    מספר ה-Page Faults הצפוי: `SIZE` (מספר שורות) * `2` (עמודים לשורה) = `2048 * 2 = 4096` Page Faults.\n    זהו מספר נמוך יחסית ויעיל, מכיוון שהגישה היא סדרתית (sequential) בתוך העמודים, וניצול ה-Spatial Locality (עקרון המיקום המרחבי) הוא גבוה.\n\n*   **`funcB` (גישה לפי עמודות - column-major):**\n    הלולאה הפנימית (`for i`) סורקת את האיברים לאורך עמודה מסוימת (`matrix[0][j]` עד `matrix[SIZE-1][j]`). כל גישה `matrix[i][j]` ו-`matrix[i+1][j]` מרוחקות בזיכרון ב-`SIZE * sizeof(int)` בתים = `2048 * 4 = 8192` בתים (`8 KB`). מכיוון שגודל העמוד הוא `4 KB`, כל גישה כזו (`matrix[i][j]`) תהיה כמעט בוודאות על עמוד שונה מהגישה הקודמת (`matrix[i-1][j]`). לכן, עבור כל אינטגר שניגשים אליו, סביר מאוד שיתרחש Page Fault. \n    מספר ה-Page Faults הצפוי: `SIZE` (מספר עמודות) * `SIZE` (מספר שורות) = `2048 * 2048 = 4,194,304` Page Faults.\n    זהו מספר גבוה מאוד ולא יעיל, מכיוון שהגישה היא לא סדרתית בתוך העמודים, וניצול ה-Spatial Locality הוא נמוך מאוד. כל גישה גורמת ל-Jump לכתובת רחוקה בזיכרון, מה שמחייב טעינת עמוד חדש כמעט בכל פעם.\n\n**מסקנה:** `funcA` תגרום למספר נמוך בהרבה של Page Faults בהשוואה ל-`funcB`.\n\n**1.2 השוואה בין `funcA` ל-`funcB` מבחינת ביצועי TLB (גודל TLB 64 כניסות, 4-way associative):**\n\n*   **`funcA` (גישה לפי שורות):**\n    כפי שצוין, כל שורה מתפרסת על 2 עמודים, ולכן דורשת 2 כניסות ב-TLB. ה-TLB יכול להכיל 64 כניסות, מה שמספיק ל-`64 / 2 = 32` שורות בו-זמנית. כאשר `funcA` ניגשת לשורה חדשה `i`, תתרחשנה 2 TLB misses עבור 2 העמודים של השורה. לאחר מכן, הגישות לאיברים באותה שורה יהיו TLB hits. לאחר 32 שורות, ה-TLB יתמלא, וכניסות ישנות יוחלפו (לפי LRU). מכיוון שכל שורה נסרקת במלואה, ורק 2 כניסות TLB נדרשות עבורה, רוב הגישות בתוך השורה ייהנו מ-TLB hits. מספר ה-TLB misses יהיה בערך `SIZE * 2 = 4096` (כל פעם ששורה חדשה נטענת ל-TLB בפעם הראשונה).\n    זהו מספר יעיל ומינימלי ביחס למספר העמודים הכולל.\n\n*   **`funcB` (גישה לפי עמודות):**\n    כל גישה ל-`matrix[i][j]` עבור `i` משתנה, ניגשת לעמוד זיכרון שונה. לכן, כמעט כל גישה `matrix[i][j]` תגרום ל-TLB miss. ה-TLB יכול להכיל רק 64 כניסות. הפונקציה ניגשת ל-`SIZE` (`2048`) איברים בעמודה אחת, כאשר כל אחד מהם נמצא בעמוד שונה. זה אומר שלאחר 64 גישות, ה-TLB יהיה מלא וכניסות ישנות יוחלפו. הגישה הבאה תהיה לכתובת שאינה ב-TLB, ותגרום ל-TLB miss נוסף. \n    מספר ה-TLB misses הצפוי: `SIZE * SIZE = 2048 * 2048 = 4,194,304` TLB misses.\n    זהו מספר גבוה מאוד ולא יעיל, בדומה ל-Page Faults, עקב חוסר ניצול ה-Spatial Locality.\n\n**מסקנה:** `funcA` תגרום למספר נמוך בהרבה של TLB misses בהשוואה ל-`funcB`.\n\n**1.3 השפעת שינוי גודל העמוד ל-16KB על Page Faults:**\n\n*   גודל עמוד חדש: `16 KB`.\n    גודל שורה במערך: `8 KB`.\n\n*   **`funcA` (גישה לפי שורות):**\n    כעת, שורה אחת בגודל `8 KB` נכנסת במלואה לעמוד יחיד בגודל `16 KB`. לכן, כאשר `funcA` ניגשת לשורה חדשה `i`, יש צורך לטעון רק עמוד אחד לזיכרון הפיזי (אם אינו כבר שם). \n    מספר ה-Page Faults הצפוי: `SIZE` (מספר שורות) * `1` (עמוד לשורה) = `2048 * 1 = 2048` Page Faults.\n    זהו שיפור משמעותי לעומת 4KB עמודים (4096 Page Faults), מכיוון שהעמודים הגדולים יותר מנצלים טוב יותר את ה-Spatial Locality של הגישה הטורית בשורות.\n\n*   **`funcB` (גישה לפי עמודות):**\n    כל גישה `matrix[i][j]` ו-`matrix[i+1][j]` מרוחקות בזיכרון ב-`8192` בתים (`8 KB`). מכיוון שגודל העמוד החדש הוא `16 KB`, שתי גישות עוקבות אלו (`matrix[i][j]` ו-`matrix[i+1][j]`) יכולות כעת להימצא באותו עמוד פיזי (אם העמוד התחיל בכתובת מתאימה, למשל `matrix[i][j]` ב-offset 0 של העמוד ו-`matrix[i+1][j]` ב-offset `8KB` של אותו עמוד). כלומר, כל שני אינטגרים עוקבים בעמודה (לדוגמה `matrix[0][j]` ו-`matrix[1][j]`) יגרמו יחד ל-Page Fault אחד. \n    מספר ה-Page Faults הצפוי: `(SIZE * SIZE) / 2` = `(2048 * 2048) / 2 = 2,097,152` Page Faults.\n    זהו שיפור לעומת 4KB עמודים (4,194,304 Page Faults), אך עדיין מספר גבוה מאוד ולא יעיל בהשוואה ל-`funcA`. הגדלת גודל העמוד עזרה ל-`funcB` מכיוון שכעת כל עמוד מכיל יותר נתונים, ולכן יש סיכוי טוב יותר שגישות לא רציפות יפלו באותו עמוד.\n\n**מסקנה כוללת:** הגדלת גודל העמוד ל-16KB משפרת את ביצועי שתי הפונקציות מבחינת Page Faults, אך `funcA` ממשיכה להיות יעילה בהרבה מ-`funcB`, והשיפור היחסי ב-`funcA` גדול יותר (חצי מ-Page Faults, בעוד שב-`funcB` גם חצי, אך עדיין מיליונים)."
    },
    "difficulty_estimation": "Hard"
  }
}