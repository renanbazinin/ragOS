{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:23:53",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3498,
      "output_tokens": 2931,
      "total_tokens": 12154
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "System Calls",
      "Process Management",
      "File I/O"
    ],
    "content": {
      "text": "נתונה תוכנית C המבצעת פעולות מערכת הקשורות לניהול תהליכים וקלט/פלט קבצים. התוכנית פותחת קובץ, יוצרת מספר תהליכי בן באמצעות `fork()`, וכל תהליך בן כותב הודעה ייחודית לקובץ באמצעות מזהה הקובץ (file descriptor) שירש מהאב. לאחר מכן, תהליך האב ממתין לסיום כל תהליכי הבן, מאפס את מצביע הקובץ לתחילתו, וקורא את כל תוכן הקובץ.\n\nנתח את הקוד המצורף וענה על השאלות הבאות:\n\n1.  **תוכן הקובץ:** מה יהיה התוכן הסופי של הקובץ `output.txt` בסיום ריצת התוכנית? האם ניתן לחזות את הסדר המדויק של ההודעות? נמק היטב.\n2.  **הסבר מנגנוני מערכת:** הסבר מדוע מתקבל תוכן כזה, תוך התייחסות למנגנוני מערכת ההפעלה הקשורים ל- `fork()`, מזהי קבצים (file descriptors), וקובץ הפתוח בטבלת הקבצים של הקרנל (file table entry) כולל מצביעי קובץ (file offsets) משותפים/נפרדים.\n3.  **פתרון לבעיה:** הצע שינוי בקוד (או תאר את השינוי הנדרש) שיבטיח שכל תהליך בן יכתוב לחלק נפרד ולא חופף בקובץ, וזאת *מבלי* לפתוח מחדש את הקובץ בכל תהליך בן. הסבר את הפתרון והצג את השינוי הרלוונטי בקוד.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <string.h>\n#include <fcntl.h> // For open flags\n\n#define NUM_CHILDREN 3\n#define FILENAME \"output.txt\"\n\nint main() {\n    int fd;\n    pid_t pid;\n    char buffer[100];\n    int i;\n\n    // Open the file for writing. If it exists, truncate it.\n    fd = open(FILENAME, O_CREAT | O_TRUNC | O_WRONLY, 0644);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Parent PID: %d\\n\", getpid());\n\n    for (i = 0; i < NUM_CHILDREN; i++) {\n        pid = fork();\n\n        if (pid == -1) {\n            perror(\"fork\");\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) { // Child process\n            sprintf(buffer, \"Child %d (PID %d) writing message %d.\\n\", i + 1, getpid(), i + 1);\n            ssize_t bytes_written = write(fd, buffer, strlen(buffer));\n            if (bytes_written == -1) {\n                perror(\"child write\");\n            }\n            // Child exits after writing\n            _exit(EXIT_SUCCESS); // Use _exit to avoid flushing parent's stdio buffers\n        }\n    }\n\n    // Parent waits for all children\n    for (i = 0; i < NUM_CHILDREN; i++) {\n        wait(NULL);\n    }\n    printf(\"All children finished.\\n\");\n\n    // Parent reads the file content\n    // First, rewind the file pointer to the beginning\n    off_t seek_result = lseek(fd, 0, SEEK_SET);\n    if (seek_result == -1) {\n        perror(\"parent lseek\");\n        close(fd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"\\nFile content after all writes:\\n\");\n    ssize_t bytes_read;\n    while ((bytes_read = read(fd, buffer, sizeof(buffer) - 1)) > 0) {\n        buffer[bytes_read] = '\\0'; // Null-terminate the read data\n        printf(\"%s\", buffer);\n    }\n    if (bytes_read == -1) {\n        perror(\"parent read\");\n    }\n\n    close(fd);\n    printf(\"File descriptor closed.\\n\");\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **תוכן הקובץ:**\n    התוכן הסופי של הקובץ `output.txt` יכלול את כל ההודעות מכל תהליכי הבן, אך **בסדר לא דטרמיניסטי** (לא ניתן לחזות מראש את סדר ההודעות). עם זאת, כל ההודעות יופיעו בקובץ במלואן, **זו אחר זו, ללא חפיפה**. כלומר, כל הודעה תתחיל מהנקודה שבה הסתיימה ההודעה הקודמת שנכתבה (על ידי כל תהליך בן אחר). הסיבה לכך היא שמצביע הקובץ (file offset) **משותף** בין תהליך האב לתהליכי הבן לאחר `fork()`.\n    לדוגמה, אם Child 1 כותב \"Child 1...\", ואז Child 2 כותב \"Child 2...\", ההודעה של Child 2 תופיע מיד אחרי ההודעה של Child 1. הסדר שבו ההודעות של הילדים השונים מופיעות בקובץ הוא הלא דטרמיניסטי.\n\n2.  **הסבר מנגנוני מערכת:**\n    *   כאשר תהליך האב מבצע `open()`, נוצר מזהה קובץ (file descriptor) חדש. מזהה זה הוא אינדקס לטבלת מזהי הקבצים הייחודית לתהליך (per-process file descriptor table).\n    *   ערך זה בטבלת מזהי הקבצים, בתורו, מצביע על ערך בטבלת הקבצים של הקרנל (per-system/kernel file table entry). ערך זה בטבלה מכיל מידע על הקובץ הפתוח, כולל מצביע הקובץ הנוכחי (current file offset), מצביעי הגישה (read/write access modes), וספירת התייחסויות (reference count).\n    *   כאשר מתבצעת קריאת המערכת `fork()`, תהליך הבן מקבל עותק של טבלת מזהי הקבצים של האב. עם זאת, מזהי הקבצים המועתקים בטבלת הבן **מצביעים על אותם ערכים בטבלת הקבצים של הקרנל** כמו אלה של האב. הם אינם מקבלים עותק נפרד של ה-file table entry.\n    *   משמעות הדבר היא שכל תהליכי הבן, וכן תהליך האב, חולקים את אותו מצביע קובץ (file offset) עבור הקובץ `output.txt`. זהו מצב של \"copy-on-fork\" עבור טבלת מזהי הקבצים, אך \"share-on-fork\" עבור ה-file table entries.\n    *   לכן, כאשר תהליך בן כלשהו קורא או כותב לקובץ, מצביע הקובץ המשותף מתקדם. תהליך הבן הבא שיכתוב יתחיל לכתוב מהמיקום החדש של מצביע הקובץ, ובכך נמנעת דריסה חלקית של נתונים.\n    *   הסדר הלא דטרמיניסטי של ההודעות בקובץ נובע מכך שתזמון המעבדים (CPU scheduling) קובע איזה תהליך בן יקבל את המעבד ויבצע את קריאת ה- `write()` בכל רגע נתון. אין ערובה לסדר ביצוע בין תהליכים נפרדים.\n\n3.  **פתרון לבעיה:**\n    כדי להבטיח שכל תהליך בן יכתוב לחלק נפרד ולא חופף בקובץ מבלי לפתוח מחדש את הקובץ, ניתן להשתמש בקריאת המערכת `lseek()` לפני כל פעולת כתיבה. כל תהליך בן יכול לחשב את המיקום הייחודי שלו בקובץ (לדוגמה, על בסיס האינדקס של הבן `i` או ה-PID שלו, בתוספת אורך ההודעות הקודמות). יש לוודא שהאורך המקסימלי של הודעה ידוע מראש או מחושב באופן דינמי כדי להבטיח מרווחים מספקים.\n\n    **שינוי בקוד (בתוך בלוק ה-`else if (pid == 0)`):**\n    נניח אורך מקסימלי קבוע להודעה, למשל 60 בתים (כולל תו רווח ושורת סיום). כל תהליך בן יקבל בלוק כתיבה במיקום ייחודי.\n\n    ```c\n    else if (pid == 0) { // Child process\n        // Calculate a unique offset for each child based on its index (i)\n        // We assume a fixed maximum message length (e.g., 60 bytes) for simplicity.\n        // In a real-world scenario, dynamic allocation or more robust coordination\n        // (e.g., using file locks or IPC for offset management) might be needed.\n        int child_index = i; // 0, 1, 2\n        off_t desired_offset = child_index * 60; // 0, 60, 120\n\n        // Move the file pointer to the unique offset for this child\n        if (lseek(fd, desired_offset, SEEK_SET) == -1) {\n            perror(\"child lseek\");\n            _exit(EXIT_FAILURE);\n        }\n\n        sprintf(buffer, \"Child %d (PID %d) writing message %d at offset %ld.\\n\", i + 1, getpid(), i + 1, (long)desired_offset);\n        ssize_t bytes_written = write(fd, buffer, strlen(buffer));\n        if (bytes_written == -1) {\n            perror(\"child write\");\n        }\n        _exit(EXIT_SUCCESS);\n    }\n    ```\n\n    **הסבר הפתרון:**\n    לפני שכל תהליך בן כותב, הוא מזיז את מצביע הקובץ באמצעות `lseek()` למיקום מחושב מראש שמיועד לו. לדוגמה, אם יש 3 בנים וכל הודעה היא באורך מקסימלי של 60 בתים, הבן עם אינדקס `i=0` יכתוב ממיקום 0, הבן עם `i=1` ממיקום 60, והבן עם `i=2` ממיקום 120. זה מבטיח שהכתיבות לא ידרסו זו את זו, וכל הודעה תשמור על מיקומה הייחודי. השימוש ב-`lseek()` מאפשר לתהליכים שחולקים את אותו file table entry לגשת למיקומים שונים בקובץ באופן עצמאי לפני כל פעולת כתיבה. יש לוודא שהקובץ גדול מספיק כדי להכיל את כל הכתיבות במיקומים אלו. אם המיקום המבוקש רחוק מה-EOF הנוכחי, `lseek` יכול ליצור \"חורים\" (sparse file) בקובץ, ופעולת ה-`write` תמלא אותם."
    },
    "difficulty_estimation": "Hard"
  }
}