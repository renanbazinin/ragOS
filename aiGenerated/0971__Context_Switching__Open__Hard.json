{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:12:47",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3023,
      "output_tokens": 3037,
      "total_tokens": 11015
    }
  },
  "question": {
    "id": 1001,
    "type": "Open",
    "topic": [
      "Context Switching",
      "Threads",
      "Operating System Internals",
      "Performance"
    ],
    "content": {
      "text": "נתון קטע קוד C++ המשתמש בספריית pthreads ליצירת חוטים. נניח שחוט `thread_A` ו-`thread_B` רצים על מעבד יחיד. אנו מתעלמים מפרטי מימוש ספציפיים של `std::thread` ומתייחסים אליו כאל חוט ברמת ליבה (kernel-level thread).\n```c++\n#include <iostream>\n#include <thread>\n#include <vector>\n#include <unistd.h> // For usleep\n\nvoid thread_function(int id) {\n    std::cout << \"Thread \" << id << \" started.\" << std::endl;\n    // Simulate some work or I/O\n    for (int i = 0; i < 5; ++i) {\n        std::cout << \"Thread \" << id << \" working, iteration \" << i << std::endl;\n        // This call often triggers a context switch if other threads are ready or blocks the thread\n        usleep(1000); // Simulate blocking I/O or reaching end of time slice\n    }\n    std::cout << \"Thread \" << id << \" finished.\" << std::endl;\n}\n\nint main() {\n    std::thread t1(thread_function, 1);\n    std::thread t2(thread_function, 2);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Main thread finished.\" << std::endl;\n    return 0;\n}\n```\n\n1.  **תיאור מפורט של החלפת הקשר (Context Switch):** תארו בפירוט את השלבים המרכזיים המתרחשים ברמת מערכת ההפעלה (ובהתאם, ברמת המעבד) כאשר מתרחשת החלפת קשר בין `thread_A` ל-`thread_B` (למשל, בעקבות קריאה ל-`usleep()` שגורמת לחוט להיחסם, או סיום קטע זמן). התייחסו לאילו רכיבים במצב משתמש (User Mode) ובמצב ליבה (Kernel Mode) מושפעים, אילו אוגרים (registers) נשמרים ואילו משוחזרים, וכיצד משתנה מצב המחסנית של החוטים.\n\n2.  **השפעה על ביצועים ופתרון אופטימיזציה:** נניח שהמערכת מריצה עשרות חוטים דומים לקטע הקוד הנתון, כאשר רובם מבצעים פעולות I/O חוסמות (לדוגמה, קריאה וכתיבה לדיסק או לרשת). הסבירו כיצד תדירות גבוהה של החלפות קשרים אלו עלולה להשפיע על ביצועי המערכת הכוללים. הציעו אסטרטגיה כללית אחת (ברמת תכנון מערכת ההפעלה או תכנון היישום) למזעור ההשפעה השלילית של החלפות הקשר במקרה זה, ונמקו את הצעתכם.",
      "code_snippet": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <unistd.h> // For usleep\n\nvoid thread_function(int id) {\n    std::cout << \"Thread \" << id << \" started.\" << std::endl;\n    // Simulate some work or I/O\n    for (int i = 0; i < 5; ++i) {\n        std::cout << \"Thread \" << id << \" working, iteration \" << i << std::endl;\n        // This call often triggers a context switch if other threads are ready or blocks the thread\n        usleep(1000); // Simulate blocking I/O or reaching end of time slice\n    }\n    std::cout << \"Thread \" << id << \" finished.\" << std::endl;\n}\n\nint main() {\n    std::thread t1(thread_function, 1);\n    std::thread t2(thread_function, 2);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Main thread finished.\" << std::endl;\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.  **תיאור מפורט של החלפת קשר (Context Switch):**\n    החלפת קשר היא תהליך שבו מערכת ההפעלה שומרת את מצבו של חוט אחד ומשחזרת את מצבו של חוט אחר, כך שניתן יהיה להמשיך את ביצוע החוט השני מהנקודה שבה הופסק. התהליך מתרחש במצב ליבה (Kernel Mode) וכולל מספר שלבים:\n    *   **מעבר ממצב משתמש למצב ליבה (User to Kernel Mode):** כאשר חוט מבצע קריאת מערכת (system call) כמו `usleep()`, או כאשר מתרחשת קטיעה (interrupt) (למשל, קטיעת טיימר בסיום קטע זמן), המעבד עובר ממצב משתמש למצב ליבה. המעבר הזה כרוך בשמירת חלק מהאוגרים של מצב המשתמש (לרוב, רק אוגרים קריטיים כמו Program Counter (PC) ו-Stack Pointer (SP)) במחסנית הליבה של החוט הנוכחי.\n    *   **שמירת מצב החוט הנוכחי:** ה-Scheduler של מערכת ההפעלה נכנס לפעולה. הוא שומר את כל האוגרים הספציפיים למעבד של החוט המופסק (כגון אוגרי נתונים, אוגרי כתובות, אוגר מצב (PSW/FLAGS), Program Counter (PC) ואוגר המחסנית (SP) של מצב המשתמש) בבלוק בקרת החוט (Thread Control Block - TCB) שלו בזיכרון הליבה. בנוסף, נשמרים פרטי זיכרון (כמו מצביע לטבלת הדפים של התהליך במקרה של החלפת תהליכים, אם כי בהחלפת חוטים באותו תהליך טבלת הדפים נשארת זהה) ופרטי I/O פתוחים.\n    *   **בחירת החוט הבא:** ה-Scheduler בוחר את החוט הבא לביצוע מתוך רשימת החוטים המוכנים (Ready Queue) על בסיס אלגוריתם התזמון. במקרה של `usleep()`, החוט הנוכחי עובר למצב חסום (Blocked).\n    *   **שחזור מצב החוט הבא:** מערכת ההפעלה טוענת את האוגרים השמורים של החוט הנבחר (PC, SP, אוגרי נתונים וכתובות וכו') מה-TCB שלו אל אוגרי המעבד. אם החוט הנבחר שייך לתהליך אחר, טבלת הדפים של המעבד (MMU) תוחלף בהתאם. במקרה של חוטים באותו תהליך, טבלת הדפים נשארת זהה.\n    *   **מעבר ממצב ליבה למצב משתמש (Kernel to User Mode):** המעבד משחזר את אוגרי המצב הנדרשים וחוזר למצב משתמש, כאשר ה-Program Counter מצביע כעת על ההוראה הבאה לביצוע של החוט החדש. החוט ממשיך את ביצועו מהנקודה שבה הופסק בעבר.\n    *   **מחסנית:** לכל חוט יש מחסנית משלו במרחב כתובות המשתמש (User Stack) ומחסנית ליבה (Kernel Stack) נפרדת. במהלך החלפת קשר, מצביע המחסנית של המשתמש (User SP) נשמר ומשוחזר, ומצביע המחסנית של הליבה מתחלף למחסנית הליבה של החוט החדש.\n\n2.  **השפעה על ביצועים ופתרון אופטימיזציה:**\n    *   **השפעה על ביצועים:** כאשר מערכת מריצה עשרות חוטים I/O-bound, כל חוט מבלה חלק ניכר מזמנו בהמתנה לפעולות I/O להסתיים. כל פעולת I/O חוסמת גורמת לקריאת מערכת, וזו בתורה מפעילה את ה-Scheduler ומביאה להחלפת קשר. התדירות הגבוהה של החלפות קשרים אלו יוצרת עומס משמעותי על המערכת. העומס הזה כולל:\n        *   **זמן CPU מבוזבז:** תהליך החלפת הקשר עצמו דורש זמן CPU לצורך שמירה ושחזור אוגרים, עדכון מבני נתונים של ה-Scheduler, ולעיתים גם ניקוי מטמונים (caches) כמו TLB (Translation Lookaside Buffer) אם מתבצעת החלפת תהליך (פחות קריטי בהחלפת חוטים באותו תהליך, אך עדיין רלוונטי). זמן זה אינו תורם לביצוע עבודה שימושית של היישום.\n        *   **פגיעה בביצועי מטמונים (Cache Performance):** כאשר חוט חדש נטען, סביר להניח שנתוניו והוראותיו אינם נמצאים במטמון ה-CPU (L1, L2). טעינתם מחדש מהזיכרון הראשי (או מטמון רחוק יותר) יוצרת 'החטאות מטמון' (cache misses) רבות, מה שמאט משמעותית את הביצועים של החוט עם תחילת ריצתו.\n        *   **Overhead של קריאות מערכת:** כל כניסה למצב ליבה ויציאה ממנו כרוכה גם היא בעלות מסוימת. ככל שיש יותר פעולות I/O חוסמות, כך יש יותר קריאות מערכת ויותר עומס.\n\n    *   **אסטרטגיית אופטימיזציה (ברמת תכנון היישום - מודל אסינכרוני/Non-blocking I/O):**\n        אסטרטגיה יעילה למזעור ההשפעה השלילית היא לעבור למודל תכנות אסינכרוני עם I/O לא חוסם (Non-blocking I/O) או מבוסס אירועים (Event-driven). במקום שכל חוט יחכה באופן חוסם לפעולת I/O, היישום יכול:\n        1.  **לשלוח בקשת I/O:** לשלוח את בקשת ה-I/O למערכת ההפעלה אך לא לחכות לסיום מיידי שלה.\n        2.  **להמשיך לבצע עבודה אחרת:** בזמן שמערכת ההפעלה מטפלת ב-I/O ברקע, החוט יכול להמשיך לבצע עבודה חישובית אחרת, או לטפל בבקשות I/O אחרות שכבר הסתיימו.\n        3.  **לקבל הודעה על סיום I/O:** כאשר פעולת ה-I/O מסתיימת, מערכת ההפעלה מודיעה ליישום (לדוגמה, באמצעות קטיעה, הודעה לתור אירועים, או קריאת מערכת כמו `epoll` ב-Linux או `IOCP` ב-Windows). רק אז, החוט (או חוט אחר ב-\"thread pool\") יטפל בתוצאות ה-I/O.\n\n        **נימוק:** גישה זו מאפשרת לחוטים רבים יותר לשתף פעולה עם מספר קטן יותר של חוטי ליבה פעילים. במקום עשרות חוטים שכל אחד מהם נחסם ומפעיל החלפת קשר, מספר קטן של חוטים (לרוב כמספר ליבות ה-CPU) יכול לנהל עשרות או מאות פעולות I/O בו-זמנית מבלי להיחסם. זה מפחית באופן דרמטי את מספר החלפות הקשרים, משפר את ניצול המעבד (כי החוטים לא מחכים סתם), ומפחית את עומס המטמון. הפחתת החלפות הקשרים מובילה לזמן CPU פנוי רב יותר לעבודה שימושית ולשיפור כללי בביצועים."
    },
    "difficulty_estimation": "Hard"
  }
}