{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:43:03",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2862,
      "output_tokens": 1224,
      "total_tokens": 6486
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Concurrency"
    ],
    "content": {
      "text": "מהו סמפור (Semaphore) וכיצד הוא משמש לפתרון בעיות סנכרון במערכות הפעלה? הסבירו את שתי הפעולות העיקריות שלו (P/wait ו-V/signal) ותנו דוגמה קצרה לשימוש בסמפור להשגת הדדיות בלעדית (Mutual Exclusion) בקטע קריטי (Critical Section).",
      "code_snippet": "/* Conceptual C/C++ code demonstrating semaphore usage for mutual exclusion */\n\n// הגדרת סמפור בינארי, מאותחל ל-1\n// (בהתאם לספרייה או מימוש, זה עשוי להיות sem_t mutex; sem_init(&mutex, 0, 1);)\nSemaphore mutex = 1; \n\nvoid critical_section_access() {\n    wait(mutex); // פעולת P: הקטנת הסמפור, המתנה אם ערכו 0\n    \n    // תחילת הקטע הקריטי\n    // קוד שניגש למשאב משותף (לדוגמה: עדכון משתנה גלובלי)\n    // ...\n    // סוף הקטע הקריטי\n    \n    signal(mutex); // פעולת V: הגדלת הסמפור, שחרור תהליכים ממתינים\n}\n\n// בתוכנית מרובת תרדדים, כל תרד יקרא ל-critical_section_access()\n// ויוודא גישה בלעדית למשאב המשותף.",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "סמפור (Semaphore) הוא משתנה שלם (integer variable) המוגן מפני גישה בו-זמנית, ומשמש ככלי סנכרון בסיסי במערכות הפעלה לפתרון בעיות של תחרות (race conditions) והדדיות בלעדית (mutual exclusion) בין תהליכים או תרדדים. הוא מאפשר לשלוט בגישה למשאבים משותפים או לתאם את סדר הפעולות.\n\nשתי הפעולות העיקריות שלו הן:\n1.  **P (או `wait()`)**: פעולה זו מנסה להקטין את ערך הסמפור באחד. אם ערך הסמפור הנוכחי הוא 0, התהליך הקורא לפעולה נחסם וממתין בתור עד שערך הסמפור יהפוך לחיובי (או גדול מ-0) ויתאפשר להקטין אותו. אם ערך הסמפור גדול מ-0, הוא מוקטן מיד והתהליך ממשיך. פעולה זו מבטיחה שרק מספר מוגבל של תהליכים (לפי ערך הסמפור ההתחלתי) יוכלו להמשיך.\n2.  **V (או `signal()`)**: פעולה זו מגדילה את ערך הסמפור באחד. אם ישנם תהליכים החסומים וממתינים על הסמפור (כתוצאה מפעולת P קודמת), אחד מהם ישוחרר ויוכל להמשיך בביצוע (כלומר, לבצע את פעולת ה-P שחסמה אותו).\n\n**דוגמה לשימוש בסמפור להשגת הדדיות בלעדית (Mutual Exclusion) בקטע קריטי:**\nכדי להבטיח שרק תהליך אחד ייכנס לקטע קריטי (חלק בקוד הניגש למשאב משותף) בכל רגע נתון, ניתן להשתמש בסמפור בינארי (סמפור שערכו יכול להיות רק 0 או 1).\n*   מאתחלים סמפור בשם `mutex` (קיצור של mutual exclusion) לערך 1.\n*   לפני הכניסה לקטע הקריטי, כל תהליך מבצע פעולת `wait(mutex)`.\n    *   התהליך הראשון שיבצע `wait(mutex)` יקטין את ערך `mutex` ל-0 וימשיך לקטע הקריטי.\n    *   כל תהליך נוסף שינסה להיכנס לקטע הקריטי (כלומר, יבצע `wait(mutex)`) ימצא את `mutex` בערך 0, ולכן ייחסם וימתין.\n*   לאחר סיום הקטע הקריטי, התהליך שביצע אותו מבצע פעולת `signal(mutex)`.\n    *   פעולה זו מגדילה את ערך `mutex` בחזרה ל-1, ואם ישנם תהליכים ממתינים, אחד מהם ישוחרר ויורשה להיכנס לקטע הקריטי.\n\n**דוגמת קוד:** (כפי שהוצג בשאלה)"
    },
    "difficulty_estimation": "Easy"
  }
}