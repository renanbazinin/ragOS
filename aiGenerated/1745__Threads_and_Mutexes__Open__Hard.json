{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Threads and Mutexes",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:30:15",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4527,
      "output_tokens": 3080,
      "total_tokens": 14970
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Threads",
      "Mutexes",
      "Condition Variables",
      "Synchronization",
      "Deadlock"
    ],
    "content": {
      "text": "נתונה תוכנית המיישמת דפוס יצרן-צרכן (Producer-Consumer) באמצעות מספר תהליכונים (threads) המשתפים חוצץ בעל גודל קבוע. התוכנית משתמשת ב-mutex ובמשתני תנאי (condition variables) לסנכרון. קוד המקור של התוכנית מובא להלן.\n\nיש לנתח את הקוד הנתון ולזהות את כל בעיות הסנכרון הפוטנציאליות, כולל תנאי מרוץ (race conditions), קיפאון (deadlocks) או שימוש שגוי במשתני התנאי. עבור כל בעיה שזוהתה, יש להסביר בפירוט מדוע היא מהווה בעיה וכיצד היא עלולה להתבטא בזמן ריצה. לבסוף, יש להציג את הקוד המתוקן המטפל בכל הבעיות שצוינו, בצירוף הסבר קצר על השינויים שבוצעו.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <time.h>\n\n#define BUFFER_SIZE 5\n#define NUM_PRODUCERS 2\n#define NUM_CONSUMERS 2\n#define MAX_ITEMS_PER_THREAD 10\n\nint buffer[BUFFER_SIZE];\nint count = 0;\nint in = 0;\nint out = 0;\n\npthread_mutex_t mutex;\npthread_cond_t cond_buffer_not_full;  // Signaled when buffer is not full\npthread_cond_t cond_buffer_not_empty; // Signaled when buffer is not empty\n\nvoid* producer(void* arg) {\n    int item;\n    for (int i = 0; i < MAX_ITEMS_PER_THREAD; ++i) {\n        item = rand() % 100;\n        pthread_mutex_lock(&mutex);\n        while (count == BUFFER_SIZE) {\n            pthread_cond_wait(&cond_buffer_not_full, &mutex);\n        }\n        buffer[in] = item;\n        in = (in + 1) % BUFFER_SIZE;\n        count++;\n        printf(\"Producer %ld produced: %d, count: %d\\n\", (long)arg, item, count);\n        pthread_cond_signal(&cond_buffer_not_full); // BUG: Should signal cond_buffer_not_empty\n        pthread_mutex_unlock(&mutex);\n        usleep(100000);\n    }\n    return NULL;\n}\n\nvoid* consumer(void* arg) {\n    int item;\n    for (int i = 0; i < MAX_ITEMS_PER_THREAD; ++i) {\n        pthread_mutex_lock(&mutex);\n        while (count == 0) {\n            pthread_cond_wait(&cond_buffer_not_empty, &mutex);\n        }\n        item = buffer[out];\n        out = (out + 1) % BUFFER_SIZE;\n        count--;\n        printf(\"Consumer %ld consumed: %d, count: %d\\n\", (long)arg, item, count);\n        pthread_cond_signal(&cond_buffer_not_empty); // BUG: Should signal cond_buffer_not_full\n        pthread_mutex_unlock(&mutex);\n        usleep(150000);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t producers[NUM_PRODUCERS];\n    pthread_t consumers[NUM_CONSUMERS];\n\n    pthread_mutex_init(&mutex, NULL);\n    pthread_cond_init(&cond_buffer_not_full, NULL);\n    pthread_cond_init(&cond_buffer_not_empty, NULL);\n\n    srand(time(NULL));\n\n    for (long i = 0; i < NUM_PRODUCERS; ++i) {\n        pthread_create(&producers[i], NULL, producer, (void*)i);\n    }\n\n    for (long i = 0; i < NUM_CONSUMERS; ++i) {\n        pthread_create(&consumers[i], NULL, consumer, (void*)i);\n    }\n\n    for (int i = 0; i < NUM_PRODUCERS; ++i) {\n        pthread_join(producers[i], NULL);\n    }\n\n    for (int i = 0; i < NUM_CONSUMERS; ++i) {\n        pthread_join(consumers[i], NULL);\n    }\n\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond_buffer_not_full);\n    pthread_cond_destroy(&cond_buffer_not_empty);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הקוד הנתון מכיל שגיאת סנכרון קריטית בשימוש במשתני התנאי, שעלולה להוביל לקיפאון (deadlock) מוחלט של התוכנית.\n\n**זיהוי והסבר הבעיה:**\n1.  **שימוש שגוי ב-`pthread_cond_signal` ב-`producer`:** לאחר שהתהליכון היצרן (producer) מוסיף פריט לחוצץ, הוא מאותת למשתנה התנאי `cond_buffer_not_full`. משתנה תנאי זה נועד עבור היצרנים *להמתין* עליו כאשר החוצץ מלא. איתות למשתנה זה מעיר יצרן אחר (אם יש), אך אינו עוזר לצרכנים שממתינים לפריטים חדשים בחוצץ. היצרן צריך לאותת למשתנה התנאי `cond_buffer_not_empty` כדי להודיע לצרכנים שהחוצץ אינו ריק יותר ויש פריטים לצרוך.\n2.  **שימוש שגוי ב-`pthread_cond_signal` ב-`consumer`:** באופן דומה, לאחר שהתהליכון הצרכן (consumer) מסיר פריט מהחוצץ, הוא מאותת למשתנה התנאי `cond_buffer_not_empty`. משתנה תנאי זה נועד עבור הצרכנים *להמתין* עליו כאשר החוצץ ריק. איתות למשתנה זה מעיר צרכן אחר (אם יש), אך אינו עוזר ליצרנים שממתינים למקום פנוי בחוצץ. הצרכן צריך לאותת למשתנה התנאי `cond_buffer_not_full` כדי להודיע ליצרנים שהחוצץ אינו מלא יותר ויש מקום פנוי.\n\n**ההשלכות – קיפאון:**\nשגיאות אלו מובילות לקיפאון. ברגע שהיצרנים ממלאים את החוצץ, הם כולם ימתינו על `cond_buffer_not_full`. מכיוון שהיצרנים מאותתים רק ל-`cond_buffer_not_full`, אף אחד לא יעיר את הצרכנים שממתינים על `cond_buffer_not_empty`. כתוצאה מכך, הצרכנים לעולם לא יתחילו לצרוך פריטים, והיצרנים לעולם לא יתעוררו מכיוון שהחוצץ יישאר מלא. מצב דומה יקרה אם הצרכנים ירוקנו את החוצץ והם ימתינו על `cond_buffer_not_empty`, כאשר היצרנים ימתינו על `cond_buffer_not_full` ולא יאותתו ל-`cond_buffer_not_full`.\n\n**קוד מתוקן:**\nכדי לתקן את הבעיה, יש להחליף את קריאות ה-`pthread_cond_signal` בין התהליכונים:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <time.h>\n\n#define BUFFER_SIZE 5\n#define NUM_PRODUCERS 2\n#define NUM_CONSUMERS 2\n#define MAX_ITEMS_PER_THREAD 10\n\nint buffer[BUFFER_SIZE];\nint count = 0;\nint in = 0;\nint out = 0;\n\npthread_mutex_t mutex;\npthread_cond_t cond_buffer_not_full;  // Signaled when buffer is not full\npthread_cond_t cond_buffer_not_empty; // Signaled when buffer is not empty\n\nvoid* producer(void* arg) {\n    int item;\n    for (int i = 0; i < MAX_ITEMS_PER_THREAD; ++i) {\n        item = rand() % 100;\n        pthread_mutex_lock(&mutex);\n        while (count == BUFFER_SIZE) {\n            pthread_cond_wait(&cond_buffer_not_full, &mutex);\n        }\n        buffer[in] = item;\n        in = (in + 1) % BUFFER_SIZE;\n        count++;\n        printf(\"Producer %ld produced: %d, count: %d\\n\", (long)arg, item, count);\n        pthread_cond_signal(&cond_buffer_not_empty); // CORRECTED: Signal consumers\n        pthread_mutex_unlock(&mutex);\n        usleep(100000);\n    }\n    return NULL;\n}\n\nvoid* consumer(void* arg) {\n    int item;\n    for (int i = 0; i < MAX_ITEMS_PER_THREAD; ++i) {\n        pthread_mutex_lock(&mutex);\n        while (count == 0) {\n            pthread_cond_wait(&cond_buffer_not_empty, &mutex);\n        }\n        item = buffer[out];\n        out = (out + 1) % BUFFER_SIZE;\n        count--;\n        printf(\"Consumer %ld consumed: %d, count: %d\\n\", (long)arg, item, count);\n        pthread_cond_signal(&cond_buffer_not_full); // CORRECTED: Signal producers\n        pthread_mutex_unlock(&mutex);\n        usleep(150000);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t producers[NUM_PRODUCERS];\n    pthread_t consumers[NUM_CONSUMERS];\n\n    pthread_mutex_init(&mutex, NULL);\n    pthread_cond_init(&cond_buffer_not_full, NULL);\n    pthread_cond_init(&cond_buffer_not_empty, NULL);\n\n    srand(time(NULL));\n\n    for (long i = 0; i < NUM_PRODUCERS; ++i) {\n        pthread_create(&producers[i], NULL, producer, (void*)i);\n    }\n\n    for (long i = 0; i < NUM_CONSUMERS; ++i) {\n        pthread_create(&consumers[i], NULL, consumer, (void*)i);\n    }\n\n    for (int i = 0; i < NUM_PRODUCERS; ++i) {\n        pthread_join(producers[i], NULL);\n    }\n\n    for (int i = 0; i < NUM_CONSUMERS; ++i) {\n        pthread_join(consumers[i], NULL);\n    }\n\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond_buffer_not_full);\n    pthread_cond_destroy(&cond_buffer_not_empty);\n\n    return 0;\n}\n```\n\n**הסבר על השינויים:**\n*   בפונקציה `producer`, השורה `pthread_cond_signal(&cond_buffer_not_full);` הוחלפה ב-`pthread_cond_signal(&cond_buffer_not_empty);`. היצרן, לאחר שהוסיף פריט, רוצה להעיר צרכן פוטנציאלי שממתין לפריטים.\n*   בפונקציה `consumer`, השורה `pthread_cond_signal(&cond_buffer_not_empty);` הוחלפה ב-`pthread_cond_signal(&cond_buffer_not_full);`. הצרכן, לאחר שפינה מקום בחוצץ, רוצה להעיר יצרן פוטנציאלי שממתין למקום פנוי."
    },
    "difficulty_estimation": "Hard"
  }
}