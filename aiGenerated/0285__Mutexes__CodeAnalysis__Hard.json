{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:33:13",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4847,
      "output_tokens": 1665,
      "total_tokens": 12167
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "Mutexes",
      "Synchronization",
      "Concurrency",
      "Deadlock"
    ],
    "content": {
      "text": "נתונה מערכת המנהלת חשבונות בנק. כל חשבון מיוצג על ידי מבנה `Account` הכולל מזהה (id), יתרה (balance) ומנעול (mutex) משלו. שתי פונקציות עיקריות מוגדרות: `transfer` המעבירה כסף בין שני חשבונות. המערכת מריצה מספר חוטים במקביל המבצעים פעולות אלו. יש לתאר בקצרה ובבירור כל פתרון ולכתוב קוד ברור.",
      "code_snippet": "```c\n#include <pthread.h>\n#include <stdio.h>\n\ntypedef struct {\n    int id;\n    int balance;\n    pthread_mutex_t mutex;\n} Account;\n\n// Global accounts (assume these are initialized, e.g., in main or init_accounts)\n// Account accountA; Account accountB;\n\n// Function to transfer 'amount' from 'from' account to 'to' account\nvoid transfer(Account* from, Account* to, int amount) {\n    pthread_mutex_lock(&from->mutex);\n    pthread_mutex_lock(&to->mutex);\n\n    if (from->balance >= amount) {\n        from->balance -= amount;\n        to->balance += amount;\n    }\n\n    pthread_mutex_unlock(&to->mutex);\n    pthread_mutex_unlock(&from->mutex);\n}\n```",
      "options": null
    },
    "sub_questions": [
      {
        "id": "8.1",
        "text": "הקוד הנ\"ל סובל מבעיה חמורה של קיפאון (Deadlock) אשר עלולה להתרחש בנסיבות מסוימות. תארו ריצה אפשרית (עם מספר חוטים כרצונכם) המדגימה את הבעיה, והסבירו מדוע היא מתרחשת.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "8.2",
        "text": "תקנו את פונקציית `transfer` כך שתמנע את בעיית הקיפאון, תוך שמירה על עקרונות הסנכרון הנדרשים (ללא שימוש באובייקטי סנכרון נוספים פרט למנעולים הקיימים). כתבו את הקוד המתוקן.",
        "code_snippet": "void transfer(Account* from, Account* to, int amount) {\n    // כתבו את הקוד המתוקן כאן\n}",
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "### פתרון לשאלה 8\n\n**8.1 תיאור בעיית הקיפאון:**\n\nהבעיה: קיפאון (Deadlock).\n\nהסבר: קיפאון יכול להתרחש כאשר שני חוטים (threads) מנסים לבצע העברה כספית במקביל, אך בכיוונים מנוגדים. לדוגמה:\n\n1.  **חוט 1 (T1)** מנסה להעביר כסף מחשבון A לחשבון B (כלומר, קורא לפונקציה `transfer(&accountA, &accountB, ...)`. הוא נועל את המנעול של חשבון A (`&accountA.mutex`) בהצלחה.\n2.  **במקביל, חוט 2 (T2)** מנסה להעביר כסף מחשבון B לחשבון A (כלומר, קורא לפונקציה `transfer(&accountB, &accountA, ...)`. הוא נועל את המנעול של חשבון B (`&accountB.mutex`) בהצלחה.\n3.  **כעת T1** מנסה לנעול את המנעול של חשבון B (`&accountB.mutex`), אך מנעול זה כבר נעול על ידי T2. לכן, T1 נכנס למצב המתנה.\n4.  **במקביל, T2** מנסה לנעול את המנעול של חשבון A (`&accountA.mutex`), אך מנעול זה כבר נעול על ידי T1. לכן, T2 נכנס למצב המתנה.\n\nשני החוטים ממתינים זה לזה לשחרור המנעול שהם צריכים, וכתוצאה מכך אף אחד מהם לא יכול להתקדם. זהו מצב קלאסי של קיפאון, כאשר כל חוט מחזיק במשאב (מנעול) וממתין למשאב אחר שמוחזק על ידי חוט אחר.\n\n**8.2 תיקון פונקציית `transfer`:**\n\nכדי למנוע קיפאון במצב זה, יש להקפיד על סדר עקבי של תפיסת המנעולים. דרך נפוצה היא לתפוס את המנעולים על בסיס מזהה ייחודי (כמו `id` במקרה זה, או כתובת זיכרון), מה שמבטיח שכל החוטים ינסו לתפוס את אותם מנעולים באותו סדר, ללא קשר לסדר הטיעונים המקוריים לפונקציה.\n\n**הקוד המתוקן:**\n```c\nvoid transfer(Account* from, Account* to, int amount) {\n    // Handle transfer to/from the same account or null accounts\n    if (from == to || from == NULL || to == NULL) {\n        // No operation needed for same account, or invalid accounts\n        return;\n    }\n\n    pthread_mutex_t *mutex1, *mutex2;\n    // Determine a consistent locking order based on account IDs.\n    // Always lock the account with the smaller ID first.\n    if (from->id < to->id) {\n        mutex1 = &from->mutex;\n        mutex2 = &to->mutex;\n    } else { // to->id < from->id (assuming IDs are unique and not equal)\n        mutex1 = &to->mutex;\n        mutex2 = &from->mutex;\n    }\n\n    // Acquire locks in the consistent order\n    pthread_mutex_lock(mutex1);\n    pthread_mutex_lock(mutex2);\n\n    // Perform the transfer logic on the original 'from' and 'to' accounts\n    if (from->balance >= amount) {\n        from->balance -= amount;\n        to->balance += amount;\n    }\n\n    // Release locks in the reverse order of acquisition (or any order, as long as both are released)\n    pthread_mutex_unlock(mutex2);\n    pthread_mutex_unlock(mutex1);\n}\n```",
      "difficulty_estimation": "Hard"
    }
  }
}