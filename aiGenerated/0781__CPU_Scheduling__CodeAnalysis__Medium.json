{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "CPU Scheduling",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 00:19:28",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2670,
      "output_tokens": 1048,
      "total_tokens": 6190
    }
  },
  "question": {
    "id": 8,
    "type": "CodeAnalysis",
    "topic": [
      "CPU Scheduling",
      "Threads",
      "Concurrency"
    ],
    "content": {
      "text": "נתונה תוכנית C הבאה המשתמשת בחוטים (threads). התוכנית רצה על מערכת הפעלה המשתמשת במתזמן (scheduler) מסוג Round Robin עם קוואנטום זמן קבוע וקטן יחסית (כלומר, חוט יכול להיקטע במהלך ביצוע לולאת העבודה הפנימית). הניחו שקריאות printf מתבצעות אטומית (כלומר, הדפסת שורה שלמה לא תיקטע), אך המתזמן יכול להחליף חוטים בכל נקודה אחרת. כתבו את כל הפלטים האפשריים של התוכנית. נמקו את תשובתכם.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nvoid *thread_func(void *arg) {\n    int id = *(int*)arg;\n    for (int i = 0; i < 3; ++i) {\n        printf(\"Thread %d executing iteration %d\\n\", id, i);\n        // Simulate work (busy-wait)\n        for (long j = 0; j < 10000000; ++j);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t tid1, tid2;\n    int id1 = 1;\n    int id2 = 2;\n\n    pthread_create(&tid1, NULL, thread_func, &id1);\n    pthread_create(&tid2, NULL, thread_func, &id2);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": 10,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "המתזמן מסוג Round Robin הוא מתזמן פרמפטיבי (preemptive), כלומר, הוא יכול להחליף חוטים בכל עת לאחר שפג קוואנטום הזמן שלהם, או אם חוט נחסם (במקרה זה, החוטים מבצעים עבודה בלולאה ארוכה, כך שסביר שיוחלפו עקב פקיעת קוואנטום). כתוצאה מכך, סדר ההדפסה בין החוטים יכול להשתנות באופן משמעותי. עם זאת, בתוך כל חוט, סדר ההדפסות נשמר: חוט 1 תמיד ידפיס 'Thread 1 executing iteration 0', ואז 'Thread 1 executing iteration 1', ואז 'Thread 1 executing iteration 2'. וכך גם עבור חוט 2. מכיוון שקריאות printf אטומיות, כל שורת פלט תודפס בשלמותה. לכן, כל פלט אפשרי יהיה מורכב משש שורות, כאשר שלוש מהן שייכות לחוט 1 בסדר עולה של איטרציות, ושלוש שייכות לחוט 2 בסדר עולה של איטרציות, וסדר הופעת השורות משני החוטים יכול להיות משולב בכל צורה אפשרית. לדוגמה, פלטים אפשריים:\n1.\nThread 1 executing iteration 0\nThread 1 executing iteration 1\nThread 1 executing iteration 2\nThread 2 executing iteration 0\nThread 2 executing iteration 1\nThread 2 executing iteration 2\n2.\nThread 2 executing iteration 0\nThread 2 executing iteration 1\nThread 2 executing iteration 2\nThread 1 executing iteration 0\nThread 1 executing iteration 1\nThread 1 executing iteration 2\n3.\nThread 1 executing iteration 0\nThread 2 executing iteration 0\nThread 1 executing iteration 1\nThread 2 executing iteration 1\nThread 1 executing iteration 2\nThread 2 executing iteration 2\nועוד שילובים רבים אחרים, כל עוד הסדר הפנימי של ההדפסות לכל חוט נשמר."
    },
    "difficulty_estimation": "Medium"
  }
}