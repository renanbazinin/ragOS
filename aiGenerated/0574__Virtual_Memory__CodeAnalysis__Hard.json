{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:50:14",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3618,
      "output_tokens": 2492,
      "total_tokens": 14369
    }
  },
  "question": {
    "id": 101,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Paging",
      "Page Faults",
      "Memory Access Patterns",
      "Page Replacement Policies"
    ],
    "content": {
      "text": "נתון קוד C המטפל במערך דו-ממדי גדול מאוד. המערך מאותחל ל-0 ונמצא בזיכרון וירטואלי. גודל כל אלמנט במערך הוא 4 בתים (int). נניח כי גודל דף זיכרון הוא 4KB, וכי ישנם 16 פריימים פיזיים פנויים בלבד בזיכרון הפיזי עבור נתוני התוכנית (כלומר, הזיכרון הפיזי קטן משמעותית מגודל המערך). מדיניות החלפת הדפים היא LRU (Least Recently Used).\n\nהמערך מוגדר כ: `int arr[1024][1024];` ופרוס בזיכרון בסדר שורות (row-major order).\n\nכמה כשלים (Page Faults) יתרחשו בסך הכל עבור כל אחד מקטעי הקוד הבאים? נמקו את תשובתכם.\n\n**קטע קוד א':**",
      "code_snippet": "int arr[1024][1024];\n// ... initialization of arr to 0 (not shown) ...\n\nfor (int i = 0; i < 1024; i++) {\n    for (int j = 0; j < 1024; j++) {\n        arr[i][j]++;\n    }\n}",
      "options": null
    },
    "sub_questions": [
      {
        "id": "101.1",
        "text": "כמה כשלים (Page Faults) יתרחשו עבור קטע קוד א'?",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "101.2",
        "text": "כמה כשלים (Page Faults) יתרחשו עבור קטע קוד ב'?",
        "code_snippet": "int arr[1024][1024];\n// ... initialization of arr to 0 (not shown) ...\n\nfor (int j = 0; j < 1024; j++) {\n    for (int i = 0; i < 1024; i++) {\n        arr[i][j]++;\n    }\n}",
        "options": null
      }
    ],
    "points": 25,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "נתוני השאלה:\n- גודל מערך: `1024 x 1024` איברים. כל איבר הוא `int` (4 בתים).\n- גודל כולל של המערך: `1024 * 1024 * 4 = 4,194,304` בתים = `4MB`.\n- גודל דף זיכרון: `4KB`.\n- מספר איברים בדף: `4KB / 4B = 1024` איברים.\n- מספר דפים כולל למערך: `4MB / 4KB = 1024` דפים.\n- מספר פריימים פיזיים זמינים: `16` פריימים.\n- מדיניות החלפת דפים: LRU.\n\n**ניתוח קטע קוד א' (גישה לפי שורות - Row-major access):**\n```c\nfor (int i = 0; i < 1024; i++) {\n    for (int j = 0; j < 1024; j++) {\n        arr[i][j]++;\n    }\n}\n```\nהמערך פרוס בזיכרון בסדר שורות (row-major order), כלומר `arr[0][0], arr[0][1], ..., arr[0][1023], arr[1][0], ...`.\nכל שורה במערך (`arr[i]`) מכילה `1024` איברים, אשר תופסים בדיוק `1024 * 4 = 4096` בתים, כלומר שורה שלמה נכנסת לדף זיכרון אחד בדיוק.\n\nבלולאה החיצונית אנו עוברים על השורות (`i`). בכל איטרציה של הלולאה החיצונית (כלומר, עבור כל שורה חדשה `i`), אנו ניגשים לאיבר הראשון בשורה (`arr[i][0]`). מכיוון שכל שורה נמצאת בדף זיכרון נפרד, ובהנחה שדף השורה הקודמת כבר יצא מהזיכרון הפיזי (בגלל מגבלת 16 הפריימים), תתרחש תקלת דף. לאחר שהדף של השורה `i` נטען לזיכרון הפיזי, כל הגישות הבאות לאיברים באותה שורה (`arr[i][1]` עד `arr[i][1023]`) לא יגרמו לתקלות דף נוספות, שכן כולם נמצאים באותו דף שכבר נטען.\n\nמכיוון שיש `1024` שורות, וכל גישה לשורה חדשה (לאחר שתקלה בדף הקודם כבר הוציאה את דף השורה מהזיכרון הפיזי) גורמת לתקלת דף אחת, המספר הכולל של תקלות דף יהיה `1024`.\n\n**תשובה 101.1: 1024 כשלים.**\n\n**ניתוח קטע קוד ב' (גישה לפי עמודות - Column-major access):**\n```c\nfor (int j = 0; j < 1024; j++) {\n    for (int i = 0; i < 1024; i++) {\n        arr[i][j]++;\n    }\n}\n```\nבלולאה החיצונית אנו עוברים על העמודות (`j`). בלולאה הפנימית אנו עוברים על השורות (`i`) עבור עמודה קבועה `j`.\n\nעבור `j=0` (העמודה הראשונה):\n- `arr[0][0]` נגיש. נגרמת תקלת דף עבור הדף המכיל את `arr[0]` (נכנה אותו `P_0`). `P_0` נטען לזיכרון הפיזי.\n- `arr[1][0]` נגיש. נגרמת תקלת דף עבור הדף המכיל את `arr[1]` (`P_1`). `P_1` נטען לזיכרון הפיזי.\n- ...\n- `arr[15][0]` נגיש. נגרמת תקלת דף עבור הדף המכיל את `arr[15]` (`P_15`). `P_15` נטען לזיכרון הפיזי.\nבשלב זה, `16` תקלות דף התרחשו, וכל `16` הפריימים בזיכרון הפיזי מלאים בדפים `P_0` עד `P_15`.\n- `arr[16][0]` נגיש. נגרמת תקלת דף עבור הדף המכיל את `arr[16]` (`P_16`). מכיוון שהזיכרון מלא ויש 16 פריימים בלבד, מדיניות LRU תוציא את הדף הכי פחות בשימוש, שהוא `P_0` (הדף של `arr[0]`). `P_16` נטען במקומו.\n- תהליך זה ממשיך. עבור כל `arr[i][0]` כאשר `i` הוא בין `0` ל-`1023`, תתרחש תקלת דף. בכל פעם, דף חדש נטען ודף ישן יותר (לפי LRU) מוצא. מכיוון שכל האיברים בעמודה שונים ונמצאים בדפים שונים, וקיימים `1024` איברים בעמודה, נקבל `1024` תקלות דף עבור העמודה הראשונה (`j=0`). בסיום עיבוד העמודה הראשונה, כל `1024` הדפים של המערך נטענו לזיכרון הפיזי לפחות פעם אחת, ו-`P_1023` עד `P_1023-15` הם הדפים האחרונים שנטענו ונמצאים בזיכרון הפיזי.\n\nעבור `j=1` (העמודה השנייה):\n- `arr[0][1]` נגיש. דף `P_0` (המכיל את `arr[0]`) הוצא מהזיכרון הפיזי במהלך עיבוד העמודה הראשונה. לכן, תתרחש תקלת דף עבור `P_0` והוא ייטען מחדש.\n- `arr[1][1]` נגיש. דף `P_1` הוצא מהזיכרון הפיזי. תתרחש תקלת דף עבור `P_1` והוא ייטען מחדש.\n- ...\n- דפוס זה חוזר על עצמו. עבור כל איבר `arr[i][j]`, הדף `P_i` המכיל אותו כבר הוצא מהזיכרון הפיזי כתוצאה מגישה לאיברים מאוחרים יותר בעמודה הקודמת. לכן, כל גישה לאיבר `arr[i][j]` תגרום לתקלת דף.\n\nמכיוון שיש `1024` עמודות, וכל עמודה מכילה `1024` איברים שכל אחד מהם נמצא בדף נפרד שיגרום לתקלת דף, המספר הכולל של תקלות דף יהיה: `1024` עמודות * `1024` תקלות דף לעמודה = `1024 * 1024 = 1,048,576` תקלות דף.\n\n**תשובה 101.2: 1,048,576 כשלים.**"
    },
    "difficulty_estimation": "Hard"
  }
}