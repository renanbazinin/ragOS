{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "File Systems",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 06:51:56",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4084,
      "output_tokens": 2339,
      "total_tokens": 11550
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "File Systems",
      "Journaling",
      "Atomicity",
      "Directory Operations"
    ],
    "content": {
      "text": "נתונה מערכת קבצים SimpleFS המשתמשת ב-journaling עבור metadata בלבד. פעולת rename(\"/dirA/fileX\", \"/dirB/fileY\") מיושמת ברמת הדיסק ברצף הפעולות הבא:\n1.  התחלת טרנזקציה ב-journal.\n2.  כתיבת רשומת תיקייה חדשה עבור fileY לבלוק הנתונים של dirB.\n3.  עדכון ה-inode של dirB (לדוגמה, mtime, ctime, גודל).\n4.  מחיקת רשומת התיקייה עבור fileX מבלוק הנתונים של dirA.\n5.  עדכון ה-inode של dirA (לדוגמה, mtime, ctime, גודל).\n6.  עדכון ה-inode של fileX (לדוגמה, ctime).\n7.  סיום טרנזקציה ב-journal.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "באיזה שלב (מתוך 1-7) עלולה קריסה לגרום לחוסר עקביות במערכת הקבצים? תאר/י את חוסר העקביות הספציפי שייווצר.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "הצע/י שינוי מינימלי לרצף הפעולות (בתוך הטרנזקציה ב-journal) שיבטיח עקביות של מערכת הקבצים גם במקרה של קריסה, תחת מנגנון metadata journaling. נמק/י מדוע השינוי המוצע פותר את הבעיה.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "בהתבסס על הפתרון שלך לסעיף 1.2, תאר/י בקצרה כיצד פעולת rename של תיקייה לא ריקה (לדוגמה, rename(\"/dirA\", \"/dirC\") כאשר dirA מכילה קבצים) תדרוש שינויים נוספים או התייחסויות מיוחדות מעבר למה שתואר עבור קובץ רגיל. האם הפתרון שלך מסעיף 1.2 עדיין תקף לחלוטין או שנדרשים שינויים נוספים?",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1. הבעיה המרכזית כאן היא שאם המערכת קורסת לאחר שלב 3 ולפני שלב 4, הטרנזקציה לא תסתיים. כאשר המערכת תעלה מחדש ותשחזר את ה-journal, היא תראה שרשומה חדשה עבור fileY נוספה ל-dirB וה-inode של dirB עודכן. עם זאת, רשומת fileX עדיין קיימת ב-dirA, וה-inode של dirA וה-inode של fileX לא עודכנו בהתאם. התוצאה היא ש-fileX קיים בשני מקומות שונים במערכת הקבצים (ב-dirA וב-dirB עם שם fileY), מה שיוצר מצב של חוסר עקביות חמור. ה-inode של fileX לא משקף את השינוי בנתיבו או את ה-ctime החדש, וייתכן שגם ספירת הקישורים הקשיחים (hard links) תהיה שגויה אם לא טופלה כראוי. העיקר הוא שהקובץ נראה קיים בשני נתיבים שונים בו זמנית.\n\n1.2. כדי להבטיח עקביות, עלינו להבטיח שפעולת המחיקה של הרשומה הישנה תבוצע לפני יצירת הרשומה החדשה, או לפחות שתיהן יהיו חלק מאותה פעולה אטומית ב-journal. השינוי המינימלי הוא להפוך את סדר הפעולות 2 ו-4:\n1.  התחלת טרנזקציה ב-journal.\n2.  מחיקת רשומת התיקייה עבור fileX מבלוק הנתונים של dirA.\n3.  עדכון ה-inode של dirA (לדוגמה, mtime, ctime, גודל).\n4.  כתיבת רשומת תיקייה חדשה עבור fileY לבלוק הנתונים של dirB.\n5.  עדכון ה-inode של dirB (לדוגמה, mtime, ctime, גודל).\n6.  עדכון ה-inode של fileX (לדוגמה, ctime).\n7.  סיום טרנזקציה ב-journal.\nנימוק: במקרה של קריסה:\n-   אם הקריסה מתרחשת לפני שלב 2: שום שינוי לא בוצע, מערכת הקבצים נשארת עקבית.\n-   אם הקריסה מתרחשת בין שלב 2 לשלב 6 (כולל): כאשר המערכת תעלה מחדש ותשחזר את ה-journal, היא תראה שרשומת fileX נמחקה מ-dirA (ו-inode dirA עודכן). אם הקריסה הייתה לפני שלב 4, fileY לא ייווצר ב-dirB. התוצאה היא ש-fileX נמחק מ-dirA ולא נוצר ב-dirB. זהו מצב של אובדן קובץ (או לפחות של הקישור אליו), אך מערכת הקבצים עדיין עקבית – אין מצב שבו הקובץ מופיע בשני מקומות, ואין מצביעים תלויים (dangling pointers) או ספירות קישורים שגויות שגורמות לשחיתות במבנה הנתונים הפנימי של מערכת הקבצים. הקובץ עצמו עדיין קיים בדיסק (אם לא נמחק), רק הגישה אליו אבדה. זהו מחיר עדיף על פני חוסר עקביות מבני.\n-   אם הקריסה מתרחשת אחרי שלב 7: הטרנזקציה הושלמה בהצלחה, והפעולה בוצעה באופן אטומי.\n\n1.3. פעולת rename של תיקייה לא ריקה היא מורכבת בהרבה מזו של קובץ רגיל. כאשר מעבירים תיקייה (dirA) לתוך תיקייה אחרת (dirC), נדרשים השינויים וההתייחסויות המיוחדות הבאות:\n1.  עדכון רשומת '..' (parent directory) בתוך התיקייה המועברת: ה-entry '..' בתוך dirA (שכעת שמה הוא dirC/dirA) צריך להתעדכן כדי להצביע על ה-inode של dirC במקום ה-inode של ההורה המקורי. זה דורש כתיבה לבלוק הנתונים של התיקייה המועברת עצמה.\n2.  שינוי ספירת קישורים קשיחים (link_count): ה-link_count של ה-inode של התיקייה המועברת (dirA) ישתנה. הוא יקטן ב-1 עבור ההורה הישן ויגדל ב-1 עבור ההורה החדש. זה משקף את השינוי במספר הקישורים לתיקייה זו (הקישור מ-dirC מחליף את הקישור מ-dirA המקורית).\n3.  עדכון ה-inode של התיקייה המועברת: ה-inode של dirA גם צריך להתעדכן (לדוגמה, ctime).\nהפתרון מסעיף 1.2 עדיין תקף באופן עקרוני בכך שהוא ממליץ על הסרת הקישור הישן לפני יצירת הקישור החדש ב-journal. עם זאת, נדרשים שינויים נוספים לרצף הפעולות בתוך הטרנזקציה:\n-   שלב 4 (כתיבת רשומה חדשה ל-dirB עבור fileY) יהפוך לכתיבת רשומה חדשה ל-dirC עבור dirA (התיקייה המועברת).\n-   שלב 2 (מחיקת רשומה מ-dirA) יהפוך למחיקת רשומה מ-dirA המקורית.\n-   יש להוסיף פעולת כתיבה לבלוק הנתונים של התיקייה המועברת (dirA עצמה) כדי לשנות את ה-entry '..' שלה כך שיצביע על ה-inode של dirC. פעולה זו חייבת להיות חלק מהטרנזקציה ב-journal.\n-   ה-link_count של ה-inode של dirA יצטרך להתעדכן. זהו שינוי metadata נוסף שחייב להיות חלק מהטרנזקציה.\nללא עדכונים אלו בתוך הטרנזקציה, קריסה עלולה להשאיר את התיקייה המועברת עם מצביע '..' שגוי (מצביע להורה הישן), או עם link_count שגוי, מה שיוביל לחוסר עקביות חמור ויכול למנוע גישה נכונה לתיקייה המועברת או לרוקן את ההורה הישן בצורה שגויה."
    },
    "difficulty_estimation": "Hard"
  }
}