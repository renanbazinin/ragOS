{
  "metadata": {
    "source": "ai_generated",
    "subject": "File Systems",
    "topic_hint": "Security",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:45:07",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 968,
      "output_tokens": 1285,
      "total_tokens": 7038
    }
  },
  "question": {
    "id": 10,
    "type": "MultipleChoice",
    "topic": [
      "Security",
      "Vulnerabilities",
      "TOCTOU",
      "Setuid Programs",
      "Race Conditions"
    ],
    "content": {
      "text": "נתונה תוכנית C המהודרת ומוגדרת כ-setuid root (בעלת הרשאות root אפקטיביות). התוכנית מקבלת שם קובץ כארגומנט, בודקת הרשאות ולאחר מכן מנסה לקרוא את תוכן הקובץ. הקוד מוצג מטה:\n\nאיזו טענה מתארת בצורה הטובה ביותר את הפגיעות הפוטנציאלית בתוכנית זו?",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    char buffer[1024];\n    int fd;\n    ssize_t bytes_read;\n\n    // בדיקת הרשאות קריאה עבור המשתמש האמיתי\n    if (access(filename, R_OK) == -1) {\n        perror(\"access check failed\");\n        return 1;\n    }\n\n    // הדמיית עיכוב (חלון מירוץ)\n    sleep(2);\n\n    // פתיחת וקריאת הקובץ - מתבצעת עם הרשאות ה-UID האפקטיבי (root)\n    fd = open(filename, O_RDONLY);\n    if (fd == -1) {\n        perror(\"open failed\");\n        return 1;\n    }\n\n    printf(\"--- Content of %s ---\\n\", filename);\n    while ((bytes_read = read(fd, buffer, sizeof(buffer) - 1)) > 0) {\n        buffer[bytes_read] = '\\0';\n        printf(\"%s\", buffer);\n    }\n    printf(\"\\n---------------------\\n\");\n\n    close(fd);\n    return 0;\n}\n",
      "options": [
        "א. התוכנית פגיעה להתקפת Buffer Overflow בקריאה ל-`read` אם גודל הקובץ גדול מדי מה-buffer.",
        "ב. התוכנית פגיעה להתקפת Time-of-Check to Time-of-Use (TOCTOU) באמצעות שימוש בקישורים סימבוליים (symlinks).",
        "ג. התוכנית פגיעה להתקפת Integer Overflow אם ה-`bytes_read` גדול מערך ה-`ssize_t` המקסימלי.",
        "ד. התוכנית אינה פגיעה מכיוון שהיא בודקת את הרשאות הקריאה באמצעות `access()` לפני פתיחת הקובץ.",
        "ה. התוכנית פגיעה להתקפת Privilege Escalation ישירה מכיוון שהיא רצה כ-root, ללא צורך ב-TOCTOU."
      ]
    },
    "sub_questions": null,
    "points": 5,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ב",
      "explanation": "התוכנית פגיעה להתקפת Time-of-Check to Time-of-Use (TOCTOU). הבדיקה `access(filename, R_OK)` מתבצעת עם ה-UID האמיתי של המשתמש, ובודקת אם למשתמש יש הרשאת קריאה לקובץ. עם זאת, הקריאה בפועל של הקובץ באמצעות `open()` מתבצעת לאחר מכן. במהלך ה'השהיה' המדומה (`sleep(2)`) או כל עיכוב אחר שנובע מפעולות קלט/פלט או עיבוד אחר, תוקף יכול להחליף את הקובץ המקורי (עבורו בדיקת הגישה עברה בהצלחה) בקישור סימבולי המצביע לקובץ מערכת רגיש (כמו `/etc/shadow`). מכיוון שפעולת ה-`open()` מתבצעת עם הרשאות ה-UID האפקטיבי (root), התוכנית תקרא את תוכן הקובץ הרגיש ותחשוף אותו למשתמש הפחות מורשה.\nאפשרות א' אינה נכונה מכיוון ש-`read` מקבלת גודל מקסימלי, ואין כאן Buffer Overflow ישיר. אפשרות ג' אינה סבירה מכיוון ש-`ssize_t` מספיק גדול עבור קריאות קבצים רגילות. אפשרות ד' שגויה לחלוטין מכיוון שהיא מתעלמת מחלון המירוץ שבין הבדיקה לפעולה. אפשרות ה' נכונה באופן כללי שהיא פגיעה ל-Privilege Escalation, אך פחות מדויקת מאפשרות ב' שמציינת את המנגנון הספציפי והמדויק (TOCTOU) שמוביל לכך."
    },
    "difficulty_estimation": "Hard"
  }
}