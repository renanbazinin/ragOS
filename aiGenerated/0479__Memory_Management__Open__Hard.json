{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 22:29:31",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3218,
      "output_tokens": 3836,
      "total_tokens": 18491
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Segmentation",
      "Paging",
      "Virtual Memory",
      "TLB",
      "Page Fault"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה המשלבת ניהול זיכרון באמצעות סגמנטציה ודפדוף (Segmentation with Paging). מרחב הכתובות הוירטואלי הוא בגודל 64 ביט. גודל דף הוא 4KB.\n\nלכל תהליך יש טבלת סגמנטים (Segment Table - ST), כאשר כל כניסה בטבלת הסגמנטים (STE) היא בגודל 64 ביט ומכילה:\n*   כתובת בסיס פיזית לטבלת הדפים של הסגמנט (Page Table Base Address PFN) – מצביע למסגרת הפיזית הראשונה של טבלת הדפים.\n*   אורך הסגמנט בבתים (Segment Length) – מספר הבתים המקסימלי הנגיש בסגמנט.\n*   ביט Valid (V), ביט Read/Write (RW), ביט Execute (X) – שלושה ביטים עבור הרשאות וסטטוס.\n\nכל סגמנט ממופה באמצעות טבלת דפים לינארית משלו. כל כניסה בטבלת הדפים (PTE) היא בגודל 32 ביט ומכילה:\n*   מספר מסגרת פיזית (PFN).\n*   ביט Present (P), ביט Dirty (D), ביט Accessed (A) – שלושה ביטים עבור סטטוס הדף.\n\nבמערכת קיים TLB מאוחד (עבור סגמנטים ודפים) המכיל 128 כניסות, בשיטת מיפוי סט אסוציאטיבי בעל 4 דרכים (4-way set associative).\n\n",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "פרטו כיצד כתובת וירטואלית מתפרקת למרכיביה (מספר סגמנט, מספר דף בתוך סגמנט, היסט דף). הציגו את מספר הביטים לכל רכיב, ונמקו את גודלם.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "תארו את תהליך תרגום כתובת וירטואלית לכתובת פיזית במערכת זו, כולל כל הבדיקות הנדרשות (לדוגמה, חריגה מגבולות סגמנט, Page Fault, TLB Miss/Hit).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "כמה גישות לזיכרון הראשי (Main Memory) וכמה גישות לדיסק יתבצעו במקרים הבאים, עבור גישת תהליך לכתובת וירטואלית מסוימת לצורך קריאה (Read)? הניחו שבכל מקרה של Page Fault נדרשת החלפת דף קיים בזיכרון, והדף המוחלף מלוכלך (Dirty). יש לכלול את הגישות לדיסק הנדרשות עבור טיפול ב-Page Fault.\nא. TLB Hit, והדף נמצא בזיכרון הפיזי.\nב. TLB Miss, אך הדף נמצא בזיכרון הפיזי.\nג. TLB Miss, והדף אינו נמצא בזיכרון הפיזי (Page Fault).",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון לשאלה:\n\n**1.1. פירוק כתובת וירטואלית למרכיביה:**\n*   **גודל כתובת וירטואלית:** 64 ביט.\n*   **גודל דף:** 4KB = 2^12 בתים. לכן, ההיסט בתוך הדף (Page Offset - PO) הוא **12 ביטים**.\n\n*   **גודל כניסה לטבלת דפים (PTE):** 32 ביט. מתוכם 3 ביטים עבור P, D, A. לכן, מספר המסגרת הפיזית (PFN) הוא 32 - 3 = **29 ביטים**.\n    *   מספר ביטים זה מגדיר את גודל הזיכרון הפיזי המקסימלי: 2^29 מסגרות * 2^12 בתים/מסגרת = 2^41 בתים (2 טרה-בייט). כלומר, כל מספר דף בתוך סגמנט (Page Number - PN) חייב להיות מיוצג על ידי לכל היותר 29 ביטים כדי שיוכל להיות ממופה למסגרת פיזית.\n    *   לכן, מספר הדף בתוך סגמנט (PN) הוא **29 ביטים**.\n\n*   **מספר הסגמנט (Segment Number - SN):** נותרו 64 ביט (סה\"כ) - 12 ביט (PO) - 29 ביט (PN) = **23 ביטים**.\n    *   זה מאפשר לכל תהליך עד 2^23 סגמנטים.\n\n**סיכום פירוק הכתובת הוירטואלית:**\n*   **Segment Number (SN): 23 ביטים**\n*   **Page Number (PN): 29 ביטים** (בתוך הסגמנט)\n*   **Page Offset (PO): 12 ביטים**\n\n**בדיקת עקביות עם STE:**\n*   **גודל כניסה לטבלת סגמנטים (STE):** 64 ביט.\n*   **PT_Base (PFN):** 29 ביטים (כפי שנקבע מגודל ה-PTE).\n*   **ביטים V, RW, X:** 3 ביטים.\n*   **נותר עבור Segment Length (SL):** 64 - 29 - 3 = **32 ביטים**.\n    *   לכן, אורך סגמנט מקסימלי (SL) הוא 2^32 בתים (4 ג'יגה-בייט). למרות שכתובת וירטואלית בתוך סגמנט (PN+PO) יכולה לכאורה לייצג 2^41 בתים, שדה ה-SL מגביל בפועל את הגודל המקסימלי של סגמנט ל-4GB.\n\n**1.2. תהליך תרגום כתובת וירטואלית לכתובת פיזית:**\nתהליך התרגום מתבצע באופן הבא:\n\n1.  **פירוק הכתובת הוירטואלית:** ה-CPU מפרק את הכתובת הוירטואלית (64 ביט) למספר סגמנט (SN), מספר דף בתוך סגמנט (PN) והיסט דף (PO) כפי שחושב בסעיף 1.1.\n\n2.  **בדיקת TLB:**\n    *   ה-CPU מנסה למצוא התאמה ב-TLB עבור הזוג (SN, PN).\n    *   **TLB Hit:** אם נמצאה כניסה מתאימה, ה-TLB מחזיר את מספר המסגרת הפיזית (PFN) ישירות, יחד עם ביטי ההרשאות והסטטוס (כגון P,D,A, RW, X). ה-CPU מבצע בדיקות הרשאה (לדוגמה, האם מותר לקרוא לכתובת זו לפי ביט RW). אם הכל תקין, הכתובת הפיזית מחושבת (PFN * Page_Size + PO) ומתבצעת גישה לזיכרון הפיזי. ביט Accessed (A) בכניסת ה-TLB מעודכן, וביט Dirty (D) מעודכן אם הגישה היא כתיבה.\n    *   **TLB Miss:** אם לא נמצאה כניסה מתאימה, ה-CPU ממשיך לגישה לטבלאות בזיכרון הראשי.\n\n3.  **גישה לטבלת הסגמנטים (ST):** (במקרה של TLB Miss)\n    *   ה-CPU משתמש במספר הסגמנט (SN) כדי לאתר את כניסת ה-STE המתאימה בטבלת הסגמנטים. כתובת הבסיס של טבלת הסגמנטים (STBR) נמצאת באוגר מיוחד ב-CPU.\n    *   ה-CPU קורא את ה-STE מכתובת: `STBR + SN * sizeof(STE)`. זוהי גישה לזיכרון הראשי.\n    *   **בדיקת Valid (V):** אם ביט V ב-STE הוא 0, מתרחשת פסיקת סגמנט (Segment Fault) – הסגמנט אינו חוקי.\n    *   **בדיקת אורך סגמנט:** ה-CPU בודק שההיסט בתוך הסגמנט (PN * Page_Size + PO) קטן מאורך הסגמנט (SL) הרשום ב-STE. אם ההיסט גדול או שווה ל-SL, מתרחשת פסיקת סגמנט (Segment Fault) – חריגה מגבולות הסגמנט.\n    *   **בדיקת הרשאות:** ה-CPU בודק את ביטי RW ו-X ב-STE מול סוג הגישה המבוקש (קריאה, כתיבה, הרצה). אם יש הפרת הרשאה, מתרחשת פסיקת הגנה (Protection Fault).\n    *   אם כל הבדיקות עברו בהצלחה, ה-CPU מחלץ את כתובת הבסיס הפיזית של טבלת הדפים של הסגמנט (PT_Base PFN) מה-STE.\n\n4.  **גישה לטבלת הדפים (PT):** (במקרה של TLB Miss)\n    *   ה-CPU משתמש במספר הדף (PN) כדי לאתר את כניסת ה-PTE המתאימה בטבלת הדפים של הסגמנט.\n    *   ה-CPU קורא את ה-PTE מכתובת: `PT_Base_PFN * Page_Size + PN * sizeof(PTE)`. זוהי גישה נוספת לזיכרון הראשי.\n    *   **בדיקת Present (P):** אם ביט P ב-PTE הוא 0, מתרחשת פסיקת דף (Page Fault).\n        *   **טיפול ב-Page Fault:** מערכת ההפעלה משתלטת. היא בוחרת מסגרת פיזית פנויה (או מפנה מסגרת קיימת לפי אלגוריתם החלפה). אם המסגרת המפונה הייתה 'מלוכלכת' (Dirty=1), תוכנה לדיסק. לאחר מכן, הדף המבוקש נטען מהדיסק למסגרת הפיזית החדשה. ה-PTE מעודכן (P=1, D=0, A=1, PFN חדש). ה-TLB מעודכן עם המיפוי החדש. הפקודה שגרמה ל-Page Fault מופעלת מחדש.\n    *   **בדיקת הרשאות:** ה-CPU בודק את ביטי ההרשאה ב-PTE מול סוג הגישה המבוקש. אם יש הפרת הרשאה, מתרחשת פסיקת הגנה.\n    *   אם הכל תקין, ה-CPU מחלץ את מספר המסגרת הפיזית (PFN) מה-PTE. ביט Accessed (A) ב-PTE מעודכן ל-1. אם הגישה היא כתיבה, ביט Dirty (D) ב-PTE מעודכן ל-1.\n    *   ה-TLB מתעדכן עם המיפוי החדש (SN, PN) -> PFN.\n\n5.  **חישוב כתובת פיזית וגישה לזיכרון הפיזי:**\n    *   הכתובת הפיזית מחושבת: `Physical_Address = PFN * Page_Size + PO`.\n    *   ה-CPU ניגש לזיכרון הפיזי בכתובת זו כדי לבצע את הפעולה המבוקשת (קריאה/כתיבה).\n\n**1.3. מספר גישות לזיכרון הראשי ולדיסק:**\n\n**א. TLB Hit, והדף נמצא בזיכרון הפיזי (גישת קריאה):**\n*   **גישות ל-TLB:** 1 (Hit).\n*   **גישות לזיכרון הראשי:** 1 (לנתון/פקודה עצמה). אין צורך לגשת לטבלאות בזיכרון הראשי.\n*   **גישות לדיסק:** 0.\n\n**ב. TLB Miss, אך הדף נמצא בזיכרון הפיזי (גישת קריאה):**\n*   **גישות ל-TLB:** 1 (Miss).\n*   **גישות לזיכרון הראשי:**\n    1.  קריאת STE מזיכרון ראשי (עבור SN).\n    2.  קריאת PTE מזיכרון ראשי (עבור PN).\n    3.  קריאת הנתון/פקודה עצמה מזיכרון ראשי.\n    *   **סה\"כ גישות לזיכרון הראשי: 3.** (לאחר מכן ה-TLB מתעדכן).\n*   **גישות לדיסק:** 0.\n\n**ג. TLB Miss, והדף אינו נמצא בזיכרון הפיזי (Page Fault, גישת קריאה):**\n*   **גישות ל-TLB:** 1 (Miss).\n*   **גישות לזיכרון הראשי:**\n    1.  קריאת STE מזיכרון ראשי (עבור SN).\n    2.  קריאת PTE מזיכרון ראשי (עבור PN) – גורם ל-Page Fault.\n    *   **בטיפול ב-Page Fault (בהנחה של דף מוחלף מלוכלך):**\n        3.  קריאת PTE של הדף המוחלף מזיכרון ראשי (כדי לבדוק P, D, A).\n        4.  קריאת תוכן הדף המוחלף מזיכרון ראשי (כדי לכתוב לדיסק).\n        5.  כתיבת PTE של הדף המוחלף לזיכרון ראשי (לסמן P=0).\n        6.  כתיבת תוכן הדף המבוקש לזיכרון ראשי (לאחר קריאה מהדיסק).\n        7.  כתיבת PTE של הדף המבוקש לזיכרון ראשי (לסמן P=1, D=0, A=1, PFN).\n    8.  קריאת הנתון/פקודה עצמה מזיכרון ראשי (לאחר שהדף נטען והפקודה מופעלת מחדש).\n    *   **סה\"כ גישות לזיכרון הראשי: 8.**\n*   **גישות לדיסק:**\n    1.  כתיבת הדף המוחלף לדיסק (כי הוא Dirty).\n    2.  קריאת הדף המבוקש מהדיסק.\n    *   **סה\"כ גישות לדיסק: 2.**"
    },
    "difficulty_estimation": "Hard"
  }
}