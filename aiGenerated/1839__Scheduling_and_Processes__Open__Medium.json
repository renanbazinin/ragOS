{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Scheduling and Processes",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-08 21:07:37",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2768,
      "output_tokens": 1425,
      "total_tokens": 6800
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Scheduling",
      "Processes",
      "CPU Scheduling",
      "Round Robin"
    ],
    "content": {
      "text": "אלגוריתם תזמון Round Robin (RR) הוא אלגוריתם נפוץ במערכות הפעלה, הידוע ביכולתו לספק הוגנות בקרב תהליכים. עם זאת, בחירת גודל ה-quantum (פרוסת הזמן המוקצית לכל תהליך) היא קריטית ומשפיעה באופן משמעותי על ביצועי המערכת. נתחו את ההשפעה של גודל ה-quantum על מדדי ביצועים שונים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "1.1",
        "text": "הסבירו כיצד גודל quantum קטן מאוד (שמתקרב לזמן הנדרש לביצוע החלפת קשר - context switch) משפיע על מדדי ביצועים כגון ניצול מעבד (CPU Utilization), זמן מחזור (Turnaround Time), ומספר החלפות הקשר (Context Switches).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.2",
        "text": "הסבירו כיצד גודל quantum גדול מאוד (שמתקרב לזמן הריצה הממוצע של תהליך, או אפילו יותר) משפיע על אותם מדדי ביצועים.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "1.3",
        "text": "בהתבסס על הניתוח שלכם בסעיפים הקודמים, מהם השיקולים המרכזיים בבחירת גודל quantum 'אופטימלי' באלגוריתם RR? תארו את ה-trade-offs הכרוכים בכך.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "1.1: גודל קוונטום קטן מאוד:\n*   **ניצול מעבד (CPU Utilization):** יורד משמעותית. הסיבה היא שחלק גדול מזמן המעבד מבוזבז על ביצוע החלפות קשר (context switches) במקום על עבודה שימושית. כל החלפת קשר דורשת שמירת מצב התהליך הנוכחי וטעינת מצב התהליך הבא, מה שצורף זמן מעבד.\n*   **זמן מחזור (Turnaround Time):** באופן כללי, זמן המחזור יגדל עבור רוב התהליכים. למרות שתהליכים קצרים עשויים לסיים מהר יותר אם יקבלו את המעבד מיד, העלות הגבוהה של החלפות קשר פוגעת בזמן הכולל של כל תהליך במערכת.\n*   **מספר החלפות קשר (Context Switches):** גבוה מאוד. המערכת עוברת בין תהליכים בתדירות גבוהה מאוד, כמעט כמו חלוקת זמן אידיאלית (processor sharing), אך עם עומס יתר גדול מאוד.\n\n1.2: גודל קוונטום גדול מאוד:\n*   **ניצול מעבד (CPU Utilization):** עולה. פחות זמן מבוזבז על החלפות קשר, מכיוון שכל תהליך מקבל זמן ריצה ארוך יותר לפני החלפת הקשר הבאה.\n*   **זמן מחזור (Turnaround Time):** יגדל, במיוחד עבור תהליכים קצרים. האלגוריתם מתקרב להתנהגות של FCFS (First Come First Served), שכן תהליך יקבל זמן מעבד ארוך לפני שיעבור לתהליך הבא, מה שעלול לגרום לתהליכים קצרים לחכות זמן רב שלא לצורך.\n*   **מספר החלפות קשר (Context Switches):** נמוך מאוד. המערכת עוברת בין תהליכים בתדירות נמוכה, ורק כאשר הקוונטום מסתיים או כשתהליך מסיים את ריצתו.\n\n1.3: שיקולים לבחירת גודל קוונטום 'אופטימלי':\n*   **איזון בין יעילות וזמן תגובה:** המטרה היא למצוא גודל קוונטום שמצד אחד לא יגרום לעומס יתר (overhead) של החלפות קשר ובכך יפגע בניצול המעבד, ומצד שני יספק זמן תגובה (responsiveness) סביר למשתמשים ולתהליכים אינטראקטיביים.\n*   **התחשבות בזמני ריצה אופייניים (CPU bursts):** קוונטום אידיאלי יהיה כזה שיהיה גדול מספיק כדי לאפשר לרוב ה-CPU bursts להסתיים בתוכו (למשל, 80% מה-CPU bursts), אך לא כל כך גדול עד כדי כך שהוא יגרום לתהליכים קצרים לחכות זמן רב שלא לצורך.\n*   **ה-trade-off המרכזי:** קיים trade-off בין **זמן תגובה** (responsiveness) לבין **תפוקה** (throughput) ו**ניצול מעבד**. קוונטום קטן מדי משפר זמן תגובה (הרגשה של מהירות תגובה) אך מוריד תפוקה וניצול מעבד. קוונטום גדול מדי משפר תפוקה וניצול מעבד (עד גבול מסוים) אך פוגע בזמן תגובה ובשוויון בין תהליכים שונים."
    },
    "difficulty_estimation": "Medium"
  }
}