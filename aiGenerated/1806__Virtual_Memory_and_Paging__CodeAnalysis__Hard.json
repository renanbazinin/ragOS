{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory and Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 21:00:12",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2792,
      "output_tokens": 3871,
      "total_tokens": 19430
    }
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Paging",
      "TLB",
      "Locality"
    ],
    "content": {
      "text": "נתונה תוכנית C המבצעת גישה למערך דו-ממדי גדול. התוכנית מבצעת שתי סריקות שונות על המערך: אחת בסדר שורות (row-major) ואחת בסדר עמודות (column-major).\n\nיש להניח את ההנחות הבאות לגבי מערכת ההפעלה ומערכת הזיכרון הווירטואלי:\n*   גודל עמוד (Page Size): 4KB (4096 בתים).\n*   גודל ערך בודד במערך: `sizeof(int)` = 4 בתים.\n*   גודל המטריצה: `MATRIX_DIM` x `MATRIX_DIM` כאשר `MATRIX_DIM = 10000`.\n*   הזיכרון הפיזי זמין גדול מספיק כדי להכיל את כל המטריצה.\n*   ה-TLB (Translation Lookaside Buffer) מכיל 64 כניסות והוא fully associative, ומשתמש במדיניות החלפה LRU (Least Recently Used).\n*   ה-TLB ריק בתחילת כל סריקה (כלומר, לפני לולאת ה-row-major ולפני לולאת ה-column-major).\n*   כל דפי המטריצה טעונים לזיכרון הפיזי, ורשומות טבלת הדפים (PTEs) עבורם תקינות. כלומר, אין page faults הדורשים טעינה מהדיסק. עם זאת, גישה ראשונה לדף כלשהו (או לאחר הוצאתו מה-TLB) תגרום ל-TLB miss.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MATRIX_DIM 10000 // N x N matrix\n\nint main() {\n    // Allocate a large 2D array on the heap\n    int **matrix = (int **)malloc(MATRIX_DIM * sizeof(int *));\n    if (matrix == NULL) {\n        perror(\"Failed to allocate matrix rows\");\n        return 1;\n    }\n    for (int i = 0; i < MATRIX_DIM; ++i) {\n        matrix[i] = (int *)malloc(MATRIX_DIM * sizeof(int));\n        if (matrix[i] == NULL) {\n            perror(\"Failed to allocate matrix columns\");\n            for (int k = 0; k < i; ++k) {\n                free(matrix[k]);\n            }\n            free(matrix);\n            return 1;\n        }\n    }\n\n    // Initialize with some values (this phase pre-loads all pages into physical memory)\n    for (int i = 0; i < MATRIX_DIM; ++i) {\n        for (int j = 0; j < MATRIX_DIM; ++j) {\n            matrix[i][j] = i * MATRIX_DIM + j;\n        }\n    }\n\n    long long sum_row_major = 0;\n    long long sum_col_major = 0;\n\n    // Access 1: Row-major\n    printf(\"Accessing row-major...\\n\");\n    for (int i = 0; i < MATRIX_DIM; ++i) {\n        for (int j = 0; j < MATRIX_DIM; ++j) {\n            sum_row_major += matrix[i][j];\n        }\n    }\n\n    // Access 2: Column-major\n    printf(\"Accessing column-major...\\n\");\n    for (int j = 0; j < MATRIX_DIM; ++j) { // Outer loop for columns\n        for (int i = 0; i < MATRIX_DIM; ++i) { // Inner loop for rows\n            sum_col_major += matrix[i][j];\n        }\n    }\n\n    // Free memory\n    for (int i = 0; i < MATRIX_DIM; ++i) {\n        free(matrix[i]);\n    }\n    free(matrix);\n\n    return 0;\n}\n```\n\n**שאלות:**\n1.  כמה דפים ייחודיים של נתוני המטריצה (ללא מערך המצביעים) קיימים בסך הכל?\n2.  כמה TLB misses יתרחשו במהלך סריקת ה-row-major? הסבר את החישוב.\n3.  כמה TLB misses יתרחשו במהלך סריקת ה-column-major? הסבר את החישוב.\n4.  הסבר את הבדלי הביצועים המשמעותיים הצפויים בין שתי שיטות הגישה, תוך התייחסות למושגי זיכרון וירטואלי כגון לוקליות מרחבית (spatial locality) והשפעת ה-TLB.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": 25,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "**חישובים והסברים:**\n\n**נתונים בסיסיים:**\n*   גודל מטריצה: `10000 x 10000` אינטגרים.\n*   גודל אינטגר: 4 בתים.\n*   גודל עמוד (Page Size): 4KB = 4096 בתים.\n*   מספר אינטגרים לדף: `4096 / 4 = 1024` אינטגרים.\n*   גודל TLB: 64 כניסות, fully associative, LRU.\n\n**1. מספר דפים ייחודיים של נתוני המטריצה:**\n*   גודל כולל של נתוני המטריצה: `10000 * 10000 * 4 = 400,000,000` בתים = `400 MB`.\n*   מספר הדפים הדרושים לנתוני המטריצה: `400 MB / 4 KB/page = 100,000` דפים.\n*   (יש גם דפים עבור מערך המצביעים `int **matrix`, שגודלו `10000 * sizeof(int*)` = `10000 * 8 = 80000` בתים = `80KB`, שזה `20` דפים. אך השאלה מתייחסת לנתוני המטריצה בלבד).\n\n**2. TLB misses במהלך סריקת ה-row-major:**\n*   גישה בסדר שורות: `matrix[i][j]` ואז `matrix[i][j+1]`, וכו'.\n*   שורת המטריצה בגודל `10000 * 4 = 40000` בתים.\n*   מספר דפים לשורה: `40000 / 4096 = 9.76...`, כלומר כל שורה מתפרסת על פני `10` דפים (9 דפים מלאים ודף עשירי חלקי).\n*   כאשר סורקים שורה, מתבצעת גישה ל-10 דפים ברצף. מאחר וה-TLB יכול להכיל 64 כניסות (`10 < 64`), כל 10 הדפים של השורה הנוכחית ייטענו ל-TLB (יגרמו ל-10 TLB misses) ויישארו בו עד לסיום הסריקה של השורה. כל הגישות הבאות לאותם 10 דפים באותה שורה יהיו TLB hits.\n*   ה-TLB יכול להכיל `64 / 10 = 6.4` שורות שלמות.\n*   **עבור השורות הראשונות (0 עד 5):** כל שורה גורמת ל-10 TLB misses כדי לטעון את 10 הדפים שלה. סך הכל `6 * 10 = 60` TLB misses. בסיום שורה 5, ה-TLB מכיל את כל 60 הדפים של השורות `0-5`.\n*   **עבור שורה 6:** נגשים ל-10 דפים חדשים. אלה יגרמו ל-10 TLB misses. מאחר וה-TLB מכיל כבר 60 כניסות, 4 מהדפים החדשים (P_6_0 עד P_6_3) ייכנסו ל-TLB, והוא יכיל 64 כניסות. 6 הדפים הנותרים של שורה 6 (P_6_4 עד P_6_9) יגרמו גם הם ל-TLB misses ויפנו 6 כניסות LRU (דפים P_0_0 עד P_0_5). בסיום שורה 6, ה-TLB מכיל 64 כניסות (P_0_6 עד P_0_9, ו-P_1_0 עד P_6_9).\n*   **עבור שורה 7 והלאה (עד שורה 9999):** כל שורה (10 דפים) תגרום ל-10 TLB misses. הסיבה היא שעד שחוזרים לדפים של שורה מסוימת, הם כבר הספיקו להיפלט מה-TLB על ידי דפים של שורות מאוחרות יותר (מאחר שה-TLB יכול להכיל רק כ-6 שורות בו זמנית).\n*   לכן, עבור כל אחת מ-`10000` השורות, יתרחשו `10` TLB misses.\n*   **סה\"כ TLB misses עבור row-major:** `10000` שורות * `10` דפים/שורה = `100,000` TLB misses.\n\n**3. TLB misses במהלך סריקת ה-column-major:**\n*   גישה בסדר עמודות: `matrix[i][j]` ואז `matrix[i+1][j]`, וכו'.\n*   כאשר `j` קבוע, הגישה `matrix[i][j]` ו-`matrix[i+1][j]` היא לדפים המרוחקים ב-`MATRIX_DIM * sizeof(int)` בתים.\n*   המרחק הזה הוא `10000 * 4 = 40000` בתים.\n*   `40000` בתים שווים ל-`10` דפים (`40000 / 4096 = 9.76...`).\n*   כלומר, כל גישה ל-`matrix[i][j]` עבור `i` עוקב (כאשר `j` קבוע) היא לדף אחר, המרוחק מאוד מהדף הקודם. לדוגמה, `matrix[0][0]` ו-`matrix[1][0]` נמצאים על דפים שונים לחלוטין (למעשה, במרחק של 10 דפים).\n*   במהלך סריקת עמודה, אנו נגשים ל-`10000` דפים ייחודיים (אחד עבור כל `matrix[i][j]` כאשר `i` משתנה).\n*   מאחר שה-TLB מכיל רק `64` כניסות, הוא אינו יכול להכיל את כל ה-`10000` דפים הללו. בפועל, כמעט כל גישה לדף תגרום ל-TLB miss, מכיוון שהדף הנדרש ככל הנראה כבר נפלט מה-TLB (או מעולם לא היה בו) על ידי דפים אחרים שנגשו אליהם קודם לכן באותה עמודה או בעמודות קודמות.\n*   **סה\"כ TLB misses עבור column-major:** `MATRIX_DIM * MATRIX_DIM = 10000 * 10000 = 100,000,000` גישות, וכל גישה כזו תגרום כמעט בוודאות ל-TLB miss. לכן, `100,000,000` TLB misses.\n\n**4. הסבר הבדלי הביצועים:**\nההבדל העצום במספר ה-TLB misses (100,000 ב-row-major לעומת 100,000,000 ב-column-major) הוא הגורם המרכזי להבדלי הביצועים:\n\n*   **לוקליות מרחבית (Spatial Locality):**\n    *   **Row-major:** גישה זו מציגה לוקליות מרחבית מצוינת. אלמנטים עוקבים במערך (`matrix[i][j]`, `matrix[i][j+1]`) מאוחסנים ברצף בזיכרון הפיזי (ובעקבות כך באותו דף זיכרון). כאשר דף נטען ל-TLB (ולמטמון המעבד), ניתן לגשת לכל שאר הנתונים באותו דף (1024 אינטגרים) ללא TLB miss נוסף (ולרוב גם ללא cache miss נוסף). זה מנצל ביעילות את גודל הדף ואת קווי המטמון (cache lines).\n    *   **Column-major:** גישה זו מציגה לוקליות מרחבית ירודה ביותר. אלמנטים עוקבים בגישה זו (`matrix[i][j]`, `matrix[i+1][j]`) מרוחקים מאוד בזיכרון הפיזי (במקרה זה, 10 דפים זה מזה). כל גישה כזו היא לדף זיכרון אחר לגמרי.\n\n*   **השפעת ה-TLB:**\n    *   **TLB miss:** כאשר מתרחש TLB miss, יחידת ניהול הזיכרון (MMU) נאלצת לחפש את ה-PTE (Page Table Entry) המתאים בטבלת הדפים, המאוחסנת בזיכרון הראשי. פעולה זו יקרה בהרבה מגישה ל-TLB (שנמצא על השבב). ה-TLB נועד להאיץ את תרגום הכתובות על ידי שמירה של מיפויים בשימוש תכוף.\n    *   **Row-major:** מספר ה-TLB misses נמוך יחסית. עבור כל שורה, יש 10 misses ראשוניים, ואז כל שאר הגישות באותה שורה הן TLB hits. למרות שה-TLB לא יכול להכיל את כל המטריצה, הוא יכול להכיל מספיק דפים כדי לספק לוקליות טובה בתוך כל שורה, וגם לשמור חלק מהשורות הקודמות.\n    *   **Column-major:** מספר ה-TLB misses גבוה באופן דרמטי. כמעט כל גישה לאינטגר במטריצה גורמת ל-TLB miss, מכיוון שהגישה היא תמיד לדף זיכרון חדש שאינו נמצא ב-TLB (ה-TLB קטן מכדי להכיל אפילו חלק קטן מהדפים הרלוונטיים לעמודה אחת). המשמעות היא שכמעט כל תרגום כתובת דורש גישה לזיכרון הראשי כדי לאתר את ה-PTE, מה שמאט את הביצועים באופן משמעותי.\n\nלסיכום, הגישה בסדר שורות מנצלת את הלוקליות המרחבית ואת ה-TLB ביעילות, מה שמוביל למספר נמוך בהרבה של TLB misses ולביצועים מהירים יותר. הגישה בסדר עמודות, לעומת זאת, סובלת מלוקליות מרחבית ירודה ומכמות עצומה של TLB misses, מה שגורם לביצועים איטיים בהרבה."
    },
    "difficulty_estimation": "Hard"
  }
}