{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Copy-on-Write",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 09:04:20",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4965,
      "output_tokens": 3360,
      "total_tokens": 15565
    }
  },
  "question": {
    "id": 10,
    "type": "Open",
    "topic": [
      "Memory Management",
      "Copy-on-Write",
      "Virtual Memory"
    ],
    "content": {
      "text": "מערכת הפעלה מודרנית מיישמת מנגנון Copy-on-Write (CoW) עבור אזורי זיכרון דינמיים בתהליכים. כאשר תהליך יוצר אזור זיכרון חדש וגדול, הוא מקצה לו דפים פיזיים. אם תהליך אחר \"משתף\" אזור זיכרון זה (באמצעות פונקציה דמיונית `share_memory_region`), שני התהליכים מצביעים לאותם דפים פיזיים, ומוני ההפניות של הדפים הללו מוגדלים בהתאם. כתיבה לדף משותף גורמת לשכפול הדף, עדכון טבלאות הדפים של התהליכים, והקטנת מונה ההפניות של הדף המקורי (עבור התהליך הכותב) והגדלת מונה ההפניות של הדף החדש. גודל דף הוא 4KB.\n\nנתונים:\n*   גודל מצביע (pointer) בטבלת דפים הוא 8 בתים.\n*   מונה הפניות לדף פיזי מאוחסן במבנה נפרד ודורש 4 בתים לכל דף.\n*   לצורך פשטות, נניח שטבלאות הדפים מתרחבות באופן אוטומטי לפי הצורך ואינן משפיעות על חישובי השימוש בדפים פיזיים אלא אם צוין אחרת.\n*   כל פעולת שכפול דף (CoW) דורשת קריאה של הדף המקורי וכתיבה לשני דפים (הדף המקורי לאחר הקטנת מונה ההפניות, והדף החדש לאחר הגדלת מונה ההפניות).",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": [
      {
        "id": "10.1",
        "text": "תהליך P1 מקצה אזור זיכרון בגודל 1MB. לאחר מכן, הוא קורא לארבעה תהליכי ילד (P2, P3, P4, P5) ומעביר לכל אחד מהם עותק CoW של אזור הזיכרון (באמצעות `share_memory_region`). לאחר מכן, כל אחד מהתהליכים (P1 עד P5) כותב לבית בודד בדף *שונה* בתוך אזור הזיכרון המשופתף. כמה דפים פיזיים בסך הכל יוקצו במערכת לאחר סיום כל הפעולות הללו? (התייחס גם לדפי נתונים וגם לדפי מטא-דאטה עבור מוני ההפניות).",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.2",
        "text": "בתרחיש אחר, תהליך P1 מקצה אזור זיכרון בגודל 2MB. לאחר מכן, הוא קורא לפונקציה `share_memory_region` חמש פעמים, כך שיש לו שישה \"עותקים\" לוגיים של אזור הזיכרון (העותק המקורי ועוד חמישה משותפים). תהליך P1 כותב כעת ל-100 דפים שונים באזור הזיכרון שלו. לאחר מכן, אחד מהעותקים המשותפים (נניח P2) כותב גם הוא ל-50 דפים שונים באזור הזיכרון שלו, כאשר 20 מהדפים הללו חופפים לדפים ש-P1 כבר כתב אליהם. כמה פעולות שכפול דפים (CoW) בסך הכל יבוצעו במהלך כל הכתיבות המתוארות? נמק.",
        "code_snippet": null,
        "options": null
      },
      {
        "id": "10.3",
        "text": "הסבר והדגם כיצד מנגנון CoW יכול להוביל לבעיית \"Fragmented Memory\" (פיצול זיכרון) במערכת, וכיצד ניתן למתן בעיה זו.",
        "code_snippet": null,
        "options": null
      }
    ],
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "10.1: תחילה, P1 מקצה אזור זיכרון בגודל 1MB. גודל דף הוא 4KB. לכן, 1MB = 1024KB. מספר דפי הנתונים הנדרשים הוא 1024KB / 4KB = 256 דפים. \n\nלצורך אחסון מוני ההפניות, כל מונה דורש 4 בתים. דף פיזי יכול להכיל 4KB / 4B = 1024 מוני הפניות. מכיוון שיש 256 דפי נתונים, נדרש דף פיזי אחד עבור מוני ההפניות (256/1024 < 1, אז דף אחד מספיק). \n\nסה\"כ דפים פיזיים שהוקצו בתחילה: 256 דפי נתונים + 1 דף מוני הפניות = 257 דפים. \n\nלאחר מכן, P1 קורא לארבעה תהליכי ילד (P2-P5) ומשתף את אזור הזיכרון. בשלב זה, מוני ההפניות של 256 דפי הנתונים מוגדלים ל-5 (P1 + P2 + P3 + P4 + P5). אין הקצאת דפים פיזיים חדשים בשלב זה. \n\nלבסוף, כל אחד מהתהליכים (P1 עד P5) כותב לבית בודד בדף *שונה* בתוך אזור הזיכרון המשופתף. כל כתיבה כזו לדף משותף (שמונה ההפניות שלו גדול מ-1) מפעילה מנגנון CoW וגורמת לשכפול הדף. מכיוון ש-5 תהליכים כותבים ל-5 דפים שונים, יבוצעו 5 פעולות CoW. כל פעולת CoW מקצה דף פיזי חדש עבור התהליך הכותב. \n\nלכן, יתווספו 5 דפי נתונים פיזיים חדשים. \nסה\"כ דפי נתונים: 256 (מקוריים) + 5 (משוכפלים) = 261 דפים. \n\nמספר מוני ההפניות הכולל הוא כעת 261. מכיוון שדף אחד יכול להכיל 1024 מוני הפניות, עדיין נדרש רק דף פיזי אחד עבור מוני ההפניות. \n\nסה\"כ דפים פיזיים בסיום הפעולות: 261 דפי נתונים + 1 דף מוני הפניות = 262 דפים.\n\n10.2: תחילה, P1 מקצה אזור זיכרון בגודל 2MB. מספר דפי הנתונים הוא 2MB / 4KB = 512 דפים. \n\nלאחר מכן, P1 קורא לפונקציה `share_memory_region` חמש פעמים, כך שיש לו שישה \"עותקים\" לוגיים של אזור הזיכרון (P1 ועוד 5 עותקים משותפים). בשלב זה, כל 512 דפי הנתונים המקוריים הם בעלי מונה הפניות של 6.\n\nתהליך P1 כותב ל-100 דפים שונים. מכיוון שכל הדפים משותפים (מונה הפניות 6), כל כתיבה כזו מפעילה CoW. לכן, P1 יבצע 100 פעולות CoW. כל פעולה כזו יוצרת דף פיזי חדש עבור P1, ומונה ההפניות של הדף המקורי (ממנו P1 העתיק) קטן מ-6 ל-5. \n\nלאחר מכן, P2 כותב ל-50 דפים שונים באזור הזיכרון שלו: \n*   **30 דפים שאינם חופפים לדפים ש-P1 כתב אליהם**: דפים אלו עדיין משותפים ל-6 תהליכים (P1 לא כתב אליהם, P2 עכשיו כותב אליהם, ועוד 4 תהליכים ועוד P1). מונה ההפניות שלהם הוא 6. כל כתיבה כזו מפעילה CoW. לכן, יבוצעו 30 פעולות CoW נוספות. \n*   **20 דפים החופפים לדפים ש-P1 כבר כתב אליהם**: כאשר P1 כתב לדפים אלו, הוא קיבל עותק פרטי חדש. הדפים המקוריים ש-P1 העתיק מהם עדיין קיימים ומשותפים ל-5 תהליכים (P2 ועוד 4 תהליכים, P1 כבר לא מצביע אליהם). לכן, מונה ההפניות של הדפים המקוריים האלה הוא 5. כאשר P2 כותב לדפים אלו, הוא עדיין מצביע לדפים המקוריים המשותפים. מכיוון שמונה ההפניות גדול מ-1 (הוא 5), גם כתיבות אלו יפעילו CoW. לכן, יבוצעו 20 פעולות CoW נוספות. \n\nסה\"כ פעולות שכפול דפים (CoW) שבוצעו: 100 (על ידי P1) + 30 (על ידי P2, לא חופפים) + 20 (על ידי P2, חופפים) = 150 פעולות CoW.\n\n10.3: מנגנון CoW, על אף יתרונותיו בחיסכון בזיכרון, עלול להוביל לבעיית \"Fragmented Memory\" (פיצול זיכרון). פיצול זה מתרחש כאשר דפים פיזיים שהיו במקור רציפים בזיכרון הווירטואלי של תהליך, הופכים ללא-רציפים בזיכרון הפיזי עקב פעולות CoW. \n\n**הסבר והדגמה:** נניח שתהליך מקצה מערך גדול של נתונים, לדוגמה `int arr[1024*1024]`, המשתרע על פני 100 דפים פיזיים רציפים (P1, P2, ..., P100). כאשר אזור זיכרון זה משותף בין מספר תהליכים, כולם מצביעים לאותם דפים פיזיים. אם אחד התהליכים משנה אלמנט ב-`arr` שנמצא בדף P50, מנגנון CoW ישכפל את P50 לדף חדש P50'. דף P50' זה יוקצה ככל הנראה במיקום פיזי שאינו רציף לדפים P49 ו-P51. כתוצאה מכך, הגישה למערך `arr` עבור התהליך ששינה אותו תכלול כעת גישה לדפים פיזיים לא רציפים: `P1, ..., P49, P50', P51, ..., P100`. \n\n**השלכות:** פיצול זיכרון כזה פוגע בביצועים מכמה סיבות: \n*   **פגיעה ב-Cache Locality:** גישה לנתונים שאינם רציפים בזיכרון הפיזי מפחיתה את יעילות ה-cache (L1, L2, L3) וה-TLB (Translation Lookaside Buffer), ומגדילה את מספר ה-cache misses וה-TLB misses. הדבר גורם לביצועים איטיים יותר עקב הצורך בגישות רבות יותר לזיכרון הראשי. \n*   **ניהול זיכרון מורכב:** מקשה על ניהול יעיל של הזיכרון על ידי מערכת ההפעלה, במיוחד כאשר מנסים להקצות אזורים גדולים ורציפים בעתיד. \n\n**דרכים למיתון הבעיה:** \n*   **הקצאה מקומית (Locality-aware allocation):** מערכת ההפעלה יכולה לנסות להקצות דפים משוכפלים במיקום פיזי קרוב ככל האפשר לדפים המקוריים, או באזורים שעדיין שומרים על עקרון המקומיות, אם כי זה לא תמיד אפשרי. \n*   **דפים ענקיים (Huge Pages):** שימוש בדפים ענקיים (Transparent Huge Pages - THP) יכול להפחית את מספר הדפים הווירטואליים הכולל, אך אם דף ענק משוכפל, הוא נשבר לדפים קטנים יותר, מה שעלול להחמיר את הפיצול. לכן, יש לנהל THP בזהירות בהקשר של CoW. \n*   **אופטימיזציה ברמת האפליקציה:** אפליקציות יכולות לתכנן את מבני הנתונים שלהן כך שימזערו כתיבות לדפים משותפים, או להשתמש בטכניקות כמו \"copy-on-write-on-write\" (כלומר, לא לשכפל מיד אלא רק כשמשתנה נוסף כותב) אם זה מתאים לדרישות ה-consistency. \n*   **איחוי זיכרון (Defragmentation):** מנגנוני איחוי זיכרון יכולים לסדר מחדש דפים פיזיים כדי להחזיר רציפות, אך אלו פעולות יקרות שעלולות לדרוש עצירה או הקפאה של תהליכים ואינן מעשיות בדרך כלל עבור זיכרון פעיל."
    },
    "difficulty_estimation": "Hard"
  }
}