{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Signals and System Calls",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 11:58:03",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4212,
      "output_tokens": 3315,
      "total_tokens": 14559
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Signals",
      "System Calls",
      "Inter-Process Communication",
      "Process Management"
    ],
    "content": {
      "text": "תהליך אב (Parent) יוצר תהליך בן (Child). הם מתקשרים ביניהם באמצעות צינור (pipe) אנונימי. תהליך הבן מתוכנן לקרוא באופן רציף בלוקים של נתונים מהצינור ולעבד אותם (לדוגמה, לספור את כמות התווים בבלוק). תהליך האב כותב בלוקים של נתונים אקראיים לצינור. לאחר כתיבת סך של N בלוקים, תהליך האב שולח אות `SIGUSR1` לתהליך הבן. תהליך הבן צריך ללכוד את האות, להדפיס הודעה מתאימה, ואז לסיים את לולאת הקריאה שלו בצורה מסודרת ולצאת.",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <string.h>\n\n#define BLOCK_SIZE 128\n#define NUM_BLOCKS 10 // N blocks\n\nvolatile sig_atomic_t sigusr1_received = 0;\n\nvoid handle_sigusr1(int sig) {\n    // TODO: Implement signal handler logic\n}\n\nint main(int argc, char *argv[]) {\n    int pipefd[2];\n    pid_t pid;\n\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Close unused write end\n\n        // TODO: Set up SIGUSR1 handler using sigaction\n\n        char buffer[BLOCK_SIZE];\n        ssize_t bytes_read;\n        int total_chars = 0;\n\n        while (!sigusr1_received) {\n            // TODO: Read from pipe, handle EINTR, process data\n        }\n\n        printf(\"Child: SIGUSR1 received. Exiting loop. Total chars processed: %d\\n\", total_chars);\n        close(pipefd[0]);\n        exit(EXIT_SUCCESS);\n\n    } else { // Parent process\n        close(pipefd[0]); // Close unused read end\n\n        // TODO: Write NUM_BLOCKS random data blocks to pipe\n        // TODO: Send SIGUSR1 to child\n\n        close(pipefd[1]);\n        wait(NULL); // Wait for child to terminate\n        printf(\"Parent: Child terminated. Exiting.\\n\");\n        exit(EXIT_SUCCESS);\n    }\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הסבר:\n1.  **הגדרת מטפל אותות (`sigaction`):**\n    *   אנו משתמשים ב-`sigaction` במקום ב-`signal` מכיוון ש-`sigaction` מספק דרך אמינה וניידת יותר לטפל באותות. הוא מאפשר שליטה עדינה יותר על התנהגות האות, כולל חסימת אותות נוספים בזמן הטיפול באות הנוכחי.\n    *   הדגל `volatile sig_atomic_t sigusr1_received` משמש כדי להבטיח גישה אטומית ובטוחה למשתנה זה הן מלולאת הריצה הראשית והן ממטפל האותות. `volatile` מונע אופטימיזציות של המהדר שעשויות למנוע עדכון נכון של המשתנה, ו-`sig_atomic_t` מבטיח שהגישה למשתנה היא אטומית (כלומר, לא ניתנת להפרעה).\n    *   מטפל האותות עצמו פשוט מאוד: הוא רק קובע את הדגל `sigusr1_received` ל-1. זוהי פרקטיקה מומלצת למטפלי אותות כדי לשמור על בטיחות אסינכרונית (async-signal-safety). פעולות מורכבות יותר בתוך מטפל אותות עלולות להוביל למצבי מירוץ, קיפאון (deadlock) או התנהגות בלתי מוגדרת.\n\n2.  **לוגיקת תהליך הבן:**\n    *   תהליך הבן סוגר את קצה הכתיבה של הצינור (`pipefd[1]`) מכיוון שאינו משתמש בו.\n    *   הוא מגדיר את מטפל האותות `SIGUSR1` באמצעות `sigaction`. לא השתמשנו בדגל `SA_RESTART` במבנה ה-`sigaction` כדי להדגים טיפול מפורש ב-`EINTR`.\n    *   הלולאה הראשית `while (!sigusr1_received)` מנסה ברציפות לקרוא מהצינור באמצעות `read()`.\n    *   **טיפול ב-`EINTR`:** קריאת המערכת `read()` עלולה להיקטע על ידי אות. אם היא מחזירה -1 ו-`errno` מוגדר ל-`EINTR`, זה אומר שמטפל האותות בוצע. במקרה זה, יש לנסות שוב את פעולת ה-`read`, אלא אם כן הדגל `sigusr1_received` כבר הוגדר (מה שיגרום ליציאה מהלולאה). זה מבטיח שהתהליך לא יפסיק לקרוא סתם בגלל אות שאינו אות סיום.\n    *   לאחר קריאת הנתונים, התהליך מעבד אותם (בדוגמה, סופר תווים שאינם null).\n    *   ברגע ש-`sigusr1_received` הופך ל-true (לאחר ביצוע מטפל האותות), הלולאה מסתיימת, קצה הקריאה של הצינור נסגר, ותהליך הבן יוצא.\n\n3.  **לוגיקת תהליך האב:**\n    *   תהליך האב סוגר את קצה הקריאה של הצינור (`pipefd[0]`) מכיוון שאינו משתמש בו.\n    *   הוא מייצר בלוקים של נתונים אקראיים וכותב אותם לצינור באמצעות `write()`.\n    *   לאחר כתיבת `NUM_BLOCKS` בלוקים, הוא שולח את האות `SIGUSR1` לתהליך הבן באמצעות `kill(pid, SIGUSR1)`.\n    *   לאחר מכן, הוא סוגר את קצה הכתיבה של הצינור וממתין לתהליך הבן שיסיים את פעולתו באמצעות `wait(NULL)`.\n\n**מושגים מרכזיים שהודגמו:**\n*   תקשורת בין תהליכים (IPC) באמצעות צינורות.\n*   יצירת תהליכים עם `fork()`.\n*   טיפול אמין באותות עם `sigaction()`.\n*   טיפול בקריאות מערכת שנקטעו (`EINTR`).\n*   שימוש ב-`volatile sig_atomic_t` עבור דגלים המשתנים על ידי מטפלי אותות.\n*   סיום תהליך בצורה מסודרת.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <string.h>\n#include <time.h> // For srand\n\n#define BLOCK_SIZE 128\n#define NUM_BLOCKS 10 // N blocks\n\n// Flag to indicate if SIGUSR1 has been received\nvolatile sig_atomic_t sigusr1_received = 0;\n\n// Signal handler for SIGUSR1\nvoid handle_sigusr1(int sig) {\n    if (sig == SIGUSR1) {\n        printf(\"Child: Signal SIGUSR1 caught!\\n\");\n        sigusr1_received = 1;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    int pipefd[2];\n    pid_t pid;\n\n    // Create the pipe\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Fork a child process\n    pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Close unused write end of the pipe\n\n        // Set up SIGUSR1 handler using sigaction for reliable signal handling\n        struct sigaction sa;\n        memset(&sa, 0, sizeof(sa));\n        sa.sa_handler = handle_sigusr1;\n        sigemptyset(&sa.sa_mask); // No additional signals blocked inside handler\n        // SA_RESTART is often used to automatically restart interrupted system calls.\n        // For a hard question, we might want to explicitly handle EINTR, so we omit SA_RESTART here.\n        // If SA_RESTART was used, read() would automatically restart unless sigusr1_received became true.\n        // sa.sa_flags = SA_RESTART;\n        if (sigaction(SIGUSR1, &sa, NULL) == -1) {\n            perror(\"sigaction\");\n            exit(EXIT_FAILURE);\n        }\n\n        char buffer[BLOCK_SIZE];\n        ssize_t bytes_read;\n        int total_chars = 0;\n        int block_count = 0;\n\n        printf(\"Child: Starting to read from pipe...\\n\");\n        while (!sigusr1_received) {\n            bytes_read = read(pipefd[0], buffer, BLOCK_SIZE);\n\n            if (bytes_read == -1) {\n                if (errno == EINTR) {\n                    // System call interrupted by a signal.\n                    // Check if it was SIGUSR1. If so, loop will terminate.\n                    // Otherwise, retry read.\n                    printf(\"Child: read() interrupted by signal, retrying...\\n\");\n                    continue; // Retry the read operation\n                } else {\n                    perror(\"read\");\n                    exit(EXIT_FAILURE);\n                }\n            } else if (bytes_read == 0) {\n                // End of file (pipe closed by parent)\n                printf(\"Child: Parent closed pipe, no more data.\\n\");\n                break;\n            } else {\n                // Successfully read data\n                block_count++;\n                printf(\"Child: Read %zd bytes (block %d). Processing...\\n\", bytes_read, block_count);\n                for (int i = 0; i < bytes_read; ++i) {\n                    if (buffer[i] != '\\0') { // Simple processing: count non-null chars\n                        total_chars++;\n                    }\n                }\n            }\n        }\n\n        printf(\"Child: SIGUSR1 received or pipe closed. Exiting loop. Total chars processed: %d\\n\", total_chars);\n        close(pipefd[0]); // Close the read end of the pipe\n        exit(EXIT_SUCCESS);\n\n    } else { // Parent process\n        close(pipefd[0]); // Close unused read end of the pipe\n        srand(time(NULL)); // Seed for random data generation\n\n        printf(\"Parent: Starting to write to pipe...\\n\");\n        for (int i = 0; i < NUM_BLOCKS; ++i) {\n            char buffer[BLOCK_SIZE];\n            for (int j = 0; j < BLOCK_SIZE; ++j) {\n                buffer[j] = (char)(33 + rand() % 94); // Printable ASCII chars\n            }\n            // Add a null terminator for string-like behavior if needed, though not strictly required for this problem.\n            // buffer[BLOCK_SIZE-1] = '\\0';\n\n            printf(\"Parent: Writing block %d to pipe...\\n\", i + 1);\n            if (write(pipefd[1], buffer, BLOCK_SIZE) == -1) {\n                perror(\"write\");\n                exit(EXIT_FAILURE);\n            }\n            sleep(1); // Simulate some work/delay\n        }\n\n        printf(\"Parent: Finished writing %d blocks. Sending SIGUSR1 to child (PID: %d)...\n\", NUM_BLOCKS, pid);\n        if (kill(pid, SIGUSR1) == -1) {\n            perror(\"kill\");\n            exit(EXIT_FAILURE);\n        }\n\n        close(pipefd[1]); // Close the write end of the pipe\n        printf(\"Parent: Waiting for child to terminate...\\n\");\n        wait(NULL); // Wait for the child process to terminate\n        printf(\"Parent: Child terminated. Exiting.\\n\");\n        exit(EXIT_SUCCESS);\n    }\n\n    return 0; // Should not be reached\n}\n"
    },
    "difficulty_estimation": "Hard"
  }
}