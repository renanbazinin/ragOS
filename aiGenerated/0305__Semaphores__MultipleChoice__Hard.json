{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 20:39:42",
    "examples_used": 2,
    "token_usage": {
      "prompt_tokens": 970,
      "output_tokens": 1132,
      "total_tokens": 9969
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Deadlock"
    ],
    "content": {
      "text": "נתון קטע הקוד הבא המשתמש בסמפורים (semaphores) לצורך סנכרון בין שני תהליכונים (threads) שונים.\n\n```c\n#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h> // for sleep\n\nsem_t sem_R1;\nsem_t sem_R2;\n\nvoid* taskA(void* arg) {\n    printf(\"TaskA: Trying to acquire R1\\n\");\n    sem_wait(&sem_R1);\n    printf(\"TaskA: Acquired R1, trying to acquire R2\\n\");\n    sleep(1); // Simulate work or context switch\n    sem_wait(&sem_R2);\n    printf(\"TaskA: Acquired R2. Critical section.\\n\");\n    // ... do work ...\n    sem_post(&sem_R2);\n    printf(\"TaskA: Released R2.\\n\");\n    sem_post(&sem_R1);\n    printf(\"TaskA: Released R1.\\n\");\n    return NULL;\n}\n\nvoid* taskB(void* arg) {\n    printf(\"TaskB: Trying to acquire R2\\n\");\n    sem_wait(&sem_R2);\n    printf(\"TaskB: Acquired R2, trying to acquire R1\\n\");\n    sleep(1); // Simulate work or context switch\n    sem_wait(&sem_R1);\n    printf(\"TaskB: Acquired R1. Critical section.\\n\");\n    // ... do work ...\n    sem_post(&sem_R1);\n    printf(\"TaskB: Released R1.\\n\");\n    sem_post(&sem_R2);\n    printf(\"TaskB: Released R2.\\n\");\n    return NULL;\n}\n\nint main() {\n    sem_init(&sem_R1, 0, 1); // Binary semaphore for R1\n    sem_init(&sem_R2, 0, 1); // Binary semaphore for R2\n\n    pthread_t tidA, tidB;\n    pthread_create(&tidA, NULL, taskA, NULL);\n    pthread_create(&tidB, NULL, taskB, NULL);\n\n    pthread_join(tidA, NULL);\n    pthread_join(tidB, NULL);\n\n    sem_destroy(&sem_R1);\n    sem_destroy(&sem_R2);\n    return 0;\n}\n```\nבאיזו בעיה, סביר להניח, נתקל בעת הרצת התוכנית עם שני התהליכונים taskA ו-taskB במקביל?",
      "code_snippet": null,
      "options": [
        "א. התוכנית תמיד תסיים את ריצתה ללא בעיות סנכרון.",
        "ב. אחד מהתהליכונים עלול לסבול מרעב (starvation) ולא לסיים את משימתו.",
        "ג. התוכנית עלולה להיכנס למצב של קיפאון (deadlock).",
        "ד. התוכנית עלולה לסבול מתנאי מרוץ (race condition) שיובילו לנתונים שגויים.",
        "ה. אף אחת מהטענות לעיל אינה נכונה."
      ]
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": "ג",
      "explanation": "ג. קטע הקוד מדגים תרחיש קלאסי של קיפאון (deadlock). תהליכון `taskA` מנסה לתפוס את `sem_R1` ולאחר מכן את `sem_R2`. לעומתו, תהליכון `taskB` מנסה לתפוס את `sem_R2` ולאחר מכן את `sem_R1`. אם `taskA` יתפוס את `sem_R1` ולאחר מכן, עקב החלפת הקשר (context switch) או תזמון, `taskB` יתפוס את `sem_R2`, שני התהליכונים ינסו לתפוס את הסמפור המוחזק על ידי השני. מצב זה יוצר תלות הדדית מעגלית (circular wait) ומוביל לקיפאון, כאשר אף אחד מהתהליכונים לא יוכל להמשיך."
    },
    "difficulty_estimation": "Hard"
  }
}