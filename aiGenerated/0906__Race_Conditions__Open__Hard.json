{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Race Conditions",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 01:12:52",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4708,
      "output_tokens": 4457,
      "total_tokens": 34650
    }
  },
  "question": {
    "id": 101,
    "type": "Open",
    "topic": [
      "Race Conditions",
      "Synchronization",
      "Condition Variables",
      "Mutexes"
    ],
    "content": {
      "text": "נתונה ספריית ניהול משאבים (Resource Pool) המאפשרת לשרשורים לרכוש ולשחרר משאבים. הספרייה משתמשת ברשימה מקושרת (std::list) לאחסון מזהי המשאבים הזמינים ובמונה שלם (available_count) כדי לעקוב אחר מספר המשאבים הזמינים. להלן קוד חלקי של הספרייה:\n\n```c++\n#include <iostream>\n#include <list>\n#include <pthread.h>\n#include <unistd.h> // For usleep\n\nstruct ResourcePool {\n    std::list<int> available_ids;\n    int available_count; // מספר המשאבים הזמינים\n    pthread_mutex_t mutex;\n    pthread_cond_t cond; // משתנה תנאי להמתנה למשאבים\n};\n\nResourcePool global_pool;\n\nvoid init_pool(int num_resources) {\n    global_pool.available_count = num_resources;\n    for (int i = 0; i < num_resources; ++i) {\n        global_pool.available_ids.push_back(i + 1); // מזהי משאבים: 1, 2, ... num_resources\n    }\n    pthread_mutex_init(&global_pool.mutex, NULL);\n    pthread_cond_init(&global_pool.cond, NULL);\n}\n\n// פונקציה לרכישת משאב\nint acquire_resource() {\n    pthread_mutex_lock(&global_pool.mutex);\n\n    while (global_pool.available_count == 0) { // המתן כאשר אין משאבים זמינים\n        pthread_cond_wait(&global_pool.cond, &global_pool.mutex);\n    }\n\n    // עדכן את המונה לפני גישה לרשימה\n    global_pool.available_count--; // (נקודה א')\n\n    // usleep(1); // הדמיית עיכוב או החלפת קונטקסט\n\n    int resource_id = global_pool.available_ids.front(); // גישה למשאב הראשון ברשימה (נקודה ב')\n    global_pool.available_ids.pop_front();\n\n    pthread_mutex_unlock(&global_pool.mutex);\n    return resource_id;\n}\n\n// פונקציה לשחרור משאב\nvoid release_resource(int id) {\n    pthread_mutex_lock(&global_pool.mutex);\n\n    // usleep(1); // הדמיית עיכוב או החלפת קונטקסט\n\n    // עדכן את המונה לפני הוספה לרשימה\n    global_pool.available_count++; // (נקודה ג')\n    global_pool.available_ids.push_back(id); // הוסף את המשאב חזרה לרשימה (נקודה ד')\n\n    pthread_cond_signal(&global_pool.cond);\n    pthread_mutex_unlock(&global_pool.mutex);\n}\n\n```\n\nא. זהו תנאי מרוץ (Race Condition) אחד לפחות הקיים בקוד, והסבירו צעד אחר צעד כיצד הוא יכול להתרחש ומה תהיה ההשלכה שלו (למשל, קריסה, חוסר עקביות בנתונים, קיפאון).\nב. הציעו פתרון מתוקן לקוד אשר ימנע את תנאי המרוץ שזיהיתם בסעיף א'. נמקו את התיקון.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. **זיהוי תנאי המרוץ והשלכותיו:**\nתנאי המרוץ נובע מחוסר עקביות אפשרי בין המונה `global_pool.available_count` לבין גודל הרשימה `global_pool.available_ids.size()`. שני משתנים אלו מייצגים את אותו מצב לוגי – מספר המשאבים הזמינים – אך הם מתעדכנים בסדר שונה בפונקציות `acquire_resource` ו-`release_resource`, ובכך יוצרים חלונות זמן קצרים בתוך ה-critical section שבהם המערכת נמצאת במצב לא עקבי.\n\n**תרחיש לדוגמה שיוביל לחוסר עקביות וקריסה:**\nנניח מצב התחלתי שבו `global_pool.available_count = 0` ו-`global_pool.available_ids` ריקה. כלומר, אין משאבים זמינים.\n\n1.  **שרשור A (acquire_resource):**\n    *   נועל את המוטקס (`pthread_mutex_lock`).\n    *   התנאי `global_pool.available_count == 0` מתקיים, ולכן קורא ל-`pthread_cond_wait`. השרשור משחרר את המוטקס ונכנס למצב המתנה.\n\n2.  **שרשור B (release_resource עם ID=100):**\n    *   נועל את המוטקס (`pthread_mutex_lock`).\n    *   מעדכן את המונה: `global_pool.available_count` הופך ל-1 (נקודה ג').\n    *   **החלפת קונטקסט (Preemption):** מערכת ההפעלה מפסיקה את פעולת שרשור B ומעבירה את השליטה לשרשור C, כאשר שרשור B עדיין מחזיק במוטקס.\n    *   **הערה חשובה:** למרות ה-`usleep` המוצג בקוד, החלפת קונטקסט יכולה להתרחש בכל נקודה, גם ללא `usleep`, ובמיוחד בין שתי פקודות מכונה נפרדות. התרחיש מתמקד בכך ש-`available_count` עודכן אך `available_ids` טרם.\n\n3.  **שרשור C (acquire_resource):**\n    *   מנסה לנעול את המוטקס (`pthread_mutex_lock`), אך המוטקס נעול על ידי שרשור B. שרשור C נכנס למצב המתנה למוטקס.\n\n4.  **שרשור B ממשיך (לאחר זמן מה):**\n    *   מערכת ההפעלה מחזירה את השליטה לשרשור B (שהחזיק במוטקס כל הזמן).\n    *   מוסיף את המשאב לרשימה: `global_pool.available_ids.push_back(100)` -> הרשימה כעת מכילה `{100}` (נקודה ד').\n    *   קורא ל-`pthread_cond_signal`, אשר מעיר את שרשור A.\n    *   משחרר את המוטקס (`pthread_mutex_unlock`).\n\n5.  **שרשור A ממשיך (לאחר שהתעורר):**\n    *   מתעורר ומנסה לרכוש מחדש את המוטקס. לאחר ששרשור B שחרר אותו, שרשור A רוכש את המוטקס.\n    *   התנאי `global_pool.available_count == 0` (שהוא כעת 1) אינו מתקיים, ולכן השרשור ממשיך.\n    *   מעדכן את המונה: `global_pool.available_count` הופך ל-0 (נקודה א').\n    *   **החלפת קונטקסט (Preemption):** מערכת ההפעלה מפסיקה את פעולת שרשור A ומעבירה את השליטה לשרשור D, כאשר שרשור A עדיין מחזיק במוטקס.\n\n6.  **שרשור D (release_resource עם ID=200):**\n    *   מנסה לנעול את המוטקס, אך המוטקס נעול על ידי שרשור A. שרשור D נכנס למצב המתנה.\n\n7.  **שרשור A ממשיך (לאחר זמן מה):**\n    *   מערכת ההפעלה מחזירה את השליטה לשרשור A (שהחזיק במוטקס כל הזמן).\n    *   מנסה לגשת למשאב הראשון ברשימה: `int resource_id = global_pool.available_ids.front();` (נקודה ב').\n    *   **השלכה:** בשלב זה, `global_pool.available_count` הוא 0, אך `global_pool.available_ids` מכילה את המשאב `100`. הגישה תצליח.\n\n**היכן מתרחשת הקריסה/חוסר העקביות?**\nהתרחיש שתיארתי לעיל לא מוביל לקריסה ישירה, אלא מדגיש את חוסר העקביות הזמני. הקריסה תתרחש בתרחיש מעט שונה, שבו המונה (`available_count`) לא משקף נכונה את מצב הרשימה (`available_ids`). לדוגמה:\n\nנניח ששרשור קורא ל-`release_resource`, מעדכן את `available_count` ל-1 (נקודה ג'), אבל קורס *לפני* שהוא מספיק להוסיף את המשאב לרשימה (`available_ids.push_back(id)` בנקודה ד').\n\n*   **מצב:** `available_count = 1`, אך `available_ids` עדיין ריקה.\n*   כעת, שרשור אחר מפעיל `acquire_resource`:\n    *   הוא נועל את המוטקס.\n    *   התנאי `global_pool.available_count == 0` (שהוא 1) אינו מתקיים, והשרשור ממשיך.\n    *   `global_pool.available_count` הופך ל-0 (נקודה א').\n    *   השרשור מנסה לגשת ל-`global_pool.available_ids.front()` (נקודה ב').\n    *   **קריסה!** הרשימה `global_pool.available_ids` ריקה, וניסיון לגשת ל-`front()` על רשימה ריקה מוביל להתנהגות בלתי מוגדרת (בדרך כלל קריסה - segmentation fault).\n\nהבעיה היא שהמונה משמש לקבלת החלטות (האם להמתין), אך הוא אינו תמיד עקבי עם מצב הרשימה בפועל, בגלל סדר הפעולות בתוך ה-critical section.\n\nב. **פתרון מתוקן:**\nכדי למנוע את תנאי המרוץ, יש לוודא שהמונה `available_count` תמיד משקף את מצב הרשימה `available_ids.size()` ושההמתנה מבוססת על המצב האמיתי של הרשימה. התיקון כולל שינוי של תנאי ההמתנה ב-`acquire_resource` ושינוי סדר הפעולות ב-`release_resource` (או הסרת המונה המיותר).\n\n**תיקון 1: הסרת המונה המיותר ושימוש ב-`available_ids.size()`:**\nהפתרון הנקי ביותר הוא להסיר את `available_count` לחלוטין, שכן הוא מידע מיותר שניתן לגזור מ-`available_ids.size()`. כך נמנעת האפשרות לחוסר עקביות בין שני משתנים המייצגים את אותו הדבר.\n\n```c++\n#include <iostream>\n#include <list>\n#include <pthread.h>\n#include <unistd.h>\n\nstruct ResourcePool {\n    std::list<int> available_ids;\n    // int available_count; // המונה מיותר\n    pthread_mutex_t mutex;\n    pthread_cond_t cond;\n};\n\nResourcePool global_pool;\n\nvoid init_pool(int num_resources) {\n    // global_pool.available_count = num_resources; // לא נחוץ\n    for (int i = 0; i < num_resources; ++i) {\n        global_pool.available_ids.push_back(i + 1);\n    }\n    pthread_mutex_init(&global_pool.mutex, NULL);\n    pthread_cond_init(&global_pool.cond, NULL);\n}\n\nint acquire_resource() {\n    pthread_mutex_lock(&global_pool.mutex);\n\n    while (global_pool.available_ids.empty()) { // המתן כאשר הרשימה ריקה\n        pthread_cond_wait(&global_pool.cond, &global_pool.mutex);\n    }\n\n    int resource_id = global_pool.available_ids.front();\n    global_pool.available_ids.pop_front();\n\n    pthread_mutex_unlock(&global_pool.mutex);\n    return resource_id;\n}\n\nvoid release_resource(int id) {\n    pthread_mutex_lock(&global_pool.mutex);\n\n    global_pool.available_ids.push_back(id);\n    // global_pool.available_count++; // לא נחוץ\n\n    pthread_cond_signal(&global_pool.cond);\n    pthread_mutex_unlock(&global_pool.mutex);\n}\n```\n\n**נימוק לתיקון 1:**\nעל ידי שימוש ישיר ב-`global_pool.available_ids.empty()` כתנאי ההמתנה, אנו מוודאים שהשרשור תמיד מחכה למצב האמיתי של הרשימה ולא למצב של מונה שעלול להיות לא עקבי. הסרת המונה `available_count` מונעת לחלוטין את הפוטנציאל לחוסר עקביות בין שני המשתנים, שכן כעת ישנו רק מקור אחד של אמת לגבי מספר המשאבים הזמינים.\n\n**תיקון 2: שמירה על המונה ותיקון סדר הפעולות (פחות מומלץ מתיקון 1 אך אפשרי):**\nאם חייבים לשמור על המונה `available_count` מסיבות כלשהן, יש לוודא שעדכון המונה ועדכון הרשימה מתבצעים בסדר כזה שהמצב הלוגי (מספר המשאבים הזמינים) תמיד עקבי בתוך ה-critical section, ושתנאי ההמתנה משקף את המצב האמיתי.\n\n```c++\n#include <iostream>\n#include <list>\n#include <pthread.h>\n#include <unistd.h>\n\nstruct ResourcePool {\n    std::list<int> available_ids;\n    int available_count; // מספר המשאבים הזמינים\n    pthread_mutex_t mutex;\n    pthread_cond_t cond;\n};\n\nResourcePool global_pool;\n\nvoid init_pool(int num_resources) {\n    global_pool.available_count = num_resources;\n    for (int i = 0; i < num_resources; ++i) {\n        global_pool.available_ids.push_back(i + 1);\n    }\n    pthread_mutex_init(&global_pool.mutex, NULL);\n    pthread_cond_init(&global_pool.cond, NULL);\n}\n\nint acquire_resource() {\n    pthread_mutex_lock(&global_pool.mutex);\n\n    while (global_pool.available_ids.empty()) { // המתן כאשר הרשימה ריקה (התנאי הנכון)\n        pthread_cond_wait(&global_pool.cond, &global_pool.mutex);\n    }\n\n    int resource_id = global_pool.available_ids.front();\n    global_pool.available_ids.pop_front();\n    global_pool.available_count--; // עדכן את המונה *אחרי* שהמשאב נלקח בהצלחה\n\n    pthread_mutex_unlock(&global_pool.mutex);\n    return resource_id;\n}\n\nvoid release_resource(int id) {\n    pthread_mutex_lock(&global_pool.mutex);\n\n    global_pool.available_ids.push_back(id);\n    global_pool.available_count++; // עדכן את המונה *אחרי* שהמשאב הוחזר בהצלחה\n\n    pthread_cond_signal(&global_pool.cond);\n    pthread_mutex_unlock(&global_pool.mutex);\n}\n```\n\n**נימוק לתיקון 2:**\n*   **`acquire_resource`:** תנאי ההמתנה שונה ל-`global_pool.available_ids.empty()`, המבטיח שהשרשור מחכה למצב האמיתי של הרשימה. המונה `global_pool.available_count` מעודכן כעת *לאחר* שהמשאב נלקח בהצלחה מהרשימה. זה מבטיח שאם תתרחש קריסה בין לקיחת המשאב ועדכון המונה, המונה לא יהיה נמוך מהמצב בפועל של הרשימה (כלומר, `available_count` לא יהיה שלילי או לא ישקף חוסר קיים).\n*   **`release_resource`:** המונה `global_pool.available_count` מעודכן כעת *לאחר* שהמשאב הוחזר בהצלחה לרשימה. זה מבטיח שאם תתרחש קריסה בין הוספת המשאב ועדכון המונה, המונה לא יהיה גבוה מהמצב בפועל של הרשימה (כלומר, `available_count` לא יהיה חיובי בעוד הרשימה עדיין ריקה באופן לוגי). סדר פעולות זה שומר על האינווריאנט (`available_count == available_ids.size()`) בנקודות קריטיות.\n\nשני התיקונים מונעים את תנאי המרוץ על ידי הבטחת עקביות בין ייצוגי מצב המערכת, אך תיקון 1 עדיף מכיוון שהוא מפשט את הקוד ומסיר את המקור הפוטנציאלי לחוסר עקביות מלכתחילה."
    },
    "difficulty_estimation": "Hard"
  }
}