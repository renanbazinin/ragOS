{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Context Switching",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 07:12:13",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3023,
      "output_tokens": 2701,
      "total_tokens": 12208
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Context Switching",
      "Operating Systems",
      "Concurrency",
      "Interrupts",
      "Performance"
    ],
    "content": {
      "text": "מעבר הקשר (Context Switching) הוא אחד המנגנונים המרכזיים המאפשרים למערכת הפעלה לממש ריבוי משימות (multitasking). תאר בפירוט ובאופן היררכי את רצף האירועים המתרחש במהלך מעבר קשר יזום על ידי פסיקת טיימר, מתהליך P1 (במצב משתמש) לתהליך P2 (במצב משתמש), במערכת עם מעבד יחיד.\n\nבתיאורך, עליך לכלול את הנקודות הבאות:\n1.  **רצף פעולות מפורט**: פרט את השלבים המדויקים, החל מרגע הפסיקה ועד לתחילת ביצוע P2. ציין אילו פעולות מבוצעות על ידי החומרה ואילו על ידי תוכנת מערכת ההפעלה (הקרנל).\n2.  **נתוני הקשר**: אילו רכיבי מידע (לדוגמה: אוגרים, מצב MMU, מחסנית) נשמרים עבור P1 ואילו נטענים עבור P2? היכן נתונים אלו נשמרים בדרך כלל?\n3.  **השלכות ביצועים**: מעבר קשר כרוך בעלויות ביצועים משמעותיות. מעבר לעלות הישירה של שמירה ושחזור אוגרים, זהה והסבר לפחות שתי עלויות ביצועים נוספות, ספציפיות ומהותיות, הנובעות ממעבר הקשר בין תהליכים.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "מעבר קשר הוא תהליך מורכב המאפשר למערכת הפעלה להחליף בין תהליכים שונים על מעבד יחיד, ובכך ליצור אשליה של ביצוע מקבילי. להלן פירוט שלבי מעבר הקשר, הנתונים המעורבים והשלכות הביצועים:\n\n**1. רצף פעולות מפורט (החל מפסיקת טיימר):**\n*   **שלב 1: התרחשות פסיקה (חומרה)**\n    *   הטיימר מגיע לאפס ויוצר פסיקת חומרה (Timer Interrupt).\n    *   המעבד (CPU) מזהה את הפסיקה ומבצע באופן אוטומטי את הפעולות הבאות:\n        *   שומר חלק מינימלי מהקשר של תהליך P1 (כגון Program Counter - PC, Stack Pointer - SP, ו-Processor Status Word - PSW/EFLAGS) למחסנית הליבה (Kernel Stack) של P1.\n        *   משנה את מצב פעולת המעבד ממצב משתמש (User Mode) למצב ליבה (Kernel Mode).\n        *   קופץ לכתובת של פונקציית הטיפול בפסיקות (Interrupt Handler) המתאימה, כפי שמוגדר בטבלת וקטורי הפסיקות (Interrupt Vector Table).\n\n*   **שלב 2: טיפול בפסיקה ושמירת קשר (תוכנת מערכת ההפעלה - הקרנל)**\n    *   פונקציית הטיפול בפסיקות בקרנל מתחילה לרוץ.\n    *   שומרת את שאר האוגרים כלליים של P1 (General Purpose Registers) למחסנית הליבה של P1 או לבלוק בקרת התהליך (Process Control Block - PCB) של P1. בשלב זה, כל הקשר של P1 נשמר.\n    *   מאשרת את הפסיקה (acknowledges the interrupt) כדי לאפשר פסיקות עתידיות.\n    *   קוראת למתזמן (Scheduler) של מערכת ההפעלה.\n\n*   **שלב 3: החלטת תזמון (מתזמן הקרנל)**\n    *   המתזמן קובע את מצבו החדש של P1 (לדוגמה, ממצב 'פועל' (Running) למצב 'מוכן' (Ready) אם הגיע זמנו או 'חסום' (Blocked) אם חיכה למשאב).\n    *   בוחר את תהליך P2 כתהליך הבא לביצוע (לפי אלגוריתם התזמון של מערכת ההפעלה).\n    *   מעדכן את מצבו של P2 ל'פועל' (Running).\n\n*   **שלב 4: טעינת קשר (תוכנת מערכת ההפעלה - הקרנל)**\n    *   הקרנל מבצע את פעולת מעבר הקשר בפועל (בפונקציה כגון `switch_to` או `context_switch`):\n        *   מעדכן את מצביע התהליך הנוכחי בקרנל (לדוגמה, `current` או `running_process`) ל-P2.\n        *   שומר את מצביע מחסנית הליבה הנוכחי של P1 ל-PCB של P1.\n        *   טוען את מצביע מחסנית הליבה של P2 מה-PCB של P2.\n        *   טוען את מצב יחידת ניהול הזיכרון (MMU) של P2 (לדוגמה, את ערך אוגר CR3 במעבדי x86, המצביע על טבלת הדפים של P2). פעולה זו למעשה מחליפה את מרחב הכתובות הוירטואלי מזה של P1 לזה של P2.\n        *   משחזר את האוגרים כלליים של P2 ממחסנית הליבה של P2 או מה-PCB של P2.\n\n*   **שלב 5: חזרה למצב משתמש והמשך ביצוע (חומרה/תוכנה)**\n    *   הקרנל מבצע פקודת חזרה מפסיקה (כגון `iret` ב-x86), אשר:\n        *   משחזרת את הקשר המינימלי של P2 (PC, SP, PSW/EFLAGS) ממחסנית הליבה של P2.\n        *   מחזירה את מצב פעולת המעבד למצב משתמש (User Mode).\n        *   תהליך P2 ממשיך בביצוע מנקודת העצירה האחרונה שלו.\n\n**2. נתוני הקשר:**\nנתוני הקשר המלאים של תהליך, הנשמרים ב-PCB של התהליך (או בחלקם על מחסנית הליבה שלו), כוללים:\n*   **אוגרי המעבד (CPU Registers)**: כולל אוגרים כלליים (EAX, EBX וכו'), אוגרי פוינטר (ESP, EBP), אוגר מונה התוכנית (PC/EIP), ואוגר מצב המעבד (PSW/EFLAGS) המכיל מידע על דגלים ומצב הרשאות.\n*   **מצב יחידת ניהול הזיכרון (MMU State)**: בעיקר האוגר המצביע על טבלת הדפים הבסיסית של התהליך (לדוגמה, CR3 ב-x86). החלפת ערך זה משנה את מרחב הכתובות הוירטואלי כולו, מכיוון שכל תהליך מנהל מרחב כתובות משלו.\n*   **מצביעים למחסניות (Stack Pointers)**: מצביע למחסנית המשתמש (User Stack Pointer) ומצביע למחסנית הליבה (Kernel Stack Pointer). לכל תהליך יש מחסנית משתמש ומחסנית ליבה משלו.\n*   **מצב התהליך (Process State)**: רץ, מוכן, חסום, סיים וכו'.\n*   **מידע תזמון (Scheduling Information)**: עדיפות, זמן שהוקצה וכו'.\n*   **מידע קבצים ו-I/O (File and I/O Information)**: קבצים פתוחים, התקנים בשימוש.\n\n**3. השלכות ביצועים:**\nמעבר קשר הוא פעולה יקרה ומהווה תקורה משמעותית למערכת ההפעלה. מעבר לעלות הישירה של שמירה ושחזור אוגרים, קיימות עלויות ביצועים מהותיות נוספות:\n*   **זיהום/אי-תקפות מטמוני נתונים והוראות (Cache Pollution/Invalidation)**:\n    *   כאשר P1 פועל, הנתונים וההוראות שבהם הוא משתמש נטענים למטמוני המעבד (L1, L2). במעבר ל-P2, תהליך P2 יגש לנתונים והוראות שונים לחלוטין. הדבר יגרום למטמונים להכיל נתונים לא רלוונטיים עבור P2 (Cache Pollution), ול-P2 יהיו בתחילה שיעורים גבוהים של החטאות מטמון (Cache Misses). המעבד יצטרך לטעון נתונים חדשים מהזיכרון הראשי, שהוא איטי בהרבה, מה שפוגע משמעותית בביצועים.\n*   **ניקוי TLB (Translation Lookaside Buffer Flush)**:\n    *   כל תהליך פועל במרחב כתובות וירטואלי משלו, הממופה לזיכרון פיזי באמצעות טבלאות דפים. ה-TLB הוא מטמון בחומרה השומר תרגומים אחרונים של כתובות וירטואליות לפיזיות. כאשר מתבצע מעבר קשר בין תהליכים, מרחב הכתובות הוירטואלי משתנה. כתוצאה מכך, רוב (או כל) הערכים ב-TLB הופכים ללא תקפים (Invalid) וצריך לנקות אותו (TLB Flush). לאחר הניקוי, P2 יחווה החטאות TLB רבות בתחילת ריצתו, מה שיחייב את המעבד לבצע הליכות בטבלת הדפים (Page Table Walks) עבור כל גישת זיכרון חדשה, פעולה איטית מאוד.\n*   **ריקון צינור עיבוד הנתונים (Pipeline Flush)**:\n    *   מעבר קשר משנה את מצב המעבד באופן דרמטי, ובפרט את אוגר מונה התוכנית (PC). המעבדים המודרניים משתמשים בצינור עיבוד נתונים (Pipeline) כדי לבצע מספר הוראות במקביל. שינוי פתאומי ב-PC כתוצאה ממעבר הקשר גורם לריקון ה-Pipeline מכל ההוראות של התהליך הקודם (P1) שהיו בתהליך ביצוע, ומילוי מחדש של ה-Pipeline עם הוראות של P2. תהליך זה כרוך בעלות זמן משלו."
    },
    "difficulty_estimation": "Hard"
  }
}