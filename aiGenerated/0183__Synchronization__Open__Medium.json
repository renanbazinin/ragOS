{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Synchronization",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 19:53:26",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 1598,
      "output_tokens": 2567,
      "total_tokens": 7540
    }
  },
  "question": {
    "id": 7,
    "type": "Open",
    "topic": [
      "Synchronization"
    ],
    "content": {
      "text": "נתון קטע קוד בשפת C המדמה מצב בו מספר תהליכונים (threads) ניגשים למשתנה גלובלי משותף (מונה) ומבצעים עליו פעולת הגדלה. קטע הקוד הנוכחי אינו משתמש במנגנוני סנכרון כלשהם.\n\nא. הסבר/י מדוע קטע קוד זה עלול לייצר תוצאות לא צפויות או שגויות. תאר/י את הבעיה הספציפית העלולה להתרחש.\nב. הצע/י פתרון לקטע הקוד באמצעות שימוש במנעול (mutex) כדי להבטיח שהמונה יוגדל באופן עקבי ונכון. הצג/י את קטע הקוד המתוקן.\nג. הצע/י פתרון נוסף לקטע הקוד באמצעות שימוש בסמפור בינארי (binary semaphore) כדי להבטיח את עקביות המונה. הצג/י את קטע הקוד המתוקן.\nד. השווה/י בקצרה בין שני הפתרונות שהצעת בסעיפים ב' ו-ג' בהקשר של בעיה זו.",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n\n#define NUM_THREADS 5\n#define ITERATIONS_PER_THREAD 100000\n\nlong long global_counter = 0;\n\nvoid* increment_counter(void* arg) {\n    for (int i = 0; i < ITERATIONS_PER_THREAD; ++i) {\n        global_counter++;\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, increment_counter, NULL);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final global_counter value: %lld\\n\", global_counter);\n    printf(\"Expected value: %lld\\n\", (long long)NUM_THREADS * ITERATIONS_PER_THREAD);\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "א. הבעיה בקטע הקוד היא תנאי מרוץ (race condition). פעולת ההגדלה של המונה (`global_counter++`) אינה פעולה אטומית (atomic operation). היא מורכבת למעשה משלוש פעולות ברמת המעבד:\n1. קריאת הערך הנוכחי של `global_counter` לתוך רגיסטר.\n2. הגדלת הערך ברגיסטר.\n3. כתיבת הערך המעודכן מהרגיסטר בחזרה ל`global_counter`.\nכאשר מספר תהליכונים מבצעים פעולה זו במקביל ללא סנכרון, ייתכן שתהליכון אחד יקרא את הערך, ותהליכון אחר יספיק לקרוא את אותו הערך, להגדיל אותו ולכתוב אותו בחזרה, לפני שהתהליכון הראשון יכתוב את הערך המוגדל שלו. כתוצאה מכך, חלק מההגדלות \"יאבדו\", והערך הסופי של `global_counter` יהיה נמוך מהצפוי.\n\nב. פתרון באמצעות מנעול (mutex):\nהמנעול מבטיח שרק תהליכון אחד יוכל להיכנס לקטע הקריטי (critical section) בו מתבצעת פעולת ההגדלה של המונה בכל רגע נתון. תהליכונים אחרים שינסו להיכנס יחסמו עד שהתהליכון המחזיק במנעול ישחרר אותו.\nהשינויים כוללים:\n1. הצהרה על משתנה `pthread_mutex_t`.\n2. אתחול המנעול באמצעות `pthread_mutex_init` לפני יצירת התהליכונים.\n3. קריאה ל`pthread_mutex_lock` לפני הכניסה לקטע הקריטי.\n4. קריאה ל`pthread_mutex_unlock` לאחר היציאה מהקטע הקריטי.\n5. השמדת המנעול באמצעות `pthread_mutex_destroy` בסיום.\n\n```c\n#include <stdio.h>\n#include <pthread.h>\n\n#define NUM_THREADS 5\n#define ITERATIONS_PER_THREAD 100000\n\nlong long global_counter = 0;\npthread_mutex_t counter_mutex; // Mutex declaration\n\nvoid* increment_counter_mutex(void* arg) {\n    for (int i = 0; i < ITERATIONS_PER_THREAD; ++i) {\n        pthread_mutex_lock(&counter_mutex);   // Acquire mutex\n        global_counter++;\n        pthread_mutex_unlock(&counter_mutex); // Release mutex\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    pthread_mutex_init(&counter_mutex, NULL); // Initialize mutex\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, increment_counter_mutex, NULL);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final global_counter value (with mutex): %lld\\n\", global_counter);\n    printf(\"Expected value: %lld\\n\", (long long)NUM_THREADS * ITERATIONS_PER_THREAD);\n\n    pthread_mutex_destroy(&counter_mutex); // Destroy mutex\n\n    return 0;\n}\n```\n\nג. פתרון באמצעות סמפור בינארי:\nסמפור בינארי יכול לשמש למטרות הדדית (mutual exclusion) בדומה למנעול. סמפור המאותחל ל-1 מאפשר רק לתהליכון אחד לבצע `sem_wait` בהצלחה, בעוד שאחרים יחסמו. `sem_post` משחרר את הסמפור ומאפשר לתהליכון אחר להיכנס.\nהשינויים כוללים:\n1. הצהרה על משתנה `sem_t`.\n2. אתחול הסמפור לערך 1 באמצעות `sem_init` לפני יצירת התהליכונים. הפרמטר השני 0 מציין שהסמפור משותף רק לתהליכונים בתוך אותו תהליך.\n3. קריאה ל`sem_wait` לפני הכניסה לקטע הקריטי (פעולת P).\n4. קריאה ל`sem_post` לאחר היציאה מהקטע הקריטי (פעולת V).\n5. השמדת הסמפור באמצעות `sem_destroy` בסיום.\n\n```c\n#include <stdio.h>\n#include <pthread.h>\n#include <semaphore.h> // For sem_t\n\n#define NUM_THREADS 5\n#define ITERATIONS_PER_THREAD 100000\n\nlong long global_counter = 0;\nsem_t counter_semaphore; // Semaphore declaration\n\nvoid* increment_counter_semaphore(void* arg) {\n    for (int i = 0; i < ITERATIONS_PER_THREAD; ++i) {\n        sem_wait(&counter_semaphore);   // Acquire semaphore (P operation)\n        global_counter++;\n        sem_post(&counter_semaphore); // Release semaphore (V operation)\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    // Initialize semaphore to 1 (binary semaphore)\n    sem_init(&counter_semaphore, 0, 1);\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, increment_counter_semaphore, NULL);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final global_counter value (with semaphore): %lld\\n\", global_counter);\n    printf(\"Expected value: %lld\\n\", (long long)NUM_THREADS * ITERATIONS_PER_THREAD);\n\n    sem_destroy(&counter_semaphore); // Destroy semaphore\n\n    return 0;\n}\n```\n\nד. השוואה בין מנעול לסמפור בינארי:\nעבור בעיה ספציפית זו של הדדית (mutual exclusion) עבור קטע קריטי בודד, הן מנעול והן סמפור בינארי מספקים פתרון נכון ויעיל. בפועל, ברוב מערכות ההפעלה המודרניות, מנעולים ממוטבים במיוחד למטרה זו ונוטים להיות קלים ויעילים יותר לשימוש עבור הדדית בלבד.\n**מנעול (Mutex):**\n*   מיועד ספציפית להדדית.\n*   לרוב, רק התהליכון שרכש את המנעול יכול לשחרר אותו (בעל \"בעלות\").\n*   מנגנוני זיהוי שגיאות מובנים (לדוגמה, ניסיון לשחרר מנעול שלא נרכש).\n*   יכול לתמוך בפרוטוקולי עדיפויות (priority inheritance) למניעת priority inversion.\n**סמפור בינארי (Binary Semaphore):**\n*   כלי כללי יותר, שיכול לשמש גם להדדית וגם לסנכרון מורכב יותר (למשל, סמפורי ספירה לתבנית מפיק-צרכן).\n*   כל תהליכון יכול לבצע `sem_post` גם אם לא הוא ביצע `sem_wait` (אין \"בעלות\"). זה יכול להיות יתרון במצבים מסוימים, אך גם מקור לשגיאות.\n*   במקרה של הדדית פשוטה, מנעול עשוי להיות קצת יותר יעיל או בטוח לשימוש עקב הייעוד הספציפי שלו והתכונות הנוספות שהוזכרו."
    },
    "difficulty_estimation": "Medium"
  }
}