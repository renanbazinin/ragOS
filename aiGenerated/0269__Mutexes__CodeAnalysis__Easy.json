{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Mutexes",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-07 20:24:26",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4189,
      "output_tokens": 1188,
      "total_tokens": 7343
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "CodeAnalysis",
    "topic": [
      "Mutexes",
      "Synchronization",
      "Concurrency",
      "Deadlock"
    ],
    "content": {
      "text": "נתונה תוכנית C המשתמשת בספריה `pthreads` ומגדילה משתנה גלובלי משותף `global_counter` באמצעות מספר תהליכונים. התוכנית מנסה להגן על הגישה למשתנה המשותף באמצעות mutex. עיין בקוד הנתון וענה על השאלה.\n\nמהי הבעיה העיקרית בקוד הנתון, וכיצד היא תשפיע על ריצת התוכנית ועל הערך הסופי של `global_counter`? כיצד ניתן לתקן את הבעיה?",
      "code_snippet": "#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h> // For sleep (optional, but good practice for real-world code)\n\n#define NUM_THREADS 5\n#define INCREMENTS_PER_THREAD 100000\n\nint global_counter = 0;\npthread_mutex_t counter_mutex;\n\nvoid *thread_function(void *arg) {\n    for (int i = 0; i < INCREMENTS_PER_THREAD; ++i) {\n        pthread_mutex_lock(&counter_mutex);\n        global_counter++;\n        // חסר שחרור ה-mutex כאן!\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n\n    pthread_mutex_init(&counter_mutex, NULL);\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_create(&threads[i], NULL, thread_function, NULL);\n    }\n\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        pthread_join(threads[i], NULL);\n    }\n\n    printf(\"Final counter value: %d\\n\", global_counter);\n\n    pthread_mutex_destroy(&counter_mutex);\n\n    return 0;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הבעיה העיקרית בקוד היא שה-mutex ננעל באמצעות `pthread_mutex_lock()` בתוך הלולאה, אך לעולם אינו משוחרר באמצעות `pthread_mutex_unlock()`.\n\n**השפעה על ריצת התוכנית:**\nכאשר תהליכון כלשהו יקבל את ה-mutex בפעם הראשונה, הוא ינעל אותו. מכיוון שזהו mutex רגיל (לא רקורסיבי, שכן הוא מאותחל עם `NULL` attributes), ניסיון לנעול mutex שכבר ננעל על ידי אותו תהליכון (באיטרציה הבאה של הלולאה) יגרום לקיפאון (deadlock) של התהליכון עצמו. אם תהליכונים אחרים ינסו לנעול את ה-mutex לפני שהתהליכון הראשון נתקע, הם פשוט ימתינו ללא הגבלה מכיוון שה-mutex נשאר נעול. כתוצאה מכך, התוכנית כולה תיתקע ולא תסיים את ריצתה.\n\n**השפעה על הערך הסופי של `global_counter`:**\nהתוכנית לא תדפיס ערך סופי כלל מכיוון שהיא תיתקע לפני השורה המדפיסה את הערך. אם איכשהו היא הייתה ממשיכה, הערך הסופי של `global_counter` יהיה שגוי ולא יגיע ל-`NUM_THREADS * INCREMENTS_PER_THREAD` (שהוא הערך המצופה).\n\n**תיקון:**\nיש לשחרר את ה-mutex לאחר כל פעולת הגדלה של המונה. התיקון הוא הוספת השורה `pthread_mutex_unlock(&counter_mutex);` מיד לאחר השורה `global_counter++;` בתוך לולאת ה-`for` בפונקציה `thread_function`. כך הקטע הקריטי יהיה מוגן כראוי וה-mutex ישוחרר לאחר כל גישה למשתנה המשותף, מה שיאפשר לתהליכונים אחרים לגשת אליו.\n\n**קוד מתוקן (קטע רלוונטי):**\n```c\nvoid *thread_function(void *arg) {\n    for (int i = 0; i < INCREMENTS_PER_THREAD; ++i) {\n        pthread_mutex_lock(&counter_mutex);\n        global_counter++;\n        pthread_mutex_unlock(&counter_mutex); // התיקון\n    }\n    return NULL;\n}\n```"
    },
    "difficulty_estimation": "Easy"
  }
}