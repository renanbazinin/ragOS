{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Synchronization",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-07 19:54:14",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 4073,
      "output_tokens": 3023,
      "total_tokens": 16269
    },
    "subject": "Concurrency"
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Threads",
      "Concurrency",
      "Mutexes",
      "Condition Variables"
    ],
    "content": {
      "text": "נתונה מערכת המורכבת מ-N חוטי עבודה (worker threads) וחוט מתאם יחיד (coordinator thread). המערכת מעבדת משימות בקבוצות (batches). כל קבוצה מכילה סך הכל N * M משימות, כאשר כל חוט עבודה אחראי על עיבוד M משימות מתוך הקבוצה.\nלאחר שכל חוט עבודה סיים לעבד את M המשימות שלו עבור קבוצה מסוימת, הוא חייב להמתין שכל שאר N-1 חוטי העבודה יסיימו גם הם את משימותיהם עבור אותה קבוצה. רק לאחר שכל N חוטי העבודה סיימו את משימותיהם בקבוצה הנוכחית, הם יכולים להתקדם לקבוצה הבאה.\nחוט המתאם אחראי על אתחול קבוצות חדשות. הוא ממתין שכל N חוטי העבודה יסיימו קבוצה אחת לפני שהוא מסמן להם להתחיל את הקבוצה הבאה. התהליך חוזר על עצמו עבור B קבוצות סך הכל.\nממשו את מבנה הנתונים ואת הלוגיקה הנדרשת עבור חוטי העבודה וחוט המתאם, תוך שימוש ב-mutexes ו-condition variables, על מנת להבטיח סנכרון נכון, למנוע תקלות (race conditions, deadlocks) ולאפשר שימוש חוזר במנגנון הסנכרון עבור קבוצות עבודה עוקבות. יש לשים דגש על יעילות ומינימום 'המתנה ערה' (busy-waiting).",
      "code_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> // For usleep, to simulate work\n\n// Structure for the synchronization mechanism\ntypedef struct {\n  pthread_mutex_t mutex;\n  pthread_cond_t cv_workers_ready_to_start_batch;          // Coordinator signals workers to start. Workers wait.\n  pthread_cond_t cv_coordinator_notified_of_batch_completion; // Last worker signals coordinator. Coordinator waits.\n  int N;                                // Total number of worker threads\n  int workers_finished_current_batch;   // Counter for workers completing tasks in the *current* batch\n  int current_batch_num;                // The batch number currently being processed by workers (or waiting to be started)\n  int total_batches;                    // Total batches to process for the entire system\n} BatchCoordinator;\n\n// Arguments for worker threads\ntypedef struct {\n  int id;\n  int M; // Number of tasks per worker per batch\n  BatchCoordinator* coordinator;\n} WorkerArgs;\n\n// Function to initialize the BatchCoordinator\nvoid init_batch_coordinator(BatchCoordinator* bc, int N_workers, int total_batches_system) {\n  pthread_mutex_init(&bc->mutex, NULL);\n  pthread_cond_init(&bc->cv_workers_ready_to_start_batch, NULL);\n  pthread_cond_init(&bc->cv_coordinator_notified_of_batch_completion, NULL);\n  bc->N = N_workers;\n  bc->workers_finished_current_batch = 0;\n  bc->current_batch_num = 0; // Initialize to 0, so workers can start batch 0 immediately\n  bc->total_batches = total_batches_system;\n}\n\n// Function to destroy the BatchCoordinator\nvoid destroy_batch_coordinator(BatchCoordinator* bc) {\n  pthread_mutex_destroy(&bc->mutex);\n  pthread_cond_destroy(&bc->cv_workers_ready_to_start_batch);\n  pthread_cond_destroy(&bc->cv_coordinator_notified_of_batch_completion);\n}\n\n// Worker thread function\nvoid* worker_thread_func(void* arg) {\n    WorkerArgs* args = (WorkerArgs*)arg;\n    BatchCoordinator* bc = args->coordinator;\n    int worker_id = args->id;\n    int M = args->M;\n\n    for (int b = 0; b < bc->total_batches; ++b) {\n        // --- Phase 1: Worker waits for coordinator to allow starting batch 'b' ---\n        pthread_mutex_lock(&bc->mutex);\n        while (bc->current_batch_num < b) {\n            pthread_cond_wait(&bc->cv_workers_ready_to_start_batch, &bc->mutex);\n        }\n        pthread_mutex_unlock(&bc->mutex);\n\n        // --- Phase 2: Process M tasks ---\n        // Simulate work (e.g., sleep for a short random time)\n        usleep(rand() % 100000);\n\n        // --- Phase 3: Worker signals completion and (implicitly) waits for others ---\n        pthread_mutex_lock(&bc->mutex);\n        bc->workers_finished_current_batch++;\n\n        if (bc->workers_finished_current_batch == bc->N) {\n            // Last worker to finish. Signal coordinator.\n            pthread_cond_signal(&bc->cv_coordinator_notified_of_batch_completion);\n        }\n        pthread_mutex_unlock(&bc->mutex);\n    }\n    return NULL;\n}\n\n// Coordinator thread function\nvoid* coordinator_thread_func(void* arg) {\n    BatchCoordinator* bc = (BatchCoordinator*)arg;\n\n    for (int b = 0; b < bc->total_batches; ++b) {\n        // Phase 1: Coordinator ensures workers are ready for batch 'b' and signals them.\n        pthread_mutex_lock(&bc->mutex);\n        bc->current_batch_num = b; // Allow workers to start batch 'b'\n        pthread_cond_broadcast(&bc->cv_workers_ready_to_start_batch); // Wake up all workers for batch 'b'\n        pthread_mutex_unlock(&bc->mutex);\n\n        // Simulate coordinator doing some preparatory work for the batch if any\n        usleep(rand() % 50000);\n\n        // Phase 2: Coordinator waits for all workers to finish batch 'b'.\n        pthread_mutex_lock(&bc->mutex);\n        while (bc->workers_finished_current_batch < bc->N) {\n            pthread_cond_wait(&bc->cv_coordinator_notified_of_batch_completion, &bc->mutex);\n        }\n        // All workers finished batch 'b'. Reset counter for the next batch.\n        bc->workers_finished_current_batch = 0;\n        pthread_mutex_unlock(&bc->mutex);\n\n        // Simulate coordinator doing some work between batches\n        usleep(rand() % 50000);\n    }\n    return NULL;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "הבעיה דורשת סנכרון דו-שלבי ושימוש חוזר: ראשית, חוטי העבודה צריכים להמתין זה לזה בסיום כל קבוצת משימות. שנית, חוט המתאם צריך לסנכרן את התחלת הקבוצות הבאות עם חוטי העבודה, ולהמתין לסיום הקבוצה הנוכחית לפני שהוא מאפשר את התחלת הבאה.\nלשם כך, נשתמש במבנה `BatchCoordinator` שיכיל:\n1.  `pthread_mutex_t mutex`: מנעול להגנה על משתנים משותפים.\n2.  `pthread_cond_t cv_workers_ready_to_start_batch`: משתנה תנאי שחוטי העבודה ממתינים עליו כדי לקבל אישור מחוט המתאם להתחיל קבוצת משימות חדשה. חוט המתאם מאותת עליו (broadcast).\n3.  `pthread_cond_t cv_coordinator_notified_of_batch_completion`: משתנה תנאי שחוט המתאם ממתין עליו כדי לקבל אישור מחוט העבודה האחרון שסיים את משימותיו בקבוצה הנוכחית. חוט העבודה האחרון מאותת עליו (signal).\n4.  `int N`: מספר חוטי העבודה הכולל.\n5.  `int workers_finished_current_batch`: מונה שסופר כמה חוטי עבודה סיימו את משימותיהם בקבוצה הנוכחית.\n6.  `int current_batch_num`: מספר הקבוצה הנוכחית שמותר לחוטי העבודה לעבד. משמש כ'שער' (turnstile) שמונע מחוטים להתקדם לקבוצה הבאה לפני שהמתאם אישר זאת.\n7.  `int total_batches`: המספר הכולל של קבוצות לעיבוד.\n\n**לוגיקת חוט העבודה (`worker_thread_func`):**\nכל חוט עבודה עובר בלולאה על כל הקבוצות (`b` מ-0 עד `total_batches-1`).\n*   **שלב 1 (המתנה לאישור מהמתאם):** החוט נועל את המוטקס ובודק אם `current_batch_num` שווה למספר הקבוצה הנוכחי `b`. אם `current_batch_num` נמוך מ-`b`, החוט ממתין על `cv_workers_ready_to_start_batch`. כאשר `current_batch_num` מגיע ל-`b` (כלומר, המתאם אישר להתחיל את קבוצה `b`), החוט משתחרר מההמתנה וממשיך.\n*   **שלב 2 (עיבוד משימות):** החוט מבצע את `M` המשימות המוטלות עליו עבור הקבוצה הנוכחית.\n*   **שלב 3 (איתות סיום):** החוט נועל את המוטקס, מגדיל את `workers_finished_current_batch` באחד. אם הוא החוט האחרון שמסיים (כלומר, `workers_finished_current_batch` שווה ל-`N`), הוא מאותת לחוט המתאם באמצעות `cv_coordinator_notified_of_batch_completion`. לאחר מכן הוא משחרר את המוטקס. החוטים אינם ממתינים זה לזה באופן מפורש בשלב זה, אלא ימתינו באופן טבעי לאישור המתאם לקבוצה הבאה בתחילת האיטרציה הבאה של הלולאה.\n\n**לוגיקת חוט המתאם (`coordinator_thread_func`):**\nחוט המתאם גם הוא עובר בלולאה על כל הקבוצות.\n*   **שלב 1 (איתות לחוטים להתחיל):** המתאם נועל את המוטקס, מעדכן את `current_batch_num` למספר הקבוצה הנוכחי `b` (כדי לאפשר לחוטי העבודה להתחיל לעבד אותה), ומשדר איתות (`pthread_cond_broadcast`) על `cv_workers_ready_to_start_batch` כדי להעיר את כל חוטי העבודה הממתינים. לאחר מכן הוא משחרר את המוטקס.\n*   **שלב 2 (המתנה לסיום הקבוצה):** המתאם נועל שוב את המוטקס וממתין על `cv_coordinator_notified_of_batch_completion` עד ש-`workers_finished_current_batch` יגיע ל-`N` (כלומר, כל חוטי העבודה סיימו את הקבוצה). ברגע שכל החוטים סיימו, המתאם מאפס את `workers_finished_current_batch` ל-0 לקראת הקבוצה הבאה, ומשחרר את המוטקס.\n\n**אתחול וסיום:**\n*   פונקציית `init_batch_coordinator` מאתחלת את כל אובייקטי הסנכרון וקובעת את `current_batch_num` ל-0, כך שחוטי העבודה יכולים להתחיל את קבוצה 0 ללא המתנה ראשונית.\n*   פונקציית `destroy_batch_coordinator` משחררת את המשאבים.\n\nפתרון זה מבטיח סנכרון נכון, מונע מצבי מירוץ וקיפאון, ומאפשר שימוש חוזר במנגנון הסנכרון ביעילות (ללא busy-waiting)."
    },
    "difficulty_estimation": "Hard"
  }
}