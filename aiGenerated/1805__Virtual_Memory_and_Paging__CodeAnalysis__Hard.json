{
  "metadata": {
    "source": "ai_generated",
    "subject": "Virtualization",
    "topic_hint": "Virtual Memory and Paging",
    "requested_type": "CodeAnalysis",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 20:59:04",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2792,
      "output_tokens": 4146,
      "total_tokens": 12965
    }
  },
  "question": {
    "id": 10,
    "type": "CodeAnalysis",
    "topic": [
      "Virtual Memory",
      "Paging",
      "Copy-on-Write",
      "Processes",
      "Memory Management"
    ],
    "content": {
      "text": "נתונה מערכת הפעלה התומכת בזיכרון וירטואלי ובדפדוף (Paging) עם מנגנון Copy-on-Write (COW) עבור יצירת תהליכים חדשים (fork). גודל הדף במערכת הוא 4KB (4096 בתים). גודל שלם (int) הוא 4 בתים.\n\nנתון קטע הקוד הבא ב-C. התוכנית מבצעת הקצאת זיכרון למערך גדול, מאתחלת אותו, ולאחר מכן יוצרת תהליך בן (child process) באמצעות `fork()`. גם תהליך האב וגם תהליך הבן מבצעים שינויים בחלקים שונים של המערך המשותף.\n\nיש להניח שהקצאת הזיכרון הראשונית (malloc) אינה גורמת להקצאת דפים פיזיים מיד, אלא דפים פיזיים מוקצים רק בעת הגישה הראשונה (demand paging). כמו כן, יש להניח שהמערכת מספיק גדולה כדי להכיל את כל הזיכרון הפיזי הנדרש.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define PAGE_SIZE 4096 // bytes\n#define INT_SIZE sizeof(int)\n// Total array size: 1024 pages (4MB)\n#define ARRAY_NUM_ELEMENTS (PAGE_SIZE / INT_SIZE * 1024) \n\nint main() {\n    int *arr = (int *)malloc(ARRAY_NUM_ELEMENTS * INT_SIZE);\n    if (arr == NULL) {\n        perror(\"malloc failed\");\n        return 1;\n    }\n\n    // Stage 1: Initialize array - triggers demand paging\n    for (int i = 0; i < ARRAY_NUM_ELEMENTS; ++i) {\n        arr[i] = i;\n    }\n\n    pid_t pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        free(arr);\n        return 1;\n    } else if (pid == 0) { // Child process\n        // Stage 3: Child modifies the second half of the array\n        for (int i = ARRAY_NUM_ELEMENTS / 2; i < ARRAY_NUM_ELEMENTS; ++i) {\n            arr[i] = -arr[i];\n        }\n        exit(0);\n    } else { // Parent process\n        // Stage 2: Parent modifies the first half of the array\n        for (int i = 0; i < ARRAY_NUM_ELEMENTS / 2; ++i) {\n            arr[i] = arr[i] * 2;\n        }\n        wait(NULL);\n        free(arr);\n    }\n\n    return 0;\n}\n```\n\nענו על השאלות הבאות, הסבירו כל שלב בפירוט:\n\n1.  כמה דפים פיזיים מוקצים עבור המערך `arr` מיד לאחר השלמת 'שלב 1' (אתחול המערך)?\n2.  כמה דפים פיזיים מוקצים בסך הכל במערכת (עבור תהליך האב והבן יחד) מיד לאחר קריאת `fork()` ולפני שמתבצעים שינויים כלשהם על ידי האב או הבן?\n3.  כמה דפים פיזיים נוספים מוקצים כתוצאה מפעולות הכתיבה של תהליך האב ב'שלב 2'? כמה Page Faults מסוג Copy-on-Write (COW) נגרמים כתוצאה מכך?\n4.  כמה דפים פיזיים נוספים מוקצים כתוצאה מפעולות הכתיבה של תהליך הבן ב'שלב 3'? כמה Page Faults מסוג Copy-on-Write (COW) נגרמים כתוצאה מכך?\n5.  כמה דפים פיזיים מוקצים בסך הכל במערכת (עבור תהליך האב והבן יחד) לאחר ששני התהליכים סיימו את פעולותיהם (הבן יצא, והאב המתין לו)?\n6.  מה יהיה הערך של `arr[0]` בתהליך האב ובתהליך הבן, ומה יהיה הערך של `arr[ARRAY_NUM_ELEMENTS - 1]` בתהליך האב ובתהליך הבן, בסיום התוכנית (לפני ה-`free`)? (התייחסו לערכים ההתחלתיים של האינדקסים הללו).",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define PAGE_SIZE 4096 // bytes\n#define INT_SIZE sizeof(int)\n// Total array size: 1024 pages (4MB)\n#define ARRAY_NUM_ELEMENTS (PAGE_SIZE / INT_SIZE * 1024) \n\nint main() {\n    int *arr = (int *)malloc(ARRAY_NUM_ELEMENTS * INT_SIZE);\n    if (arr == NULL) {\n        perror(\"malloc failed\");\n        return 1;\n    }\n\n    // Stage 1: Initialize array - triggers demand paging\n    for (int i = 0; i < ARRAY_NUM_ELEMENTS; ++i) {\n        arr[i] = i;\n    }\n\n    pid_t pid = fork();\n\n    if (pid < 0) {\n        perror(\"fork failed\");\n        free(arr);\n        return 1;\n    } else if (pid == 0) { // Child process\n        // Stage 3: Child modifies the second half of the array\n        for (int i = ARRAY_NUM_ELEMENTS / 2; i < ARRAY_NUM_ELEMENTS; ++i) {\n            arr[i] = -arr[i];\n        }\n        exit(0);\n    } else { // Parent process\n        // Stage 2: Parent modifies the first half of the array\n        for (int i = 0; i < ARRAY_NUM_ELEMENTS / 2; ++i) {\n            arr[i] = arr[i] * 2;\n        }\n        wait(NULL);\n        free(arr);\n    }\n\n    return 0;\n}"
    },
    "sub_questions": null,
    "points": 25,
    "solution": {
      "is_present_in_file": false,
      "correct_option": null,
      "explanation": "להלן פירוט הפתרון לשאלות:\n\n1.  **כמה דפים פיזיים מוקצים עבור המערך `arr` מיד לאחר השלמת 'שלב 1' (אתחול המערך)?**\n    *   `ARRAY_NUM_ELEMENTS` מוגדר כ-`(PAGE_SIZE / INT_SIZE * 1024)`. נתון ש-`PAGE_SIZE = 4096` בתים ו-`INT_SIZE = 4` בתים.\n    *   לכן, `ARRAY_NUM_ELEMENTS = (4096 / 4 * 1024) = 1024 * 1024 = 1,048,576` שלמים.\n    *   הגודל הכולל של המערך בבתים הוא `1,048,576 * 4` בתים = `4,194,304` בתים, שהם `4MB`.\n    *   מספר הדפים הנדרשים עבור `4MB` ב-`PAGE_SIZE = 4KB` הוא `4MB / 4KB = 1024` דפים.\n    *   לולאת האתחול ב'שלב 1' (`for (int i = 0; i < ARRAY_NUM_ELEMENTS; ++i) { arr[i] = i; }`) כותבת לכל איבר במערך. מכיוון שדפים פיזיים מוקצים על פי דרישה (demand paging) בעת הגישה הראשונה לכתיבה, כל כתיבה לדף וירטואלי חדש שטרם הוקצה לו דף פיזי תגרום ל-Page Fault ולהקצאת דף פיזי.\n    *   מאחר והלולאה כותבת לכל האיברים במערך המשתרע על פני 1024 דפים וירטואליים, יוקצו **1024 דפים פיזיים** עבור המערך.\n\n2.  **כמה דפים פיזיים מוקצים בסך הכל במערכת (עבור תהליך האב והבן יחד) מיד לאחר קריאת `fork()` ולפני שמתבצעים שינויים כלשהם על ידי האב או הבן?**\n    *   בעת קריאת `fork()`, מרחב הכתובות הווירטואלי של תהליך האב משוכפל עבור תהליך הבן. עם זאת, בזכות מנגנון Copy-on-Write (COW), הדפים הפיזיים עצמם אינם משוכפלים באופן מיידי.\n    *   במקום זאת, גם האב וגם הבן חולקים את אותם 1024 דפים פיזיים שהוקצו בשלב 1. דפים אלו מסומנים כ-read-only (קריאה בלבד) בטבלאות הדפים של שני התהליכים.\n    *   לכן, מספר הדפים הפיזיים הכולל המוקצים במערכת נשאר **1024 דפים פיזיים**.\n\n3.  **כמה דפים פיזיים נוספים מוקצים כתוצאה מפעולות הכתיבה של תהליך האב ב'שלב 2'? כמה Page Faults מסוג Copy-on-Write (COW) נגרמים כתוצאה מכך?**\n    *   תהליך האב משנה את החצי הראשון של המערך: `for (int i = 0; i < ARRAY_NUM_ELEMENTS / 2; ++i) { arr[i] = arr[i] * 2; }`.\n    *   החצי הראשון של המערך מכסה את האינדקסים `0` עד `ARRAY_NUM_ELEMENTS / 2 - 1`. מספר הדפים הווירטואליים המכוסים בחצי זה הוא `(ARRAY_NUM_ELEMENTS / 2) / (PAGE_SIZE / INT_SIZE) = (1024 * 1024 / 2) / 1024 = 512` דפים (דפים וירטואליים 0 עד 511).\n    *   כל כתיבה לדף שמשותף בין האב לבן (ומסומן כ-read-only) תגרום ל-Page Fault מסוג Copy-on-Write. מערכת ההפעלה תעתיק את הדף המשותף לדף פיזי חדש, תעדכן את טבלת הדפים של תהליך האב שתצביע לדף החדש, ותסמן את הדף החדש כניתן לכתיבה (read-write).\n    *   מאחר שהאב כותב לכל איבר בחצי הראשון, הוא יגרום ל-COW עבור כל אחד מ-**512 הדפים** הללו.\n    *   לכן, יוקצו **512 דפים פיזיים נוספים** עבור תהליך האב, וייגרמו **512 Page Faults מסוג Copy-on-Write**.\n\n4.  **כמה דפים פיזיים נוספים מוקצים כתוצאה מפעולות הכתיבה של תהליך הבן ב'שלב 3'? כמה Page Faults מסוג Copy-on-Write (COW) נגרמים כתוצאה מכך?**\n    *   תהליך הבן משנה את החצי השני של המערך: `for (int i = ARRAY_NUM_ELEMENTS / 2; i < ARRAY_NUM_ELEMENTS; ++i) { arr[i] = -arr[i]; }`.\n    *   החצי השני של המערך מכסה את האינדקסים `ARRAY_NUM_ELEMENTS / 2` עד `ARRAY_NUM_ELEMENTS - 1`. מספר הדפים הווירטואליים המכוסים בחצי זה הוא גם כן **512 דפים** (דפים וירטואליים 512 עד 1023).\n    *   בדומה לאב, כל כתיבה לדף שמשותף תגרום ל-Page Fault מסוג Copy-on-Write, והדף יועתק לדף פיזי חדש עבור תהליך הבן.\n    *   לכן, יוקצו **512 דפים פיזיים נוספים** עבור תהליך הבן, וייגרמו **512 Page Faults מסוג Copy-on-Write**.\n\n5.  **כמה דפים פיזיים מוקצים בסך הכל במערכת (עבור תהליך האב והבן יחד) לאחר ששני התהליכים סיימו את פעולותיהם (הבן יצא, והאב המתין לו)?**\n    *   דפים פיזיים ראשוניים (לאחר שלב 1): 1024.\n    *   דפים פיזיים נוספים שהוקצו עבור האב (שלב 2): 512.\n    *   דפים פיזיים נוספים שהוקצו עבור הבן (שלב 3): 512.\n    *   סה\"כ דפים פיזיים במערכת: `1024 + 512 + 512 = 2048`.\n    *   סה\"כ **2048 דפים פיזיים** מוקצים במערכת.\n\n6.  **מה יהיה הערך של `arr[0]` בתהליך האב ובתהליך הבן, ומה יהיה הערך של `arr[ARRAY_NUM_ELEMENTS - 1]` בתהליך האב ובתהליך הבן, בסיום התוכנית (לפני ה-`free`)?**\n    *   **ערכים התחלתיים (לאחר שלב 1):**\n        *   `arr[0]` = `0`\n        *   `arr[ARRAY_NUM_ELEMENTS - 1]` = `ARRAY_NUM_ELEMENTS - 1`\n\n    *   **בתהליך האב:**\n        *   האב משנה את החצי הראשון של המערך (אינדקסים `0` עד `ARRAY_NUM_ELEMENTS / 2 - 1`). `arr[0]` נמצא בחצי הראשון. פעולת האב היא `arr[i] = arr[i] * 2;`. לכן, `arr[0]` יהיה `0 * 2 = 0` (הערך ההתחלתי היה 0).\n        *   `arr[ARRAY_NUM_ELEMENTS - 1]` נמצא בחצי השני של המערך. האב אינו משנה את החצי השני. הדף הפיזי המכיל `arr[ARRAY_NUM_ELEMENTS - 1]` נשאר משותף עם הדף המקורי, ולכן ערכו בתהליך האב יישאר כפי שהיה בעת ה-fork, כלומר `ARRAY_NUM_ELEMENTS - 1`.\n        *   **ערכים סופיים בתהליך האב:** `arr[0]` = `0`, `arr[ARRAY_NUM_ELEMENTS - 1]` = `ARRAY_NUM_ELEMENTS - 1`.\n\n    *   **בתהליך הבן:**\n        *   הבן משנה את החצי השני של המערך (אינדקסים `ARRAY_NUM_ELEMENTS / 2` עד `ARRAY_NUM_ELEMENTS - 1`). `arr[0]` נמצא בחצי הראשון. הבן אינו משנה את החצי הראשון. הדף הפיזי המכיל `arr[0]` נשאר משותף עם הדף המקורי, ולכן ערכו בתהליך הבן יישאר כפי שהיה בעת ה-fork, כלומר `0`.\n        *   `arr[ARRAY_NUM_ELEMENTS - 1]` נמצא בחצי השני של המערך. פעולת הבן היא `arr[i] = -arr[i];`. לכן, `arr[ARRAY_NUM_ELEMENTS - 1]` יהיה `-(ARRAY_NUM_ELEMENTS - 1)` (הערך ההתחלתי היה `ARRAY_NUM_ELEMENTS - 1`).\n        *   **ערכים סופיים בתהליך הבן:** `arr[0]` = `0`, `arr[ARRAY_NUM_ELEMENTS - 1]` = `-(ARRAY_NUM_ELEMENTS - 1)`."
    },
    "difficulty_estimation": "Hard"
  }
}