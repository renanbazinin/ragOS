{
  "metadata": {
    "source": "ai_generated",
    "subject": "Concurrency",
    "topic_hint": "Synchronization and Deadlocks",
    "requested_type": "Open",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-08 10:00:04",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 3054,
      "output_tokens": 3768,
      "total_tokens": 11227
    }
  },
  "question": {
    "id": 1,
    "type": "Open",
    "topic": [
      "Synchronization",
      "Deadlocks",
      "Resource Management",
      "Semaphores"
    ],
    "content": {
      "text": "מערכת הפעלה מנהלת שני סוגי משאבים: `Resource A` ו-`Resource B`. ישנם `N_A` יחידות זמינות מ-`Resource A` ו-`N_B` יחידות זמינות מ-`Resource B`. במערכת רצים שני סוגי תהליכים (Threads):\n1.  **תהליכים מסוג `PrintScan`**: תהליך מסוג זה זקוק תחילה ליחידה אחת מ-`Resource A`, ולאחר מכן ליחידה אחת מ-`Resource B`. בסיום עבודתו, הוא משחרר את `Resource B` ולאחר מכן את `Resource A`.\n2.  **תהליכים מסוג `ScanPrint`**: תהליך מסוג זה זקוק תחילה ליחידה אחת מ-`Resource B`, ולאחר מכן ליחידה אחת מ-`Resource A`. בסיום עבודתו, הוא משחרר את `Resource A` ולאחר מכן את `Resource B`.\n\nכל תהליך מבצע לולאה אינסופית של `acquire resources -> do work -> release resources`.\nהציגו מימוש של מנגנון הקצאת המשאבים באמצעות סמפורים (Semaphores).\n\n**סעיף א'**: כתבו את הקוד של הפונקציות `acquire_resources_PrintScan`, `release_resources_PrintScan`, `acquire_resources_ScanPrint`, ו-`release_resources_ScanPrint`. השתמשו בסמפורים בלבד.\n**סעיף ב'**: האם המימוש שלכם בסעיף א' יכול להוביל למצב של קיפאון (Deadlock)? אם כן, הסבירו מדוע ותארו תרחיש לדוגמה.\n**סעיף ג'**: אם תשובתכם לסעיף ב' היא חיובית, הציעו ויישמו שינויים בקוד כדי למנוע קיפאון. הסבירו איזו אסטרטגיה למניעת קיפאון יישמתם.\n**סעיף ד'**: האם המימוש המתוקן שלכם בסעיף ג' עלול לסבול מרעב (Starvation) של תהליכים מסוימים? אם כן, הסבירו מדוע.",
      "code_snippet": null,
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "פתרון:\n\nנשתמש בשני סמפורים, אחד עבור כל סוג משאב, שישמשו כמונים של היחידות הזמינות מכל משאב. נניח שהסמפורים מוגדרים גלובלית ומאותחלים בהתאם למספר היחידות מכל משאב.\n\n```c\n#include <semaphore.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n// הגדרת סמפורים גלובליים\nsem_t sem_A;\nsem_t sem_B;\n\n// פונקציית אתחול למשאבים (תקרא פעם אחת בתחילת ריצת המערכת)\nvoid init_resources(int N_A, int N_B) {\n    sem_init(&sem_A, 0, N_A); // אתחול סמפור A עם N_A יחידות\n    sem_init(&sem_B, 0, N_B); // אתחול סמפור B עם N_B יחידות\n}\n\n// פונקציית ניקוי למשאבים (תקרא בסיום ריצת המערכת)\nvoid destroy_resources() {\n    sem_destroy(&sem_A);\n    sem_destroy(&sem_B);\n}\n```\n\n**סעיף א'**: מימוש ראשוני של הפונקציות (ללא טיפול בקיפאון)\n\n```c\n// פונקציות עבור תהליכים מסוג PrintScan\nvoid acquire_resources_PrintScan() {\n    printf(\"PrintScan: Attempting to acquire Resource A...\\n\");\n    sem_wait(&sem_A); // תופס יחידה מ-Resource A\n    printf(\"PrintScan: Acquired Resource A. Attempting to acquire Resource B...\\n\");\n    sem_wait(&sem_B); // תופס יחידה מ-Resource B\n    printf(\"PrintScan: Acquired Resource B. All resources acquired.\\n\");\n}\n\nvoid release_resources_PrintScan() {\n    printf(\"PrintScan: Releasing Resource B...\\n\");\n    sem_post(&sem_B); // משחרר יחידה מ-Resource B\n    printf(\"PrintScan: Releasing Resource A...\\n\");\n    sem_post(&sem_A); // משחרר יחידה מ-Resource A\n    printf(\"PrintScan: All resources released.\\n\");\n}\n\n// פונקציות עבור תהליכים מסוג ScanPrint\nvoid acquire_resources_ScanPrint() {\n    printf(\"ScanPrint: Attempting to acquire Resource B...\\n\");\n    sem_wait(&sem_B); // תופס יחידה מ-Resource B\n    printf(\"ScanPrint: Acquired Resource B. Attempting to acquire Resource A...\\n\");\n    sem_wait(&sem_A); // תופס יחידה מ-Resource A\n    printf(\"ScanPrint: Acquired Resource A. All resources acquired.\\n\");\n}\n\nvoid release_resources_ScanPrint() {\n    printf(\"ScanPrint: Releasing Resource A...\\n\");\n    sem_post(&sem_A); // משחרר יחידה מ-Resource A\n    printf(\"ScanPrint: Releasing Resource B...\\n\");\n    sem_post(&sem_B); // משחרר יחידה מ-Resource B\n    printf(\"ScanPrint: All resources released.\\n\");\n}\n```\n\n**סעיף ב'**: האם המימוש בסעיף א' יכול להוביל לקיפאון?\n\nכן, המימוש בסעיף א' יכול להוביל למצב של קיפאון (Deadlock). קיפאון מתרחש כאשר מתקיימים ארבעת התנאים של הוופמן (Coffman conditions):\n1.  **מניעה הדדית (Mutual Exclusion)**: הסמפורים מבטיחים זאת; רק תהליך אחד יכול לתפוס יחידה ממשאב מסוים בו-זמנית (אם המונה הוא 1), או מספר מוגבל (אם המונה גדול מ-1).\n2.  **החזקה והמתנה (Hold and Wait)**: תהליכים תופסים משאב אחד (למשל, `Resource A` על ידי `PrintScan` או `Resource B` על ידי `ScanPrint`) וממתינים למשאב נוסף.\n3.  **אי-הפקעה (No Preemption)**: המשאבים אינם נלקחים בכוח מתהליך שמחזיק בהם; רק התהליך המחזיק משחרר אותם.\n4.  **המתנה מעגלית (Circular Wait)**: זהו התנאי העיקרי שמתקיים כאן. תהליכים מסוג `PrintScan` מחזיקים ב-`Resource A` וממתינים ל-`Resource B`, בעוד שתהליכים מסוג `ScanPrint` מחזיקים ב-`Resource B` וממתינים ל-`Resource A`. זה יוצר מעגל תלות.\n\n**תרחיש לדוגמה לקיפאון (Deadlock Scenario)**:\nנניח שיש לנו `N_A = 1` ו-`N_B = 1` (יחידה אחת מכל משאב), ושני תהליכים: אחד מסוג `PrintScan` ואחד מסוג `ScanPrint`.\n1.  תהליך `PrintScan` מתחיל וקורא ל-`sem_wait(&sem_A)`. הוא מצליח לתפוס את `Resource A`.\n2.  באותו זמן, תהליך `ScanPrint` מתחיל וקורא ל-`sem_wait(&sem_B)`. הוא מצליח לתפוס את `Resource B`.\n3.  תהליך `PrintScan` מנסה כעת לתפוס את `Resource B` על ידי קריאה ל-`sem_wait(&sem_B)`. הוא נחסם, מכיוון ש-`Resource B` מוחזק על ידי `ScanPrint`.\n4.  תהליך `ScanPrint` מנסה כעת לתפוס את `Resource A` על ידי קריאה ל-`sem_wait(&sem_A)`. הוא נחסם, מכיוון ש-`Resource A` מוחזק על ידי `PrintScan`.\n\nשני התהליכים חסומים וכל אחד ממתין למשאב שמוחזק על ידי האחר. זהו מצב קיפאון.\n\n**סעיף ג'**: מניעת קיפאון באמצעות שינויים בקוד\n\nכדי למנוע קיפאון, נשבור את תנאי ההמתנה המעגלית. הדרך הנפוצה והפשוטה ביותר לעשות זאת היא על ידי **הטלת סדר כולל על המשאבים (Resource Ordering)**. כלומר, כל התהליכים במערכת חייבים לתפוס את המשאבים באותו סדר קבוע מראש. במקרה שלנו, נחליט שכל התהליכים יתפסו תמיד את `Resource A` לפני `Resource B`.\n\n```c\n// פונקציות מתוקנות עבור תהליכים מסוג PrintScan (אין שינוי, כבר תופס A ואז B)\nvoid acquire_resources_PrintScan_no_deadlock() {\n    printf(\"PrintScan (no deadlock): Attempting to acquire Resource A...\\n\");\n    sem_wait(&sem_A); // תופס יחידה מ-Resource A\n    printf(\"PrintScan (no deadlock): Acquired Resource A. Attempting to acquire Resource B...\\n\");\n    sem_wait(&sem_B); // תופס יחידה מ-Resource B\n    printf(\"PrintScan (no deadlock): Acquired Resource B. All resources acquired.\\n\");\n}\n\nvoid release_resources_PrintScan_no_deadlock() {\n    printf(\"PrintScan (no deadlock): Releasing Resource B...\\n\");\n    sem_post(&sem_B); // משחרר יחידה מ-Resource B\n    printf(\"PrintScan (no deadlock): Releasing Resource A...\\n\n\");\n    sem_post(&sem_A); // משחרר יחידה מ-Resource A\n    printf(\"PrintScan (no deadlock): All resources released.\\n\");\n}\n\n// פונקציות מתוקנות עבור תהליכים מסוג ScanPrint (כעת תופס A ואז B)\nvoid acquire_resources_ScanPrint_no_deadlock() {\n    printf(\"ScanPrint (no deadlock): Attempting to acquire Resource A (forced order)...\\n\");\n    sem_wait(&sem_A); // חייב לתפוס את Resource A ראשון, גם אם ה'צורך' המקורי שלו היה B ואז A\n    printf(\"ScanPrint (no deadlock): Acquired Resource A. Attempting to acquire Resource B...\\n\");\n    sem_wait(&sem_B); // ואז לתפוס את Resource B\n    printf(\"ScanPrint (no deadlock): Acquired Resource B. All resources acquired.\\n\");\n}\n\nvoid release_resources_ScanPrint_no_deadlock() {\n    // סדר השחרור אינו משפיע על מניעת קיפאון, אך מומלץ לשחרר בסדר הפוך לסדר התפיסה.\n    printf(\"ScanPrint (no deadlock): Releasing Resource B...\\n\");\n    sem_post(&sem_B); // משחרר יחידה מ-Resource B\n    printf(\"ScanPrint (no deadlock): Releasing Resource A...\\n\");\n    sem_post(&sem_A); // משחרר יחידה מ-Resource A\n    printf(\"ScanPrint (no deadlock): All resources released.\\n\");\n}\n```\n\n**הסבר על אסטרטגיית מניעת הקיפאון**: אסטרטגיה זו היא **הטלת סדר כולל על המשאבים (Resource Ordering)**. על ידי כך שאנו מכריחים את כל התהליכים לתפוס את המשאבים בסדר קבוע (למשל, תמיד `Resource A` לפני `Resource B`), אנו מבטיחים שלא יכולה להיווצר שרשרת המתנה מעגלית. תהליך יכול להחזיק ב-`Resource A` ולהמתין ל-`Resource B`, אך אף תהליך לא יכול להחזיק ב-`Resource B` ולהמתין ל-`Resource A` (כי הוא היה צריך לתפוס את `A` קודם לכן). זה שובר את תנאי ההמתנה המעגלית ולכן מונע קיפאון.\n\n**סעיף ד'**: האם המימוש המתוקן עלול לסבול מרעב (Starvation)?\n\nכן, המימוש המתוקן בסעיף ג' עלול לסבול מרעב (Starvation) של תהליכים מסוימים. למרות שמנענו קיפאון, לא בהכרח הבטחנו הוגנות (Fairness) בהקצאת המשאבים.\n\n**תרחיש לדוגמה לרעב**:\nנניח שיש לנו `N_A = 1` ו-`N_B = 1` (יחידה אחת מכל משאב).\nנניח שיש זרם רציף של תהליכי `PrintScan` המגיעים למערכת. כל תהליך `PrintScan` תופס את `Resource A`, ואז את `Resource B`, מבצע את עבודתו, ומשחרר אותם (בסדר הפוך).\n\nכעת, נניח שתהליך `ScanPrint` מגיע. על פי המימוש המתוקן, הוא גם ינסה לתפוס תחילה את `Resource A` ולאחר מכן את `Resource B`. אם יש זרם בלתי פוסק של תהליכי `PrintScan`, ייתכן שכל פעם ש-`Resource A` משתחרר על ידי תהליך `PrintScan` אחד, הוא נתפס מיד על ידי תהליך `PrintScan` אחר. במצב כזה, תהליך ה-`ScanPrint` עלול להמתין ללא הגבלת זמן ל-`Resource A` ולא יוכל לעולם להתקדם, למרות שהמשאבים משתחררים ונתפסים מחדש. זהו מצב של רעב עבור תהליך ה-`ScanPrint`.\n\nהסיבה לכך היא שסמפורים רגילים אינם מבטיחים סדר הגעה (FIFO) או הוגנות כלשהי בהקצאת המשאבים. ההחלטה איזה תהליך יקבל את המשאב הבא מתוך התהליכים הממתינים תלויה לרוב במתזמן (Scheduler) של מערכת ההפעלה, ואין ערובה שלא ייווצר מצב שבו תהליכים מסוימים נדחים שוב ושוב לטובת אחרים."
    },
    "difficulty_estimation": "Hard"
  }
}