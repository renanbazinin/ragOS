{
  "metadata": {
    "source": "ai_generated",
    "topic_hint": "Semaphores",
    "requested_type": "Open",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-07 20:48:40",
    "examples_used": 3,
    "token_usage": {
      "prompt_tokens": 2630,
      "output_tokens": 2074,
      "total_tokens": 7981
    }
  },
  "question": {
    "id": 8,
    "type": "Open",
    "topic": [
      "Semaphores",
      "Synchronization",
      "Producer-Consumer"
    ],
    "content": {
      "text": "נתונה בעיית המאגר החסום (Bounded Buffer) בגודל `BUFFER_SIZE`. ישנם מספר תהליכי יצרן (Producer) שמוסיפים פריטים למאגר ומספר תהליכי צרכן (Consumer) שמוציאים פריטים מהמאגר.\n\nיש לממש את הפונקציות `producer` ו-`consumer` תוך שימוש בסמפורים בלבד (ללא מנעולים או Mutex-ים אחרים) כדי להבטיח סנכרון נכון בין התהליכים.\n\nיש להגדיר את הסמפורים הנדרשים, לאתחל אותם בערכים המתאימים, ולשלב אותם במימוש הפונקציות. הניחו שקיימת מערכת תומכת בפעולות `sem_init`, `sem_wait`, `sem_post` עבור סמפורים. הניחו שקיימות פונקציות `produce_item()` ו-`consume_item(item)` המבצעות את הלוגיקה העסקית של יצירת וצריכת פריטים בהתאמה, וכן פונקציות `insert_item(item)` ו-`remove_item()` המטפלות בגישה למאגר עצמו (אך יש להגן עליהן באמצעות סמפורים).",
      "code_snippet": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep\n\n#define BUFFER_SIZE 5\n\nint buffer[BUFFER_SIZE];\nint in = 0; // Next empty slot\nint out = 0; // Next item to remove\n\n// Declare semaphores here\n// sem_t ...\n\n// Initialize semaphores\nvoid init_semaphores() {\n    // ...\n}\n\nvoid insert_item(int item) {\n    buffer[in] = item;\n    in = (in + 1) % BUFFER_SIZE;\n    printf(\"Producer inserted item %d. Buffer state: \", item);\n    for (int i=0; i<BUFFER_SIZE; ++i) {\n        printf(\"%d \", buffer[i]);\n    }\n    printf(\"]\\n\");\n}\n\nint remove_item() {\n    int item = buffer[out];\n    buffer[out] = -1; // Mark as empty for clarity\n    out = (out + 1) % BUFFER_SIZE;\n    printf(\"Consumer removed item %d. Buffer state: \", item);\n    for (int i=0; i<BUFFER_SIZE; ++i) {\n        printf(\"%d \", buffer[i]);\n    }\n    printf(\"]\\n\");\n    return item;\n}\n\nvoid *producer(void *param) {\n    int item;\n    while (1) {\n        // ... synchronization logic using semaphores ...\n        item = rand() % 100; // Simulate producing an item\n        insert_item(item);\n        // ... synchronization logic using semaphores ...\n        sleep(1); // Simulate work\n    }\n    return NULL;\n}\n\nvoid *consumer(void *param) {\n    int item;\n    while (1) {\n        // ... synchronization logic using semaphores ...\n        item = remove_item();\n        // ... synchronization logic using semaphores ...\n        sleep(2); // Simulate work\n    }\n    return NULL;\n}",
      "options": null
    },
    "sub_questions": null,
    "points": null,
    "solution": {
      "is_present_in_file": true,
      "correct_option": null,
      "explanation": "לפתרון בעיית המאגר החסום באמצעות סמפורים נדרשים שלושה סמפורים:\n1.  **`mutex` (סמפור בינארי / סמפור הדדיות):** מגן על הגישה לקטעים הקריטיים של המאגר (הפונקציות `insert_item` ו-`remove_item`) כדי להבטיח שרק תהליך אחד יבצע שינויים במאגר בכל רגע נתון. ערך אתחול: 1 (המאגר פנוי לגישה).\n2.  **`empty` (סמפור ספירה):** עוקב אחר מספר המקומות הריקים במאגר. תהליך יצרן ימתין על סמפור זה אם אין מקום פנוי. ערך אתחול: `BUFFER_SIZE` (בהתחלה כל המאגר ריק).\n3.  **`full` (סמפור ספירה):** עוקב אחר מספר הפריטים המלאים במאגר. תהליך צרכן ימתין על סמפור זה אם המאגר ריק מפריטים. ערך אתחול: 0 (בהתחלה המאגר ריק מפריטים).\n\nהמימוש של הפונקציות `producer` ו-`consumer` ישתמש בסמפורים אלו באופן הבא:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h> // For sleep\n\n#define BUFFER_SIZE 5\n\nint buffer[BUFFER_SIZE];\nint in = 0; // Next empty slot\nint out = 0; // Next item to remove\n\nsem_t mutex; // For mutual exclusion\nsem_t empty; // Counts empty slots\nsem_t full;  // Counts full slots\n\n// Initialize buffer items to -1 for clarity (empty)\nvoid init_buffer() {\n    for (int i = 0; i < BUFFER_SIZE; ++i) {\n        buffer[i] = -1;\n    }\n}\n\nvoid init_semaphores() {\n    sem_init(&mutex, 0, 1); // Binary semaphore for mutual exclusion, initial value 1\n    sem_init(&empty, 0, BUFFER_SIZE); // Counting semaphore for empty slots, initial value BUFFER_SIZE\n    sem_init(&full, 0, 0); // Counting semaphore for full slots, initial value 0\n}\n\nvoid insert_item(int item) {\n    buffer[in] = item;\n    in = (in + 1) % BUFFER_SIZE;\n    printf(\"Producer inserted item %d. Buffer state: \", item);\n    for (int i=0; i<BUFFER_SIZE; ++i) {\n        printf(\"%d \", buffer[i]);\n    }\n    printf(\"]\\n\");\n}\n\nint remove_item() {\n    int item = buffer[out];\n    buffer[out] = -1; // Mark as empty for clarity\n    out = (out + 1) % BUFFER_SIZE;\n    printf(\"Consumer removed item %d. Buffer state: \", item);\n    for (int i=0; i<BUFFER_SIZE; ++i) {\n        printf(\"%d \", buffer[i]);\n    }\n    printf(\"]\\n\");\n    return item;\n}\n\nvoid *producer(void *param) {\n    int item;\n    while (1) {\n        item = rand() % 100; // Simulate producing an item\n        \n        sem_wait(&empty); // Wait if buffer is full (no empty slots)\n        sem_wait(&mutex); // Acquire lock for critical section\n        \n        insert_item(item);\n        \n        sem_post(&mutex); // Release lock\n        sem_post(&full);  // Signal that a slot is now full\n        \n        sleep(1); // Simulate work\n    }\n    return NULL;\n}\n\nvoid *consumer(void *param) {\n    int item;\n    while (1) {\n        sem_wait(&full);  // Wait if buffer is empty (no full slots)\n        sem_wait(&mutex); // Acquire lock for critical section\n        \n        item = remove_item();\n        \n        sem_post(&mutex); // Release lock\n        sem_post(&empty); // Signal that a slot is now empty\n        \n        sleep(2); // Simulate work\n    }\n    return NULL;\n}\n```"
    },
    "difficulty_estimation": "Medium"
  }
}