{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Cache Coherence",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:48:05",
    "context_chunks_used": 5,
    "context_lectures": [
      16,
      15
    ],
    "token_usage": {
      "prompt_tokens": 2018,
      "output_tokens": 1071,
      "total_tokens": 4818
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Cache Coherence"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "במערכת מרובת מעבדים שבה לכל מעבד מטמון משלו, מתעוררת בעיה מהותית של קוהרנטיות מטמון. איזו מהטענות הבאות מתארת בצורה הטובה ביותר את הדילמה המרכזית שנוצרת כתוצאה מכך, ואת השפעותיה על תקינות הנתונים וביצועי המערכת?",
      "code_snippet": null,
      "options": [
        "א. הבעיה היא ששינוי נתונים במטמון מקומי של מעבד אחד מבלי לעדכן מיד את הזיכרון הראשי עלול להוביל לכך שמעבדים אחרים יקראו נתונים לא עדכניים; ניסיון לפתור זאת על ידי עדכון תמידי של הזיכרון הראשי גורם להאטה משמעותית בביצועים.",
        "ב. הבעיה העיקרית היא חוסר ב-cache affinity, הגורם לכך שתהליכים עוברים בין מעבדים שונים בתדירות גבוהה, ומבזבזים זמן רב על טעינת נתונים חדשים למטמון.",
        "ג. קוהרנטיות מטמון מתייחסת בעיקר למניעת מצבי קיפאון (deadlock) שעלולים להיווצר כאשר מספר מעבדים מנסים לגשת לאותו בלוק זיכרון במקביל, ודורשת מנגנוני נעילה מורכבים.",
        "ד. הבעיה היחידה בחוסר קוהרנטיות היא שמעבד אחד לא יוכל לדעת מתי מעבד אחר שינה ערך בזיכרון, ופתרונה דורש רק פרוטוקול פשוט של הודעות בין המטמונים המקומיים."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. על פי חומר ההרצאה (Lecture 15, chunk 23), הבעיה המרכזית בקוהרנטיות מטמון היא שאם מעבד אחד קורא נתון מה-RAM למטמון שלו ומשנה אותו, השינוי מתבצע במטמון המקומי שלו בלבד. אם הזיכרון הראשי אינו מעודכן באופן מיידי, מעבדים אחרים שיקראו את אותו נתון מהזיכרון הראשי יקבלו ערך לא תקין ולא עדכני. זוהי בעיית חוסר תיאום. הדילמה היא ש'אם לא נעדכן את הזיכרון, לא נהיה מתואמים עם שאר המעבדים', אך 'אם כן נעדכן את הזיכרון על כל שינוי, זה יהיה מאוד איטי'. תשובה א' מתארת במדויק דילמה זו של חוסר עקביות נתונים מול פגיעה בביצועים.\n\nתשובה ב' מתארת בעיה של 'cache affinity' (Lecture 15, chunks 27-28), שהיא קשורה לביצועים וליעילות ניצול המטמון על ידי תזמון תהליכים על אותו מעבד, אך אינה עוסקת ישירות בבעיית עקביות הנתונים בין מטמונים שונים, שהיא לב ליבה של קוהרנטיות מטמון.\n\nתשובה ג' מתייחסת ל'deadlock' ול'מנגנוני נעילה' (Lecture 16, chunk 8), שהם מושגים הקשורים לסנכרון ומניעת מצבי קיפאון כלליים בגישה למשאבים משותפים, אך אינם התיאור המדויק לבעיית קוהרנטיות המטמון כפי שהוצגה בחומר ההרצאה.\n\nתשובה ד' אינה נכונה מכיוון שהיא מפשטת יתר על המידה את הבעיה ומציעה פתרון פשוט, בעוד שהחומר מציין במפורש שעדכון הזיכרון הראשי על כל שינוי הוא 'מאוד איטי', מה שמעיד על כך שהפתרון אינו פשוט ואינו חסר עלות ביצועית."
    }
  }
}