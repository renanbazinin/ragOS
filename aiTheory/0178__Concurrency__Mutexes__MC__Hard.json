{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Mutexes",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:34:43",
    "context_chunks_used": 5,
    "context_lectures": [
      10,
      11,
      13,
      14,
      16
    ],
    "token_usage": {
      "prompt_tokens": 2001,
      "output_tokens": 1101,
      "total_tokens": 6336
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Mutexes"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתייחס לפעולת wait של משתנה תנאי, כפי שהוסברה בהקשר של מנעולים, ובהינתן הקוד הפנימי הבא המדגים את התנהגותה האטומי:\n```c\n// בתוך wait(&cv1, &m1):\n// באופן אטומי:\nunlock(&m1);\nwait_for_signal(&cv1);\n// לאחר התעוררות:\nlock(&m1);\n```\nמהי הסיבה המהותית ביותר לכך ששחרור המנעול (unlock(&m1)) מתבצע באופן אטומי *לפני* הכניסה למצב המתנה (wait_for_signal(&cv1))?",
      "code_snippet": "lock(&m1);\nwait(&cv1, &m1);\nunlock(&m1);\n\n-> Atomic:\nunlock(&m1);\nwait_for_signal(&cv1);\n// after waking up:\nlock(&m1);",
      "options": [
        "א. להבטיח שחוטים אחרים יוכלו להיכנס לקטע הקריטי, לגשת לנתונים המשותפים המוגנים על ידי m1, ואף לשלוח signal שיעיר את החוט הממתין, ובכך למנוע מצב של קיפאון (deadlock).",
        "ב. למנוע מצב שבו מספר חוטים יחזיקו את המנעול m1 בו-זמנית בזמן שהם ממתינים, ובכך לשמור על עקביות הנתונים.",
        "ג. לאפשר לחוט הממתין לסיים את עבודתו בקטע הקריטי מיד עם קבלת ה-signal, ללא צורך לרכוש מחדש את המנעול.",
        "ד. להבטיח מניעה הדדית (mutual exclusion) מלאה על המשאב המוגן על ידי m1 גם כאשר החוט נמצא במצב המתנה."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "האופי האטומי של פעולת `wait` הוא קריטי למניעת קיפאון (deadlock) במערכות מקביליות המשתמשות במנעולים (mutexes) ומשתני תנאי (condition variables). כאשר חוט קורא ל-`wait(&cv, &m)`, הוא למעשה משחרר את המנעול `m` באופן אטומי *לפני* שהוא נכנס למצב המתנה עבור `cv`. כפי שהוסבר בחומר הלימוד, \"בנקודה הזו, הוא שחרר את המנעול וכרגע חוט A חסום עד שישלחו לו signal\". אם המנעול לא היה משוחרר, שום חוט אחר לא היה יכול להיכנס לקטע הקריטי המוגן על ידי `m`, לשנות את התנאי המבוקש (שעליו החוט ממתין), או לשלוח `signal` שיעיר את החוט הממתין. מצב זה היה מוביל לקיפאון, שכן החוט הממתין היה ממתין לתנאי שלא יכול להשתנות, והחוטים האחרים לא היו יכולים לגשת למנעול כדי לשנות את התנאי או לשלוח את ה-signal. רק לאחר שהחוט מתעורר מקריאת ה-`wait_for_signal`, הוא רוכש מחדש את המנעול (`lock(&m)`) באופן אוטומטי, ובכך מבטיח שהוא יכול להמשיך את פעולתו בקטע הקריטי תוך שמירה על מניעה הדדית. לכן, שחרור המנעול מאפשר לחוטים אחרים להתקדם ולשנות את המצב המערכתי, ובכך מונע קיפאון. אפשרות ב' אינה נכונה מכיוון שמנעול מטבעו מונע החזקה בו-זמנית על ידי מספר חוטים. אפשרות ג' אינה נכונה מכיוון שהחוט הממתין *כן* רוכש מחדש את המנעול לאחר ההתעוררות. אפשרות ד' אינה נכונה מכיוון שהמטרה של שחרור המנעול היא דווקא לאפשר לחוטים אחרים להיכנס לקטע הקריטי בזמן שהחוט ממתין, ובכך לא לשמור על מניעה הדדית *באותו רגע* עבור החוט הממתין."
    }
  }
}