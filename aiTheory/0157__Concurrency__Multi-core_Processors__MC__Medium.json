{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Multi-core Processors",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-14 17:29:26",
    "context_chunks_used": 5,
    "context_lectures": [
      10,
      12,
      15
    ],
    "token_usage": {
      "prompt_tokens": 2191,
      "output_tokens": 721,
      "total_tokens": 5163
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Multi-core Processors"
    ],
    "difficulty_estimation": "Medium",
    "content": {
      "text": "בתזמון תהליכים במעבדים מרובי ליבות, מדוע שמירה על \"זיקת מטמון\" (cache affinity) נחשבת ליתרון משמעותי?",
      "code_snippet": null,
      "options": [
        "א. היא מפחיתה את הצורך בנעילות (locks) בין מעבדים שונים, מכיוון שכל תהליך משויך למעבד קבוע.",
        "ב. היא מבטיחה שנתונים שבהם התהליך השתמש בעבר יישארו במטמון הפרטי של המעבד, ובכך משפרת את ביצועי הגישה לזיכרון.",
        "ג. היא מאפשרת לכל תהליך לגשת לזיכרון הראשי (RAM) בקצב מהיר יותר, על ידי עקיפת מגבלות רוחב הפס של ה-BUS.",
        "ד. היא מאפשרת למערכת ההפעלה להריץ מספר תהליכים במקביל על ליבות שונות, ובכך להשיג מקביליות אמיתית."
      ]
    },
    "solution": {
      "correct_option": "ב",
      "explanation": "שמירה על זיקת מטמון (cache affinity) פירושה שתהליך ירוץ ככל הניתן על אותו מעבד שהריץ אותו בעבר. היתרון בכך נובע מהעובדה שבמערכות מרובות ליבות, לכל מעבד יש מטמון (cache) פרטי משלו. כאשר תהליך רץ על מעבד מסוים, הנתונים וההוראות שבהם הוא משתמש נטענים למטמון הפרטי של אותו מעבד. אם התהליך עובר למעבד אחר, הוא מאבד את הנתונים הללו מהמטמון הישן, ונדרש לטעון אותם מחדש למטמון של המעבד החדש. טעינה מחדש של נתונים מהזיכרון הראשי (RAM) היא פעולה יקרה ואיטית יחסית (כמה עשרות מחזורי שעון, ושימוש ב-BUS). לכן, שמירה על זיקת מטמון ממקסמת את הסיכוי שהנתונים הרלוונטיים לתהליך כבר יהיו זמינים במטמון המקומי של המעבד, ובכך משפרת משמעותית את ביצועי הגישה לזיכרון ומאיצה את ביצוע התהליך. אפשרות א' מתארת יתרון של Multi-queue multiprocessor scheduling, אשר באופן טבעי משיג cache affinity, אך זו אינה הסיבה הישירה לחשיבות ה-cache affinity עצמה. אפשרויות ג' ו-ד' אינן קשורות ישירות ליתרון הספציפי של cache affinity."
    }
  }
}