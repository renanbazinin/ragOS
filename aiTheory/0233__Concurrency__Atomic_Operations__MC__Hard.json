{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Atomic Operations",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:50:19",
    "context_chunks_used": 5,
    "context_lectures": [
      11,
      13,
      14
    ],
    "token_usage": {
      "prompt_tokens": 1793,
      "output_tokens": 961,
      "total_tokens": 5524
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Atomic Operations"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהקשר של פעולות אטומיות במערכות הפעלה, פעולת ה-`wait` של משתנה תנאי (condition variable) מתוארת כפעולה שבה \"משחררים מנעול והולכים לישון (זה אטומי, בו זמנית)\". מהי הסיבה העיקרית לכך ששני שלבים אלו חייבים להתבצע באופן אטומי, ומדוע זה קריטי לתקינות המערכת?",
      "code_snippet": "-> Atomic:\nunlock(&m1);\nwait_for_signal(&cv1);\n// after waking up:\nlock(&m1);",
      "options": [
        "א. האטומיות מבטיחה ששחרור המנעול והכניסה למצב שינה יתרחשו כיחידה בלתי ניתנת להפרעה, ובכך מונעת מצב שבו חוט אחר יתפוס את המנעול, ישנה את מצב התנאי וישלח סיגנל (signal) לפני שהחוט הקורא ל-`wait` הספיק להירדם, מה שיוביל לאובדן הסיגנל ולקיפאון (deadlock) פוטנציאלי.",
        "ב. האטומיות של פעולת ה-`wait` נובעת מכך שהיא ממומשת באופן בלעדי באמצעות פקודת חומרה יחידה בדומה ל-`TestAndSet`, המשלבת את כל הפעולות הנדרשות לשחרור מנעול וכניסה למצב שינה.",
        "ג. האטומיות מבטיחה שרק חוט אחד יוכל לקרוא ל-`wait` על משתנה תנאי מסוים בכל רגע נתון, מה שמבטיח סדר קבוע וידוע מראש של המתנה בין החוטים.",
        "ד. האטומיות מיועדת למנוע מצב שבו המערכת קורסת באמצע פעולת ה-`wait`, ובכך מבטיחה שהמנעול תמיד ישוחרר ושהחוט לא ייתקע במצב ביניים בלתי עקבי."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "האטומיות של פעולת ה-`wait` במשתני תנאי היא קריטית למניעת תזמון לא נכון (race condition) ואף קיפאון. ללא אטומיות זו, יכול להיווצר חלון זמן קצר בין שחרור המנעול לבין כניסת החוט למצב שינה. בחלון זמן זה, חוט אחר יכול לתפוס את המנעול, לשנות את התנאי שעליו ממתינים, ולשלוח סיגנל. אם הסיגנל נשלח לפני שהחוט הראשון הספיק להירדם, הסיגנל \"יאבד\", והחוט הראשון יירדם וימתין לסיגנל שלעולם לא יגיע, מה שיוביל לקיפאון. לכן, שחרור המנעול והכניסה למצב שינה חייבים להתבצע כיחידה אטומית אחת, כפי שמצוין בחומר ההרצאה: \"כשאנחנו קוראים ל-wait ומחכים למסר, אנחנו משחררים מנעול והולכים לישון (זה אטומי, בו זמנית).\" אפשרות ב' שגויה מכיוון שפעולת `wait` מורכבת מכדי להיות ממומשת כפקודת חומרה יחידה בלבד; היא משלבת פרימיטיבים חומרתיים עם לוגיקה של מתזמן מערכת ההפעלה. אפשרויות ג' ו-ד' אינן מתארות נכונה את מטרת האטומיות בהקשר זה."
    }
  }
}