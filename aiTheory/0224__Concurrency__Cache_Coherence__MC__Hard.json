{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Cache Coherence",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:47:51",
    "context_chunks_used": 5,
    "context_lectures": [
      16,
      15
    ],
    "token_usage": {
      "prompt_tokens": 2018,
      "output_tokens": 938,
      "total_tokens": 4732
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Cache Coherence"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהקשר של מערכות מרובות מעבדים עם מטמונים פרטיים לכל מעבד, בעיית קוהרנטיות המטמון (Cache Coherence) מציגה דילמה מהותית. איזו מהטענות הבאות מתארת בצורה הטובה ביותר את הדילמה המרכזית כפי שהוצגה בחומר הלימוד?",
      "code_snippet": null,
      "options": [
        "א. הצורך לשמור על temporal locality ו-spatial locality עבור כל מעבד מתנגש עם היכולת להקצות ג'ובים באופן אקראי בין מעבדים שונים, מה שפוגע ב-cache affinity.",
        "ב. מצד אחד, אי-עדכון מיידי של הזיכרון הראשי על ידי מעבד ששינה נתון מקומי במטמון שלו עלול להוביל לחוסר עקביות ולקריאת ערכים שגויים על ידי מעבדים אחרים; מצד שני, עדכון מיידי של הזיכרון הראשי על כל שינוי הוא איטי מאוד ופוגע בביצועים.",
        "ג. הבעיה העיקרית היא שמעבדים שונים עלולים להחזיק עותקים שונים של אותו נתון במטמונים שלהם, מה שמחייב מנגנוני נעילה מורכבים בזיכרון הראשי כדי למנוע deadlock.",
        "ד. מנגנוני קוהרנטיות מטמון דורשים תמיד שימוש בפעולות אטומיות כמו fetch_and_add על משתנה משותף, דבר המגביל את מדרגיות המערכת ומעלה את העומס על אפיק הזיכרון."
      ]
    },
    "solution": {
      "correct_option": "ב",
      "explanation": "האפשרות הנכונה מתארת במדויק את הדילמה המוצגת בחומר הלימוד (הרצאה 15, קטע 23): 'מצד אחד, אם לא נעדכן את הזיכרון, לא נהיה מתואמים עם שאר המעבדים. מצד שני, אם כן נעדכן את הזיכרון על כל שינוי, זה יהיה מאוד איטי.' דילמה זו מבליטה את המתח בין שמירה על עקביות נתונים מיידית בין כל המטמונים לבין שמירה על ביצועים גבוהים על ידי הימנעות מכתיבה תכופה לזיכרון הראשי.\n\nאפשרות א' מתייחסת ל-cache affinity (זיקה למטמון), שהיא מושג הקשור ליעילות ניצול המטמון על ידי תזמון תהליכים על אותם מעבדים, ולא לבעיית עקביות הנתונים בין מטמונים שונים (cache coherence). חומר הלימוד מתאר את ה-cache affinity בהקשר של תזמון ג'ובים (הרצאה 15, קטעים 27-28).\n\nאפשרות ג' מתארת חלק מהבעיה (עותקים שונים), אך הדילמה המרכזית שהוצגה אינה מתמקדת במנגנוני נעילה מורכבים בזיכרון הראשי כבעיה בפני עצמה, אלא במתח בין עדכון לביצועים.\n\nאפשרות ד' מתייחסת לשימוש בפעולות אטומיות, אשר הוזכרו בהקשר של מימוש מחסומים (barrier) (הרצאה 16, קטע 35) ולא כחלק מהדילמה המהותית של קוהרנטיות המטמון כפי שהוצגה."
    }
  }
}