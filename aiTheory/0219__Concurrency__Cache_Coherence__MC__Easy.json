{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Cache Coherence",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Easy",
    "generated_at": "2026-02-14 17:46:46",
    "context_chunks_used": 5,
    "context_lectures": [
      16,
      15
    ],
    "token_usage": {
      "prompt_tokens": 2018,
      "output_tokens": 586,
      "total_tokens": 4109
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Cache Coherence"
    ],
    "difficulty_estimation": "Easy",
    "content": {
      "text": "מהי הבעיה העיקרית המתוארת בהקשר של עקביות מטמון (Cache Coherence) במערכת מרובת מעבדים, כאשר לכל מעבד יש מטמון משלו?",
      "code_snippet": null,
      "options": [
        "א. כאשר מעבד משנה ערך במטמון המקומי שלו, מעבדים אחרים עלולים לקרוא ערך לא מעודכן (שגוי) של אותו משתנה.",
        "ב. כל המעבדים ניגשים לזיכרון הראשי בו זמנית, מה שיוצר עומס רב ומאט את המערכת.",
        "ג. עקרון ה-spatial locality נפגע, מכיוון שמעבדים שונים ניגשים לכתובות זיכרון מרוחקות.",
        "ד. מתרחשים קיפאונות (deadlocks) תכופים עקב הצורך בסנכרון מתמיד בין המטמונים."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "החומר המצוין מתאר בבירור את בעיית עקביות המטמון: \"אם יש לנו כמה מעבדים שכל אחד יש לו cache משל עצמו, ברגע שמעבד מספר 1 למשל קורא את עניין a מה-ram, הוא מסביר את זה למטמון שלו... אם הוא משנה את ערכו, זה משתנה במטמון המקומי והזיכרון הראשי עדיין לא מעודכן, אבל אם לא נעדכן חזרה את הזיכרון, אם מעבד אחר ירצה לקרוא את ערכו של a הוא יקבל ערך לא תקין.\" תשובה א' משקפת בדיוק מצב זה – מעבד אחד משנה נתון במטמון שלו, ומעבד אחר קורא את הגרסה הישנה (הלא מעודכנת) מהזיכרון הראשי או ממטמון אחר. שאר התשובות מתארות בעיות אחרות או פגיעה בעקרונות אחרים שאינם הבעיה הישירה של עקביות מטמון כפי שתוארה בחומר."
    }
  }
}