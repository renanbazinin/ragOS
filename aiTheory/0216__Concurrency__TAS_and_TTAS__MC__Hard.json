{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "TAS and TTAS",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:46:17",
    "context_chunks_used": 5,
    "context_lectures": [
      12,
      13
    ],
    "token_usage": {
      "prompt_tokens": 1941,
      "output_tokens": 1068,
      "total_tokens": 6174
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "TAS and TTAS"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתבסס על ארכיטקטורת מעבדים מרובי ליבות כפי שתוארה בחומר הלימוד, מדוע מנגנון הנעילה Test-and-Test-and-Set (TTAS) מציג ביצועים עדיפים באופן משמעותי על פני Test-and-Set (TAS), למרות ששניהם נועדו לבצע פעולה דומה?",
      "code_snippet": "void lock()\n{\n    while (true) {\n        while (state) {}\n        if (!testAndSet(state, true))\n            return;\n    }\n}",
      "options": [
        "א. הלולאה הפנימית של TTAS (while (state) {}) מאפשרת לחוטים הממתינים לבצע סבסוב (spin) על עותק מקומי של מצב המנעול מהמטמון הפרטי שלהם, ובכך מפחיתה באופן דרמטי את תעבורת האפיק (bus traffic) הנגרמת מניסיונות חוזרים ונשנים לבצע פעולת TestAndSet אטומית כאשר המנעול כבר תפוס.",
        "ב. TTAS משתמש באלגוריתם מתקדם יותר לניהול תורים, המבטיח שהחוטים יקבלו את המנעול בסדר הוגן יותר ובכך מונע רעב (starvation) ומקצר את זמן ההמתנה הכולל.",
        "ג. מנגנון ה-TestAndSet ב-TAS גורם להחלפות קשר (context switches) תכופות בין חוטים, מה שיוצר תקורה משמעותית, בעוד TTAS נמנע מכך על ידי שימוש בפעולות לא חוסמות.",
        "ד. הלולאה הפנימית ב-TTAS מבצעת קריאות חוזרות ונשנות לזיכרון הראשי (RAM) כדי לבדוק את מצב המנעול, מה שמבטיח עדכניות גבוהה יותר של הנתונים לעומת TAS שמסתמך על מטמון בלבד."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "ההסבר לפער הביצועים המשמעותי בין מנעולי TAS ו-TTAS טמון באופן שבו הם מתייחסים לארכיטקטורת המעבדים מרובי הליבות ולזיכרון המטמון (cache) הפרטי של כל ליבה. במנגנון TAS, כל ניסיון לתפוס את המנעול כרוך בביצוע פעולת `testAndSet` אטומית. פעולה אטומית זו דורשת לרוב פרוטוקולי קוהרנטיות מטמון (cache coherence) המבטיחים שכל הליבות יראו את העדכון באופן עקבי. כאשר חוטים רבים מנסים לתפוס מנעול תפוס, כל אחד מהם מבצע `testAndSet`, מה שמוביל לשליחת הודעות ביטול מטמון (cache invalidation messages) רבות על האפיק המשותף (bus), יצירת עומס כבד והאטה משמעותית.\n\nלעומת זאת, מנגנון TTAS כולל לולאה פנימית (`while (state) {}`) לפני ניסיון ה-`testAndSet`. כאשר המנעול תפוס, חוטים ממתינים יכולים לבצע סבסוב בלולאה פנימית זו על ידי קריאת ערך המנעול מתוך העותק השמור במטמון הפרטי שלהם. רק כאשר ערך המנעול נראה פנוי במטמון המקומי, החוט מנסה לבצע את פעולת ה-`testAndSet` האטומית, אשר אכן מייצרת תעבורת אפיק. אך מכיוון שרוב זמן ההמתנה מתבצע על עותק מקומי במטמון, מספר הפעולות האטומיות והודעות ביטול המטמון על האפיק מצטמצם דרמטית, ובכך משפר את הביצועים באופן ניכר, כפי שתואר בחומר הלימוד כ'פתרון לתעלומה' על ידי התחשבות בארכיטקטורת ה-cache."
    }
  }
}