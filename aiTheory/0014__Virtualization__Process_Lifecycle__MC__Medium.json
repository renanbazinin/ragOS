{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Virtualization",
    "topic_hint": "Process Lifecycle",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-14 16:54:55",
    "context_chunks_used": 5,
    "context_lectures": [
      2,
      4,
      5
    ],
    "token_usage": {
      "prompt_tokens": 1884,
      "output_tokens": 581,
      "total_tokens": 4120
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Virtualization",
    "topic": [
      "Process Lifecycle"
    ],
    "difficulty_estimation": "Medium",
    "content": {
      "text": "מהי הסיבה העיקרית שמערכת הפעלה אינה מפנה באופן אוטומטי תהליכי זומבי (defunct), גם לאחר שסיימו את ריצתם?",
      "code_snippet": null,
      "options": [
        "א. מכיוון שתהליך האב עדיין מצפה לקרוא ל-wait() על תהליך הבן כדי לאסוף את סטטוס הסיום שלו.",
        "ב. מכיוון שתהליך זומבי נשאר במצב זה עד שתהליך ה-init יאמץ אותו ויפנה אותו.",
        "ג. כדי לאפשר לתהליכים אחרים לבצע דיבוג (debugging) על מצבו האחרון של התהליך שהסתיים.",
        "ד. מערכת ההפעלה אינה מזהה תהליכים במצב זומבי ודורשת התערבות ידנית."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "ההסבר מהחומר המצורף (הרצאה 5, קטע 6) קובע במפורש: \"מדוע מערכת ההפעלה לא עושה פינוי לתהליכים שהם זומבים? מכיוון שתהליך האב עלול לעשות לתהליך הבן wait.\" תהליך זומבי הוא תהליך שסיים את ריצתו אך רשומתו עדיין קיימת בטבלת התהליכים. מערכת ההפעלה משאירה את הרשומה הזו עד שתהליך האב יקרא ל-`wait()` כדי לאסוף את קוד היציאה של תהליך הבן. אם מערכת ההפעלה הייתה מפנה את הזומבי אוטומטית, תהליך האב לא היה יכול לקבל מידע זה. לכן, תשובה א' היא הנכונה. תשובה ב' מתארת מצב שבו תהליך הופך ליתום (orphan) לאחר סיום תהליך האב, ואז `init` מפנה אותו, אך זו אינה הסיבה שמערכת ההפעלה אינה מפנה זומבים באופן כללי. תשובות ג' ו-ד' אינן נתמכות בחומר ההרצאה."
    }
  }
}