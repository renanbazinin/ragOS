{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Starvation and Deadlocks",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 19:08:20",
    "context_chunks_used": 5,
    "context_lectures": [
      16,
      15
    ],
    "token_usage": {
      "prompt_tokens": 1763,
      "output_tokens": 1102,
      "total_tokens": 5386
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Starvation and Deadlocks"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתבסס על ההגדרה של הרעבה בחומר הקורס, ובהתחשב במימוש המנעול הבא:\n\n```c\nint turn;\nvoid lock(int i) {\n    turn = 1-i;\n    while (turn != i);\n}\nvoid unlock(int i) {\n    turn = 1-i;\n}\n```\n\nאיזו טענה מתארת באופן המדויק ביותר מצב של הרעבה (starvation) עבור חוט `i` במערכת המשתמשת במנעול זה?",
      "code_snippet": "int turn;\nvoid lock(int i) {\n    turn = 1-i;\n    while (turn != i);\n}\nvoid unlock(int i) {\n    turn = 1-i;\n}",
      "options": [
        "א. חוט `i` נכנס ללולאת `while` ב-`lock(i)` ומתקדם לעולמים מבלי שחוט אחר יבצע `unlock`.",
        "ב. חוט `i` נכנס ללולאת `while` ב-`lock(i)`, בעוד חוט `1-i` מבצע לסירוגין `lock(1-i)` ו-`unlock(1-i)` שוב ושוב, מונע מחוט `i` אי פעם לצאת מהלולאה.",
        "ג. חוט `i` תפס את המשאב, אך חוטים אחרים ממתינים לו לנצח, ולכן המערכת כולה בקיפאון.",
        "ד. חוט `i` אינו מצליח לבצע `lock(i)` אף פעם, מכיוון שחוט `1-i` תמיד מחזיק במנעול ואינו משחרר אותו."
      ]
    },
    "solution": {
      "correct_option": "ב",
      "explanation": "התשובה הנכונה היא ב'. הרעבה (starvation) מוגדרת בחומר הקורס כמצב שבו חוט אחד חסום ואינו מתקדם, בעוד חוטים אחרים במערכת ממשיכים להתקדם ולבצע פעולות. יתר על כן, חומר הקורס מדגיש כי \"אם חוט תפס את המשאב ומחזיק בו לנצח, זו לא הרעבה, זה באג בקוד. בשביל הרעבה צריך שיהיה מישהו שתמיד תופס ומשחרר את המשאב.\" כלומר, המשאב חייב להיות זמין (משוחרר) מעת לעת, אך חוט מסוים אינו מצליח להשיג אותו.\n\nבמימוש המנעול הנתון, חוט `i` נכנס ללולאת `while (turn != i)` לאחר שקבע `turn = 1-i`. כדי שחוט `i` יצא מהלולאה, המשתנה `turn` חייב להשתנות ל-`i`. אם חוט `1-i` מבצע לסירוגין `lock(1-i)` ו-`unlock(1-i)` שוב ושוב, הוא מונע מחוט `i` מלהתקדם. בפרט, חוט `1-i` קובע `turn = i` בתוך ה-`unlock` שלו, אך מיד לאחר מכן, ב-`lock` הבא שלו, הוא שוב קובע `turn = 1-(1-i) = i` ואז משנה את `turn` ל-`1-i` בתוך הלולאה (או לפני הכניסה אליה) מבלי שחוט `i` הספיק לצאת מהלולאה שלו. תזמון זה, כפי שמתואר ב\"Lecture 16 (chunk 11)\", גורם לכך שחוט `i` יהיה מורעב בעוד חוט `1-i` ממשיך להתקדם.\n\nאפשרויות א' ו-ד' מתארות מצב שבו המשאב אינו משוחרר כלל, או שחוט אחר תמיד מחזיק בו, מה שהוגדר בחומר כ\"באג בקוד\" ולא כהרעבה. אפשרות ג' מתארת קיפאון, שבו כל החוטים תקועים ואינם מתקדמים, בניגוד להגדרת הרעבה שבה חוטים אחרים דווקא מתקדמים."
    }
  }
}