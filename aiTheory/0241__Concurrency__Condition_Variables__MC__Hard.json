{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Condition Variables",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:52:30",
    "context_chunks_used": 5,
    "context_lectures": [
      11,
      14
    ],
    "token_usage": {
      "prompt_tokens": 1903,
      "output_tokens": 963,
      "total_tokens": 6812
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Condition Variables"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהקשר של פתרון בעיית היצרן-צרכן (Producer-Consumer) תוך שימוש במשתני תנאי (Condition Variables) לסנכרון גישה למאגר חסום (Bounded Buffer), ובהתבסס על הבעיות והפתרונות הנדונים בחומר הקורס, מהי הגישה המומלצת למנוע מצבי קיפאון (Deadlock) הנובעים מערבוב הודעות סנכרון?",
      "code_snippet": null,
      "options": [
        "א. יש להשתמש במשתנה תנאי יחיד עבור כל ההודעות הקשורות למאגר, כאשר הן היצרנים והן הצרכנים ממתינים עליו ומודיעים זה לזה דרכו.",
        "ב. יש להשתמש בשני משתני תנאי נפרדים: אחד (empty) עליו ממתינים הצרכנים כאשר המאגר ריק, ואליו שולחים היצרנים סיגנל בעת הוספת מוצר; ואחד (full) עליו ממתינים היצרנים כאשר המאגר מלא, ואליו שולחים הצרכנים סיגנל בעת צריכת מוצר.",
        "ג. יש להסתפק בשימוש במנעול (mutex) בודד המגן על הגישה למאגר, שכן הוא מספק בלעדיות (mutual exclusion) ובכך מונע את כל בעיות הסנכרון, כולל קיפאון.",
        "ד. יש להחליף את השימוש במשתני תנאי בסמפורים (Semaphores) עם פעולות wait ו-post, מכיוון שהם מספקים פונקציונליות רחבה יותר ואינם סובלים מבעיות קיפאון בבעיית היצרן-צרכן."
      ]
    },
    "solution": {
      "correct_option": "ב",
      "explanation": "החומר המצורף מציין במפורש כי שימוש במשתנה תנאי יחיד עבור שני סוגי הודעות (כשהמאגר ריק וכשהמאגר מלא) בבעיית היצרן-צרכן עלול להוביל למצב של קיפאון (Deadlock). דוגמה לכך היא מצב שבו צרכן חסום כי אין מוצרים ויצרן חסום כי אין מקום פנוי, למרות שבפועל עשוי להיות מקום פנוי או מוצרים זמינים. הפתרון המומלץ, על פי החומר, הוא \"שימוש בשני condition variables\" ו-\"לא נערבב בין הודעות, כל הודעה היא בפני עצמה.\" הוסבר כי יש להשתמש במשתנה תנאי `empty` עבור צרכנים הממתינים על מאגר ריק (ויצרנים שולחים לו סיגנל), ובמשתנה תנאי `full` עבור יצרנים הממתינים על מאגר מלא (וצרכנים שולחים לו סיגנל). לכן, אפשרות ב' מתארת במדויק את הפתרון לבעיה זו כפי שהוצג בהרצאה. אפשרות א' מתארת את הגורם לקיפאון. אפשרות ג' אינה נכונה, מכיוון שמנעול לבדו מספק בלעדיות אך אינו מאפשר לחוטים לחכות לתנאי מסוים. אפשרות ד' אינה נכונה, שכן סמפורים ומשתני תנאי הם מנגנוני סנכרון שונים, והחומר מציג את המימוש הספציפי של משתני תנאי בלינוקס באמצעות `pthread_cond_wait` ו-`pthread_cond_signal`, ומבהיר את הצורך בפתרון הספציפי הזה עם שני משתני תנאי כדי למנוע קיפאון בבעיה זו."
    }
  }
}