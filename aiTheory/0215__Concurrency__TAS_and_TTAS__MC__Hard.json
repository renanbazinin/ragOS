{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "TAS and TTAS",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:45:56",
    "context_chunks_used": 5,
    "context_lectures": [
      12,
      13
    ],
    "token_usage": {
      "prompt_tokens": 1941,
      "output_tokens": 1263,
      "total_tokens": 5497
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "TAS and TTAS"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "למרות שהמנעולים Test-and-Set (TAS) ו-Test-and-Test-and-Set (TTAS) נראים לכאורה מבחינה לוגית כמבצעים את אותה הפעולה, חומר הקורס מציין פער ביצועים משמעותי לטובת TTAS, בעיקר במערכות מרובות ליבות. בהתבסס על ההסבר שניתן בחומר לגבי ארכיטקטורת מעבד מרובה ליבות (cache פרטי ו-BUS משותף), מהי הסיבה העיקרית לפער ביצועים זה?\n\nלהלן מימוש פשטני של מנעול TTAS:\n",
      "code_snippet": "void lock()\n{\n    while (true) {\n        while (state) {} // הלולאה הפנימית\n        if (!testAndSet(state, true))\n            return;\n    }\n}",
      "options": [
        "א. לולאת ה-`while (state) {}` הפנימית ב-TTAS מאפשרת לחוטים \"להמתין בשקט\" על עותק ה-cache הפרטי שלהם של משתנה ה-`state`, ובכך מפחיתה באופן דרמטי את תעבורת ה-BUS ואת הודעות ה-invalidation הקשורות לניסיונות חוזרים ונשנים לבצע `testAndSet` על המנעול כשהוא תפוס.",
        "ב. מנגנון ה-`testAndSet` ב-TTAS מהיר יותר באופן אינהרנטי מאשר ב-TAS, מכיוון שהוא ממומש בחומרה בצורה אופטימלית יותר עבור מערכות מרובות מעבדים.",
        "ג. TTAS משתמש במשתנה `state` גדול יותר (בערך 128 בתים, כגודל שורת cache), מה שמאפשר גישה מהירה יותר לנתונים על ידי המעבדים ומפחית false sharing.",
        "ד. TTAS משתמש באלגוריתם תזמון חוטים מתקדם יותר המונע \"רעב\" (starvation) ומבטיח חלוקה שווה של זמן מעבד בין החוטים, מה שמוביל לביצועים טובים יותר."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. חומר הקורס מסביר כי הפער המשמעותי בביצועים בין TAS ל-TTAS נובע מהאופן שבו הם מתקשרים עם ארכיטקטורת המעבד מרובה הליבות, ובפרט עם ה-cache הפרטי של כל מעבד וה-BUS המשותף. פעולת ה-`testAndSet` היא פעולה אטומית של קריאה-שינוי-כתיבה (Read-Modify-Write) הדורשת בלעדיות על שורת ה-cache הרלוונטית. כאשר חוט מבצע `testAndSet`, הוא שולח הודעות invalidation (פסילה) לכל שאר ה-caches המכילים עותק של המשתנה, מה שגורם לתעבורה רבה ב-BUS ולצורך בטעינה מחדש של שורת ה-cache.\n\nבמנעול TAS, כל איטרציה בלולאת ההמתנה מנסה לבצע `testAndSet`. כאשר המנעול תפוס, חוטים רבים מנסים שוב ושוב את הפעולה האטומית, מה שמוביל ל\"סערת\" הודעות invalidation על ה-BUS ולפגיעה קשה בביצועים.\n\nבמנעול TTAS, לעומת זאת, קיימת לולאה פנימית `while (state) {}`. לולאה זו מבצעת קריאה בלבד של משתנה ה-`state`. כל עוד ה-`state` הוא `true` (המנעול תפוס), החוט קורא את הערך מעותק ה-cache הפרטי שלו. רק כאשר חוט אחר משחרר את המנעול, הוא משנה את ערך ה-`state` ל-`false`, ופעולה זו גורמת להודעת invalidation שנשלחת לכל ה-caches האחרים. כאשר ה-cache המקומי של חוט ממתין מקבל את הודעת ה-invalidation, הוא מסמן את שורת ה-cache כלא תקפה. בגישה הבאה למשתנה `state` (באיטרציה הבאה של הלולאה הפנימית), הוא יטען את הערך המעודכן (כלומר `false`) מהזיכרון הראשי. רק אז, כשהלולאה הפנימית מסתיימת, החוט ינסה לבצע את פעולת ה-`testAndSet` היקרה. מנגנון זה מפחית באופן דרמטי את מספר הפעולות האטומית `testAndSet` המבוצעות על ה-BUS, ובכך מצמצם את תעבורת ה-BUS ואת הודעות ה-invalidation, מה שמוביל לשיפור ביצועים משמעותי."
    }
  }
}