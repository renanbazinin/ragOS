{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Disks",
    "topic_hint": "I/O Devices",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 18:32:49",
    "context_chunks_used": 5,
    "context_lectures": [
      17,
      18
    ],
    "token_usage": {
      "prompt_tokens": 2181,
      "output_tokens": 863,
      "total_tokens": 5464
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Disks",
    "topic": [
      "I/O Devices"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתחשב במנגנונים של **Memory-Mapped I/O** ו**דרייברים (מנהלי התקן)** כפי שתוארו בחומר הקורס, ובהינתן שמערכת ההפעלה אינה מאפשרת ליישום במרחב המשתמש (user space) למפות לזיכרון רגיסטרים של פקודה (command registers) או מצב (status registers) של התקן חומרה ישירות, כדי למנוע נזק למערכת, איזו מהאפשרויות הבאות מתארת בצורה הטובה ביותר את הדרך שבה יישום במרחב המשתמש יכול להפעיל פעולת כתיבה (למשל, \"התחל הקלטה\") על התקן חומרה מותאם אישית?",
      "code_snippet": null,
      "options": [
        "א. על ידי גישה ישירה ל-**Command Register** של ההתקן באמצעות **Memory-Mapped I/O**, שכן ה-OS ממפה את כל רגיסטרי ההתקן למרחב הכתובות של היישום.",
        "ב. באמצעות כתיבה ישירה ל-**Data Register** של ההתקן דרך **Memory-Mapped I/O**, שכן פעולות כתיבה תמיד מתבצעות דרך רגיסטר הנתונים בלבד.",
        "ג. באמצעות קריאת מערכת (system call) שמערכת ההפעלה מספקת, אשר בתורה משתמשת בדרייבר המתאים כדי לכתוב ל-**Command Register** של ההתקן.",
        "ד. על ידי טעינת קוד דרייבר חדש ישירות ממרחב המשתמש לתוך זיכרון הליבה (kernel memory) וביצוע הפקודה באופן עצמאי."
      ]
    },
    "solution": {
      "correct_option": "ג",
      "explanation": "חומר הקורס מציין כי Memory-Mapped I/O מאפשר גישה לרכיבי חומרה, אך מערכת ההפעלה אינה מאפשרת למפות רגיסטרים שעלולים להזיק (כמו Command/Status registers) למרחב המשתמש, כדי למנוע נזק. לכן, אפשרות א' שגויה. אפשרות ב' שגויה מכיוון ש-Data Register משמש להעברת נתונים עבור פעולה מסוימת, אך לא להפעלת הפקודה עצמה; הפקודה מוגדרת ברגיסטר הפקודה (Command Register). אפשרות ד' שגויה, שכן טעינת דרייבר היא פעולה מבוקרת של מערכת ההפעלה, ולא משהו שיישום משתמש מבצע ישירות לתוך זיכרון הליבה באופן אד-הוק. הדרך הנכונה היא שאפליקציית משתמש תבצע קריאת מערכת (system call) למערכת ההפעלה. מערכת ההפעלה, בתורה, תשתמש בדרייבר המתאים (שכבר טעון במערכת ופועל במצב ליבה) כדי לתקשר עם רגיסטרי הפקודה של ההתקן ולבצע את הפעולה המבוקשת בצורה בטוחה ומבוקרת. הדרייבר הוא האבסטרקציה שמאפשרת למערכת ההפעלה לתקשר עם רכיבי חומרה ספציפיים."
    }
  }
}