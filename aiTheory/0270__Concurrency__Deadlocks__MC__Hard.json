{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Deadlocks",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:59:40",
    "context_chunks_used": 5,
    "context_lectures": [
      16,
      15
    ],
    "token_usage": {
      "prompt_tokens": 2076,
      "output_tokens": 659,
      "total_tokens": 4597
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Deadlocks"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "מדוע עקרונות תכנות נכון, כגון אנקפסולציה ושימוש ב\"קופסא שחורה\" עבור אובייקטים, נחשבים למאתגרים או לא עובדים היטב עם מניעה או איתור של קיפאונות (deadlocks) במערכות מקביליות?",
      "code_snippet": null,
      "options": [
        "א. עקרונות אלו מטשטשים את סדר תפיסת המנעולים הפנימי בתוך קריאות לפעולות של אובייקטים, ובכך מקשים על זיהוי המתנה מעגלית.",
        "ב. אנקפסולציה מפחיתה את מספר המנעולים הכולל במערכת, מה שדווקא מקטין את הסבירות לקיפאון.",
        "ג. \"קופסא שחורה\" מונעת מחוטים אחרים לגשת למשאבים משותפים, ובכך תורמת באופן ישיר למניעת תנאי 'החזקה והמתנה'.",
        "ד. עקרונות אלו מביאים ליצירת קוד פשוט מדי, מה שמקשה על המהדר לזהות דפוסי גישה למשאבים."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. כפי שמצוין בחומר ההרצאה, עקרונות תכנות מונחה עצמים כמו אנקפסולציה והתייחסות לפעולות כאובייקטים כ'קופסא שחורה' (black box) אומרים שאנו לא אמורים לדעת את פרטי המימוש הפנימיים. אך אם פעולה של אובייקט תופסת מנעול, ובנוסף קוראת לפעולות אחרות שגם הן תופסות מנעולים, אנו מאבדים את השליטה והראות לגבי סדר תפיסת המנעולים הכולל במערכת. חוסר היכולת לדעת \"מי תופס את המנעול, מתי ובאיזה סדר\" מקשה מאוד על זיהוי ומניעה של תנאי המתנה מעגלית (circular wait), שהוא תנאי הכרחי לקיומו של קיפאון. לכן, עקרונות אלו, למרות שהם טובים לארגון קוד, יוצרים אתגר משמעותי בהבנה ובשליטה על התנהגות מנעולים במערכת מקבילית."
    }
  }
}