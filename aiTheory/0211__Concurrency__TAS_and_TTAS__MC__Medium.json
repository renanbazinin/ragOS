{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "TAS and TTAS",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-14 17:44:54",
    "context_chunks_used": 5,
    "context_lectures": [
      12,
      13
    ],
    "token_usage": {
      "prompt_tokens": 1941,
      "output_tokens": 894,
      "total_tokens": 5670
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "TAS and TTAS"
    ],
    "difficulty_estimation": "Medium",
    "content": {
      "text": "מדוע מנעול TTAS (Test-and-Test-and-Set) מציג ביצועים טובים באופן משמעותי ממנעול TAS (Test-and-Set) במערכת מרובת ליבות, למרות שהלולאה הפנימית שלו עשויה להיראות מיותרת?",
      "code_snippet": "void lock()\n{\n    while (true) {\n        while (state) {}\n        if (!testAndSet(state, true))\n            return;\n    }\n}",
      "options": [
        "א. מנעול TTAS מפחית באופן משמעותי את תעבורת ה-BUS על ידי קריאת מצב המנעול מזיכרון המטמון הפרטי של המעבד (cache) בלולאה הפנימית, ובכך נמנע משימוש בפעולת testAndSet שיוצרת תעבורת BUS רבה, אלא רק כאשר המנעול נראה פנוי.",
        "ב. מנעול TTAS מבטיח תור הוגן יותר בין החוטים הממתינים למנעול, מה שמפחית את זמן ההמתנה הכולל עבור כל חוט.",
        "ג. מנעול TTAS אינו משתמש בפעולת testAndSet כלל, אלא מסתמך על מנגנון נעילה אופטימיסטי אחר שאינו דורש סנכרון חומרה.",
        "ד. הלולאה הפנימית של TTAS מפחיתה את מספר הקריאות לפונקציית lock ובכך מקטינה את התקורה של קריאות לפונקציות."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. ההבדל המשמעותי בביצועים בין מנעול TAS למנעול TTAS נובע מהאופן שבו הם מתקשרים עם זיכרון המטמון (cache) המשותף במערכות מרובות ליבות. מנעול TAS מבצע פעולת `testAndSet` באופן חוזר ונשנה בלולאת ההמתנה שלו. פעולה זו היא פעולת כתיבה אטומית, וככזו, היא דורשת סנכרון דרך ה-BUS המשותף כדי לוודא עקביות בין זיכרונות המטמון של כל הליבות. כל ביצוע של `testAndSet` עלול לגרום לפסילת שורות מטמון אצל מעבדים אחרים ולייצר תעבורה רבה ב-BUS, מה שפוגע בביצועים ככל שיש יותר חוטים.\n\nלעומת זאת, מנעול TTAS, באמצעות הלולאה הפנימית `while (state) {}`, קורא את מצב המנעול מזיכרון המטמון הפרטי של המעבד. קריאה זו היא זולה יחסית ואינה יוצרת תעבורת BUS משמעותית אם הנתון כבר נמצא במטמון המקומי. רק כאשר הליבה רואה שמצב המנעול הוא 'פנוי' (כלומר `state` הוא false) בזיכרון המטמון שלה, היא מנסה לבצע את פעולת ה-`testAndSet` היקרה יותר. בכך, TTAS מפחית באופן דרמטי את כמות תעבורת ה-BUS ואת פסילות המטמון, מה שמוביל לשיפור ניכר בביצועים, במיוחד במערכות עם מספר רב של ליבות."
    }
  }
}