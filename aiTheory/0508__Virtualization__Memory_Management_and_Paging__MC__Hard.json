{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Virtualization",
    "topic_hint": "Memory Management and Paging",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 18:57:01",
    "context_chunks_used": 5,
    "context_lectures": [
      9,
      5,
      6
    ],
    "token_usage": {
      "prompt_tokens": 2143,
      "output_tokens": 937,
      "total_tokens": 7602
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Virtualization",
    "topic": [
      "Memory Management and Paging"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתבסס על תיאור אלגוריתם \"free list\" בחומר הלימוד, אשר מחלק את הזיכרון לבלוקים שווים בגודלם ומנהל אותם ברשימה מקושרת, מהו האתגר המרכזי שאלגוריתם זה יתקשה להתמודד איתו ביעילות, בהשוואה לשיטות מתקדמות יותר כמו \"segmentation\" או \"Buddy Allocation\", במערכת הפעלה המנהלת תהליכים בעלי צרכי זיכרון דינמיים ומשתנים?",
      "code_snippet": null,
      "options": [
        "א. קושי בניהול והקצאת זיכרון עבור רכיבים כמו ערימה (heap) או מחסנית (stack) הדורשים יכולת גדילה והתכווצות דינמית בגדלים משתנים.",
        "ב. בזבוז זיכרון משמעותי עקב פרגמנטציה פנימית (internal fragmentation) כאשר בקשות קטנות מבלוק בגודל קבוע.",
        "ג. חוסר יכולת לאחד בלוקי זיכרון פנויים סמוכים (coalescing) כדי ליצור בלוקים גדולים יותר, מה שמוביל לפרגמנטציה חיצונית (external fragmentation).",
        "ד. עלות תקורה גבוהה הכרוכה בניהול הרשימה המקושרת של הבלוקים הפנויים, הפוגעת בביצועי המערכת."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "אלגוריתם ה-\"free list\" המתואר בחומר הלימוד מחלק את הזיכרון לבלוקים בגודל קבוע וזהה. תכונה זו, למרות פשטותה ויעילותה עבור הקצאות בגודל קבוע, מהווה מגבלה מהותית כאשר יש צורך לנהל רכיבי זיכרון כמו ערימה (heap) או מחסנית (stack), אשר גודלם משתנה באופן דינמי ובלתי צפוי במהלך ריצת התהליך. חומר הלימוד מציין במפורש כי בשיטת \"segmentation\", ה-bounds של סגמנטים כמו מחסנית וערימה \"יגדלו וישתנו תוך כדי ריצה ככל שמקצים זיכרון\", מה שמדגיש את הצורך ביכולת גמישות בגודל. אלגוריתם \"Buddy Allocation\" גם הוא נועד להתמודד עם בקשות בגדלים משתנים. לעומת זאת, אלגוריתם \"free list\" בגרסתו זו, המקצה \"איבר מהרשימה\" (בלוק יחיד בגודל קבוע), אינו מספק פתרון טבעי ויעיל לניהול זיכרון בעל דרישות גודל גמישות כאלה. אפשרות ב' (פרגמנטציה פנימית) נכונה באופן כללי עבור בלוקים בגודל קבוע, אך לא מהווה את האתגר המרכזי הייחודי בהשוואה לשיטות מתקדמות המטפלות בגדלים משתנים. אפשרות ג' (coalescing ופרגמנטציה חיצונית) רלוונטית יותר לאלגוריתמים המנהלים בלוקים בגדלים משתנים (כמו Buddy Allocation המיועד לפתור בעיות coalesce), ואילו ב-free list עם בלוקים שווים בגודלם, בעיית האיחוד שונה. אפשרות ד' (עלות תקורה גבוהה) נשללת על ידי חומר הלימוד הקובע כי free list \"מאוד יעיל וזה מאוד פשוט\"."
    }
  }
}