{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Virtualization",
    "topic_hint": "Process Lifecycle",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 16:55:41",
    "context_chunks_used": 5,
    "context_lectures": [
      2,
      4,
      5
    ],
    "token_usage": {
      "prompt_tokens": 1884,
      "output_tokens": 910,
      "total_tokens": 5730
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Virtualization",
    "topic": [
      "Process Lifecycle"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "תהליך בן סיים את ריצתו בהצלחה, אך תהליך האב שלו, שעדיין פעיל, אינו מבצע עליו קריאת מערכת wait. בהתבסס על המידע הנתון, מהו המצב בו יימצא תהליך הבן, ומהו המנגנון העיקרי שמערכת ההפעלה תסתמך עליו כדי לוודא שמשאביו יפונו לבסוף, גם אם תהליך האב לעולם לא יקרא ל-wait?",
      "code_snippet": null,
      "options": [
        "א. תהליך הבן יימצא במצב \"זומבי\" (defunct). מערכת ההפעלה תמתין לסיום ריצתו של תהליך האב; ברגע שתהליך האב יסיים, תהליך הבן יאומץ על ידי init, אשר ידאג לפנות את רשומתו.",
        "ב. תהליך הבן יימצא במצב \"מוכן לריצה\" (Ready). מערכת ההפעלה תזהה חוסר פעילות ותעביר אותו למצב \"מושהה\" (Suspended) ולאחר מכן תפנה את משאביו באופן יזום.",
        "ג. תהליך הבן יימצא במצב \"רץ\" (Running) אך ללא פקודות לביצוע. מערכת ההפעלה תשלח אות kill -9 לתהליך הבן כדי לפנות את משאביו.",
        "ד. תהליך הבן יימצא במצב \"זומבי\" (defunct). מערכת ההפעלה תפעיל טיימר מיוחד, ולאחר פרק זמן קצוב תפנה את רשומתו באופן אוטומטי, ללא תלות בתהליך האב או ב-init."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. כאשר תהליך בן מסיים את ריצתו, אך תהליך האב שלו (שעדיין פעיל) אינו מבצע עליו קריאת מערכת wait, תהליך הבן נכנס למצב \"זומבי\" (defunct). במצב זה, תהליך הבן כבר אינו רץ ורוב משאביו שוחררו, אך רשומת ה-PCB שלו (ותוכם מידע כמו קוד היציאה) נשארת בטבלת התהליכים. מערכת ההפעלה אינה מפנה רשומות אלו באופן יזום, כיוון שהיא מצפה שתהליך האב יקרא ל-wait על מנת לאסוף את קוד היציאה ולפנות את הרשומה. אם תהליך האב לעולם לא יקרא ל-wait, הדרך העיקרית לפינוי רשומת הזומבי היא כאשר תהליך האב עצמו יסיים את ריצתו. במקרה כזה, כל תהליכי הבנים שנותרו (כולל הזומבים) מאומצים על ידי תהליך init (תהליך מספר 1), אשר ידוע בכך שהוא דואג לפנות את רשומות הזומבים שלו, ובכך משחרר את ה-PCB של תהליך הבן. אפשרויות ב', ג' ו-ד' אינן נכונות: תהליך שהסתיים אינו יכול להיות במצב \"מוכן לריצה\" או \"רץ\". מערכת ההפעלה אינה מפנה זומבים באופן יזום באמצעות טיימר או אות kill -9 ישירות לתהליך הזומבי, אלא ממתינה לפעולת האב או לסיום האב."
    }
  }
}