{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Threads and Locks",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 19:00:48",
    "context_chunks_used": 5,
    "context_lectures": [
      10,
      11
    ],
    "token_usage": {
      "prompt_tokens": 1789,
      "output_tokens": 821,
      "total_tokens": 5015
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Threads and Locks"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתבסס על מנגנון המנעול מבוסס ה\"תור\" (turn) המוצג בחומר הלימוד, אשר נועד לסנכרן גישה לקטע קריטי בין שני חוטים (A ו-B), מדוע מנגנון זה עלול להוביל למצב של קיפאון (deadlock) בתרחיש מסוים?",
      "code_snippet": "Thread A\nwhile (turn != A)\n  ; // busy-wait\n// critical section\nturn = B;\n\nThread B\nwhile (turn != B)\n  ; // busy-wait\n// critical section\nturn = A;",
      "options": [
        "א. חוט שמגיע תורו (לדוגמה, turn == A) אך אינו מעוניין להיכנס לקטע הקריטי באותו רגע, ימשיך לבצע פעולות אחרות ולא ישחרר את ה\"תור\". כתוצאה מכך, החוט השני (B) ימתין בלולאה אינסופית (busy-wait) ולא יוכל להיכנס לקטע הקריטי, מה שיוביל לקיפאון.",
        "ב. הבעיה נובעת מכך ששני החוטים מנסים לשנות את ערך המשתנה turn בו-זמנית, מה שגורם למצב מרוץ (race condition) ועלול להוביל לכך שאף חוט לא יצליח לתפוס את המנעול.",
        "ג. מנגנון זה אינו מבטיח הגינות (fairness), וחוט אחד עלול להישאר מורעב (starvation) ולא לקבל את תורו לעולם, גם אם החוט השני מסיים את הקטע הקריטי ומשחרר את המנעול.",
        "ד. הקוד אינו מטפל במקרה שבו חוט אחד מסיים את פעולתו לפני שהחוט השני מספיק להיכנס לקטע הקריטי, ומשאיר את המשתנה turn במצב לא עקבי."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. מנגנון ה\"תור\" המוצג סובל מבעיית קיפאון (deadlock) בתרחיש שבו תורו של חוט מסוים (לדוגמה, חוט A) הגיע (כלומר, turn == A), אך חוט A אינו מעוניין באותו רגע להיכנס לקטע הקריטי ומבצע פעולות אחרות. במצב כזה, חוט A לא ייכנס ללולאת ה-busy-wait שלו, ולכן גם לא יגיע לשורה turn = B שתשחרר את ה\"תור\" לחוט השני. חוט B, לעומת זאת, ימצא את עצמו בלולאת while (turn != B) אינסופית, ממתין לתורו שלעולם לא יגיע. חוט A לא יאפשר ל-B להתקדם, ו-B ימתין ל-A, מה שיוצר קיפאון קלאסי. כפי שצויין בחומר הלימוד, \"חוט B מחכה לתורו אבל אף פעם לא יגיע תורו\"."
    }
  }
}