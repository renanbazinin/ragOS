{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "TAS and TTAS",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-14 17:45:23",
    "context_chunks_used": 5,
    "context_lectures": [
      12,
      13
    ],
    "token_usage": {
      "prompt_tokens": 1941,
      "output_tokens": 799,
      "total_tokens": 5084
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "TAS and TTAS"
    ],
    "difficulty_estimation": "Medium",
    "content": {
      "text": "למרות הדמיון הפונקציונלי לכאורה בין מנעולי TAS ו-TTAS, קיימים פערי ביצועים משמעותיים ביניהם בסביבת ריבוי מעבדים (Multi-core). מהי הסיבה העיקרית לשיפור הביצועים המשמעותי של מנעול TTAS?",
      "code_snippet": "void lock()\n{\n    while (true) {\n        while (state) {}\n        if (!testAndSet(state, true))\n            return;\n    }\n}",
      "options": [
        "א. הלולאה הפנימית במנעול TTAS מאפשרת לחוטים ממתינים לבדוק את מצב המנעול מתוך זיכרון המטמון הפרטי שלהם (cache), ובכך מפחיתה באופן דרמטי את תעבורת ה-BUS ופגיעות בביצועים.",
        "ב. מנעול TAS מכיל שגיאה לוגית מובנית הגורמת לו לחסום חוטים ללא צורך, בעוד TTAS מתקן שגיאה זו.",
        "ג. מנעול TTAS משתמש באלגוריתם שונה לחלוטין שאינו מסתמך על פעולת testAndSet אטומית, ובכך הוא יעיל יותר.",
        "ד. מנעול TTAS מטמיע מנגנון תזמון (scheduler) פנימי המונע ממנועי הליבה לבצע פעולות מיותרות."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "החומר המצטבר מציין במפורש כי הלולאה הפנימית `while (state) {}` במנעול TTAS, שלכאורה נראית מיותרת, היא הגורם המרכזי לשיפור הביצועים המשמעותי. בארכיטקטורת ריבוי ליבות, לכל מעבד יש זיכרון מטמון (cache) פרטי משלו. כאשר חוט ממתין למנעול שמוחזק על ידי חוט אחר, לולאה זו מאפשרת לו לבדוק שוב ושוב את מצב המשתנה `state` מתוך העותק המאוחסן בזיכרון המטמון המקומי שלו. זה מפחית באופן דרמטי את מספר הפעמים שהחוט צריך לגשת לזיכרון משותף (שמעורר תעבורת BUS ופגיעה בעקביות המטמון), בניגוד ל-TAS, שבו כל ניסיון לרכוש את המנעול באמצעות `testAndSet` כרוך בכתיבה לזיכרון משותף ולרוב גורם לפסילת מטמונים של מעבדים אחרים, גם כשהמנעול תפוס. רק כאשר המשתנה `state` משתחרר על ידי המחזיק הנוכחי של המנעול (מה שגורם לפסילת העותקים המאוחסנים במטמונים של מעבדים אחרים), החוטים הממתינים ממשיכים לנסות לבצע `testAndSet`."
    }
  }
}