{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-14 17:53:59",
    "context_chunks_used": 5,
    "context_lectures": [
      14
    ],
    "token_usage": {
      "prompt_tokens": 1516,
      "output_tokens": 929,
      "total_tokens": 4770
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Producer-Consumer"
    ],
    "difficulty_estimation": "Medium",
    "content": {
      "text": "מהי הבעיה העיקרית שיכולה להתעורר במימוש בעיית היצרן-צרכן (Producer-Consumer) עם משתנה תנאי יחיד (condition variable) עבור שני סוגי התהליכים (יצרנים וצרכנים), כפי שנדון בחומר ההרצאה?",
      "code_snippet": "Producer:\n```c\nlock(&m1);\nmmmBop();\nwhile (count < MAX)\n    wait(&cv1, &m1);\n++count;\nsignal(&cv1);\nunlock(&m1);\n```\n\nConsumer:\n```c\nlock(&m1);\nwhile (count == 0)\n    wait(&cv1, &m1);\nbaDuBop();\n--count;\nsignal(&cv1);\nunlock(&m1);\n```",
      "options": [
        "א. מצב של קיפאון (deadlock) עלול להתרחש כאשר אות (signal) שמיועד להעיר תהליך מסוג מסוים מעיר בטעות תהליך מסוג אחר, מה שמוביל לחסימה הדדית.",
        "ב. ביצועי המערכת יורדים משמעותית עקב ריבוי החלפות הקשר (context switches) בין היצרנים לצרכנים, ללא קשר לזמינות המאגר.",
        "ג. נתונים במאגר המשותף עלולים להיפגם (data corruption) כתוצאה מכניסת מספר תהליכים לאזור קריטי בו-זמנית, מכיוון שמשתנה התנאי אינו מבטיח הדדיות.",
        "ד. תהליכים מסוימים עלולים להיכנס למצב של הרעבה (starvation) ולא לקבל לעולם הזדמנות לבצע את פעולתם, גם כשהמאגר פנוי או מכיל פריטים."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. במימוש בעיית היצרן-צרכן עם משתנה תנאי יחיד (כמו `cv1` בקוד לדוגמה), קיימת בעיה מהותית של חוסר ספציפיות באותות (signals). כפי שמתואר בחומר ההרצאה: 'כאשר עושים signal ל-cv1, ייתכן ואנחנו רוצים להעיר צרכן אבל במקום זאת בטעות יצרן שמחכה לסיגנל יתעורר.' מצב זה יכול להוביל לקיפאון (deadlock). לדוגמה, יצרן ממלא את המאגר ושולח סיגנל, אך במקום להעיר צרכן שיפנה מקום, הוא מעיר יצרן אחר שמנסה להוסיף למאגר מלא ומיד נחסם. במקביל, אם צרכנים ממתינים על מאגר ריק, הם יישארו חסומים והמערכת כולה עלולה להיתקע. דוגמה זו מודגשת בחומר ההרצאה כ'מקרה של קיפאון, יש צרכן שחוסם (כי אין מוצרים במחסן) ויצרן חסום (כי אין מקום פנוי במחסן) למרות שיש מקום פנוי במחסן'. השימוש בשני משתני תנאי נפרדים (`empty` ו-`full`), כפי שמוצג בפתרון המתקדם יותר בחומר, מאפשר שליטה מדויקת יותר על איזה סוג תהליך יתעורר, ובכך מונע את הקיפאון הנובע מחוסר ספציפיות זו."
    }
  }
}