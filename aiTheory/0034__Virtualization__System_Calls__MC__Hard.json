{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Virtualization",
    "topic_hint": "System Calls",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:00:06",
    "context_chunks_used": 5,
    "context_lectures": [
      2,
      5
    ],
    "token_usage": {
      "prompt_tokens": 2015,
      "output_tokens": 871,
      "total_tokens": 5166
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Virtualization",
    "topic": [
      "System Calls"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "למרות שקריאות מערכת (system calls) גורמות למעבר ממצב משתמש (user mode) למצב ליבה (kernel mode), ומאפשרות למערכת ההפעלה לבצע פעולות בשם התהליך המבקש, מדוע מנגנון זה לבדו אינו מספק על מנת להבטיח שליטה רציפה של מערכת ההפעלה במעבד?",
      "code_snippet": null,
      "options": [
        "א. קריאות מערכת פותרות את בעיית האבטחה אך אינן מספקות מנגנון למערכת ההפעלה להחזיר לעצמה שליטה יזומה כאשר תהליך רץ ברצף מבלי לבצע קריאת מערכת.",
        "ב. קריאות מערכת מיועדות רק לגישה לחומרה ואינן קשורות כלל לשמירת שליטה במעבד.",
        "ג. מעבר למצב ליבה באמצעות קריאת מערכת מוגבל בזמן וחוזר אוטומטית למצב משתמש לאחר פרק זמן קצר.",
        "ד. תהליכים במצב משתמש יכולים לעקוף קריאות מערכת ולגשת ישירות למשאבי חומרה, ובכך למנוע שליטה של מערכת ההפעלה."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "הסבר: קריאות מערכת אכן מאפשרות למערכת ההפעלה להשיג שליטה באופן זמני ולבצע פעולות מורשות (privileged operations) בצורה בטוחה, ובכך פותרות את בעיית האבטחה. אולם, כפי שמצוין בחומר ההרצאה, \"נותרה לנו בעיה שנייה – איך מערכת ההפעלה שומרת על שליטה במעבד? ברגע שתהליך רץ, המעבד מריץ אותו פקודה אחרי פקודה ואז מערכת ההפעלה לא רצה ולא יכולה להריץ קוד.\" (Lecture 2, chunk 28). כלומר, אם תהליך רץ במצב משתמש ואינו מבצע קריאת מערכת, מערכת ההפעלה אינה מקבלת שליטה בחזרה באופן יזום. גישת ה-Cooperative approach, שבה תהליכים היו אמורים לבצע קריאות מערכת כמו `yield` כדי לוותר על המעבד, נחשבת לבעייתית מכיוון שהיא \"סומכת יותר מדי על התהליכים\" (Lecture 2, chunk 29). לכן, קריאות מערכת לבדן אינן מספקות שליטה רציפה של מערכת ההפעלה. אפשרות ב' שגויה מכיוון שקריאות מערכת קשורות גם לשמירת שליטה (כמו ב-`yield`) וגם לביצוע פעולות אחרות מעבר לגישה ישירה לחומרה (כמו הקצאת זיכרון או פתיחת קובץ). אפשרות ג' שגויה כיוון שאין הגבלת זמן על שהות הליבה במצב ליבה; הליבה חוזרת למצב משתמש רק לאחר שסיימה את פעולתה. אפשרות ד' שגויה לחלוטין, שכן מנגנון קריאות המערכת והמעבר בין מצבים נועד בדיוק למנוע מתהליכים במצב משתמש לגשת ישירות למשאבי חומרה."
    }
  }
}