{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Atomic Operations",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:50:02",
    "context_chunks_used": 5,
    "context_lectures": [
      11,
      13,
      14
    ],
    "token_usage": {
      "prompt_tokens": 1793,
      "output_tokens": 1071,
      "total_tokens": 6356
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Atomic Operations"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתייחס לפעולת החומרה TestAndSet כפי שהוצגה בחומר הלימוד, אשר מוגדרת באמצעות \"הגדרה סדרתית\" (sequential specification) אך מבוצעת באופן אטומי על ידי המעבד, מהי הטענה הנכונה ביותר לגבי תרומתה המהותית לפתרון בעיות אטומיות במערכות הפעלה?",
      "code_snippet": "int TestAndSet(int* old_ptr, int new) {\n  int old = *old_ptr;\n  *old_ptr = new;\n  return old;\n}",
      "options": [
        "א. היא מאפשרת לבצע רצף של פעולות קריאה וכתיבה על משתנה יחיד כפעולה בלתי ניתנת להפרעה (אטומית), ובכך מונעת מצב שבו חוט אחר מתערב בין הקריאה לכתיבה.",
        "ב. היא נועדה בעיקר להחליף מנגנוני נעילה מורכבים כמו mutexes במקרים של גישה למשאב משותף, ובכך מבטיחה יעילות ביצוע גבוהה יותר באופן גורף.",
        "ג. תפקידה העיקרי הוא לאפשר לחוטים להשהות את ביצועם באופן אטומי תוך שחרור מנעול קיים, בדומה לפעולת wait של Condition Variable, ובכך למנוע דדלוקים.",
        "ד. היא משמשת רק לביצוע פעולות חשבוניות אטומיות פשוטות כמו הגדלת מונה, והשימוש בה מומלץ רק כאשר יש צורך מובהק בסנכרון."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "הסבר: פעולת ה-TestAndSet מוגדרת בחומר הלימוד כפקודת מכונה המבצעת באופן אטומי רצף של קריאת ערך ממשתנה, כתיבת ערך חדש לאותו משתנה, והחזרת הערך הישן. העובדה שהיא \"מבוצעת באופן אטומי בבת אחת\" (כפי שצוין בפירוש בחומר), למרות ה\"הגדרה הסדרתית\" שלה, היא המפתח. תרומתה המהותית היא שהיא מאפשרת לבצע את שתי הפעולות (קריאה וכתיבה) כטרנזקציה אחת בלתי ניתנת להפרעה, ובכך פותרת את בעיית ה-atomicity violation שבה חוט אחד עלול לקרוא ערך, חוט שני לשנות אותו, ורק אז החוט הראשון לכתוב ערך מיושן. זהו הבסיס למימוש מנעולים ומנגנוני סנכרון אחרים.\n\nאפשרויות שגויות:\nב. החומר מציין ש\"יש שיקולים שגורמים לפקודות הללו להיות פחות יעילות\" אם לא צריך סנכרון, ולכן הטענה ליעילות גורפת אינה נכונה. בנוסף, היא לא בהכרח \"מחליפה\" מנגנוני נעילה מורכבים אלא משמשת כפרימיטיב לבנייתם.\nג. תיאור זה מתייחס לפעולה האטומית של `wait(&cv1, &m1)` המשלבת שחרור מנעול והמתנה, כפי שהוסבר בחומר הלימוד. פעולת TestAndSet אינה כוללת שחרור מנעולים או \"ללכת לישון\".\nד. תיאור זה מתאים יותר לפעולות כמו `__sync_fetch_and_add` שהוצגו כדוגמה לפעולות אטומיות חשבוניות פשוטות. TestAndSet היא פקודה כללית יותר של קריאה-שינוי-כתיבה המשמשת לבניית מנעולים, ולא מוגבלת לפעולות חשבוניות בלבד. כמו כן, הטענה כי השימוש בה מומלץ רק כשיש צורך בסנכרון נכונה באופן כללי לפעולות אטומיות, אך לא מייחדת את TestAndSet רק לפעולות חשבוניות פשוטות."
    }
  }
}