{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:54:53",
    "context_chunks_used": 5,
    "context_lectures": [
      14
    ],
    "token_usage": {
      "prompt_tokens": 1516,
      "output_tokens": 1073,
      "total_tokens": 4641
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Producer-Consumer"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתבסס על מימוש בעיית היצרן-צרכן עם משתנה תנאי יחיד (cv1) כפי שמוצג, ובהתחשב בתרחיש הקיפאון המתואר בהרצאה (1: consumer -> count==0 -> wait, 2: consumer -> count==0 -> wait, 3: producer -> produces, signal -> consumer 1, 4: producer -> count==MAX -> wait, 5: consumer -> consumes item, signal -> consumer 2, 1 & 2 -> count==0, wait Deadlock), מהי הסיבה העיקרית לקיפאון במצב זה?",
      "code_snippet": "Producer:\n```c\nlock(&m1);\nmmmBop();\nwhile (count < MAX)\n    wait(&cv1, &m1);\n++count;\nsignal(&cv1);\nunlock(&m1);\n```\n\nConsumer:\n```c\nlock(&m1);\nwhile (count == 0)\n    wait(&cv1, &m1);\nbaDuBop();\n--count;\nsignal(&cv1);\nunlock(&m1);\n```",
      "options": [
        "א. שליחת סיגנל (signal) למשתנה התנאי cv1 אינה מבחינה בין יצרנים לצרכנים הממתינים, מה שעלול להעיר חוט שאינו יכול להמשיך (לדוגמה, יצרן מתעורר כשהמחסן מלא, או צרכן מתעורר כשהמחסן ריק), ובכך למנוע התקדמות של חוטים אחרים.",
        "ב. המנעול (m1) אינו משוחרר לפני ביצוע פעולת ה-wait, מה שמוביל לכך שחוטים אחרים אינם יכולים להיכנס לאזור הקריטי.",
        "ג. מספר הפריטים במחסן (count) אינו מוגן כראוי על ידי המנעול, מה שמאפשר תנאי מרוץ (race conditions) ומספרים שגויים.",
        "ד. אין מספיק חוטי יצרן או צרכן פעילים כדי למנוע מצב של קיפאון, ונדרשת אסטרטגיה של ניהול תורים מורכבת יותר."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. הבעיה המרכזית בשימוש במשתנה תנאי יחיד (cv1) עבור יצרנים וצרכנים היא שפעולת ה-signal(&cv1) אינה ספציפית. כאשר יצרן מוסיף פריט ושולח סיגנל, הוא עלול להעיר יצרן אחר הממתין על cv1 (במחשבה שהמחסן מלא), במקום צרכן. באופן דומה, כאשר צרכן צורך פריט ושולח סיגנל, הוא עלול להעיר צרכן אחר הממתין על cv1 (במחשבה שהמחסן ריק), במקום יצרן. בתרחיש הקיפאון המתואר בהרצאה, יצרנים עלולים לחכות שמקום יתפנה (כי count הגיע ל-MAX), וצרכנים עלולים לחכות לפריטים (כי count הגיע ל-0). אם סיגנל מעיר את הסוג הלא נכון של חוט (למשל, יצרן מעיר יצרן אחר כשהמחסן מלא), הוא לא פותר את החסימה, וכל החוטים יכולים להישאר במצב המתנה אינסופי. כפי שמוזכר בהרצאה: \"כאשר עושים signal ל-cv1, ייתכן ואנחנו רוצים להעיר צרכן אבל במקום זאת בטעות יצרן שמחכה לסיגנל יתעורר.\" הפתרון הנכון, כפי שמוצג בהרצאה, הוא שימוש בשני משתני תנאי נפרדים: empty עבור צרכנים הממתינים לפריטים (ושיצרנים שולחים להם סיגנל), ו-full עבור יצרנים הממתינים למקום פנוי (ושרכנים שולחים להם סיגנל)."
    }
  }
}