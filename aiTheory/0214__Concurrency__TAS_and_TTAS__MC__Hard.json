{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "TAS and TTAS",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:45:38",
    "context_chunks_used": 5,
    "context_lectures": [
      12,
      13
    ],
    "token_usage": {
      "prompt_tokens": 1941,
      "output_tokens": 1108,
      "total_tokens": 4901
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "TAS and TTAS"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "נתונים שני מנגנוני נעילה, Test-and-Set (TAS) ו-Test-and-Test-and-Set (TTAS), כפי שהוצגו בחומר הקורס. למרות ששניהם מיועדים להשגת הדדיות בלעדית, מנעול ה-TTAS מציג ביצועים עדיפים משמעותית על פני מנעול ה-TAS במערכות מרובות ליבות. מהו ההסבר העיקרי לפער ביצועים זה, בהתבסס על ארכיטקטורת המעבדים המודרנית?",
      "code_snippet": "void lock()\n{\n    while (true) {\n        while (state) {}\n        if (!testAndSet(state, true))\n            return;\n    }\n}",
      "options": [
        "א. TTAS מפחית באופן דרמטי את תעבורת ה-BUS על ידי כך שחוטים ממתינים בלולאה הפנימית (while(state) {}) וקוראים את משתנה המנעול מהמטמון הפרטי שלהם, במקום לבצע פעולות testAndSet אטומיות ועתירות תקשורת BUS באופן חוזר ונשנה כשהמנעול תפוס.",
        "ב. TTAS משתמש באלגוריתם חכם יותר לבחירת החוט הבא שייכנס לאזור הקריטי, בדומה למנגנון תור, מה שמבטיח הוגנות ומונע רעב.",
        "ג. מנגנון ה-TTAS מבצע אופטימיזציה של פעולות ה-I/O על ידי שימוש בזיכרון וירטואלי בצורה יעילה יותר, מה שמפחית את הצורך בגישות לדיסק הקשיח.",
        "ד. מנעול ה-TTAS מאפשר למספר חוטים להיכנס לאזור הקריטי בו-זמנית, כל עוד הם מבצעים פעולות קריאה בלבד, ובכך מגביר את המקביליות."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "ההסבר המרכזי לפער הביצועים בין TAS ל-TTAS טמון באופן שבו הם מתקשרים עם ארכיטקטורת זיכרון המטמון במערכות מרובות ליבות. במנעול TAS, חוט מנסה לתפוס את המנעול שוב ושוב באמצעות הפעולה האטומית `testAndSet`. פעולה זו, הכוללת כתיבה, גורמת בדרך כלל לפרוטוקולי עקיבות מטמון (cache coherence protocols) להפיץ הודעות אי-תקפות (invalidation messages) ב-BUS לכל המעבדים שייתכן שיש להם עותק של המשתנה במטמון שלהם. תעבורת BUS גבוהה זו יוצרת צוואר בקבוק משמעותי ומורידה את הביצועים.\n\nלעומת זאת, מנעול ה-TTAS משלב לולאה פנימית (`while (state) {}`) לפני ניסיון ה-`testAndSet`. בלולאה זו, חוטים ממתינים על ידי קריאת ערך המנעול. אם המנעול תפוס, הם קוראים את המשתנה `state` שוב ושוב. מכיוון שזו פעולת קריאה בלבד, והמשתנה `state` נמצא במטמון הפרטי של המעבד (כל עוד המנעול לא שוחרר על ידי מעבד אחר), חוטים יכולים \"לסובב\" (spin) על עותק המטמון המקומי שלהם מבלי ליצור תעבורת BUS נוספת. רק כאשר המנעול משוחרר על ידי מעבד אחר, העותק במטמון המקומי של החוט הממתין הופך ללא תקף, והוא יצטרך לבצע קריאה מהזיכרון הראשי או ממטמון של מעבד אחר. רק אז הוא ינסה לבצע את פעולת ה-`testAndSet` האטומית. הפחתה דרמטית זו של תעבורת ה-BUS היא הסיבה העיקרית לביצועים העדיפים של TTAS, כפי שנדון בהרחבה בהקשר של ארכיטקטורת מעבדים מרובי ליבות וזיכרונות מטמון פרטיים."
    }
  }
}