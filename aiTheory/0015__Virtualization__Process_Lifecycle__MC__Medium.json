{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Virtualization",
    "topic_hint": "Process Lifecycle",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-14 16:55:09",
    "context_chunks_used": 5,
    "context_lectures": [
      2,
      4,
      5
    ],
    "token_usage": {
      "prompt_tokens": 1884,
      "output_tokens": 628,
      "total_tokens": 4612
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Virtualization",
    "topic": [
      "Process Lifecycle"
    ],
    "difficulty_estimation": "Medium",
    "content": {
      "text": "מה מתאר בצורה הטובה ביותר תהליך \"זומבי\" (Zombie Process) במחזור חייו, ומדוע מערכת ההפעלה אינה מנקה אותו מיד?",
      "code_snippet": null,
      "options": [
        "א. תהליך שנמצא במצב \"Ready\" ומוכן לרוץ, אך המערכת מסמנת אותו כ\"defunct\" עד שתהליך האב יקרא לו wait().",
        "ב. תהליך שהסתיים בהצלחה ושוחרר מזיכרון המערכת, אך מזהה ה-PID שלו נשמר לזמן קצר למטרות תיעוד.",
        "ג. תהליך שהסתיים, אך רשומת ה-PCB שלו עדיין קיימת בטבלת התהליכים (מסומנת כ-\"defunct\"), מכיוון שתהליך האב שלו עדיין פעיל ועלול לבצע wait() עליו.",
        "ד. תהליך תקוע במצב \"Running\" שאינו מגיב, ומערכת ההפעלה ממתינה לתהליך האב שיסיים את ריצתו כדי להפוך את הזומבי לבן של init."
      ]
    },
    "solution": {
      "correct_option": "ג",
      "explanation": "על פי חומר ההרצאה (Lecture 5, chunk 6), תהליך זומבי הוא \"תהליך שהסתיים אבל הרשומה שלו עדיין קיימת בטבלת התהליכים\" והוא מסומן במילה \"defunct\". הסיבה שמערכת ההפעלה אינה מנקה אותו מיד היא \"מכיוון שתהליך האב עלול לעשות לתהליך הבן wait\". אם תהליך האב עדיין רץ, הוא עשוי לקרוא ל-wait() כדי לאסוף את קוד היציאה של תהליך הבן. לכן, אפשרות ג' מתארת במדויק את המצב והסיבה.\nאפשרויות א' ו-ד' שגויות מכיוון שתהליך זומבי אינו במצב \"Ready\" או \"Running\"; הוא כבר סיים את ריצתו. אפשרות ב' שגויה מכיוון שרשומת ה-PCB עדיין קיימת, והסיבה העיקרית היא לא רק תיעוד אלא הצורך לאפשר לתהליך האב לאסוף מידע."
    }
  }
}