{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Atomic Operations",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:50:39",
    "context_chunks_used": 5,
    "context_lectures": [
      11,
      13,
      14
    ],
    "token_usage": {
      "prompt_tokens": 1793,
      "output_tokens": 1176,
      "total_tokens": 6201
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Atomic Operations"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "הבעיה של הפרת אטומיות (atomicity violation) מתרחשת כאשר רצף פעולות המיועד להתבצע כיחידה בלתי ניתנת לחלוקה מופרע. קיימות מספר גישות לפתרון בעיה זו. איזו מהטענות הבאות מתארת בצורה המדויקת ביותר את ההבדל העקרוני באופן שבו מנעול (mutex) ופקודת חומרה אטומית (כגון __sync_fetch_and_add) מבטיחים אטומיות?",
      "code_snippet": null,
      "options": [
        "א. מנעול מבטיח שקטע קוד שלם יתבצע באופן אטומי על ידי מניעת גישה מקבילית אליו, בעוד שפקודת חומרה אטומית מבצעת רצף ספציפי של פעולות כפקודת מעבד יחידה ובלתי ניתנת לחלוקה.",
        "ב. פקודות חומרה אטומיות הן תמיד יעילות יותר ממנעולים לצורך סנכרון, מכיוון שהן אינן דורשות מעבר למצב ליבה או החלפת הקשר.",
        "ג. מנעולים מיועדים להגן על מבני נתונים מורכבים בלבד, בעוד שפקודות חומרה אטומיות משמשות רק לפעולות אריתמטיות פשוטות על משתנים בודדים.",
        "ד. מנעולים ממומשים באופן בלעדי בתוכנה באמצעות אלגוריתמים מורכבים, ואילו פקודות חומרה אטומיות דורשות תמיד כתיבת קוד אסמבלי ישיר."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'.\n\nעל פי חומר ההרצאה (Lecture 14, chunk 42), מנעול (mutex) משמש לפתרון \"atomicity violation\" על ידי כך ש\"נתפוס את המנעול בקטע הקוד שהתכוונו שיהיה אטומי, ונתפוס את המנעול בכל קטע קוד אחר שעלול להפריע לנו. עכשיו זה יהיה אטומי\". כלומר, מנעול אוכף אטומיות על קטע קוד שלם על ידי הבטחת מניעת גישה הדדית (mutual exclusion), כך שרק חוט אחד יכול לבצע את הקטע בזמן נתון.\n\nלעומת זאת, פקודות חומרה אטומיות (כמו אלו המוזכרות ב-Lecture 11, chunk 38, כגון __sync_fetch_and_add, ו-TestAndSet ב-Lecture 11, chunk 40) מתוארות כ\"פעולות חומרה שיש במעבד, שבבת אחת עושות כמה פעולות\" או \"פקודת מכונה שמבצעת את הקוד הבא: ... המימוש של הפקודה מתבצע באופן אטומי\". הן מבצעות רצף פעולות קצר ויחיד כפקודת מעבד אינדיבידואלית, שאינה ניתנת להפרעה ברמת החומרה.\n\nאפשרויות ב', ג' ו-ד' שגויות:\n*   ב': חומר ההרצאה (Lecture 11, chunk 40) מציין כי \"יש שיקולים שגורמים לפקודות הללו להיות פחות יעילות. אם אנחנו לא צריכים סינכרון, אל לנו להשתמש בהן. פעולת הגדלת מונה פשוטה יכולה להיות יותר יעילה מאשר ביצוע פעולה אטומית.\" כלומר, פקודות חומרה אטומיות אינן *תמיד* יעילות יותר ממנעולים.\n*   ג': מנעולים מגינים על כל קטע קריטי, לא רק על מבני נתונים מורכבים, ופקודות חומרה אטומיות יכולות לשמש לבניית פרימיטיבי סנכרון מורכבים יותר (כמו מנעולים עצמם, באמצעות TestAndSet), ולא רק לפעולות אריתמטיות פשוטות.\n*   ד': מנעולים רבים ממומשים תוך שימוש בפקודות חומרה אטומיות (כמו TestAndSet) בתור אבני הבניין שלהם, ולכן אינם \"בלעדית בתוכנה\". בנוסף, פקודות כמו __sync_fetch_and_add ניתנות לשימוש ישירות מ-C/C++ ולא דורשות תמיד כתיבת קוד אסמבלי ישיר."
    }
  }
}