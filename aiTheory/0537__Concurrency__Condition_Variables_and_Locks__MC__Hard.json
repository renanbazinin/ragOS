{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Condition Variables and Locks",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 19:05:00",
    "context_chunks_used": 5,
    "context_lectures": [
      16,
      11,
      15
    ],
    "token_usage": {
      "prompt_tokens": 1698,
      "output_tokens": 1063,
      "total_tokens": 6576
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Condition Variables and Locks"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "ההרצאה מציגה מימוש של מנעול בשם `FlakyLock` וקובעת כי \"לא ייתכן שהוא גם מקיים מניעה הדדית וגם deadlock freedom\". בהתבסס על החומר הנלמד, מהי הסיבה העיקרית לכך שהמנעול הזה נחשב ל\"לא תקין\" ולבלתי מסוגל להבטיח בו-זמנית את שתי התכונות הללו באופן כללי?",
      "code_snippet": "```c\n// Assume FlakyLock struct has busy and turn members\n// void lock(FlakyLock *lock, int me) { // Assuming 'me' is thread ID\n//     do {\n//         while (lock->busy);\n//         lock->busy = 1;\n//     } while (lock->turn != me);\n// }\n// void unlock(FlakyLock *lock) {\n//     lock->busy = 0;\n// }\n```",
      "options": [
        "א. המימוש סובל מבעיית livelock במקום deadlock, שבה חוטים מנסים להיכנס לקטע הקריטי אך אף אחד לא מצליח להתקדם.",
        "ב. ההבטחה למניעה הדדית נפגעת כיוון שהפקודה `lock->busy = 1` אינה אטומית, ומאפשרת ליותר מחוט אחד להיכנס לקטע הקריטי.",
        "ג. המנעול משתמש בשני משתנים בלבד (`busy` ו-`turn`) שאינם מספיקים למימוש נכון של מנעול עבור מספר שרירותי של חוטים ללא פקודות חומרה מיוחדות, ולכן אינו יכול להבטיח את שתי התכונות יחד.",
        "ד. הוא תמיד יוביל ל-deadlock קלאסי במצב של \"hold and wait\", שבו חוטים מחזיקים במשאבים וממתינים למשאבים שבידי אחרים."
      ]
    },
    "solution": {
      "correct_option": "ג",
      "explanation": "ההסבר המפורש בחומר ההרצאה (Lecture 16, chunk 27) מציין כי \"לא ניתן לממש מנעול לכל מספר של חוטים עם רק שני משתנים בלבד. בשביל לממש מנעול ל-100 חוטים, נדרשים 100 משתנים. אלא אם כן משתמשים בפקודות חומרה מיוחדות מה שלא קורה כאן. אז לא יכול להיות שהמנעול הזה תקין. לא ייתכן שהוא גם מקיים מניעה הדדית וגם deadlock freedom\". קביעה זו מבהירה שהמגבלה הבסיסית של `FlakyLock` נובעת מכך שהוא מנסה לנהל סינכרון עבור מספר לא מוגדר של חוטים באמצעות מספר קבוע וקטן מדי של משתנים (רק `busy` ו-`turn`). חוסר זה במשאבי מצב הופך אותו לבלתי מסוגל להבטיח בו-זמנית מניעה הדדית (Mutual Exclusion) וגם חופש מקיפאון (Deadlock Freedom) באופן כללי, מכיוון שהארכיטקטורה שלו אינה מספיקה לניהול נכון של כל התרחישים האפשריים בריבוי חוטים. לכן, תשובה ג' היא הנכונה ביותר.\nתשובה א' אינה נכונה מכיוון שההרצאה מזכירה livelock בהקשר של מימושים ללא מנעולים (lock-free), ולא בהכרח בהקשר של `FlakyLock` זה.\nתשובה ב' מצביעה על בעיה פוטנציאלית של אטומיות, אך ההרצאה מתמקדת במגבלת מספר המשתנים כסיבה העיקרית לחוסר התקינות הכללי של המנעול.\nתשובה ד' מתארת תנאי ל-deadlock אך הסיבה העמוקה יותר לחוסר היכולת להימנע ממנו, לפי ההרצאה, היא המגבלה המבנית של המנעול הנובעת ממספר המשתנים המצומצם."
    }
  }
}