{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "File Systems",
    "topic_hint": "Directory Structure",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 18:17:47",
    "context_chunks_used": 5,
    "context_lectures": [
      20,
      21
    ],
    "token_usage": {
      "prompt_tokens": 2034,
      "output_tokens": 1135,
      "total_tokens": 7784
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "File Systems",
    "topic": [
      "Directory Structure"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתבסס על מבנה ה-inode כפי שתואר ועל עקרונות עקביות מערכת הקבצים לאחר קריסה, איזו מהטענות הבאות מתארת את בעיית העקביות החמורה ביותר שעלולה להיווצר במערכת קבצים המשתמשת ב-inodes, בעת יצירת קישור קשיח (hard link) לקובץ קיים, אם סדר הפעולות אינו מתוכנן בקפידה?",
      "code_snippet": null,
      "options": [
        "א. אם ספירת הקישורים ב-inode של הקובץ מעודכנת לעלות לפני שרשומת התיקייה החדשה נכתבת לדיסק, ומתרחשת קריסה, אז הקובץ יופיע עם ספירת קישורים גבוהה מדי, מה שיוביל לבזבוז משאבים בכך שה-inode לא ישוחרר גם אם כל הקישורים האחרים יוסרו.",
        "ב. אם רשומת התיקייה החדשה נכתבת לדיסק לפני שספירת הקישורים ב-inode של הקובץ מעודכנת לעלות, ומתרחשת קריסה, אז הקישור החדש בתיקייה יצביע ל-inode עם ספירת קישורים נמוכה מדי. אם כל הקישורים המקוריים יוסרו, ה-inode עלול להימחק ולהיות מוקצה מחדש בזמן שהקישור החדש עדיין קיים, מה שיוביל לקישור תלוי (dangling pointer) ולשחיתות נתונים פוטנציאלית.",
        "ג. יצירת קישור קשיח אינה דורשת עדכון של ה-inode עצמו, אלא רק הוספת רשומה בתיקיית האב, ולכן אין בעיות עקביות הנוגעות לספירת קישורים ב-inode.",
        "ד. ה-inode מכיל רק מצביעים לבלוקי נתונים ואינו קשור ישירות לספירת קישורים, ולכן עדכון ספירת הקישורים אינו מהווה פעולה קריטית לשמירת עקביות ה-inode במקרה של קריסה."
      ]
    },
    "solution": {
      "correct_option": "ב",
      "explanation": "ה-inode מכיל את ספירת הקישורים (Links count), כפי שצוין בחומר ההרצאה. בעת יצירת קישור קשיח, נדרשות לפחות שתי פעולות עיקריות: עדכון ספירת הקישורים ב-inode של הקובץ, וכתיבת רשומה חדשה בבלוק הנתונים של תיקיית האב המצביעה על ה-inode של הקובץ.\n\nאפשרות א' מתארת מצב שבו ספירת הקישורים ב-inode גבוהה מדי. זהו מצב של 'ליג' משאבים', בדומה לתרחיש של עדכון ה-data bitmap לפני עדכון ה-inode כפי שתואר בהרצאה (Lecture 21, chunk 8), שבו בלוק מסומן כתפוס אך לא בשימוש. מצב זה מוביל לבזבוז מקום אך בדרך כלל אינו מוביל לשחיתות נתונים חמורה.\n\nאפשרות ב' מתארת את הבעיה החמורה יותר: אם רשומת התיקייה נכתבת לפני שספירת הקישורים ב-inode מעודכנת, ומתרחשת קריסה, הרי שרשומה חוקית בתיקייה מצביעה על inode שאינו 'מודע' לקיומה. אם כל הקישורים המקוריים לקובץ נמחקים, ספירת הקישורים ב-inode תגיע לאפס (שכן היא לא הוגדלה עבור הקישור החדש), וה-inode עלול להימחק ולהיות מוקצה מחדש. במצב זה, הקישור החדש בתיקייה יצביע ל-inode שאינו שייך לקובץ המקורי, מה שיוצר 'קישור תלוי' (dangling pointer) ועלול להוביל לשחיתות נתונים חמורה או לקריסת המערכת בגישה לנתונים שגויים.\n\nאפשרויות ג' ו-ד' שגויות, שכן חומר ההרצאה מציין במפורש ש-inode מכיל 'Links count (# paths)', ולכן עדכון זה הוא קריטי לשמירת העקביות של מערכת הקבצים."
    }
  }
}