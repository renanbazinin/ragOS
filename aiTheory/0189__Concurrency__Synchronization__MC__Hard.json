{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Synchronization",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:38:02",
    "context_chunks_used": 5,
    "context_lectures": [
      10,
      11,
      13,
      15
    ],
    "token_usage": {
      "prompt_tokens": 2007,
      "output_tokens": 1585,
      "total_tokens": 7992
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Synchronization"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהינתן בעיית ה\"איתות האבוד\" (Lost Signal) כפי שתוארה בחומר ההרצאה, שבה חוט A ממתין לאירוע וחוט B מאותת עליו, וללא שימוש נכון במנעולים עלול האיתות ללכת לאיבוד. הקוד הראשוני שהוצג, שבו האיתות עלול ללכת לאיבוד, היה כדלקמן:\n\n```c\n// Thread A\nlock(&m1);\nif (!done)\n  wait(&cv1, &m1);\nbaDuBop();\nunlock(&m1);\n\n// Thread B\nmmmBop();\ndone = 1;\nsignal(&cv1); // A signal might be lost here\n```\n\nהפתרון שהוצע כלל הוספת מנעול גם לחוט B, כך:\n\n```c\n// Thread A (unchanged)\nlock(&m1);\nif (!done)\n  wait(&cv1, &m1);\nbaDuBop();\nunlock(&m1);\n\n// Thread B (modified)\nlock(&m1); // Added\nmmmBop();\ndone = 1;\nsignal(&cv1);\nunlock(&m1); // Added\n```\n\nמהי הסיבה המדויקת והעיקרית להוספת המנעול (lock/unlock) בחוט B, כפי שהוצג בפתרון, למניעת בעיית ה\"איתות האבוד\"?",
      "code_snippet": null,
      "options": [
        "א. המנעול בחוט B מבטיח שאף חוט אחר לא יוכל להיכנס לקטע קריטי המוגן על ידי m1 בזמן שחוט B מעדכן את done ושולח את האיתות. זה מונע מצב שבו חוט A בודק את done, מוצא אותו כ-0, ואז לפני שהוא מספיק לקרוא ל-wait, חוט B משנה את done ל-1 ושולח signal, אשר אובד.",
        "ב. המנעול בחוט B נחוץ כדי להגן על המשתנה done מפני Race Condition, שכן done הוא משאב משותף, אך אינו קשור ישירות לאובדן האיתות.",
        "ג. המנעול בחוט B מונע מחוט A לקרוא ל-wait(&cv1, &m1) אם חוט B כבר סיים את mmmBop() ושלח את האיתות, ובכך מונע חסימה מיותרת של חוט A.",
        "ד. המנעול בחוט B מאפשר לחוט B להמשיך לרוץ במקביל לחוט A גם לאחר שליחת האיתות, מבלי שחוט A יחסום אותו."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "הבעיה המרכזית ב\"איתות האבוד\" מתרחשת כאשר חוט A בודק את התנאי (`if (!done)`), מוצא אותו כ-`true` (כלומר `done` הוא `0`), אך לפני שהוא מספיק לקרוא לפונקציה `wait(&cv1, &m1)` (שגם משחררת את המנעול וגם חוסמת את החוט), מתרחש מיתוג הקשר (context switch) לחוט B. חוט B רץ, משנה את `done` ל-`1`, ושולח `signal(&cv1)`. מכיוון שחוט A עדיין לא קרא ל-`wait`, אין מי שממתין לאיתות זה, והאיתות הולך לאיבוד. כאשר חוט A יחזור לרוץ ויקרא ל-`wait`, הוא ייחסם ללא הגבלת זמן, למרות שהאירוע כבר התרחש.\n\nהוספת המנעול בחוט B (lock/unlock) מבטיחה שכל הרצף של עדכון `done` ושליחת `signal` יתבצע כפעולה אטומית, כלומר, לא ניתן יהיה לבצע מיתוג הקשר לחוט A (או לכל חוט אחר שמשתמש במנעול `m1`) בתוך רצף פעולות זה. בפרט, אם חוט A תפס את המנעול `m1` ובודק את `done`, חוט B לא יוכל לתפוס את `m1` ולהתקדם עד שחוט A ישחרר אותו (למשל, בעת קריאה ל-`wait` או יציאה מהקטע הקריטי). באופן דומה, אם חוט B תפס את `m1` ומתקדם לעדכון `done` ושליחת `signal`, חוט A לא יוכל לתפוס את `m1` ולבדוק את `done` או לקרוא ל-`wait`. בכך, המנעול מבטיח שחוט A לא יבדוק את `done` ויחליט להיכנס למצב המתנה, רק כדי שחוט B ישלים את פעולותיו וישלח איתות שייאבד לפני שחוט A נכנס למצב המתנה בפועל. כפי שצויין בהרצאה, \"עכשיו הם לא יכולים להתערבב\".\n\nאפשרויות ב', ג' ו-ד' אינן הסיבה העיקרית והמדויקת: \n*   **ב'** - הגנה על `done` מפני Race Condition היא חשובה, אך זוהי רק חלק מהתמונה. הבעיה העיקרית של ה\"איתות האבוד\" היא סנכרון התזמון בין `signal` ל-`wait`, ולא רק עקביות המשתנה `done` בפני עצמה.\n*   **ג'** - מניעת חסימה מיותרת של חוט A היא תוצאה רצויה של הפתרון, אך הסיבה העיקרית להוספת המנעול היא למנוע את אובדן האיתות מלכתחילה, מה שמוביל לחסימה מיותרת. המנעול פותר את שורש הבעיה ולא רק את הסימפטום.\n*   **ד'** - מנעולים (mutexes) משמשים למניעת ריצה מקבילית של קטעים קריטיים, כלומר להבטחת הדרה הדדית (mutual exclusion), ולא כדי לאפשר ריצה מקבילית. לכן, אפשרות זו שגויה לחלוטין."
    }
  }
}