{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:55:42",
    "context_chunks_used": 5,
    "context_lectures": [
      14
    ],
    "token_usage": {
      "prompt_tokens": 1516,
      "output_tokens": 1367,
      "total_tokens": 7223
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Producer-Consumer"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהתייחס לבעיית היצרן-צרכן (Producer-Consumer) עם מאגר חסום (Bounded Buffer), נתבונן במימוש הבא המשתמש במשתנה תנאי יחיד (cv1):\n\n```c\n// קוד היצרן (Producer)\nlock(&m1);\nmmmBop(); // פעולת ייצור\nwhile (count < MAX)\n    wait(&cv1, &m1);\n++count;\nsignal(&cv1);\nunlock(&m1);\n\n// קוד הצרכן (Consumer)\nlock(&m1);\nwhile (count == 0)\n    wait(&cv1, &m1);\nbaDuBop(); // פעולת צריכה\n--count;\nsignal(&cv1);\nunlock(&m1);\n```\n\nמדוע מימוש זה עלול להוביל לקיפאון (deadlock) או לחוסר יעילות, וכיצד השימוש בשני משתני תנאי נפרדים (empty ו-full) פותר בעיה זו, כפי שמוצע בחומר ההרצאה?",
      "code_snippet": "// קוד היצרן (Producer)\nlock(&m1);\nmmmBop(); // פעולת ייצור\nwhile (count < MAX)\n    wait(&cv1, &m1);\n++count;\nsignal(&cv1);\nunlock(&m1);\n\n// קוד הצרכן (Consumer)\nlock(&m1);\nwhile (count == 0)\n    wait(&cv1, &m1);\nbaDuBop(); // פעולת צריכה\n--count;\nsignal(&cv1);\nunlock(&m1);",
      "options": [
        "א. המימוש עם cv1 עלול לגרום לקיפאון מכיוון ש-signal(&cv1) עלול להעיר יצרן כאשר המאגר מלא וצרכן נחוץ, או להעיר צרכן כאשר המאגר ריק ויצרן נחוץ. empty ו-full פותרים זאת על ידי הבטחה שרק חוטים מהסוג הנכון (יצרנים או צרכנים) יתעוררו כאשר התנאי המתאים מתקיים.",
        "ב. המימוש עם cv1 אינו מבטיח שהמונה (count) יישאר בטווח חוקי (0 עד MAX), מה שמוביל לגישה לא חוקית לזיכרון. empty ו-full פותרים זאת על ידי אכיפת גבולות המאגר באופן מפורש.",
        "ג. המימוש עם cv1 גורם לקיפאון כי הוא אינו משתמש במנעול (mutex) כדי להגן על הגישה למונה (count), ובכך מאפשר מצבי מרוץ (race conditions). empty ו-full פועלים רק בשילוב עם מנעול, ולכן פותרים את בעיית ה-race conditions.",
        "ד. המימוש עם cv1 אינו מאפשר ליותר מיצרן או צרכן יחיד לפעול בו-זמנית, מה שפוגע במקביליות. empty ו-full מאפשרים למספר יצרנים וצרכנים לפעול במקביל ללא בעיות."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. חומר ההרצאה מציין במפורש כי במימוש עם משתנה תנאי יחיד (כמו cv1), \"כאשר עושים signal ל-cv1, ייתכן ואנחנו רוצים להעיר צרכן אבל במקום זאת בטעות יצרן שמחכה לסיגנל יתעורר\" (Lecture 14, chunk 11). מצב זה עלול להוביל לקיפאון או לחוסר יעילות, שכן חוט מסוג לא רלוונטי מתעורר ומיד נחסם שוב (לדוגמה, יצרן מתעורר כשהמאגר עדיין מלא, או צרכן מתעורר כשהמאגר עדיין ריק), בעוד שהחוט הנחוץ (יצרן כשיש מקום פנוי, או צרכן כשיש פריט) נשאר רדום. הפתרון עם שני משתני תנאי נפרדים, empty ו-full, פותר בעיה זו על ידי יצירת ערוצי איתות ייעודיים: יצרנים ממתינים על full ומאותתים ל-empty, וצרכנים ממתינים על empty ומאותתים ל-full. בכך, מובטח ש-signal יופנה תמיד לחוטים מהסוג הנכון שבאמת יכולים להתקדם, כפי שמתואר ב-Lecture 14, chunk 14.\n\nאפשרויות ב', ג' ו-ד' שגויות: ב' שגויה מכיוון ששני המימושים משתמשים בלולאות while ו-wait כדי לאכוף את גבולות המאגר. ג' שגויה כי שני המימושים משתמשים במנעול (lock/unlock(&m1)) כדי להגן על הגישה למונה ולמנוע מצבי מרוץ. ד' שגויה כי השימוש במנעול יחיד מונע מיותר מחוט אחד להיות בתוך האזור הקריטי בכל רגע נתון, והבעיה אינה קשורה למקביליות בתוך האזור הקריטי אלא לתזמון נכון של התעוררות חוטים."
    }
  }
}