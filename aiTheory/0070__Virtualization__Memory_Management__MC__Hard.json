{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Virtualization",
    "topic_hint": "Memory Management",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:09:31",
    "context_chunks_used": 5,
    "context_lectures": [
      9,
      5,
      6
    ],
    "token_usage": {
      "prompt_tokens": 2240,
      "output_tokens": 931,
      "total_tokens": 5983
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Virtualization",
    "topic": [
      "Memory Management"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "איזה אלגוריתם ניהול זיכרון תוכנן במיוחד כדי לטפל ביעילות בפרגמנטציה חיצונית על ידי פישוט איחודם של בלוקי זיכרון פנויים סמוכים, ומהו המנגנון העיקרי שלו להשגת מטרה זו?",
      "code_snippet": null,
      "options": [
        "א. Free List עם בלוקים בגודל קבוע – הוא שומר רשימה של בלוקים פנויים זהים בגודלם, ולכן אינו מתמודד עם פרגמנטציה חיצונית באמצעות איחוד, אלא מונע אותה על ידי מבנה קבוע.",
        "ב. Buddy Allocation – הוא מפצל את הזיכרון לבלוקים בגדלים שהם חזקות של 2, ומאפשר איחוד מהיר של בלוקים שכנים פנויים על ידי בדיקת ביט בכתובת הזיכרון שלהם.",
        "ג. Slab Allocation – הוא מקצה בלוקים בגודל קבוע עבור אובייקטים ספציפיים, מה שמפחית פרגמנטציה פנימית אך אינו מיועד לפתור ביעילות פרגמנטציה חיצונית רחבה באמצעות איחוד בלוקים בגדלים שונים.",
        "ד. Free List עם בלוקים בגודל משתנה – הוא שומר כתובת וגודל לכל בלוק פנוי, אך איחוד בלוקים סמוכים דורש סריקה מורכבת של הרשימה או מבנה נתונים מורכב יותר למציאת שכנים, ואינו \"מפושט\" כפי שמתואר."
      ]
    },
    "solution": {
      "correct_option": "ב",
      "explanation": "האלגוריתם Buddy Allocation תוכנן במפורש כדי לפתור את בעיית ה-coalesce (איחוד שטחי זיכרון בודדים ופנויים), שהיא הדרך להתמודד עם פרגמנטציה חיצונית. לפי חומר ההרצאה, הוא מפצל את הזיכרון לבלוקים בגדלים שהם חזקות של 2. כאשר משתמש מפנה בלוק, האלגוריתם בודק את ה\"חבר\" (buddy) שלו – בלוק שכתובתו נבדלת בביט אחד בלבד. אם גם ה\"חבר\" פנוי, ניתן לאחד אותם במהירות לבלוק גדול יותר, ובכך לפשט מאוד את תהליך האיחוד ולשחזר שטחי זיכרון גדולים יותר. אפשרות א' (Free List עם בלוקים בגודל קבוע) אינה דורשת איחוד במובן של coalesce מכיוון שכל הבלוקים באותו גודל; היא מונעת פרגמנטציה חיצונית מורכבת אך אינה \"פותרת\" אותה באמצעות איחוד יעיל של בלוקים שונים. אפשרות ג' (Slab Allocation) מתמקדת בהקצאה יעילה של אובייקטים קטנים וקבועי גודל, בעיקר כדי להפחית פרגמנטציה פנימית וניהול תקורה, אך אינה מציעה מנגנון יעיל לפישוט איחוד בלוקים פנויים בגדלים משתנים. אפשרות ד' (Free List עם בלוקים בגודל משתנה) אכן סובלת מפרגמנטציה חיצונית ודורשת איחוד, אך חומר ההרצאה מציין שהרשימה המקושרת הופכת \"מורכבת יותר\" ואינו מתאר מנגנון \"מפושט\" לאיחוד, בניגוד ל-Buddy Allocation."
    }
  }
}