{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Virtualization",
    "topic_hint": "TLB",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:21:54",
    "context_chunks_used": 5,
    "context_lectures": [
      8,
      7
    ],
    "token_usage": {
      "prompt_tokens": 2114,
      "output_tokens": 1410,
      "total_tokens": 6358
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Virtualization",
    "topic": [
      "TLB"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "תהליך P1 רץ, ולאחר מכן מתרחש context switch לתהליך P2. תהליך P2 מבצע כעת גישה לכתובת וירטואלית. בהתחשב בכך שה-TLB מכיל רשומות עם מזהה ASID (Address Space ID) עבור תהליכים שונים, וכי הדף הפיזי המתאים לכתובת הוירטואלית הנדרשת על ידי P2 אינו נמצא כרגע בזיכרון הפיזי (כלומר, ה-Present bit עבור ה-PTE המתאים בטבלת הדפים של P2 הוא 0), מהו הרצף הנכון של האירועים שיגרמו ל-MMU להעלות Trap למערכת ההפעלה?",
      "code_snippet": null,
      "options": [
        "א. ה-MMU יבצע בדיקת TLB, יקבל TLB miss (עקב ASID שאינו תואם או אי-קיום רשומה), יגש לטבלת הדפים של P2, ימצא שה-Present bit של הדף הוא 0, ויעלה Trap למערכת ההפעלה.",
        "ב. ה-MMU יזהה מיידית את חוסר הדף בזיכרון הפיזי עוד לפני גישה ל-TLB, ויעלה Trap.",
        "ג. ה-MMU יבצע בדיקת TLB, יקבל TLB hit (בזכות רשומה קודמת של תהליך P1 ללא התחשבות ב-ASID), ואז יגש לכתובת פיזית שגויה ויעלה Trap.",
        "ד. ה-MMU יבצע בדיקת TLB, יקבל TLB miss, יעדכן את ה-TLB עם מיפוי חדש מתוך טבלת הדפים (למרות שהדף אינו ב-RAM), ורק אז ינסה לגשת לזיכרון הפיזי ויקבל Trap."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "התשובה הנכונה היא א'. להלן ההסבר המפורט, בהתבסס על חומר ההרצאה:\n\n1.  **בדיקת TLB ראשונית:** חומר ההרצאה קובע במפורש ש\"בכל פעם שיש גישה לזיכרון, [ה-MMU] קודם יבדוק את ה-tlb\". לכן, כל גישה לכתובת וירטואלית מתחילה בבדיקת ה-TLB.\n\n2.  **TLB miss עקב ASID:** השאלה מציינת שה-TLB מכיל רשומות עם ASID. כאשר מתרחש context switch מ-P1 ל-P2, ה-TLB עשוי להכיל רשומות של P1 או רשומות קודמות של P2. אם קיימת רשומה עבור הכתובת הוירטואלית אך ה-ASID שלה אינו תואם ל-P2 הנוכחי, או שאין רשומה כלל עבור כתובת זו של P2, יתקבל **TLB miss**. ה-ASID מונע מצב של \"TLB hit\" שגוי על רשומה של תהליך אחר, כפי שמצוין בחומר: \"נוסיף לכל רשומה ב-tlb מזהה נוסף שנקרא ASID (address space id) שיציין לאיזה תהליך הרשומה הזו שייכת וכך ניתן להבדיל בין רשומות של תהליכים שונים.\"\n\n3.  **גישה לטבלת הדפים:** לאחר TLB miss, ה-MMU יגש לטבלת הדפים כדי למצוא את המיפוי. \"אם המיפוי לא קיים [ב-TLB], נעשה את התהליך הארוך (נלך לחפש בטבלת הדפים)\".\n\n4.  **בדיקת Present bit:** בטבלת הדפים, ה-MMU ימצא את ה-PTE המתאים לכתובת הוירטואלית ויבדוק את ה-Present bit שלו. \"ה-mmu ניגש לטבלת הדפים ומחפש את המיפוי שם, ובודק את ה-present bit\".\n\n5.  **העלאת Trap:** מכיוון שהשאלה קובעת שה-Present bit הוא 0, משמעות הדבר היא שהדף אינו נמצא בזיכרון הפיזי (RAM). במצב זה, \"ה-mmu יוצר trap למערכת ההפעלה\".\n\n**מדוע שאר האפשרויות שגויות:**\n*   **ב.** שגויה מכיוון שה-MMU תמיד בודק את ה-TLB תחילה לפני שהוא מנסה \"לזהות\" משהו לגבי מצב הדף בזיכרון הפיזי.\n*   **ג.** שגויה מכיוון שהשימוש ב-ASID מונע TLB hit עבור רשומות של תהליכים אחרים (כמו P1) לאחר context switch. ללא ASID, אפשרות זו הייתה יכולה להיות נכונה.\n*   **ד.** שגויה מכיוון שה-TLB לא מתעדכן עם מיפוי של דף שאינו נמצא ב-RAM (כלומר, ה-Present bit שלו הוא 0). חומר ההרצאה מציין ש\"ה-tlb מחזיק רק רשומות שה-present bit שלהן הוא 1\" וכי עדכון ה-TLB מתבצע \"אחרי שנמצא את המיפוי\" (משמע, מיפוי חוקי לדף ב-RAM)."
    }
  }
}