{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Producer-Consumer",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Hard",
    "generated_at": "2026-02-14 17:55:16",
    "context_chunks_used": 5,
    "context_lectures": [
      14
    ],
    "token_usage": {
      "prompt_tokens": 1516,
      "output_tokens": 1175,
      "total_tokens": 6337
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Producer-Consumer"
    ],
    "difficulty_estimation": "Hard",
    "content": {
      "text": "בהינתן מימוש בעיית היצרן-צרכן הבא, המשתמש במשתנה תנאי יחיד (`cv1`) עבור שתי הפעולות של יצרנים וצרכנים:\n\nאיזו מהטענות הבאות מתארת בצורה הטובה ביותר את הבעיה העיקרית של מימוש זה, שעלולה להוביל למצב קיפאון (deadlock)?",
      "code_snippet": "Producer:\n```c\nlock(&m1);\nmmmBop();\nwhile (count < MAX)\n    wait(&cv1, &m1);\n++count;\nsignal(&cv1);\nunlock(&m1);\n```\n\nConsumer:\n```c\nlock(&m1);\nwhile (count == 0)\n    wait(&cv1, &m1);\nbaDuBop();\n--count;\nsignal(&cv1);\nunlock(&m1);\n```",
      "options": [
        "א. שימוש במשתנה תנאי יחיד (`cv1`) עבור יצרנים וצרכנים כאחד עלול לגרום לכך שפעולת `signal` תעיר חוט מהסוג הלא נכון (לדוגמה, יצרן יתעורר במקום צרכן), ובכך למנוע התקדמות של המערכת ולהוביל לקיפאון.",
        "ב. הפעולה `mmmBop()` או `baDuBop()` אינה מוגנת באמצעות מנעול, מה שעלול לגרום לתנאי מרוץ (race condition) בגישה למשאבים משותפים.",
        "ג. לולאת `while` בבדיקת התנאים (לדוגמה, `while (count == 0)`) אינה נחוצה, ודי בבדיקת `if` יחידה, מה שמוביל לבדיקות מיותרות ולפגיעה בביצועים.",
        "ד. המשתנה `MAX` אינו מוגדר כ-`volatile`, ועלול לגרום לקומפיילר לבצע אופטימיזציות שגויות המשפיעות על נכונות בדיקת גודל המאגר."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "הבעיה המרכזית במימוש המוצג, כפי שמתואר בחומר ההרצאה (Lecture 14, chunk 11), היא השימוש במשתנה תנאי יחיד (`cv1`) הן עבור יצרנים והן עבור צרכנים. כאשר מתבצעת פעולת `signal(&cv1)`, המערכת מעירה חוט אקראי מבין כל החוטים הממתינים על משתנה תנאי זה. הבעיה היא שייתכן וחוט מהסוג הלא נכון יתעורר – לדוגמה, יצרן הממתין על `cv1` עלול להתעורר כאשר צרכן מסיים לצרוך פריט ומשחרר מקום, אף על פי שהכוונה הייתה להעיר יצרן שחיכה למקום פנוי. או לחלופין, צרכן עלול להתעורר כאשר יצרן מוסיף פריט, אך במקום זאת יצרן אחר יתעורר בטעות. מצב זה, של העוררות שגויה, עלול להוביל לכך שחוטים נשארים במצב המתנה אף על פי שהתנאי עבורם התקיים, או שחוטים מתעוררים ללא סיבה רלוונטית, ובכך ליצור מצב קיפאון (deadlock) בו המערכת כולה נתקעת, כפי שמוצג בדוגמת הדדלוק בחומר ההרצאה.\n\nאפשרויות ב', ג' ו-ד' אינן מתארות את הבעיה העיקרית הספציפית לשימוש במשתנה תנאי יחיד: אפשרות ב' אינה נכונה מכיוון שהפעולות `mmmBop()` ו-`baDuBop()` נמצאות בתוך בלוק נעול (`lock(&m1)`), כך שהן מוגנות. אפשרות ג' אינה נכונה מכיוון שלולאת `while` הכרחית בשימוש עם `wait` של משתני תנאי, שכן חוטים עלולים להתעורר באופן שגוי (spurious wakeups) או שהתנאי לא יהיה תקף עוד כאשר החוט יתעורר. אפשרות ד' מתייחסת לפרט מימוש שאינו קשור לבעיה הספציפית של משתנה התנאי היחיד ולא נדונה בחומר ההרצאה."
    }
  }
}