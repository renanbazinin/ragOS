{
  "metadata": {
    "source": "ai_generated_from_summary",
    "subject": "Concurrency",
    "topic_hint": "Cache Coherence",
    "requested_type": "MultipleChoice",
    "requested_difficulty": "Medium",
    "generated_at": "2026-02-14 17:47:24",
    "context_chunks_used": 5,
    "context_lectures": [
      16,
      15
    ],
    "token_usage": {
      "prompt_tokens": 2018,
      "output_tokens": 631,
      "total_tokens": 4932
    }
  },
  "question": {
    "id": 1,
    "type": "MultipleChoice",
    "subject": "Concurrency",
    "topic": [
      "Cache Coherence"
    ],
    "difficulty_estimation": "Medium",
    "content": {
      "text": "על פי חומר ההרצאה, מהי הבעיה המרכזית המתעוררת בהקשר של עקביות מטמון (Cache Coherence) במערכת מרובת מעבדים?",
      "code_snippet": null,
      "options": [
        "א. כאשר מעבד אחד משנה נתון במטמון המקומי שלו, מעבדים אחרים עלולים לקרוא ערך לא מעודכן של אותו נתון מהזיכרון הראשי או מהמטמונים שלהם.",
        "ב. קושי בשמירה על \"cache affinity\", כלומר תהליך אינו רץ באופן עקבי על אותו מעבד שהריץ אותו בעבר.",
        "ג. מניעה הדדית בין תהליכים אינה מובטחת, מה שמאפשר למספר תהליכים להיכנס לקטע קריטי בו זמנית.",
        "ד. כל עדכון לזיכרון הראשי מחייב עדכון מיידי של כל המטמונים האחרים, מה שמוביל בהכרח להאטה משמעותית בביצועים."
      ]
    },
    "solution": {
      "correct_option": "א",
      "explanation": "חומר ההרצאה (Lecture 15, chunk 23) מתאר במפורש כי כאשר מעבד אחד קורא נתון מהזיכרון הראשי למטמון המקומי שלו ומשנה אותו, הזיכרון הראשי (ומטמונים של מעבדים אחרים) עלולים להחזיק בערך לא מעודכן. אם מעבד אחר ינסה לאחר מכן לקרוא את אותו נתון, הוא יקבל ערך שגוי או מיושן ('ערך לא תקין'). זוהי הבעיה המרכזית של עקביות מטמון – הבטחת שכל המעבדים רואים את הגרסה העדכנית ביותר של הנתונים. אפשרות ב' מתארת בעיה של 'cache affinity' הקשורה לתזמון ג'ובים, אפשרות ג' מתארת בעיה של מניעה הדדית הקשורה למנגנוני סנכרון, ואפשרות ד' מתארת אתגר או תוצאה של ניסיון לפתור את בעיית העקביות, אך לא את הבעיה הבסיסית של חוסר עקביות הנתונים עצמה."
    }
  }
}